{"ast":null,"code":"const VIEW = 'view',\n  LBRACK = '[',\n  RBRACK = ']',\n  LBRACE = '{',\n  RBRACE = '}',\n  COLON = ':',\n  COMMA = ',',\n  NAME = '@',\n  GT = '>',\n  ILLEGAL = /[[\\]{}]/,\n  DEFAULT_MARKS = {\n    '*': 1,\n    arc: 1,\n    area: 1,\n    group: 1,\n    image: 1,\n    line: 1,\n    path: 1,\n    rect: 1,\n    rule: 1,\n    shape: 1,\n    symbol: 1,\n    text: 1,\n    trail: 1\n  };\nlet DEFAULT_SOURCE, MARKS;\n\n/**\n * Parse an event selector string.\n * Returns an array of event stream definitions.\n */\nfunction eventSelector(selector, source, marks) {\n  DEFAULT_SOURCE = source || VIEW;\n  MARKS = marks || DEFAULT_MARKS;\n  return parseMerge(selector.trim()).map(parseSelector);\n}\nfunction isMarkType(type) {\n  return MARKS[type];\n}\nfunction find(s, i, endChar, pushChar, popChar) {\n  const n = s.length;\n  let count = 0,\n    c;\n  for (; i < n; ++i) {\n    c = s[i];\n    if (!count && c === endChar) return i;else if (popChar && popChar.indexOf(c) >= 0) --count;else if (pushChar && pushChar.indexOf(c) >= 0) ++count;\n  }\n  return i;\n}\nfunction parseMerge(s) {\n  const output = [],\n    n = s.length;\n  let start = 0,\n    i = 0;\n  while (i < n) {\n    i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);\n    output.push(s.substring(start, i).trim());\n    start = ++i;\n  }\n  if (output.length === 0) {\n    throw 'Empty event selector: ' + s;\n  }\n  return output;\n}\nfunction parseSelector(s) {\n  return s[0] === '[' ? parseBetween(s) : parseStream(s);\n}\nfunction parseBetween(s) {\n  const n = s.length;\n  let i = 1,\n    b;\n  i = find(s, i, RBRACK, LBRACK, RBRACK);\n  if (i === n) {\n    throw 'Empty between selector: ' + s;\n  }\n  b = parseMerge(s.substring(1, i));\n  if (b.length !== 2) {\n    throw 'Between selector must have two elements: ' + s;\n  }\n  s = s.slice(i + 1).trim();\n  if (s[0] !== GT) {\n    throw 'Expected \\'>\\' after between selector: ' + s;\n  }\n  b = b.map(parseSelector);\n  const stream = parseSelector(s.slice(1).trim());\n  if (stream.between) {\n    return {\n      between: b,\n      stream: stream\n    };\n  } else {\n    stream.between = b;\n  }\n  return stream;\n}\nfunction parseStream(s) {\n  const stream = {\n      source: DEFAULT_SOURCE\n    },\n    source = [];\n  let throttle = [0, 0],\n    markname = 0,\n    start = 0,\n    n = s.length,\n    i = 0,\n    j,\n    filter;\n\n  // extract throttle from end\n  if (s[n - 1] === RBRACE) {\n    i = s.lastIndexOf(LBRACE);\n    if (i >= 0) {\n      try {\n        throttle = parseThrottle(s.substring(i + 1, n - 1));\n      } catch (e) {\n        throw 'Invalid throttle specification: ' + s;\n      }\n      s = s.slice(0, i).trim();\n      n = s.length;\n    } else throw 'Unmatched right brace: ' + s;\n    i = 0;\n  }\n  if (!n) throw s;\n\n  // set name flag based on first char\n  if (s[0] === NAME) markname = ++i;\n\n  // extract first part of multi-part stream selector\n  j = find(s, i, COLON);\n  if (j < n) {\n    source.push(s.substring(start, j).trim());\n    start = i = ++j;\n  }\n\n  // extract remaining part of stream selector\n  i = find(s, i, LBRACK);\n  if (i === n) {\n    source.push(s.substring(start, n).trim());\n  } else {\n    source.push(s.substring(start, i).trim());\n    filter = [];\n    start = ++i;\n    if (start === n) throw 'Unmatched left bracket: ' + s;\n  }\n\n  // extract filters\n  while (i < n) {\n    i = find(s, i, RBRACK);\n    if (i === n) throw 'Unmatched left bracket: ' + s;\n    filter.push(s.substring(start, i).trim());\n    if (i < n - 1 && s[++i] !== LBRACK) throw 'Expected left bracket: ' + s;\n    start = ++i;\n  }\n\n  // marshall event stream specification\n  if (!(n = source.length) || ILLEGAL.test(source[n - 1])) {\n    throw 'Invalid event selector: ' + s;\n  }\n  if (n > 1) {\n    stream.type = source[1];\n    if (markname) {\n      stream.markname = source[0].slice(1);\n    } else if (isMarkType(source[0])) {\n      stream.marktype = source[0];\n    } else {\n      stream.source = source[0];\n    }\n  } else {\n    stream.type = source[0];\n  }\n  if (stream.type.slice(-1) === '!') {\n    stream.consume = true;\n    stream.type = stream.type.slice(0, -1);\n  }\n  if (filter != null) stream.filter = filter;\n  if (throttle[0]) stream.throttle = throttle[0];\n  if (throttle[1]) stream.debounce = throttle[1];\n  return stream;\n}\nfunction parseThrottle(s) {\n  const a = s.split(COMMA);\n  if (!s.length || a.length > 2) throw s;\n  return a.map(_ => {\n    const x = +_;\n    if (x !== x) throw s;\n    return x;\n  });\n}\nexport { eventSelector as parseSelector };","map":{"version":3,"names":["VIEW","LBRACK","RBRACK","LBRACE","RBRACE","COLON","COMMA","NAME","GT","ILLEGAL","DEFAULT_MARKS","arc","area","group","image","line","path","rect","rule","shape","symbol","text","trail","DEFAULT_SOURCE","MARKS","eventSelector","selector","source","marks","parseMerge","trim","map","parseSelector","isMarkType","type","find","s","i","endChar","pushChar","popChar","n","length","count","c","indexOf","output","start","push","substring","parseBetween","parseStream","b","slice","stream","between","throttle","markname","j","filter","lastIndexOf","parseThrottle","e","test","marktype","consume","debounce","a","split","_","x"],"sources":["C:/Users/sutul/node_modules/vega-event-selector/build/vega-event-selector.module.js"],"sourcesContent":["const VIEW = 'view',\n  LBRACK = '[',\n  RBRACK = ']',\n  LBRACE = '{',\n  RBRACE = '}',\n  COLON = ':',\n  COMMA = ',',\n  NAME = '@',\n  GT = '>',\n  ILLEGAL = /[[\\]{}]/,\n  DEFAULT_MARKS = {\n    '*': 1,\n    arc: 1,\n    area: 1,\n    group: 1,\n    image: 1,\n    line: 1,\n    path: 1,\n    rect: 1,\n    rule: 1,\n    shape: 1,\n    symbol: 1,\n    text: 1,\n    trail: 1\n  };\nlet DEFAULT_SOURCE, MARKS;\n\n/**\n * Parse an event selector string.\n * Returns an array of event stream definitions.\n */\nfunction eventSelector (selector, source, marks) {\n  DEFAULT_SOURCE = source || VIEW;\n  MARKS = marks || DEFAULT_MARKS;\n  return parseMerge(selector.trim()).map(parseSelector);\n}\nfunction isMarkType(type) {\n  return MARKS[type];\n}\nfunction find(s, i, endChar, pushChar, popChar) {\n  const n = s.length;\n  let count = 0,\n    c;\n  for (; i < n; ++i) {\n    c = s[i];\n    if (!count && c === endChar) return i;else if (popChar && popChar.indexOf(c) >= 0) --count;else if (pushChar && pushChar.indexOf(c) >= 0) ++count;\n  }\n  return i;\n}\nfunction parseMerge(s) {\n  const output = [],\n    n = s.length;\n  let start = 0,\n    i = 0;\n  while (i < n) {\n    i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);\n    output.push(s.substring(start, i).trim());\n    start = ++i;\n  }\n  if (output.length === 0) {\n    throw 'Empty event selector: ' + s;\n  }\n  return output;\n}\nfunction parseSelector(s) {\n  return s[0] === '[' ? parseBetween(s) : parseStream(s);\n}\nfunction parseBetween(s) {\n  const n = s.length;\n  let i = 1,\n    b;\n  i = find(s, i, RBRACK, LBRACK, RBRACK);\n  if (i === n) {\n    throw 'Empty between selector: ' + s;\n  }\n  b = parseMerge(s.substring(1, i));\n  if (b.length !== 2) {\n    throw 'Between selector must have two elements: ' + s;\n  }\n  s = s.slice(i + 1).trim();\n  if (s[0] !== GT) {\n    throw 'Expected \\'>\\' after between selector: ' + s;\n  }\n  b = b.map(parseSelector);\n  const stream = parseSelector(s.slice(1).trim());\n  if (stream.between) {\n    return {\n      between: b,\n      stream: stream\n    };\n  } else {\n    stream.between = b;\n  }\n  return stream;\n}\nfunction parseStream(s) {\n  const stream = {\n      source: DEFAULT_SOURCE\n    },\n    source = [];\n  let throttle = [0, 0],\n    markname = 0,\n    start = 0,\n    n = s.length,\n    i = 0,\n    j,\n    filter;\n\n  // extract throttle from end\n  if (s[n - 1] === RBRACE) {\n    i = s.lastIndexOf(LBRACE);\n    if (i >= 0) {\n      try {\n        throttle = parseThrottle(s.substring(i + 1, n - 1));\n      } catch (e) {\n        throw 'Invalid throttle specification: ' + s;\n      }\n      s = s.slice(0, i).trim();\n      n = s.length;\n    } else throw 'Unmatched right brace: ' + s;\n    i = 0;\n  }\n  if (!n) throw s;\n\n  // set name flag based on first char\n  if (s[0] === NAME) markname = ++i;\n\n  // extract first part of multi-part stream selector\n  j = find(s, i, COLON);\n  if (j < n) {\n    source.push(s.substring(start, j).trim());\n    start = i = ++j;\n  }\n\n  // extract remaining part of stream selector\n  i = find(s, i, LBRACK);\n  if (i === n) {\n    source.push(s.substring(start, n).trim());\n  } else {\n    source.push(s.substring(start, i).trim());\n    filter = [];\n    start = ++i;\n    if (start === n) throw 'Unmatched left bracket: ' + s;\n  }\n\n  // extract filters\n  while (i < n) {\n    i = find(s, i, RBRACK);\n    if (i === n) throw 'Unmatched left bracket: ' + s;\n    filter.push(s.substring(start, i).trim());\n    if (i < n - 1 && s[++i] !== LBRACK) throw 'Expected left bracket: ' + s;\n    start = ++i;\n  }\n\n  // marshall event stream specification\n  if (!(n = source.length) || ILLEGAL.test(source[n - 1])) {\n    throw 'Invalid event selector: ' + s;\n  }\n  if (n > 1) {\n    stream.type = source[1];\n    if (markname) {\n      stream.markname = source[0].slice(1);\n    } else if (isMarkType(source[0])) {\n      stream.marktype = source[0];\n    } else {\n      stream.source = source[0];\n    }\n  } else {\n    stream.type = source[0];\n  }\n  if (stream.type.slice(-1) === '!') {\n    stream.consume = true;\n    stream.type = stream.type.slice(0, -1);\n  }\n  if (filter != null) stream.filter = filter;\n  if (throttle[0]) stream.throttle = throttle[0];\n  if (throttle[1]) stream.debounce = throttle[1];\n  return stream;\n}\nfunction parseThrottle(s) {\n  const a = s.split(COMMA);\n  if (!s.length || a.length > 2) throw s;\n  return a.map(_ => {\n    const x = +_;\n    if (x !== x) throw s;\n    return x;\n  });\n}\n\nexport { eventSelector as parseSelector };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}