{"ast":null,"code":"import { truthy, error, hasOwnProperty, isFunction, isString, stringValue, extend, isArray, isObject, field, peek, identity, array as array$1, isBoolean, isDate, isNumber, isRegExp, toBoolean, toDate, toNumber, toString, flush, lerp, pad, span, inrange, truncate, quarter, utcquarter, extent, clampRange, panLinear, panLog, panPow, panSymlog, zoomLinear, zoomLog, zoomPow, zoomSymlog } from 'vega-util';\nimport { Literal, codegenExpression, constants, functions, parseExpression, CallExpression } from 'vega-expression';\nimport { isRegisteredScale, bandSpace, scale as scale$1, scaleFraction } from 'vega-scale';\nimport { geoArea as geoArea$1, geoBounds as geoBounds$1, geoCentroid as geoCentroid$1 } from 'd3-geo';\nimport { rgb, lab, hcl, hsl } from 'd3-color';\nimport { isTuple } from 'vega-dataflow';\nimport { Gradient, pathRender, pathParse, Bounds, intersect as intersect$1 } from 'vega-scenegraph';\nimport { selectionVisitor, selectionTest, selectionIdTest, selectionResolve, selectionTuples } from 'vega-selections';\nimport { random, cumulativeNormal, cumulativeLogNormal, cumulativeUniform, densityNormal, densityLogNormal, densityUniform, quantileNormal, quantileLogNormal, quantileUniform, sampleNormal, sampleLogNormal, sampleUniform } from 'vega-statistics';\nimport { utcOffset, utcSequence, timeOffset, timeSequence, timeUnitSpecifier, week, utcweek, dayofyear, utcdayofyear } from 'vega-time';\nimport { range as range$1 } from 'd3-array';\nfunction data(name) {\n  const data = this.context.data[name];\n  return data ? data.values.value : [];\n}\nfunction indata(name, field, value) {\n  const index = this.context.data[name]['index:' + field],\n    entry = index ? index.value.get(value) : undefined;\n  return entry ? entry.count : entry;\n}\nfunction setdata(name, tuples) {\n  const df = this.context.dataflow,\n    data = this.context.data[name],\n    input = data.input;\n  df.pulse(input, df.changeset().remove(truthy).insert(tuples));\n  return 1;\n}\nfunction encode(item, name, retval) {\n  if (item) {\n    const df = this.context.dataflow,\n      target = item.mark.source;\n    df.pulse(target, df.changeset().encode(item, name));\n  }\n  return retval !== undefined ? retval : item;\n}\nconst wrap = method => function (value, spec) {\n  const locale = this.context.dataflow.locale();\n  return value === null ? 'null' : locale[method](spec)(value);\n};\nconst format = wrap('format');\nconst timeFormat = wrap('timeFormat');\nconst utcFormat = wrap('utcFormat');\nconst timeParse = wrap('timeParse');\nconst utcParse = wrap('utcParse');\nconst dateObj = new Date(2000, 0, 1);\nfunction time(month, day, specifier) {\n  if (!Number.isInteger(month) || !Number.isInteger(day)) return '';\n  dateObj.setYear(2000);\n  dateObj.setMonth(month);\n  dateObj.setDate(day);\n  return timeFormat.call(this, dateObj, specifier);\n}\nfunction monthFormat(month) {\n  return time.call(this, month, 1, '%B');\n}\nfunction monthAbbrevFormat(month) {\n  return time.call(this, month, 1, '%b');\n}\nfunction dayFormat(day) {\n  return time.call(this, 0, 2 + day, '%A');\n}\nfunction dayAbbrevFormat(day) {\n  return time.call(this, 0, 2 + day, '%a');\n}\nconst DataPrefix = ':';\nconst IndexPrefix = '@';\nconst ScalePrefix = '%';\nconst SignalPrefix = '$';\nfunction dataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) {\n    error('First argument to data functions must be a string literal.');\n  }\n  const data = args[0].value,\n    dataName = DataPrefix + data;\n  if (!hasOwnProperty(dataName, params)) {\n    try {\n      params[dataName] = scope.getData(data).tuplesRef();\n    } catch (err) {\n      // if data set does not exist, there's nothing to track\n    }\n  }\n}\nfunction indataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to indata must be a string literal.');\n  if (args[1].type !== Literal) error('Second argument to indata must be a string literal.');\n  const data = args[0].value,\n    field = args[1].value,\n    indexName = IndexPrefix + field;\n  if (!hasOwnProperty(indexName, params)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n}\nfunction scaleVisitor(name, args, scope, params) {\n  if (args[0].type === Literal) {\n    // add scale dependency\n    addScaleDependency(scope, params, args[0].value);\n  } else {\n    // indirect scale lookup; add all scales as parameters\n    for (name in scope.scales) {\n      addScaleDependency(scope, params, name);\n    }\n  }\n}\nfunction addScaleDependency(scope, params, name) {\n  const scaleName = ScalePrefix + name;\n  if (!hasOwnProperty(params, scaleName)) {\n    try {\n      params[scaleName] = scope.scaleRef(name);\n    } catch (err) {\n      // TODO: error handling? warning?\n    }\n  }\n}\nfunction getScale(nameOrFunction, ctx) {\n  if (isFunction(nameOrFunction)) {\n    return nameOrFunction;\n  }\n  if (isString(nameOrFunction)) {\n    const maybeScale = ctx.scales[nameOrFunction];\n    return maybeScale && isRegisteredScale(maybeScale.value) ? maybeScale.value : undefined;\n  }\n  return undefined;\n}\nfunction internalScaleFunctions(codegen, fnctx, visitors) {\n  // add helper method to the 'this' expression function context\n  fnctx.__bandwidth = s => s && s.bandwidth ? s.bandwidth() : 0;\n\n  // register AST visitors for internal scale functions\n  visitors._bandwidth = scaleVisitor;\n  visitors._range = scaleVisitor;\n  visitors._scale = scaleVisitor;\n\n  // resolve scale reference directly to the signal hash argument\n  const ref = arg => '_[' + (arg.type === Literal ? stringValue(ScalePrefix + arg.value) : stringValue(ScalePrefix) + '+' + codegen(arg)) + ']';\n\n  // define and return internal scale function code generators\n  // these internal functions are called by mark encoders\n  return {\n    _bandwidth: args => `this.__bandwidth(${ref(args[0])})`,\n    _range: args => `${ref(args[0])}.range()`,\n    _scale: args => `${ref(args[0])}(${codegen(args[1])})`\n  };\n}\nfunction geoMethod(methodName, globalMethod) {\n  return function (projection, geojson, group) {\n    if (projection) {\n      // projection defined, use it\n      const p = getScale(projection, (group || this).context);\n      return p && p.path[methodName](geojson);\n    } else {\n      // projection undefined, use global method\n      return globalMethod(geojson);\n    }\n  };\n}\nconst geoArea = geoMethod('area', geoArea$1);\nconst geoBounds = geoMethod('bounds', geoBounds$1);\nconst geoCentroid = geoMethod('centroid', geoCentroid$1);\nfunction geoScale(projection, group) {\n  const p = getScale(projection, (group || this).context);\n  return p && p.scale();\n}\nfunction inScope(item) {\n  const group = this.context.group;\n  let value = false;\n  if (group) while (item) {\n    if (item === group) {\n      value = true;\n      break;\n    }\n    item = item.mark.group;\n  }\n  return value;\n}\nfunction log(df, method, args) {\n  try {\n    df[method].apply(df, ['EXPRESSION'].concat([].slice.call(args)));\n  } catch (err) {\n    df.warn(err);\n  }\n  return args[args.length - 1];\n}\nfunction warn() {\n  return log(this.context.dataflow, 'warn', arguments);\n}\nfunction info() {\n  return log(this.context.dataflow, 'info', arguments);\n}\nfunction debug() {\n  return log(this.context.dataflow, 'debug', arguments);\n}\n\n// https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\nfunction channel_luminance_value(channelValue) {\n  const val = channelValue / 255;\n  if (val <= 0.03928) {\n    return val / 12.92;\n  }\n  return Math.pow((val + 0.055) / 1.055, 2.4);\n}\nfunction luminance(color) {\n  const c = rgb(color),\n    r = channel_luminance_value(c.r),\n    g = channel_luminance_value(c.g),\n    b = channel_luminance_value(c.b);\n  return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n}\n\n// https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\nfunction contrast(color1, color2) {\n  const lum1 = luminance(color1),\n    lum2 = luminance(color2),\n    lumL = Math.max(lum1, lum2),\n    lumD = Math.min(lum1, lum2);\n  return (lumL + 0.05) / (lumD + 0.05);\n}\nfunction merge() {\n  const args = [].slice.call(arguments);\n  args.unshift({});\n  return extend(...args);\n}\nfunction equal(a, b) {\n  return a === b || a !== a && b !== b ? true : isArray(a) ? isArray(b) && a.length === b.length ? equalArray(a, b) : false : isObject(a) && isObject(b) ? equalObject(a, b) : false;\n}\nfunction equalArray(a, b) {\n  for (let i = 0, n = a.length; i < n; ++i) {\n    if (!equal(a[i], b[i])) return false;\n  }\n  return true;\n}\nfunction equalObject(a, b) {\n  for (const key in a) {\n    if (!equal(a[key], b[key])) return false;\n  }\n  return true;\n}\nfunction removePredicate(props) {\n  return _ => equalObject(props, _);\n}\nfunction modify(name, insert, remove, toggle, modify, values) {\n  const df = this.context.dataflow,\n    data = this.context.data[name],\n    input = data.input,\n    stamp = df.stamp();\n  let changes = data.changes,\n    predicate,\n    key;\n  if (df._trigger === false || !(input.value.length || insert || toggle)) {\n    // nothing to do!\n    return 0;\n  }\n  if (!changes || changes.stamp < stamp) {\n    data.changes = changes = df.changeset();\n    changes.stamp = stamp;\n    df.runAfter(() => {\n      data.modified = true;\n      df.pulse(input, changes).run();\n    }, true, 1);\n  }\n  if (remove) {\n    predicate = remove === true ? truthy : isArray(remove) || isTuple(remove) ? remove : removePredicate(remove);\n    changes.remove(predicate);\n  }\n  if (insert) {\n    changes.insert(insert);\n  }\n  if (toggle) {\n    predicate = removePredicate(toggle);\n    if (input.value.some(predicate)) {\n      changes.remove(predicate);\n    } else {\n      changes.insert(toggle);\n    }\n  }\n  if (modify) {\n    for (key in values) {\n      changes.modify(modify, key, values[key]);\n    }\n  }\n  return 1;\n}\nfunction pinchDistance(event) {\n  const t = event.touches,\n    dx = t[0].clientX - t[1].clientX,\n    dy = t[0].clientY - t[1].clientY;\n  return Math.hypot(dx, dy);\n}\nfunction pinchAngle(event) {\n  const t = event.touches;\n  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);\n}\n\n// memoize accessor functions\nconst accessors = {};\nfunction pluck(data, name) {\n  const accessor = accessors[name] || (accessors[name] = field(name));\n  return isArray(data) ? data.map(accessor) : accessor(data);\n}\nfunction array(seq) {\n  return isArray(seq) || ArrayBuffer.isView(seq) ? seq : null;\n}\nfunction sequence(seq) {\n  return array(seq) || (isString(seq) ? seq : null);\n}\nfunction join(seq) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  return array(seq).join(...args);\n}\nfunction indexof(seq) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n  return sequence(seq).indexOf(...args);\n}\nfunction lastindexof(seq) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n  return sequence(seq).lastIndexOf(...args);\n}\nfunction slice(seq) {\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n  return sequence(seq).slice(...args);\n}\nfunction replace(str, pattern, repl) {\n  if (isFunction(repl)) error('Function argument passed to replace.');\n  return String(str).replace(pattern, repl);\n}\nfunction reverse(seq) {\n  return array(seq).slice().reverse();\n}\nfunction bandspace(count, paddingInner, paddingOuter) {\n  return bandSpace(count || 0, paddingInner || 0, paddingOuter || 0);\n}\nfunction bandwidth(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s && s.bandwidth ? s.bandwidth() : 0;\n}\nfunction copy(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s.copy() : undefined;\n}\nfunction domain(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s.domain() : [];\n}\nfunction invert(name, range, group) {\n  const s = getScale(name, (group || this).context);\n  return !s ? undefined : isArray(range) ? (s.invertRange || s.invert)(range) : (s.invert || s.invertExtent)(range);\n}\nfunction range(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s && s.range ? s.range() : [];\n}\nfunction scale(name, value, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s(value) : undefined;\n}\nfunction scaleGradient(scale, p0, p1, count, group) {\n  scale = getScale(scale, (group || this).context);\n  const gradient = Gradient(p0, p1);\n  let stops = scale.domain(),\n    min = stops[0],\n    max = peek(stops),\n    fraction = identity;\n  if (!(max - min)) {\n    // expand scale if domain has zero span, fix #1479\n    scale = (scale.interpolator ? scale$1('sequential')().interpolator(scale.interpolator()) : scale$1('linear')().interpolate(scale.interpolate()).range(scale.range())).domain([min = 0, max = 1]);\n  } else {\n    fraction = scaleFraction(scale, min, max);\n  }\n  if (scale.ticks) {\n    stops = scale.ticks(+count || 15);\n    if (min !== stops[0]) stops.unshift(min);\n    if (max !== peek(stops)) stops.push(max);\n  }\n  stops.forEach(_ => gradient.stop(fraction(_), scale(_)));\n  return gradient;\n}\nfunction geoShape(projection, geojson, group) {\n  const p = getScale(projection, (group || this).context);\n  return function (context) {\n    return p ? p.path.context(context)(geojson) : '';\n  };\n}\nfunction pathShape(path) {\n  let p = null;\n  return function (context) {\n    return context ? pathRender(context, p = p || pathParse(path)) : path;\n  };\n}\nconst datum = d => d.data;\nfunction treeNodes(name, context) {\n  const tree = data.call(context, name);\n  return tree.root && tree.root.lookup || {};\n}\nfunction treePath(name, source, target) {\n  const nodes = treeNodes(name, this),\n    s = nodes[source],\n    t = nodes[target];\n  return s && t ? s.path(t).map(datum) : undefined;\n}\nfunction treeAncestors(name, node) {\n  const n = treeNodes(name, this)[node];\n  return n ? n.ancestors().map(datum) : undefined;\n}\nconst _window = () => typeof window !== 'undefined' && window || null;\nfunction screen() {\n  const w = _window();\n  return w ? w.screen : {};\n}\nfunction windowSize() {\n  const w = _window();\n  return w ? [w.innerWidth, w.innerHeight] : [undefined, undefined];\n}\nfunction containerSize() {\n  const view = this.context.dataflow,\n    el = view.container && view.container();\n  return el ? [el.clientWidth, el.clientHeight] : [undefined, undefined];\n}\nfunction intersect(b, opt, group) {\n  if (!b) return [];\n  const [u, v] = b,\n    box = new Bounds().set(u[0], u[1], v[0], v[1]),\n    scene = group || this.context.dataflow.scenegraph().root;\n  return intersect$1(scene, box, filter(opt));\n}\nfunction filter(opt) {\n  let p = null;\n  if (opt) {\n    const types = array$1(opt.marktype),\n      names = array$1(opt.markname);\n    p = _ => (!types.length || types.some(t => _.marktype === t)) && (!names.length || names.some(s => _.name === s));\n  }\n  return p;\n}\n\n/**\n * Appends a new point to the lasso\n *\n * @param {*} lasso the lasso in pixel space\n * @param {*} x the x coordinate in pixel space\n * @param {*} y the y coordinate in pixel space\n * @param {*} minDist the minimum distance, in pixels, that thenew point needs to be apart from the last point\n * @returns a new array containing the lasso with the new point\n */\nfunction lassoAppend(lasso, x, y) {\n  let minDist = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;\n  lasso = array$1(lasso);\n  const last = lasso[lasso.length - 1];\n\n  // Add point to lasso if its the first point or distance to last point exceed minDist\n  return last === undefined || Math.hypot(last[0] - x, last[1] - y) > minDist ? [...lasso, [x, y]] : lasso;\n}\n\n/**\n * Generates a svg path command which draws a lasso\n *\n * @param {*} lasso the lasso in pixel space in the form [[x,y], [x,y], ...]\n * @returns the svg path command that draws the lasso\n */\nfunction lassoPath(lasso) {\n  return array$1(lasso).reduce((svg, _ref, i) => {\n    let [x, y] = _ref;\n    return svg += i == 0 ? `M ${x},${y} ` : i === lasso.length - 1 ? ' Z' : `L ${x},${y} `;\n  }, '');\n}\n\n/**\n * Inverts the lasso from pixel space to an array of vega scenegraph tuples\n *\n * @param {*} data the dataset\n * @param {*} pixelLasso the lasso in pixel space, [[x,y], [x,y], ...]\n * @param {*} unit the unit where the lasso is defined\n *\n * @returns an array of vega scenegraph tuples\n */\nfunction intersectLasso(markname, pixelLasso, unit) {\n  const {\n    x,\n    y,\n    mark\n  } = unit;\n  const bb = new Bounds().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);\n\n  // Get bounding box around lasso\n  for (const [px, py] of pixelLasso) {\n    if (px < bb.x1) bb.x1 = px;\n    if (px > bb.x2) bb.x2 = px;\n    if (py < bb.y1) bb.y1 = py;\n    if (py > bb.y2) bb.y2 = py;\n  }\n\n  // Translate bb against unit coordinates\n  bb.translate(x, y);\n  const intersection = intersect([[bb.x1, bb.y1], [bb.x2, bb.y2]], markname, mark);\n\n  // Check every point against the lasso\n  return intersection.filter(tuple => pointInPolygon(tuple.x, tuple.y, pixelLasso));\n}\n\n/**\n * Performs a test if a point is inside a polygon based on the idea from\n * https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\n *\n * This method will not need the same start/end point since it wraps around the edges of the array\n *\n * @param {*} test a point to test against\n * @param {*} polygon a polygon in the form [[x,y], [x,y], ...]\n * @returns true if the point lies inside the polygon, false otherwise\n */\nfunction pointInPolygon(testx, testy, polygon) {\n  let intersections = 0;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const [prevX, prevY] = polygon[j];\n    const [x, y] = polygon[i];\n\n    // count intersections\n    if (y > testy != prevY > testy && testx < (prevX - x) * (testy - y) / (prevY - y) + x) {\n      intersections++;\n    }\n  }\n\n  // point is in polygon if intersection count is odd\n  return intersections & 1;\n}\n\n// Expression function context object\nconst functionContext = {\n  random() {\n    return random();\n  },\n  // override default\n  cumulativeNormal,\n  cumulativeLogNormal,\n  cumulativeUniform,\n  densityNormal,\n  densityLogNormal,\n  densityUniform,\n  quantileNormal,\n  quantileLogNormal,\n  quantileUniform,\n  sampleNormal,\n  sampleLogNormal,\n  sampleUniform,\n  isArray,\n  isBoolean,\n  isDate,\n  isDefined(_) {\n    return _ !== undefined;\n  },\n  isNumber,\n  isObject,\n  isRegExp,\n  isString,\n  isTuple,\n  isValid(_) {\n    return _ != null && _ === _;\n  },\n  toBoolean,\n  toDate(_) {\n    return toDate(_);\n  },\n  // suppress extra arguments\n  toNumber,\n  toString,\n  indexof,\n  join,\n  lastindexof,\n  replace,\n  reverse,\n  slice,\n  flush,\n  lerp,\n  merge,\n  pad,\n  peek,\n  pluck,\n  span,\n  inrange,\n  truncate,\n  rgb,\n  lab,\n  hcl,\n  hsl,\n  luminance,\n  contrast,\n  sequence: range$1,\n  format,\n  utcFormat,\n  utcParse,\n  utcOffset,\n  utcSequence,\n  timeFormat,\n  timeParse,\n  timeOffset,\n  timeSequence,\n  timeUnitSpecifier,\n  monthFormat,\n  monthAbbrevFormat,\n  dayFormat,\n  dayAbbrevFormat,\n  quarter,\n  utcquarter,\n  week,\n  utcweek,\n  dayofyear,\n  utcdayofyear,\n  warn,\n  info,\n  debug,\n  extent(_) {\n    return extent(_);\n  },\n  // suppress extra arguments\n  inScope,\n  intersect,\n  clampRange,\n  pinchDistance,\n  pinchAngle,\n  screen,\n  containerSize,\n  windowSize,\n  bandspace,\n  setdata,\n  pathShape,\n  panLinear,\n  panLog,\n  panPow,\n  panSymlog,\n  zoomLinear,\n  zoomLog,\n  zoomPow,\n  zoomSymlog,\n  encode,\n  modify,\n  lassoAppend,\n  lassoPath,\n  intersectLasso\n};\nconst eventFunctions = ['view', 'item', 'group', 'xy', 'x', 'y'],\n  // event functions\n  eventPrefix = 'event.vega.',\n  // event function prefix\n  thisPrefix = 'this.',\n  // function context prefix\n  astVisitors = {}; // AST visitors for dependency analysis\n\n// export code generator parameters\nconst codegenParams = {\n  forbidden: ['_'],\n  allowed: ['datum', 'event', 'item'],\n  fieldvar: 'datum',\n  globalvar: id => `_[${stringValue(SignalPrefix + id)}]`,\n  functions: buildFunctions,\n  constants: constants,\n  visitors: astVisitors\n};\n\n// export code generator\nconst codeGenerator = codegenExpression(codegenParams);\n\n// Build expression function registry\nfunction buildFunctions(codegen) {\n  const fn = functions(codegen);\n  eventFunctions.forEach(name => fn[name] = eventPrefix + name);\n  for (const name in functionContext) {\n    fn[name] = thisPrefix + name;\n  }\n  extend(fn, internalScaleFunctions(codegen, functionContext, astVisitors));\n  return fn;\n}\n\n// Register an expression function\nfunction expressionFunction(name, fn, visitor) {\n  if (arguments.length === 1) {\n    return functionContext[name];\n  }\n\n  // register with the functionContext\n  functionContext[name] = fn;\n\n  // if there is an astVisitor register that, too\n  if (visitor) astVisitors[name] = visitor;\n\n  // if the code generator has already been initialized,\n  // we need to also register the function with it\n  if (codeGenerator) codeGenerator.functions[name] = thisPrefix + name;\n  return this;\n}\n\n// register expression functions with ast visitors\nexpressionFunction('bandwidth', bandwidth, scaleVisitor);\nexpressionFunction('copy', copy, scaleVisitor);\nexpressionFunction('domain', domain, scaleVisitor);\nexpressionFunction('range', range, scaleVisitor);\nexpressionFunction('invert', invert, scaleVisitor);\nexpressionFunction('scale', scale, scaleVisitor);\nexpressionFunction('gradient', scaleGradient, scaleVisitor);\nexpressionFunction('geoArea', geoArea, scaleVisitor);\nexpressionFunction('geoBounds', geoBounds, scaleVisitor);\nexpressionFunction('geoCentroid', geoCentroid, scaleVisitor);\nexpressionFunction('geoShape', geoShape, scaleVisitor);\nexpressionFunction('geoScale', geoScale, scaleVisitor);\nexpressionFunction('indata', indata, indataVisitor);\nexpressionFunction('data', data, dataVisitor);\nexpressionFunction('treePath', treePath, dataVisitor);\nexpressionFunction('treeAncestors', treeAncestors, dataVisitor);\n\n// register Vega-Lite selection functions\nexpressionFunction('vlSelectionTest', selectionTest, selectionVisitor);\nexpressionFunction('vlSelectionIdTest', selectionIdTest, selectionVisitor);\nexpressionFunction('vlSelectionResolve', selectionResolve, selectionVisitor);\nexpressionFunction('vlSelectionTuples', selectionTuples);\nfunction parser(expr, scope) {\n  const params = {};\n\n  // parse the expression to an abstract syntax tree (ast)\n  let ast;\n  try {\n    expr = isString(expr) ? expr : stringValue(expr) + '';\n    ast = parseExpression(expr);\n  } catch (err) {\n    error('Expression parse error: ' + expr);\n  }\n\n  // analyze ast function calls for dependencies\n  ast.visit(node => {\n    if (node.type !== CallExpression) return;\n    const name = node.callee.name,\n      visit = codegenParams.visitors[name];\n    if (visit) visit(name, node.arguments, scope, params);\n  });\n\n  // perform code generation\n  const gen = codeGenerator(ast);\n\n  // collect signal dependencies\n  gen.globals.forEach(name => {\n    const signalName = SignalPrefix + name;\n    if (!hasOwnProperty(params, signalName) && scope.getSignal(name)) {\n      params[signalName] = scope.signalRef(name);\n    }\n  });\n\n  // return generated expression code and dependencies\n  return {\n    $expr: extend({\n      code: gen.code\n    }, scope.options.ast ? {\n      ast\n    } : null),\n    $fields: gen.fields,\n    $params: params\n  };\n}\nexport { DataPrefix, IndexPrefix, ScalePrefix, SignalPrefix, bandspace, bandwidth, codeGenerator, codegenParams, containerSize, contrast, copy, data, dataVisitor, dayAbbrevFormat, dayFormat, debug, domain, encode, expressionFunction, format, functionContext, geoArea, geoBounds, geoCentroid, geoScale, geoShape, inScope, indata, indataVisitor, indexof, info, invert, join, lastindexof, luminance, merge, modify, monthAbbrevFormat, monthFormat, parser as parseExpression, pathShape, pinchAngle, pinchDistance, pluck, range, replace, reverse, scale, scaleGradient, scaleVisitor, screen, setdata, slice, timeFormat, timeParse, treeAncestors, treePath, utcFormat, utcParse, warn, windowSize };","map":{"version":3,"names":["truthy","error","hasOwnProperty","isFunction","isString","stringValue","extend","isArray","isObject","field","peek","identity","array","array$1","isBoolean","isDate","isNumber","isRegExp","toBoolean","toDate","toNumber","toString","flush","lerp","pad","span","inrange","truncate","quarter","utcquarter","extent","clampRange","panLinear","panLog","panPow","panSymlog","zoomLinear","zoomLog","zoomPow","zoomSymlog","Literal","codegenExpression","constants","functions","parseExpression","CallExpression","isRegisteredScale","bandSpace","scale","scale$1","scaleFraction","geoArea","geoArea$1","geoBounds","geoBounds$1","geoCentroid","geoCentroid$1","rgb","lab","hcl","hsl","isTuple","Gradient","pathRender","pathParse","Bounds","intersect","intersect$1","selectionVisitor","selectionTest","selectionIdTest","selectionResolve","selectionTuples","random","cumulativeNormal","cumulativeLogNormal","cumulativeUniform","densityNormal","densityLogNormal","densityUniform","quantileNormal","quantileLogNormal","quantileUniform","sampleNormal","sampleLogNormal","sampleUniform","utcOffset","utcSequence","timeOffset","timeSequence","timeUnitSpecifier","week","utcweek","dayofyear","utcdayofyear","range","range$1","data","name","context","values","value","indata","index","entry","get","undefined","count","setdata","tuples","df","dataflow","input","pulse","changeset","remove","insert","encode","item","retval","target","mark","source","wrap","method","spec","locale","format","timeFormat","utcFormat","timeParse","utcParse","dateObj","Date","time","month","day","specifier","Number","isInteger","setYear","setMonth","setDate","call","monthFormat","monthAbbrevFormat","dayFormat","dayAbbrevFormat","DataPrefix","IndexPrefix","ScalePrefix","SignalPrefix","dataVisitor","args","scope","params","type","dataName","getData","tuplesRef","err","indataVisitor","indexName","indataRef","scaleVisitor","addScaleDependency","scales","scaleName","scaleRef","getScale","nameOrFunction","ctx","maybeScale","internalScaleFunctions","codegen","fnctx","visitors","__bandwidth","s","bandwidth","_bandwidth","_range","_scale","ref","arg","geoMethod","methodName","globalMethod","projection","geojson","group","p","path","geoScale","inScope","log","apply","concat","slice","warn","length","arguments","info","debug","channel_luminance_value","channelValue","val","Math","pow","luminance","color","c","r","g","b","contrast","color1","color2","lum1","lum2","lumL","max","lumD","min","merge","unshift","equal","a","equalArray","equalObject","i","n","key","removePredicate","props","_","modify","toggle","stamp","changes","predicate","_trigger","runAfter","modified","run","some","pinchDistance","event","t","touches","dx","clientX","dy","clientY","hypot","pinchAngle","atan2","accessors","pluck","accessor","map","seq","ArrayBuffer","isView","sequence","join","_len","Array","_key","indexof","_len2","_key2","indexOf","lastindexof","_len3","_key3","lastIndexOf","_len4","_key4","replace","str","pattern","repl","String","reverse","bandspace","paddingInner","paddingOuter","copy","domain","invert","invertRange","invertExtent","scaleGradient","p0","p1","gradient","stops","fraction","interpolator","interpolate","ticks","push","forEach","stop","geoShape","pathShape","datum","d","treeNodes","tree","root","lookup","treePath","nodes","treeAncestors","node","ancestors","_window","window","screen","w","windowSize","innerWidth","innerHeight","containerSize","view","el","container","clientWidth","clientHeight","opt","u","v","box","set","scene","scenegraph","filter","types","marktype","names","markname","lassoAppend","lasso","x","y","minDist","last","lassoPath","reduce","svg","_ref","intersectLasso","pixelLasso","unit","bb","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","px","py","x1","x2","y1","y2","translate","intersection","tuple","pointInPolygon","testx","testy","polygon","intersections","j","prevX","prevY","functionContext","isDefined","isValid","eventFunctions","eventPrefix","thisPrefix","astVisitors","codegenParams","forbidden","allowed","fieldvar","globalvar","id","buildFunctions","codeGenerator","fn","expressionFunction","visitor","parser","expr","ast","visit","callee","gen","globals","signalName","getSignal","signalRef","$expr","code","options","$fields","fields","$params"],"sources":["C:/Users/sutul/node_modules/vega-functions/build/vega-functions.module.js"],"sourcesContent":["import { truthy, error, hasOwnProperty, isFunction, isString, stringValue, extend, isArray, isObject, field, peek, identity, array as array$1, isBoolean, isDate, isNumber, isRegExp, toBoolean, toDate, toNumber, toString, flush, lerp, pad, span, inrange, truncate, quarter, utcquarter, extent, clampRange, panLinear, panLog, panPow, panSymlog, zoomLinear, zoomLog, zoomPow, zoomSymlog } from 'vega-util';\nimport { Literal, codegenExpression, constants, functions, parseExpression, CallExpression } from 'vega-expression';\nimport { isRegisteredScale, bandSpace, scale as scale$1, scaleFraction } from 'vega-scale';\nimport { geoArea as geoArea$1, geoBounds as geoBounds$1, geoCentroid as geoCentroid$1 } from 'd3-geo';\nimport { rgb, lab, hcl, hsl } from 'd3-color';\nimport { isTuple } from 'vega-dataflow';\nimport { Gradient, pathRender, pathParse, Bounds, intersect as intersect$1 } from 'vega-scenegraph';\nimport { selectionVisitor, selectionTest, selectionIdTest, selectionResolve, selectionTuples } from 'vega-selections';\nimport { random, cumulativeNormal, cumulativeLogNormal, cumulativeUniform, densityNormal, densityLogNormal, densityUniform, quantileNormal, quantileLogNormal, quantileUniform, sampleNormal, sampleLogNormal, sampleUniform } from 'vega-statistics';\nimport { utcOffset, utcSequence, timeOffset, timeSequence, timeUnitSpecifier, week, utcweek, dayofyear, utcdayofyear } from 'vega-time';\nimport { range as range$1 } from 'd3-array';\n\nfunction data(name) {\n  const data = this.context.data[name];\n  return data ? data.values.value : [];\n}\nfunction indata(name, field, value) {\n  const index = this.context.data[name]['index:' + field],\n    entry = index ? index.value.get(value) : undefined;\n  return entry ? entry.count : entry;\n}\nfunction setdata(name, tuples) {\n  const df = this.context.dataflow,\n    data = this.context.data[name],\n    input = data.input;\n  df.pulse(input, df.changeset().remove(truthy).insert(tuples));\n  return 1;\n}\n\nfunction encode (item, name, retval) {\n  if (item) {\n    const df = this.context.dataflow,\n      target = item.mark.source;\n    df.pulse(target, df.changeset().encode(item, name));\n  }\n  return retval !== undefined ? retval : item;\n}\n\nconst wrap = method => function (value, spec) {\n  const locale = this.context.dataflow.locale();\n  return value === null ? 'null' : locale[method](spec)(value);\n};\nconst format = wrap('format');\nconst timeFormat = wrap('timeFormat');\nconst utcFormat = wrap('utcFormat');\nconst timeParse = wrap('timeParse');\nconst utcParse = wrap('utcParse');\nconst dateObj = new Date(2000, 0, 1);\nfunction time(month, day, specifier) {\n  if (!Number.isInteger(month) || !Number.isInteger(day)) return '';\n  dateObj.setYear(2000);\n  dateObj.setMonth(month);\n  dateObj.setDate(day);\n  return timeFormat.call(this, dateObj, specifier);\n}\nfunction monthFormat(month) {\n  return time.call(this, month, 1, '%B');\n}\nfunction monthAbbrevFormat(month) {\n  return time.call(this, month, 1, '%b');\n}\nfunction dayFormat(day) {\n  return time.call(this, 0, 2 + day, '%A');\n}\nfunction dayAbbrevFormat(day) {\n  return time.call(this, 0, 2 + day, '%a');\n}\n\nconst DataPrefix = ':';\nconst IndexPrefix = '@';\nconst ScalePrefix = '%';\nconst SignalPrefix = '$';\n\nfunction dataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) {\n    error('First argument to data functions must be a string literal.');\n  }\n  const data = args[0].value,\n    dataName = DataPrefix + data;\n  if (!hasOwnProperty(dataName, params)) {\n    try {\n      params[dataName] = scope.getData(data).tuplesRef();\n    } catch (err) {\n      // if data set does not exist, there's nothing to track\n    }\n  }\n}\nfunction indataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to indata must be a string literal.');\n  if (args[1].type !== Literal) error('Second argument to indata must be a string literal.');\n  const data = args[0].value,\n    field = args[1].value,\n    indexName = IndexPrefix + field;\n  if (!hasOwnProperty(indexName, params)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n}\nfunction scaleVisitor(name, args, scope, params) {\n  if (args[0].type === Literal) {\n    // add scale dependency\n    addScaleDependency(scope, params, args[0].value);\n  } else {\n    // indirect scale lookup; add all scales as parameters\n    for (name in scope.scales) {\n      addScaleDependency(scope, params, name);\n    }\n  }\n}\nfunction addScaleDependency(scope, params, name) {\n  const scaleName = ScalePrefix + name;\n  if (!hasOwnProperty(params, scaleName)) {\n    try {\n      params[scaleName] = scope.scaleRef(name);\n    } catch (err) {\n      // TODO: error handling? warning?\n    }\n  }\n}\n\nfunction getScale(nameOrFunction, ctx) {\n  if (isFunction(nameOrFunction)) {\n    return nameOrFunction;\n  }\n  if (isString(nameOrFunction)) {\n    const maybeScale = ctx.scales[nameOrFunction];\n    return maybeScale && isRegisteredScale(maybeScale.value) ? maybeScale.value : undefined;\n  }\n  return undefined;\n}\nfunction internalScaleFunctions(codegen, fnctx, visitors) {\n  // add helper method to the 'this' expression function context\n  fnctx.__bandwidth = s => s && s.bandwidth ? s.bandwidth() : 0;\n\n  // register AST visitors for internal scale functions\n  visitors._bandwidth = scaleVisitor;\n  visitors._range = scaleVisitor;\n  visitors._scale = scaleVisitor;\n\n  // resolve scale reference directly to the signal hash argument\n  const ref = arg => '_[' + (arg.type === Literal ? stringValue(ScalePrefix + arg.value) : stringValue(ScalePrefix) + '+' + codegen(arg)) + ']';\n\n  // define and return internal scale function code generators\n  // these internal functions are called by mark encoders\n  return {\n    _bandwidth: args => `this.__bandwidth(${ref(args[0])})`,\n    _range: args => `${ref(args[0])}.range()`,\n    _scale: args => `${ref(args[0])}(${codegen(args[1])})`\n  };\n}\n\nfunction geoMethod(methodName, globalMethod) {\n  return function (projection, geojson, group) {\n    if (projection) {\n      // projection defined, use it\n      const p = getScale(projection, (group || this).context);\n      return p && p.path[methodName](geojson);\n    } else {\n      // projection undefined, use global method\n      return globalMethod(geojson);\n    }\n  };\n}\nconst geoArea = geoMethod('area', geoArea$1);\nconst geoBounds = geoMethod('bounds', geoBounds$1);\nconst geoCentroid = geoMethod('centroid', geoCentroid$1);\nfunction geoScale(projection, group) {\n  const p = getScale(projection, (group || this).context);\n  return p && p.scale();\n}\n\nfunction inScope (item) {\n  const group = this.context.group;\n  let value = false;\n  if (group) while (item) {\n    if (item === group) {\n      value = true;\n      break;\n    }\n    item = item.mark.group;\n  }\n  return value;\n}\n\nfunction log(df, method, args) {\n  try {\n    df[method].apply(df, ['EXPRESSION'].concat([].slice.call(args)));\n  } catch (err) {\n    df.warn(err);\n  }\n  return args[args.length - 1];\n}\nfunction warn() {\n  return log(this.context.dataflow, 'warn', arguments);\n}\nfunction info() {\n  return log(this.context.dataflow, 'info', arguments);\n}\nfunction debug() {\n  return log(this.context.dataflow, 'debug', arguments);\n}\n\n// https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\nfunction channel_luminance_value(channelValue) {\n  const val = channelValue / 255;\n  if (val <= 0.03928) {\n    return val / 12.92;\n  }\n  return Math.pow((val + 0.055) / 1.055, 2.4);\n}\nfunction luminance(color) {\n  const c = rgb(color),\n    r = channel_luminance_value(c.r),\n    g = channel_luminance_value(c.g),\n    b = channel_luminance_value(c.b);\n  return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n}\n\n// https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\nfunction contrast(color1, color2) {\n  const lum1 = luminance(color1),\n    lum2 = luminance(color2),\n    lumL = Math.max(lum1, lum2),\n    lumD = Math.min(lum1, lum2);\n  return (lumL + 0.05) / (lumD + 0.05);\n}\n\nfunction merge () {\n  const args = [].slice.call(arguments);\n  args.unshift({});\n  return extend(...args);\n}\n\nfunction equal(a, b) {\n  return a === b || a !== a && b !== b ? true : isArray(a) ? isArray(b) && a.length === b.length ? equalArray(a, b) : false : isObject(a) && isObject(b) ? equalObject(a, b) : false;\n}\nfunction equalArray(a, b) {\n  for (let i = 0, n = a.length; i < n; ++i) {\n    if (!equal(a[i], b[i])) return false;\n  }\n  return true;\n}\nfunction equalObject(a, b) {\n  for (const key in a) {\n    if (!equal(a[key], b[key])) return false;\n  }\n  return true;\n}\nfunction removePredicate(props) {\n  return _ => equalObject(props, _);\n}\nfunction modify (name, insert, remove, toggle, modify, values) {\n  const df = this.context.dataflow,\n    data = this.context.data[name],\n    input = data.input,\n    stamp = df.stamp();\n  let changes = data.changes,\n    predicate,\n    key;\n  if (df._trigger === false || !(input.value.length || insert || toggle)) {\n    // nothing to do!\n    return 0;\n  }\n  if (!changes || changes.stamp < stamp) {\n    data.changes = changes = df.changeset();\n    changes.stamp = stamp;\n    df.runAfter(() => {\n      data.modified = true;\n      df.pulse(input, changes).run();\n    }, true, 1);\n  }\n  if (remove) {\n    predicate = remove === true ? truthy : isArray(remove) || isTuple(remove) ? remove : removePredicate(remove);\n    changes.remove(predicate);\n  }\n  if (insert) {\n    changes.insert(insert);\n  }\n  if (toggle) {\n    predicate = removePredicate(toggle);\n    if (input.value.some(predicate)) {\n      changes.remove(predicate);\n    } else {\n      changes.insert(toggle);\n    }\n  }\n  if (modify) {\n    for (key in values) {\n      changes.modify(modify, key, values[key]);\n    }\n  }\n  return 1;\n}\n\nfunction pinchDistance(event) {\n  const t = event.touches,\n    dx = t[0].clientX - t[1].clientX,\n    dy = t[0].clientY - t[1].clientY;\n  return Math.hypot(dx, dy);\n}\nfunction pinchAngle(event) {\n  const t = event.touches;\n  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);\n}\n\n// memoize accessor functions\nconst accessors = {};\nfunction pluck (data, name) {\n  const accessor = accessors[name] || (accessors[name] = field(name));\n  return isArray(data) ? data.map(accessor) : accessor(data);\n}\n\nfunction array(seq) {\n  return isArray(seq) || ArrayBuffer.isView(seq) ? seq : null;\n}\nfunction sequence(seq) {\n  return array(seq) || (isString(seq) ? seq : null);\n}\nfunction join(seq) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  return array(seq).join(...args);\n}\nfunction indexof(seq) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n  return sequence(seq).indexOf(...args);\n}\nfunction lastindexof(seq) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n  return sequence(seq).lastIndexOf(...args);\n}\nfunction slice(seq) {\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n  return sequence(seq).slice(...args);\n}\nfunction replace(str, pattern, repl) {\n  if (isFunction(repl)) error('Function argument passed to replace.');\n  return String(str).replace(pattern, repl);\n}\nfunction reverse(seq) {\n  return array(seq).slice().reverse();\n}\n\nfunction bandspace(count, paddingInner, paddingOuter) {\n  return bandSpace(count || 0, paddingInner || 0, paddingOuter || 0);\n}\nfunction bandwidth(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s && s.bandwidth ? s.bandwidth() : 0;\n}\nfunction copy(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s.copy() : undefined;\n}\nfunction domain(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s.domain() : [];\n}\nfunction invert(name, range, group) {\n  const s = getScale(name, (group || this).context);\n  return !s ? undefined : isArray(range) ? (s.invertRange || s.invert)(range) : (s.invert || s.invertExtent)(range);\n}\nfunction range(name, group) {\n  const s = getScale(name, (group || this).context);\n  return s && s.range ? s.range() : [];\n}\nfunction scale(name, value, group) {\n  const s = getScale(name, (group || this).context);\n  return s ? s(value) : undefined;\n}\n\nfunction scaleGradient (scale, p0, p1, count, group) {\n  scale = getScale(scale, (group || this).context);\n  const gradient = Gradient(p0, p1);\n  let stops = scale.domain(),\n    min = stops[0],\n    max = peek(stops),\n    fraction = identity;\n  if (!(max - min)) {\n    // expand scale if domain has zero span, fix #1479\n    scale = (scale.interpolator ? scale$1('sequential')().interpolator(scale.interpolator()) : scale$1('linear')().interpolate(scale.interpolate()).range(scale.range())).domain([min = 0, max = 1]);\n  } else {\n    fraction = scaleFraction(scale, min, max);\n  }\n  if (scale.ticks) {\n    stops = scale.ticks(+count || 15);\n    if (min !== stops[0]) stops.unshift(min);\n    if (max !== peek(stops)) stops.push(max);\n  }\n  stops.forEach(_ => gradient.stop(fraction(_), scale(_)));\n  return gradient;\n}\n\nfunction geoShape(projection, geojson, group) {\n  const p = getScale(projection, (group || this).context);\n  return function (context) {\n    return p ? p.path.context(context)(geojson) : '';\n  };\n}\nfunction pathShape(path) {\n  let p = null;\n  return function (context) {\n    return context ? pathRender(context, p = p || pathParse(path)) : path;\n  };\n}\n\nconst datum = d => d.data;\nfunction treeNodes(name, context) {\n  const tree = data.call(context, name);\n  return tree.root && tree.root.lookup || {};\n}\nfunction treePath(name, source, target) {\n  const nodes = treeNodes(name, this),\n    s = nodes[source],\n    t = nodes[target];\n  return s && t ? s.path(t).map(datum) : undefined;\n}\nfunction treeAncestors(name, node) {\n  const n = treeNodes(name, this)[node];\n  return n ? n.ancestors().map(datum) : undefined;\n}\n\nconst _window = () => typeof window !== 'undefined' && window || null;\nfunction screen() {\n  const w = _window();\n  return w ? w.screen : {};\n}\nfunction windowSize() {\n  const w = _window();\n  return w ? [w.innerWidth, w.innerHeight] : [undefined, undefined];\n}\nfunction containerSize() {\n  const view = this.context.dataflow,\n    el = view.container && view.container();\n  return el ? [el.clientWidth, el.clientHeight] : [undefined, undefined];\n}\n\nfunction intersect (b, opt, group) {\n  if (!b) return [];\n  const [u, v] = b,\n    box = new Bounds().set(u[0], u[1], v[0], v[1]),\n    scene = group || this.context.dataflow.scenegraph().root;\n  return intersect$1(scene, box, filter(opt));\n}\nfunction filter(opt) {\n  let p = null;\n  if (opt) {\n    const types = array$1(opt.marktype),\n      names = array$1(opt.markname);\n    p = _ => (!types.length || types.some(t => _.marktype === t)) && (!names.length || names.some(s => _.name === s));\n  }\n  return p;\n}\n\n/**\n * Appends a new point to the lasso\n *\n * @param {*} lasso the lasso in pixel space\n * @param {*} x the x coordinate in pixel space\n * @param {*} y the y coordinate in pixel space\n * @param {*} minDist the minimum distance, in pixels, that thenew point needs to be apart from the last point\n * @returns a new array containing the lasso with the new point\n */\nfunction lassoAppend(lasso, x, y) {\n  let minDist = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;\n  lasso = array$1(lasso);\n  const last = lasso[lasso.length - 1];\n\n  // Add point to lasso if its the first point or distance to last point exceed minDist\n  return last === undefined || Math.hypot(last[0] - x, last[1] - y) > minDist ? [...lasso, [x, y]] : lasso;\n}\n\n/**\n * Generates a svg path command which draws a lasso\n *\n * @param {*} lasso the lasso in pixel space in the form [[x,y], [x,y], ...]\n * @returns the svg path command that draws the lasso\n */\nfunction lassoPath(lasso) {\n  return array$1(lasso).reduce((svg, _ref, i) => {\n    let [x, y] = _ref;\n    return svg += i == 0 ? `M ${x},${y} ` : i === lasso.length - 1 ? ' Z' : `L ${x},${y} `;\n  }, '');\n}\n\n/**\n * Inverts the lasso from pixel space to an array of vega scenegraph tuples\n *\n * @param {*} data the dataset\n * @param {*} pixelLasso the lasso in pixel space, [[x,y], [x,y], ...]\n * @param {*} unit the unit where the lasso is defined\n *\n * @returns an array of vega scenegraph tuples\n */\nfunction intersectLasso(markname, pixelLasso, unit) {\n  const {\n    x,\n    y,\n    mark\n  } = unit;\n  const bb = new Bounds().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);\n\n  // Get bounding box around lasso\n  for (const [px, py] of pixelLasso) {\n    if (px < bb.x1) bb.x1 = px;\n    if (px > bb.x2) bb.x2 = px;\n    if (py < bb.y1) bb.y1 = py;\n    if (py > bb.y2) bb.y2 = py;\n  }\n\n  // Translate bb against unit coordinates\n  bb.translate(x, y);\n  const intersection = intersect([[bb.x1, bb.y1], [bb.x2, bb.y2]], markname, mark);\n\n  // Check every point against the lasso\n  return intersection.filter(tuple => pointInPolygon(tuple.x, tuple.y, pixelLasso));\n}\n\n/**\n * Performs a test if a point is inside a polygon based on the idea from\n * https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\n *\n * This method will not need the same start/end point since it wraps around the edges of the array\n *\n * @param {*} test a point to test against\n * @param {*} polygon a polygon in the form [[x,y], [x,y], ...]\n * @returns true if the point lies inside the polygon, false otherwise\n */\nfunction pointInPolygon(testx, testy, polygon) {\n  let intersections = 0;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const [prevX, prevY] = polygon[j];\n    const [x, y] = polygon[i];\n\n    // count intersections\n    if (y > testy != prevY > testy && testx < (prevX - x) * (testy - y) / (prevY - y) + x) {\n      intersections++;\n    }\n  }\n\n  // point is in polygon if intersection count is odd\n  return intersections & 1;\n}\n\n// Expression function context object\nconst functionContext = {\n  random() {\n    return random();\n  },\n  // override default\n  cumulativeNormal,\n  cumulativeLogNormal,\n  cumulativeUniform,\n  densityNormal,\n  densityLogNormal,\n  densityUniform,\n  quantileNormal,\n  quantileLogNormal,\n  quantileUniform,\n  sampleNormal,\n  sampleLogNormal,\n  sampleUniform,\n  isArray,\n  isBoolean,\n  isDate,\n  isDefined(_) {\n    return _ !== undefined;\n  },\n  isNumber,\n  isObject,\n  isRegExp,\n  isString,\n  isTuple,\n  isValid(_) {\n    return _ != null && _ === _;\n  },\n  toBoolean,\n  toDate(_) {\n    return toDate(_);\n  },\n  // suppress extra arguments\n  toNumber,\n  toString,\n  indexof,\n  join,\n  lastindexof,\n  replace,\n  reverse,\n  slice,\n  flush,\n  lerp,\n  merge,\n  pad,\n  peek,\n  pluck,\n  span,\n  inrange,\n  truncate,\n  rgb,\n  lab,\n  hcl,\n  hsl,\n  luminance,\n  contrast,\n  sequence: range$1,\n  format,\n  utcFormat,\n  utcParse,\n  utcOffset,\n  utcSequence,\n  timeFormat,\n  timeParse,\n  timeOffset,\n  timeSequence,\n  timeUnitSpecifier,\n  monthFormat,\n  monthAbbrevFormat,\n  dayFormat,\n  dayAbbrevFormat,\n  quarter,\n  utcquarter,\n  week,\n  utcweek,\n  dayofyear,\n  utcdayofyear,\n  warn,\n  info,\n  debug,\n  extent(_) {\n    return extent(_);\n  },\n  // suppress extra arguments\n  inScope,\n  intersect,\n  clampRange,\n  pinchDistance,\n  pinchAngle,\n  screen,\n  containerSize,\n  windowSize,\n  bandspace,\n  setdata,\n  pathShape,\n  panLinear,\n  panLog,\n  panPow,\n  panSymlog,\n  zoomLinear,\n  zoomLog,\n  zoomPow,\n  zoomSymlog,\n  encode,\n  modify,\n  lassoAppend,\n  lassoPath,\n  intersectLasso\n};\nconst eventFunctions = ['view', 'item', 'group', 'xy', 'x', 'y'],\n  // event functions\n  eventPrefix = 'event.vega.',\n  // event function prefix\n  thisPrefix = 'this.',\n  // function context prefix\n  astVisitors = {}; // AST visitors for dependency analysis\n\n// export code generator parameters\nconst codegenParams = {\n  forbidden: ['_'],\n  allowed: ['datum', 'event', 'item'],\n  fieldvar: 'datum',\n  globalvar: id => `_[${stringValue(SignalPrefix + id)}]`,\n  functions: buildFunctions,\n  constants: constants,\n  visitors: astVisitors\n};\n\n// export code generator\nconst codeGenerator = codegenExpression(codegenParams);\n\n// Build expression function registry\nfunction buildFunctions(codegen) {\n  const fn = functions(codegen);\n  eventFunctions.forEach(name => fn[name] = eventPrefix + name);\n  for (const name in functionContext) {\n    fn[name] = thisPrefix + name;\n  }\n  extend(fn, internalScaleFunctions(codegen, functionContext, astVisitors));\n  return fn;\n}\n\n// Register an expression function\nfunction expressionFunction(name, fn, visitor) {\n  if (arguments.length === 1) {\n    return functionContext[name];\n  }\n\n  // register with the functionContext\n  functionContext[name] = fn;\n\n  // if there is an astVisitor register that, too\n  if (visitor) astVisitors[name] = visitor;\n\n  // if the code generator has already been initialized,\n  // we need to also register the function with it\n  if (codeGenerator) codeGenerator.functions[name] = thisPrefix + name;\n  return this;\n}\n\n// register expression functions with ast visitors\nexpressionFunction('bandwidth', bandwidth, scaleVisitor);\nexpressionFunction('copy', copy, scaleVisitor);\nexpressionFunction('domain', domain, scaleVisitor);\nexpressionFunction('range', range, scaleVisitor);\nexpressionFunction('invert', invert, scaleVisitor);\nexpressionFunction('scale', scale, scaleVisitor);\nexpressionFunction('gradient', scaleGradient, scaleVisitor);\nexpressionFunction('geoArea', geoArea, scaleVisitor);\nexpressionFunction('geoBounds', geoBounds, scaleVisitor);\nexpressionFunction('geoCentroid', geoCentroid, scaleVisitor);\nexpressionFunction('geoShape', geoShape, scaleVisitor);\nexpressionFunction('geoScale', geoScale, scaleVisitor);\nexpressionFunction('indata', indata, indataVisitor);\nexpressionFunction('data', data, dataVisitor);\nexpressionFunction('treePath', treePath, dataVisitor);\nexpressionFunction('treeAncestors', treeAncestors, dataVisitor);\n\n// register Vega-Lite selection functions\nexpressionFunction('vlSelectionTest', selectionTest, selectionVisitor);\nexpressionFunction('vlSelectionIdTest', selectionIdTest, selectionVisitor);\nexpressionFunction('vlSelectionResolve', selectionResolve, selectionVisitor);\nexpressionFunction('vlSelectionTuples', selectionTuples);\n\nfunction parser (expr, scope) {\n  const params = {};\n\n  // parse the expression to an abstract syntax tree (ast)\n  let ast;\n  try {\n    expr = isString(expr) ? expr : stringValue(expr) + '';\n    ast = parseExpression(expr);\n  } catch (err) {\n    error('Expression parse error: ' + expr);\n  }\n\n  // analyze ast function calls for dependencies\n  ast.visit(node => {\n    if (node.type !== CallExpression) return;\n    const name = node.callee.name,\n      visit = codegenParams.visitors[name];\n    if (visit) visit(name, node.arguments, scope, params);\n  });\n\n  // perform code generation\n  const gen = codeGenerator(ast);\n\n  // collect signal dependencies\n  gen.globals.forEach(name => {\n    const signalName = SignalPrefix + name;\n    if (!hasOwnProperty(params, signalName) && scope.getSignal(name)) {\n      params[signalName] = scope.signalRef(name);\n    }\n  });\n\n  // return generated expression code and dependencies\n  return {\n    $expr: extend({\n      code: gen.code\n    }, scope.options.ast ? {\n      ast\n    } : null),\n    $fields: gen.fields,\n    $params: params\n  };\n}\n\nexport { DataPrefix, IndexPrefix, ScalePrefix, SignalPrefix, bandspace, bandwidth, codeGenerator, codegenParams, containerSize, contrast, copy, data, dataVisitor, dayAbbrevFormat, dayFormat, debug, domain, encode, expressionFunction, format, functionContext, geoArea, geoBounds, geoCentroid, geoScale, geoShape, inScope, indata, indataVisitor, indexof, info, invert, join, lastindexof, luminance, merge, modify, monthAbbrevFormat, monthFormat, parser as parseExpression, pathShape, pinchAngle, pinchDistance, pluck, range, replace, reverse, scale, scaleGradient, scaleVisitor, screen, setdata, slice, timeFormat, timeParse, treeAncestors, treePath, utcFormat, utcParse, warn, windowSize };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}