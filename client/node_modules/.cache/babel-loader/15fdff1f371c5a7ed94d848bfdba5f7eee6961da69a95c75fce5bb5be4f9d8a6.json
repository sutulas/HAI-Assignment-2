{"ast":null,"code":"import { array, isObject } from 'vega-util';\nimport { getPositionChannelFromLatLong, isGeoPositionChannel, isScaleChannel, isSingleDefUnitChannel } from '../../channel';\nimport * as log from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { SELECTION_ID } from '../../selection';\nimport { hash, keys, varName, isEmpty } from '../../util';\nimport { TimeUnitNode } from '../data/timeunit';\nimport { assembleProjection } from './assemble';\nimport { isBinnedTimeUnit } from '../../timeunit';\nexport const TUPLE_FIELDS = '_tuple_fields';\nexport class SelectionProjectionComponent {\n  constructor() {\n    for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n      items[_key] = arguments[_key];\n    }\n    this.items = items;\n    this.hasChannel = {};\n    this.hasField = {};\n    this.hasSelectionId = false;\n  }\n}\nconst project = {\n  defined: () => {\n    return true; // This transform handles its own defaults, so always run parse.\n  },\n  parse: (model, selCmpt, selDef) => {\n    const name = selCmpt.name;\n    const proj = selCmpt.project ?? (selCmpt.project = new SelectionProjectionComponent());\n    const parsed = {};\n    const timeUnits = {};\n    const signals = new Set();\n    const signalName = (p, range) => {\n      const suffix = range === 'visual' ? p.channel : p.field;\n      let sg = varName(`${name}_${suffix}`);\n      for (let counter = 1; signals.has(sg); counter++) {\n        sg = varName(`${name}_${suffix}_${counter}`);\n      }\n      signals.add(sg);\n      return {\n        [range]: sg\n      };\n    };\n    const type = selCmpt.type;\n    const cfg = model.config.selection[type];\n    const init = selDef.value !== undefined ? array(selDef.value) : null;\n    // If no explicit projection (either fields or encodings) is specified, set some defaults.\n    // If an initial value is set, try to infer projections.\n    let {\n      fields,\n      encodings\n    } = isObject(selDef.select) ? selDef.select : {};\n    if (!fields && !encodings && init) {\n      for (const initVal of init) {\n        // initVal may be a scalar value to smoothen varParam -> pointSelection gradient.\n        if (!isObject(initVal)) {\n          continue;\n        }\n        for (const key of keys(initVal)) {\n          if (isSingleDefUnitChannel(key)) {\n            (encodings || (encodings = [])).push(key);\n          } else {\n            if (type === 'interval') {\n              log.warn(log.message.INTERVAL_INITIALIZED_WITH_POS);\n              encodings = cfg.encodings;\n            } else {\n              (fields ?? (fields = [])).push(key);\n            }\n          }\n        }\n      }\n    }\n    // If no initial value is specified, use the default configuration.\n    // We break this out as a separate if block (instead of an else condition)\n    // to account for unprojected point selections that have scalar initial values\n    if (!fields && !encodings) {\n      encodings = cfg.encodings;\n      if ('fields' in cfg) {\n        fields = cfg.fields;\n      }\n    }\n    for (const channel of encodings ?? []) {\n      const fieldDef = model.fieldDef(channel);\n      if (fieldDef) {\n        let field = fieldDef.field;\n        if (fieldDef.aggregate) {\n          log.warn(log.message.cannotProjectAggregate(channel, fieldDef.aggregate));\n          continue;\n        } else if (!field) {\n          log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n          continue;\n        }\n        if (fieldDef.timeUnit && !isBinnedTimeUnit(fieldDef.timeUnit)) {\n          field = model.vgField(channel);\n          // Construct TimeUnitComponents which will be combined into a\n          // TimeUnitNode. This node may need to be inserted into the\n          // dataflow if the selection is used across views that do not\n          // have these time units defined.\n          const component = {\n            timeUnit: fieldDef.timeUnit,\n            as: field,\n            field: fieldDef.field\n          };\n          timeUnits[hash(component)] = component;\n        }\n        // Prevent duplicate projections on the same field.\n        // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n        if (!parsed[field]) {\n          // Determine whether the tuple will store enumerated or ranged values.\n          // Interval selections store ranges for continuous scales, and enumerations otherwise.\n          // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n          const tplType = type === 'interval' && isScaleChannel(channel) && hasContinuousDomain(model.getScaleComponent(channel).get('type')) ? 'R' : fieldDef.bin ? 'R-RE' : 'E';\n          const p = {\n            field,\n            channel,\n            type: tplType,\n            index: proj.items.length\n          };\n          p.signals = {\n            ...signalName(p, 'data'),\n            ...signalName(p, 'visual')\n          };\n          proj.items.push(parsed[field] = p);\n          proj.hasField[field] = parsed[field];\n          proj.hasSelectionId = proj.hasSelectionId || field === SELECTION_ID;\n          if (isGeoPositionChannel(channel)) {\n            p.geoChannel = channel;\n            p.channel = getPositionChannelFromLatLong(channel);\n            proj.hasChannel[p.channel] = parsed[field];\n          } else {\n            proj.hasChannel[channel] = parsed[field];\n          }\n        }\n      } else {\n        log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n      }\n    }\n    for (const field of fields ?? []) {\n      if (proj.hasField[field]) continue;\n      const p = {\n        type: 'E',\n        field,\n        index: proj.items.length\n      };\n      p.signals = {\n        ...signalName(p, 'data')\n      };\n      proj.items.push(p);\n      proj.hasField[field] = p;\n      proj.hasSelectionId = proj.hasSelectionId || field === SELECTION_ID;\n    }\n    if (init) {\n      selCmpt.init = init.map(v => {\n        // Selections can be initialized either with a full object that maps projections to values\n        // or scalar values to smoothen the abstraction gradient from variable params to point selections.\n        return proj.items.map(p => isObject(v) ? v[p.geoChannel || p.channel] !== undefined ? v[p.geoChannel || p.channel] : v[p.field] : v);\n      });\n    }\n    if (!isEmpty(timeUnits)) {\n      proj.timeUnit = new TimeUnitNode(null, timeUnits);\n    }\n  },\n  signals: (model, selCmpt, allSignals) => {\n    const name = selCmpt.name + TUPLE_FIELDS;\n    const hasSignal = allSignals.filter(s => s.name === name);\n    return hasSignal.length > 0 || selCmpt.project.hasSelectionId ? allSignals : allSignals.concat({\n      name,\n      value: selCmpt.project.items.map(assembleProjection)\n    });\n  }\n};\nexport default project;","map":{"version":3,"names":["array","isObject","getPositionChannelFromLatLong","isGeoPositionChannel","isScaleChannel","isSingleDefUnitChannel","log","hasContinuousDomain","SELECTION_ID","hash","keys","varName","isEmpty","TimeUnitNode","assembleProjection","isBinnedTimeUnit","TUPLE_FIELDS","SelectionProjectionComponent","constructor","_len","arguments","length","items","Array","_key","hasChannel","hasField","hasSelectionId","project","defined","parse","model","selCmpt","selDef","name","proj","parsed","timeUnits","signals","Set","signalName","p","range","suffix","channel","field","sg","counter","has","add","type","cfg","config","selection","init","value","undefined","fields","encodings","select","initVal","key","push","warn","message","INTERVAL_INITIALIZED_WITH_POS","fieldDef","aggregate","cannotProjectAggregate","cannotProjectOnChannelWithoutField","timeUnit","vgField","component","as","tplType","getScaleComponent","get","bin","index","geoChannel","map","v","allSignals","hasSignal","filter","s","concat"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\selection\\project.ts"],"sourcesContent":["import {array, isObject} from 'vega-util';\nimport {\n  GeoPositionChannel,\n  getPositionChannelFromLatLong,\n  isGeoPositionChannel,\n  isScaleChannel,\n  isSingleDefUnitChannel,\n  SingleDefUnitChannel\n} from '../../channel';\nimport * as log from '../../log';\nimport {hasContinuousDomain} from '../../scale';\nimport {PointSelectionConfig, SelectionInitIntervalMapping, SelectionInitMapping, SELECTION_ID} from '../../selection';\nimport {Dict, hash, keys, varName, isEmpty} from '../../util';\nimport {TimeUnitComponent, TimeUnitNode} from '../data/timeunit';\nimport {SelectionCompiler} from '.';\nimport {assembleProjection} from './assemble';\nimport {isBinnedTimeUnit} from '../../timeunit';\nexport const TUPLE_FIELDS = '_tuple_fields';\n\n/**\n * Whether the selection tuples hold enumerated or ranged values for a field.\n */\nexport type TupleStoreType =\n  // enumerated\n  | 'E'\n  // ranged, exclusive, left-right inclusive\n  | 'R'\n  // ranged, left-inclusive, right-exclusive\n  | 'R-RE';\n\nexport interface SelectionProjection {\n  type: TupleStoreType;\n  field: string;\n  index: number;\n  channel?: SingleDefUnitChannel;\n  geoChannel?: GeoPositionChannel;\n  signals?: {data?: string; visual?: string};\n  hasLegend?: boolean;\n}\n\nexport class SelectionProjectionComponent {\n  public hasChannel: Partial<Record<SingleDefUnitChannel, SelectionProjection>>;\n  public hasField: Record<string, SelectionProjection>;\n  public hasSelectionId: boolean;\n  public timeUnit?: TimeUnitNode;\n  public items: SelectionProjection[];\n\n  constructor(...items: SelectionProjection[]) {\n    this.items = items;\n    this.hasChannel = {};\n    this.hasField = {};\n    this.hasSelectionId = false;\n  }\n}\n\nconst project: SelectionCompiler = {\n  defined: () => {\n    return true; // This transform handles its own defaults, so always run parse.\n  },\n\n  parse: (model, selCmpt, selDef) => {\n    const name = selCmpt.name;\n    const proj = (selCmpt.project ??= new SelectionProjectionComponent());\n    const parsed: Dict<SelectionProjection> = {};\n    const timeUnits: Dict<TimeUnitComponent> = {};\n\n    const signals = new Set<string>();\n    const signalName = (p: SelectionProjection, range: 'data' | 'visual') => {\n      const suffix = range === 'visual' ? p.channel : p.field;\n      let sg = varName(`${name}_${suffix}`);\n      for (let counter = 1; signals.has(sg); counter++) {\n        sg = varName(`${name}_${suffix}_${counter}`);\n      }\n      signals.add(sg);\n      return {[range]: sg};\n    };\n\n    const type = selCmpt.type;\n    const cfg = model.config.selection[type];\n    const init =\n      selDef.value !== undefined\n        ? (array(selDef.value as any) as SelectionInitMapping[] | SelectionInitIntervalMapping[])\n        : null;\n\n    // If no explicit projection (either fields or encodings) is specified, set some defaults.\n    // If an initial value is set, try to infer projections.\n    let {fields, encodings} = (isObject(selDef.select) ? selDef.select : {}) as PointSelectionConfig;\n    if (!fields && !encodings && init) {\n      for (const initVal of init) {\n        // initVal may be a scalar value to smoothen varParam -> pointSelection gradient.\n        if (!isObject(initVal)) {\n          continue;\n        }\n\n        for (const key of keys(initVal)) {\n          if (isSingleDefUnitChannel(key)) {\n            (encodings || (encodings = [])).push(key as SingleDefUnitChannel);\n          } else {\n            if (type === 'interval') {\n              log.warn(log.message.INTERVAL_INITIALIZED_WITH_POS);\n              encodings = cfg.encodings;\n            } else {\n              (fields ??= []).push(key);\n            }\n          }\n        }\n      }\n    }\n\n    // If no initial value is specified, use the default configuration.\n    // We break this out as a separate if block (instead of an else condition)\n    // to account for unprojected point selections that have scalar initial values\n    if (!fields && !encodings) {\n      encodings = cfg.encodings;\n      if ('fields' in cfg) {\n        fields = cfg.fields;\n      }\n    }\n\n    for (const channel of encodings ?? []) {\n      const fieldDef = model.fieldDef(channel);\n      if (fieldDef) {\n        let field = fieldDef.field;\n\n        if (fieldDef.aggregate) {\n          log.warn(log.message.cannotProjectAggregate(channel, fieldDef.aggregate));\n          continue;\n        } else if (!field) {\n          log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n          continue;\n        }\n\n        if (fieldDef.timeUnit && !isBinnedTimeUnit(fieldDef.timeUnit)) {\n          field = model.vgField(channel);\n          // Construct TimeUnitComponents which will be combined into a\n          // TimeUnitNode. This node may need to be inserted into the\n          // dataflow if the selection is used across views that do not\n          // have these time units defined.\n          const component = {\n            timeUnit: fieldDef.timeUnit,\n            as: field,\n            field: fieldDef.field\n          };\n\n          timeUnits[hash(component)] = component;\n        }\n\n        // Prevent duplicate projections on the same field.\n        // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n        if (!parsed[field]) {\n          // Determine whether the tuple will store enumerated or ranged values.\n          // Interval selections store ranges for continuous scales, and enumerations otherwise.\n          // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n          const tplType: TupleStoreType =\n            type === 'interval' &&\n            isScaleChannel(channel) &&\n            hasContinuousDomain(model.getScaleComponent(channel).get('type'))\n              ? 'R'\n              : fieldDef.bin\n                ? 'R-RE'\n                : 'E';\n\n          const p: SelectionProjection = {field, channel, type: tplType, index: proj.items.length};\n          p.signals = {...signalName(p, 'data'), ...signalName(p, 'visual')};\n          proj.items.push((parsed[field] = p));\n          proj.hasField[field] = parsed[field];\n          proj.hasSelectionId = proj.hasSelectionId || field === SELECTION_ID;\n\n          if (isGeoPositionChannel(channel)) {\n            p.geoChannel = channel;\n            p.channel = getPositionChannelFromLatLong(channel);\n            proj.hasChannel[p.channel] = parsed[field];\n          } else {\n            proj.hasChannel[channel] = parsed[field];\n          }\n        }\n      } else {\n        log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n      }\n    }\n\n    for (const field of fields ?? []) {\n      if (proj.hasField[field]) continue;\n      const p: SelectionProjection = {type: 'E', field, index: proj.items.length};\n      p.signals = {...signalName(p, 'data')};\n      proj.items.push(p);\n      proj.hasField[field] = p;\n      proj.hasSelectionId = proj.hasSelectionId || field === SELECTION_ID;\n    }\n\n    if (init) {\n      selCmpt.init = (init as any).map((v: SelectionInitMapping | SelectionInitIntervalMapping) => {\n        // Selections can be initialized either with a full object that maps projections to values\n        // or scalar values to smoothen the abstraction gradient from variable params to point selections.\n        return proj.items.map(p =>\n          isObject(v) ? (v[p.geoChannel || p.channel] !== undefined ? v[p.geoChannel || p.channel] : v[p.field]) : v\n        );\n      });\n    }\n\n    if (!isEmpty(timeUnits)) {\n      proj.timeUnit = new TimeUnitNode(null, timeUnits);\n    }\n  },\n\n  signals: (model, selCmpt, allSignals) => {\n    const name = selCmpt.name + TUPLE_FIELDS;\n    const hasSignal = allSignals.filter(s => s.name === name);\n    return hasSignal.length > 0 || selCmpt.project.hasSelectionId\n      ? allSignals\n      : allSignals.concat({\n          name,\n          value: selCmpt.project.items.map(assembleProjection)\n        });\n  }\n};\n\nexport default project;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}