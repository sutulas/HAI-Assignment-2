{"ast":null,"code":"import { getViewConfigContinuousSize } from '../../config';\nimport { hasDiscreteDomain } from '../../scale';\nimport { getFirstDefined } from '../../util';\nimport { isSignalRef, isVgRangeStep } from '../../vega.schema';\nimport { signalOrStringValue } from '../common';\nimport { isFacetModel } from '../model';\nexport function assembleLayoutSignals(model) {\n  return [...sizeSignals(model, 'width'), ...sizeSignals(model, 'height'), ...sizeSignals(model, 'childWidth'), ...sizeSignals(model, 'childHeight')];\n}\nexport function sizeSignals(model, sizeType) {\n  const channel = sizeType === 'width' ? 'x' : 'y';\n  const size = model.component.layoutSize.get(sizeType);\n  if (!size || size === 'merged') {\n    return [];\n  }\n  // Read size signal name from name map, just in case it is the top-level size signal that got renamed.\n  const name = model.getSizeSignalRef(sizeType).signal;\n  if (size === 'step') {\n    const scaleComponent = model.getScaleComponent(channel);\n    if (scaleComponent) {\n      const type = scaleComponent.get('type');\n      const range = scaleComponent.get('range');\n      if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n        const scaleName = model.scaleName(channel);\n        if (isFacetModel(model.parent)) {\n          // If parent is facet and this is an independent scale, return only signal signal\n          // as the width/height will be calculated using the cardinality from\n          // facet's aggregate rather than reading from scale domain\n          const parentResolve = model.parent.component.resolve;\n          if (parentResolve.scale[channel] === 'independent') {\n            return [stepSignal(scaleName, range)];\n          }\n        }\n        return [stepSignal(scaleName, range), {\n          name,\n          update: sizeExpr(scaleName, scaleComponent, `domain('${scaleName}').length`)\n        }];\n      }\n    }\n    /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n    throw new Error('layout size is step although width/height is not step.');\n  } else if (size == 'container') {\n    const isWidth = name.endsWith('width');\n    const expr = isWidth ? 'containerSize()[0]' : 'containerSize()[1]';\n    const defaultValue = getViewConfigContinuousSize(model.config.view, isWidth ? 'width' : 'height');\n    const safeExpr = `isFinite(${expr}) ? ${expr} : ${defaultValue}`;\n    return [{\n      name,\n      init: safeExpr,\n      on: [{\n        update: safeExpr,\n        events: 'window:resize'\n      }]\n    }];\n  } else {\n    return [{\n      name,\n      value: size\n    }];\n  }\n}\nfunction stepSignal(scaleName, range) {\n  const name = `${scaleName}_step`;\n  if (isSignalRef(range.step)) {\n    return {\n      name,\n      update: range.step.signal\n    };\n  } else {\n    return {\n      name,\n      value: range.step\n    };\n  }\n}\nexport function sizeExpr(scaleName, scaleComponent, cardinality) {\n  const type = scaleComponent.get('type');\n  const padding = scaleComponent.get('padding');\n  const paddingOuter = getFirstDefined(scaleComponent.get('paddingOuter'), padding);\n  let paddingInner = scaleComponent.get('paddingInner');\n  paddingInner = type === 'band' ?\n  // only band has real paddingInner\n  paddingInner !== undefined ? paddingInner : padding :\n  // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,\n  // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.\n  1;\n  return `bandspace(${cardinality}, ${signalOrStringValue(paddingInner)}, ${signalOrStringValue(paddingOuter)}) * ${scaleName}_step`;\n}","map":{"version":3,"names":["getViewConfigContinuousSize","hasDiscreteDomain","getFirstDefined","isSignalRef","isVgRangeStep","signalOrStringValue","isFacetModel","assembleLayoutSignals","model","sizeSignals","sizeType","channel","size","component","layoutSize","get","name","getSizeSignalRef","signal","scaleComponent","getScaleComponent","type","range","scaleName","parent","parentResolve","resolve","scale","stepSignal","update","sizeExpr","Error","isWidth","endsWith","expr","defaultValue","config","view","safeExpr","init","on","events","value","step","cardinality","padding","paddingOuter","paddingInner","undefined"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\layoutsize\\assemble.ts"],"sourcesContent":["import {InitSignal, NewSignal} from 'vega';\nimport {getViewConfigContinuousSize} from '../../config';\nimport {hasDiscreteDomain} from '../../scale';\nimport {getFirstDefined} from '../../util';\nimport {isSignalRef, isVgRangeStep, VgRangeStep} from '../../vega.schema';\nimport {signalOrStringValue} from '../common';\nimport {isFacetModel, Model} from '../model';\nimport {ScaleComponent} from '../scale/component';\nimport {LayoutSizeType} from './component';\n\nexport function assembleLayoutSignals(model: Model): NewSignal[] {\n  return [\n    ...sizeSignals(model, 'width'),\n    ...sizeSignals(model, 'height'),\n    ...sizeSignals(model, 'childWidth'),\n    ...sizeSignals(model, 'childHeight')\n  ];\n}\n\nexport function sizeSignals(model: Model, sizeType: LayoutSizeType): (NewSignal | InitSignal)[] {\n  const channel = sizeType === 'width' ? 'x' : 'y';\n  const size = model.component.layoutSize.get(sizeType);\n  if (!size || size === 'merged') {\n    return [];\n  }\n\n  // Read size signal name from name map, just in case it is the top-level size signal that got renamed.\n  const name = model.getSizeSignalRef(sizeType).signal;\n\n  if (size === 'step') {\n    const scaleComponent = model.getScaleComponent(channel);\n\n    if (scaleComponent) {\n      const type = scaleComponent.get('type');\n      const range = scaleComponent.get('range');\n\n      if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n        const scaleName = model.scaleName(channel);\n\n        if (isFacetModel(model.parent)) {\n          // If parent is facet and this is an independent scale, return only signal signal\n          // as the width/height will be calculated using the cardinality from\n          // facet's aggregate rather than reading from scale domain\n          const parentResolve = model.parent.component.resolve;\n          if (parentResolve.scale[channel] === 'independent') {\n            return [stepSignal(scaleName, range)];\n          }\n        }\n\n        return [\n          stepSignal(scaleName, range),\n          {\n            name,\n            update: sizeExpr(scaleName, scaleComponent, `domain('${scaleName}').length`)\n          }\n        ];\n      }\n    }\n    /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n    throw new Error('layout size is step although width/height is not step.');\n  } else if (size == 'container') {\n    const isWidth = name.endsWith('width');\n    const expr = isWidth ? 'containerSize()[0]' : 'containerSize()[1]';\n    const defaultValue = getViewConfigContinuousSize(model.config.view, isWidth ? 'width' : 'height');\n    const safeExpr = `isFinite(${expr}) ? ${expr} : ${defaultValue}`;\n    return [{name, init: safeExpr, on: [{update: safeExpr, events: 'window:resize'}]}];\n  } else {\n    return [\n      {\n        name,\n        value: size\n      }\n    ];\n  }\n}\n\nfunction stepSignal(scaleName: string, range: VgRangeStep): NewSignal {\n  const name = `${scaleName}_step`;\n  if (isSignalRef(range.step)) {\n    return {name, update: range.step.signal};\n  } else {\n    return {name, value: range.step};\n  }\n}\n\nexport function sizeExpr(scaleName: string, scaleComponent: ScaleComponent, cardinality: string) {\n  const type = scaleComponent.get('type');\n  const padding = scaleComponent.get('padding');\n  const paddingOuter = getFirstDefined(scaleComponent.get('paddingOuter'), padding);\n\n  let paddingInner = scaleComponent.get('paddingInner');\n  paddingInner =\n    type === 'band'\n      ? // only band has real paddingInner\n        paddingInner !== undefined\n        ? paddingInner\n        : padding\n      : // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,\n        // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.\n        1;\n  return `bandspace(${cardinality}, ${signalOrStringValue(paddingInner)}, ${signalOrStringValue(\n    paddingOuter\n  )}) * ${scaleName}_step`;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}