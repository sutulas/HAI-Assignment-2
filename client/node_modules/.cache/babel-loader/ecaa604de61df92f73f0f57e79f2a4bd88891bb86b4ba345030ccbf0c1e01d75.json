{"ast":null,"code":"import { isArgmaxDef, isArgminDef } from '../../aggregate';\nimport { getPositionChannelFromLatLong, getSecondaryRangeChannel, isGeoPositionChannel, isScaleChannel, isXorY } from '../../channel';\nimport { binRequiresRange, getBandPosition, hasBandEnd, isScaleFieldDef, isTypedFieldDef, vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { isFieldRange } from '../../scale';\nimport { duplicate, hash, keys, replacePathInField, setEqual } from '../../util';\nimport { isUnitModel } from '../model';\nimport { DataFlowNode } from './dataflow';\nimport { isRectBasedMark } from '../../mark';\nimport { OFFSETTED_RECT_END_SUFFIX, OFFSETTED_RECT_START_SUFFIX } from './timeunit';\nfunction addDimension(dims, channel, fieldDef, model) {\n  const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined;\n  if (isTypedFieldDef(fieldDef) && isUnitModel(model) && hasBandEnd(fieldDef, channelDef2, model.markDef, model.config)) {\n    dims.add(vgField(fieldDef, {}));\n    dims.add(vgField(fieldDef, {\n      suffix: 'end'\n    }));\n    const {\n      mark,\n      markDef,\n      config\n    } = model;\n    const bandPosition = getBandPosition({\n      fieldDef,\n      markDef,\n      config\n    });\n    if (isRectBasedMark(mark) && bandPosition !== 0.5 && isXorY(channel)) {\n      dims.add(vgField(fieldDef, {\n        suffix: OFFSETTED_RECT_START_SUFFIX\n      }));\n      dims.add(vgField(fieldDef, {\n        suffix: OFFSETTED_RECT_END_SUFFIX\n      }));\n    }\n    if (fieldDef.bin && binRequiresRange(fieldDef, channel)) {\n      dims.add(vgField(fieldDef, {\n        binSuffix: 'range'\n      }));\n    }\n  } else if (isGeoPositionChannel(channel)) {\n    const posChannel = getPositionChannelFromLatLong(channel);\n    dims.add(model.getName(posChannel));\n  } else {\n    dims.add(vgField(fieldDef));\n  }\n  if (isScaleFieldDef(fieldDef) && isFieldRange(fieldDef.scale?.range)) {\n    dims.add(fieldDef.scale.range.field);\n  }\n  return dims;\n}\nfunction mergeMeasures(parentMeasures, childMeasures) {\n  for (const field of keys(childMeasures)) {\n    // when we merge a measure, we either have to add an aggregation operator or even a new field\n    const ops = childMeasures[field];\n    for (const op of keys(ops)) {\n      if (field in parentMeasures) {\n        // add operator to existing measure field\n        parentMeasures[field][op] = new Set([...(parentMeasures[field][op] ?? []), ...ops[op]]);\n      } else {\n        parentMeasures[field] = {\n          [op]: ops[op]\n        };\n      }\n    }\n  }\n}\nexport class AggregateNode extends DataFlowNode {\n  clone() {\n    return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));\n  }\n  /**\n   * @param dimensions string set for dimensions\n   * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n   */\n  constructor(parent, dimensions, measures) {\n    super(parent);\n    this.dimensions = dimensions;\n    this.measures = measures;\n  }\n  get groupBy() {\n    return this.dimensions;\n  }\n  static makeFromEncoding(parent, model) {\n    let isAggregate = false;\n    model.forEachFieldDef(fd => {\n      if (fd.aggregate) {\n        isAggregate = true;\n      }\n    });\n    const meas = {};\n    const dims = new Set();\n    if (!isAggregate) {\n      // no need to create this node if the model has no aggregation\n      return null;\n    }\n    model.forEachFieldDef((fieldDef, channel) => {\n      const {\n        aggregate,\n        field\n      } = fieldDef;\n      if (aggregate) {\n        if (aggregate === 'count') {\n          meas['*'] ?? (meas['*'] = {});\n          meas['*']['count'] = new Set([vgField(fieldDef, {\n            forAs: true\n          })]);\n        } else {\n          if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n            const op = isArgminDef(aggregate) ? 'argmin' : 'argmax';\n            const argField = aggregate[op];\n            meas[argField] ?? (meas[argField] = {});\n            meas[argField][op] = new Set([vgField({\n              op,\n              field: argField\n            }, {\n              forAs: true\n            })]);\n          } else {\n            meas[field] ?? (meas[field] = {});\n            meas[field][aggregate] = new Set([vgField(fieldDef, {\n              forAs: true\n            })]);\n          }\n          // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n          if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n            meas[field] ?? (meas[field] = {});\n            meas[field]['min'] = new Set([vgField({\n              field,\n              aggregate: 'min'\n            }, {\n              forAs: true\n            })]);\n            meas[field]['max'] = new Set([vgField({\n              field,\n              aggregate: 'max'\n            }, {\n              forAs: true\n            })]);\n          }\n        }\n      } else {\n        addDimension(dims, channel, fieldDef, model);\n      }\n    });\n    if (dims.size + keys(meas).length === 0) {\n      return null;\n    }\n    return new AggregateNode(parent, dims, meas);\n  }\n  static makeFromTransform(parent, t) {\n    var _a;\n    const dims = new Set();\n    const meas = {};\n    for (const s of t.aggregate) {\n      const {\n        op,\n        field,\n        as\n      } = s;\n      if (op) {\n        if (op === 'count') {\n          meas['*'] ?? (meas['*'] = {});\n          meas['*']['count'] = new Set([as ? as : vgField(s, {\n            forAs: true\n          })]);\n        } else {\n          meas[field] ?? (meas[field] = {});\n          (_a = meas[field])[op] ?? (_a[op] = new Set());\n          meas[field][op].add(as ? as : vgField(s, {\n            forAs: true\n          }));\n        }\n      }\n    }\n    for (const s of t.groupby ?? []) {\n      dims.add(s);\n    }\n    if (dims.size + keys(meas).length === 0) {\n      return null;\n    }\n    return new AggregateNode(parent, dims, meas);\n  }\n  merge(other) {\n    if (setEqual(this.dimensions, other.dimensions)) {\n      mergeMeasures(this.measures, other.measures);\n      return true;\n    }\n    log.debug('different dimensions, cannot merge');\n    return false;\n  }\n  addDimensions(fields) {\n    fields.forEach(this.dimensions.add, this.dimensions);\n  }\n  dependentFields() {\n    return new Set([...this.dimensions, ...keys(this.measures)]);\n  }\n  producedFields() {\n    const out = new Set();\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        const m = this.measures[field][op];\n        if (m.size === 0) {\n          out.add(`${op}_${field}`);\n        } else {\n          m.forEach(out.add, out);\n        }\n      }\n    }\n    return out;\n  }\n  hash() {\n    return `Aggregate ${hash({\n      dimensions: this.dimensions,\n      measures: this.measures\n    })}`;\n  }\n  assemble() {\n    const ops = [];\n    const fields = [];\n    const as = [];\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        for (const alias of this.measures[field][op]) {\n          as.push(alias);\n          ops.push(op);\n          fields.push(field === '*' ? null : replacePathInField(field));\n        }\n      }\n    }\n    const result = {\n      type: 'aggregate',\n      groupby: [...this.dimensions].map(replacePathInField),\n      ops,\n      fields,\n      as\n    };\n    return result;\n  }\n}","map":{"version":3,"names":["isArgmaxDef","isArgminDef","getPositionChannelFromLatLong","getSecondaryRangeChannel","isGeoPositionChannel","isScaleChannel","isXorY","binRequiresRange","getBandPosition","hasBandEnd","isScaleFieldDef","isTypedFieldDef","vgField","log","isFieldRange","duplicate","hash","keys","replacePathInField","setEqual","isUnitModel","DataFlowNode","isRectBasedMark","OFFSETTED_RECT_END_SUFFIX","OFFSETTED_RECT_START_SUFFIX","addDimension","dims","channel","fieldDef","model","channelDef2","encoding","undefined","markDef","config","add","suffix","mark","bandPosition","bin","binSuffix","posChannel","getName","scale","range","field","mergeMeasures","parentMeasures","childMeasures","ops","op","Set","AggregateNode","clone","dimensions","measures","constructor","parent","groupBy","makeFromEncoding","isAggregate","forEachFieldDef","fd","aggregate","meas","forAs","argField","scaleDomain","size","length","makeFromTransform","t","s","as","_a","groupby","merge","other","debug","addDimensions","fields","forEach","dependentFields","producedFields","out","m","assemble","alias","push","result","type","map"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\data\\aggregate.ts"],"sourcesContent":["import {AggregateOp, AggregateTransform as VgAggregateTransform} from 'vega';\nimport {isArgmaxDef, isArgminDef} from '../../aggregate';\nimport {\n  Channel,\n  getPositionChannelFromLatLong,\n  getSecondaryRangeChannel,\n  isGeoPositionChannel,\n  isScaleChannel,\n  isXorY\n} from '../../channel';\nimport {\n  binRequiresRange,\n  FieldDef,\n  getBandPosition,\n  hasBandEnd,\n  isScaleFieldDef,\n  isTypedFieldDef,\n  vgField\n} from '../../channeldef';\nimport * as log from '../../log';\nimport {isFieldRange} from '../../scale';\nimport {AggregateTransform} from '../../transform';\nimport {Dict, duplicate, hash, keys, replacePathInField, setEqual} from '../../util';\nimport {isUnitModel, ModelWithField} from '../model';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\nimport {isRectBasedMark} from '../../mark';\nimport {OFFSETTED_RECT_END_SUFFIX, OFFSETTED_RECT_START_SUFFIX} from './timeunit';\n\ntype Measures = Dict<Partial<Record<AggregateOp, Set<string>>>>;\n\nfunction addDimension(dims: Set<string>, channel: Channel, fieldDef: FieldDef<string>, model: ModelWithField) {\n  const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined;\n\n  if (\n    isTypedFieldDef(fieldDef) &&\n    isUnitModel(model) &&\n    hasBandEnd(fieldDef, channelDef2, model.markDef, model.config)\n  ) {\n    dims.add(vgField(fieldDef, {}));\n    dims.add(vgField(fieldDef, {suffix: 'end'}));\n\n    const {mark, markDef, config} = model;\n\n    const bandPosition = getBandPosition({fieldDef, markDef, config});\n\n    if (isRectBasedMark(mark) && bandPosition !== 0.5 && isXorY(channel)) {\n      dims.add(vgField(fieldDef, {suffix: OFFSETTED_RECT_START_SUFFIX}));\n      dims.add(vgField(fieldDef, {suffix: OFFSETTED_RECT_END_SUFFIX}));\n    }\n\n    if (fieldDef.bin && binRequiresRange(fieldDef, channel)) {\n      dims.add(vgField(fieldDef, {binSuffix: 'range'}));\n    }\n  } else if (isGeoPositionChannel(channel)) {\n    const posChannel = getPositionChannelFromLatLong(channel);\n    dims.add(model.getName(posChannel));\n  } else {\n    dims.add(vgField(fieldDef));\n  }\n  if (isScaleFieldDef(fieldDef) && isFieldRange(fieldDef.scale?.range)) {\n    dims.add(fieldDef.scale.range.field);\n  }\n  return dims;\n}\n\nfunction mergeMeasures(parentMeasures: Measures, childMeasures: Measures) {\n  for (const field of keys(childMeasures)) {\n    // when we merge a measure, we either have to add an aggregation operator or even a new field\n    const ops = childMeasures[field];\n    for (const op of keys(ops)) {\n      if (field in parentMeasures) {\n        // add operator to existing measure field\n        parentMeasures[field][op] = new Set([...(parentMeasures[field][op] ?? []), ...ops[op]]);\n      } else {\n        parentMeasures[field] = {[op]: ops[op]};\n      }\n    }\n  }\n}\n\nexport class AggregateNode extends DataFlowNode {\n  public clone() {\n    return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));\n  }\n\n  /**\n   * @param dimensions string set for dimensions\n   * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n   */\n  constructor(\n    parent: DataFlowNode,\n    private dimensions: Set<string>,\n    private measures: Measures\n  ) {\n    super(parent);\n  }\n\n  get groupBy() {\n    return this.dimensions;\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: UnitModel): AggregateNode {\n    let isAggregate = false;\n    model.forEachFieldDef(fd => {\n      if (fd.aggregate) {\n        isAggregate = true;\n      }\n    });\n\n    const meas: Measures = {};\n    const dims = new Set<string>();\n\n    if (!isAggregate) {\n      // no need to create this node if the model has no aggregation\n      return null;\n    }\n\n    model.forEachFieldDef((fieldDef, channel: Channel) => {\n      const {aggregate, field} = fieldDef;\n      if (aggregate) {\n        if (aggregate === 'count') {\n          meas['*'] ??= {};\n          meas['*']['count'] = new Set([vgField(fieldDef, {forAs: true})]);\n        } else {\n          if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n            const op = isArgminDef(aggregate) ? 'argmin' : 'argmax';\n            const argField = (aggregate as any)[op];\n            meas[argField] ??= {};\n            meas[argField][op] = new Set([vgField({op, field: argField}, {forAs: true})]);\n          } else {\n            meas[field] ??= {};\n            (meas[field] as any)[aggregate] = new Set([vgField(fieldDef, {forAs: true})]);\n          }\n\n          // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n          if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n            meas[field] ??= {};\n            meas[field]['min'] = new Set([vgField({field, aggregate: 'min'}, {forAs: true})]);\n            meas[field]['max'] = new Set([vgField({field, aggregate: 'max'}, {forAs: true})]);\n          }\n        }\n      } else {\n        addDimension(dims, channel, fieldDef, model);\n      }\n    });\n\n    if (dims.size + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, t: AggregateTransform): AggregateNode {\n    const dims = new Set<string>();\n    const meas: Measures = {};\n\n    for (const s of t.aggregate) {\n      const {op, field, as} = s;\n      if (op) {\n        if (op === 'count') {\n          meas['*'] ??= {};\n          meas['*']['count'] = new Set([as ? as : vgField(s, {forAs: true})]);\n        } else {\n          meas[field] ??= {};\n          meas[field][op] ??= new Set();\n          meas[field][op].add(as ? as : vgField(s, {forAs: true}));\n        }\n      }\n    }\n\n    for (const s of t.groupby ?? []) {\n      dims.add(s);\n    }\n\n    if (dims.size + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  public merge(other: AggregateNode): boolean {\n    if (setEqual(this.dimensions, other.dimensions)) {\n      mergeMeasures(this.measures, other.measures);\n      return true;\n    }\n    log.debug('different dimensions, cannot merge');\n    return false;\n  }\n\n  public addDimensions(fields: readonly string[]) {\n    fields.forEach(this.dimensions.add, this.dimensions);\n  }\n\n  public dependentFields() {\n    return new Set([...this.dimensions, ...keys(this.measures)]);\n  }\n\n  public producedFields() {\n    const out = new Set<string>();\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        const m = this.measures[field][op];\n        if (m.size === 0) {\n          out.add(`${op}_${field}`);\n        } else {\n          m.forEach(out.add, out);\n        }\n      }\n    }\n\n    return out;\n  }\n\n  public hash() {\n    return `Aggregate ${hash({dimensions: this.dimensions, measures: this.measures})}`;\n  }\n\n  public assemble(): VgAggregateTransform {\n    const ops: AggregateOp[] = [];\n    const fields: string[] = [];\n    const as: string[] = [];\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        for (const alias of this.measures[field][op]) {\n          as.push(alias);\n          ops.push(op);\n          fields.push(field === '*' ? null : replacePathInField(field));\n        }\n      }\n    }\n\n    const result: VgAggregateTransform = {\n      type: 'aggregate',\n      groupby: [...this.dimensions].map(replacePathInField),\n      ops,\n      fields,\n      as\n    };\n\n    return result;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}