{"ast":null,"code":"import { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel } from '../../../channel';\nimport { isFieldOrDatumDef } from '../../../channeldef';\nimport * as log from '../../../log';\nimport { isRelativeBandSize } from '../../../mark';\nimport { getMarkStyleConfig } from '../../common';\nimport { positionOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPosition, pointPositionDefaultRef } from './position-point';\nimport * as ref from './valueref';\n/**\n * Utility for area/rule position, which can be either point or range.\n * (One of the axes should be point and the other should be range.)\n */\nexport function pointOrRangePosition(channel, model, _ref) {\n  let {\n    defaultPos,\n    defaultPos2,\n    range\n  } = _ref;\n  if (range) {\n    return rangePosition(channel, model, {\n      defaultPos,\n      defaultPos2\n    });\n  }\n  return pointPosition(channel, model, {\n    defaultPos\n  });\n}\nexport function rangePosition(channel, model, _ref2) {\n  let {\n    defaultPos,\n    defaultPos2\n  } = _ref2;\n  const {\n    markDef,\n    config\n  } = model;\n  const channel2 = getSecondaryRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n  const pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);\n  const vgChannel = pos2Mixins[sizeChannel] ?\n  // If there is width/height, we need to position the marks based on the alignment.\n  vgAlignedPositionChannel(channel, markDef, config) :\n  // Otherwise, make sure to apply to the right Vg Channel (for arc mark)\n  getVgPositionChannel(channel);\n  return {\n    ...pointPosition(channel, model, {\n      defaultPos,\n      vgChannel\n    }),\n    ...pos2Mixins\n  };\n}\n/**\n * Return encode for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\nfunction pointPosition2OrSize(model, defaultPos, channel) {\n  const {\n    encoding,\n    mark,\n    markDef,\n    stack,\n    config\n  } = model;\n  const baseChannel = getMainRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n  const channelDef = encoding[baseChannel];\n  const scaleName = model.scaleName(baseChannel);\n  const scale = model.getScaleComponent(baseChannel);\n  const {\n    offset\n  } = channel in encoding || channel in markDef ? positionOffset({\n    channel,\n    markDef,\n    encoding,\n    model\n  }) : positionOffset({\n    channel: baseChannel,\n    markDef,\n    encoding,\n    model\n  });\n  if (!channelDef && (channel === 'x2' || channel === 'y2') && (encoding.latitude || encoding.longitude)) {\n    const vgSizeChannel = getSizeChannel(channel);\n    const size = model.markDef[vgSizeChannel];\n    if (size != null) {\n      return {\n        [vgSizeChannel]: {\n          value: size\n        }\n      };\n    } else {\n      return {\n        [vgChannel]: {\n          field: model.getName(channel)\n        }\n      };\n    }\n  }\n  const valueRef = position2Ref({\n    channel,\n    channelDef,\n    channel2Def: encoding[channel],\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: undefined\n  });\n  if (valueRef !== undefined) {\n    return {\n      [vgChannel]: valueRef\n    };\n  }\n  // TODO: check width/height encoding here once we add them\n  // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n  // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n  return position2orSize(channel, markDef) || position2orSize(channel, {\n    [channel]: getMarkStyleConfig(channel, markDef, config.style),\n    [sizeChannel]: getMarkStyleConfig(sizeChannel, markDef, config.style)\n  }) || position2orSize(channel, config[mark]) || position2orSize(channel, config.mark) || {\n    [vgChannel]: pointPositionDefaultRef({\n      model,\n      defaultPos,\n      channel,\n      scaleName,\n      scale\n    })()\n  };\n}\nexport function position2Ref(_ref3) {\n  let {\n    channel,\n    channelDef,\n    channel2Def,\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef\n  } = _ref3;\n  if (isFieldOrDatumDef(channelDef) && stack &&\n  // If fieldChannel is X and channel is X2 (or Y and Y2)\n  channel.charAt(0) === stack.fieldChannel.charAt(0)) {\n    return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, {\n      suffix: 'start'\n    }, {\n      offset\n    });\n  }\n  return ref.midPointRefWithPositionInvalidTest({\n    channel,\n    channelDef: channel2Def,\n    scaleName,\n    scale,\n    stack,\n    markDef,\n    config,\n    offset,\n    defaultRef\n  });\n}\nfunction position2orSize(channel, markDef) {\n  const sizeChannel = getSizeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n  if (markDef[vgChannel] !== undefined) {\n    return {\n      [vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[vgChannel])\n    };\n  } else if (markDef[channel] !== undefined) {\n    return {\n      [vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[channel])\n    };\n  } else if (markDef[sizeChannel]) {\n    const dimensionSize = markDef[sizeChannel];\n    if (isRelativeBandSize(dimensionSize)) {\n      log.warn(log.message.relativeBandSizeNotSupported(sizeChannel));\n    } else {\n      return {\n        [sizeChannel]: ref.widthHeightValueOrSignalRef(channel, dimensionSize)\n      };\n    }\n  }\n  return undefined;\n}","map":{"version":3,"names":["getMainRangeChannel","getSecondaryRangeChannel","getSizeChannel","getVgPositionChannel","isFieldOrDatumDef","log","isRelativeBandSize","getMarkStyleConfig","positionOffset","vgAlignedPositionChannel","pointPosition","pointPositionDefaultRef","ref","pointOrRangePosition","channel","model","_ref","defaultPos","defaultPos2","range","rangePosition","_ref2","markDef","config","channel2","sizeChannel","pos2Mixins","pointPosition2OrSize","vgChannel","encoding","mark","stack","baseChannel","channelDef","scaleName","scale","getScaleComponent","offset","latitude","longitude","vgSizeChannel","size","value","field","getName","valueRef","position2Ref","channel2Def","defaultRef","undefined","position2orSize","style","_ref3","charAt","fieldChannel","valueRefForFieldOrDatumDef","suffix","midPointRefWithPositionInvalidTest","widthHeightValueOrSignalRef","dimensionSize","warn","message","relativeBandSizeNotSupported"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\mark\\encode\\position-range.ts"],"sourcesContent":["import type {SignalRef} from 'vega';\nimport {getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel} from '../../../channel';\nimport {isFieldOrDatumDef} from '../../../channeldef';\nimport * as log from '../../../log';\nimport {isRelativeBandSize, Mark, MarkConfig, MarkDef} from '../../../mark';\nimport {VgEncodeEntry, VgValueRef} from '../../../vega.schema';\nimport {getMarkStyleConfig} from '../../common';\nimport {UnitModel} from '../../unit';\nimport {positionOffset} from './offset';\nimport {vgAlignedPositionChannel} from './position-align';\nimport {pointPosition, pointPositionDefaultRef} from './position-point';\nimport * as ref from './valueref';\n\n/**\n * Utility for area/rule position, which can be either point or range.\n * (One of the axes should be point and the other should be range.)\n */\nexport function pointOrRangePosition(\n  channel: 'x' | 'y',\n  model: UnitModel,\n  {\n    defaultPos,\n    defaultPos2,\n    range\n  }: {\n    defaultPos: 'zeroOrMin' | 'zeroOrMax' | 'mid';\n    defaultPos2: 'zeroOrMin' | 'zeroOrMax';\n    range: boolean;\n  }\n) {\n  if (range) {\n    return rangePosition(channel, model, {defaultPos, defaultPos2});\n  }\n  return pointPosition(channel, model, {defaultPos});\n}\n\nexport function rangePosition(\n  channel: 'x' | 'y' | 'theta' | 'radius',\n  model: UnitModel,\n  {\n    defaultPos,\n    defaultPos2\n  }: {\n    defaultPos: 'zeroOrMin' | 'zeroOrMax' | 'mid';\n    defaultPos2: 'zeroOrMin' | 'zeroOrMax';\n  }\n): VgEncodeEntry {\n  const {markDef, config} = model;\n  const channel2 = getSecondaryRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n\n  const pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);\n\n  const vgChannel = pos2Mixins[sizeChannel]\n    ? // If there is width/height, we need to position the marks based on the alignment.\n      vgAlignedPositionChannel(channel, markDef, config)\n    : // Otherwise, make sure to apply to the right Vg Channel (for arc mark)\n      getVgPositionChannel(channel);\n\n  return {\n    ...pointPosition(channel, model, {defaultPos, vgChannel}),\n    ...pos2Mixins\n  };\n}\n\n/**\n * Return encode for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\nfunction pointPosition2OrSize(\n  model: UnitModel,\n  defaultPos: 'zeroOrMin' | 'zeroOrMax',\n  channel: 'x2' | 'y2' | 'radius2' | 'theta2'\n) {\n  const {encoding, mark, markDef, stack, config} = model;\n\n  const baseChannel = getMainRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n\n  const channelDef = encoding[baseChannel];\n  const scaleName = model.scaleName(baseChannel);\n  const scale = model.getScaleComponent(baseChannel);\n\n  const {offset} =\n    channel in encoding || channel in markDef\n      ? positionOffset({channel, markDef, encoding, model})\n      : positionOffset({channel: baseChannel, markDef, encoding, model});\n\n  if (!channelDef && (channel === 'x2' || channel === 'y2') && (encoding.latitude || encoding.longitude)) {\n    const vgSizeChannel = getSizeChannel(channel);\n\n    const size = model.markDef[vgSizeChannel];\n    if (size != null) {\n      return {\n        [vgSizeChannel]: {value: size}\n      };\n    } else {\n      return {\n        [vgChannel]: {field: model.getName(channel)}\n      };\n    }\n  }\n\n  const valueRef = position2Ref({\n    channel,\n    channelDef,\n    channel2Def: encoding[channel],\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: undefined\n  });\n\n  if (valueRef !== undefined) {\n    return {[vgChannel]: valueRef};\n  }\n\n  // TODO: check width/height encoding here once we add them\n\n  // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n  // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n\n  return (\n    position2orSize(channel, markDef) ||\n    position2orSize(channel, {\n      [channel]: getMarkStyleConfig(channel, markDef, config.style),\n      [sizeChannel]: getMarkStyleConfig(sizeChannel, markDef, config.style)\n    }) ||\n    position2orSize(channel, config[mark]) ||\n    position2orSize(channel, config.mark) || {\n      [vgChannel]: pointPositionDefaultRef({\n        model,\n        defaultPos,\n        channel,\n        scaleName,\n        scale\n      })()\n    }\n  );\n}\n\nexport function position2Ref({\n  channel,\n  channelDef,\n  channel2Def,\n  markDef,\n  config,\n  scaleName,\n  scale,\n  stack,\n  offset,\n  defaultRef\n}: ref.MidPointParams & {\n  channel: 'x2' | 'y2' | 'radius2' | 'theta2';\n}): VgValueRef | VgValueRef[] {\n  if (\n    isFieldOrDatumDef(channelDef) &&\n    stack &&\n    // If fieldChannel is X and channel is X2 (or Y and Y2)\n    channel.charAt(0) === stack.fieldChannel.charAt(0)\n  ) {\n    return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, {suffix: 'start'}, {offset});\n  }\n  return ref.midPointRefWithPositionInvalidTest({\n    channel,\n    channelDef: channel2Def,\n    scaleName,\n    scale,\n    stack,\n    markDef,\n    config,\n    offset,\n    defaultRef\n  });\n}\n\nfunction position2orSize(\n  channel: 'x2' | 'y2' | 'radius2' | 'theta2',\n  markDef: MarkConfig<SignalRef> | MarkDef<Mark, SignalRef>\n) {\n  const sizeChannel = getSizeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n  if (markDef[vgChannel] !== undefined) {\n    return {[vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[vgChannel])};\n  } else if (markDef[channel] !== undefined) {\n    return {[vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[channel])};\n  } else if (markDef[sizeChannel]) {\n    const dimensionSize = markDef[sizeChannel];\n    if (isRelativeBandSize(dimensionSize)) {\n      log.warn(log.message.relativeBandSizeNotSupported(sizeChannel));\n    } else {\n      return {[sizeChannel]: ref.widthHeightValueOrSignalRef(channel, dimensionSize)};\n    }\n  }\n  return undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}