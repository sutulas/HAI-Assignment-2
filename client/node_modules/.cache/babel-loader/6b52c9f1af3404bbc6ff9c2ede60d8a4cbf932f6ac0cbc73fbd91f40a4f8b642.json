{"ast":null,"code":"import { isArray, isNumber } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../../bin';\nimport { getOffsetChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isPolarPositionChannel, isXorY } from '../../../channel';\nimport { getBandPosition, getBandSize, isFieldDef, isFieldOrDatumDef, vgField } from '../../../channeldef';\nimport { getViewConfigDiscreteStep } from '../../../config';\nimport * as log from '../../../log';\nimport { isRelativeBandSize } from '../../../mark';\nimport { hasDiscreteDomain } from '../../../scale';\nimport { isSignalRef, isVgRangeStep } from '../../../vega.schema';\nimport { getMarkConfig, getMarkPropOrConfig, signalOrStringValue, signalOrValueRef } from '../../common';\nimport { nonPosition } from './nonposition';\nimport { positionOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPositionDefaultRef } from './position-point';\nimport { rangePosition } from './position-range';\nimport * as ref from './valueref';\nimport { getOffsetScaleChannel } from '../../../channel';\nimport { getFirstDefined } from '../../../util';\nimport { OFFSETTED_RECT_END_SUFFIX, OFFSETTED_RECT_START_SUFFIX } from '../../data/timeunit';\nexport function rectPosition(model, channel) {\n  const {\n    config,\n    encoding,\n    markDef\n  } = model;\n  const mark = markDef.type;\n  const channel2 = getSecondaryRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n  const channelDef = encoding[channel];\n  const channelDef2 = encoding[channel2];\n  const scale = model.getScaleComponent(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n  const orient = markDef.orient;\n  const hasSizeDef = encoding[sizeChannel] ?? encoding.size ?? getMarkPropOrConfig('size', markDef, config, {\n    vgChannel: sizeChannel\n  });\n  const offsetScaleChannel = getOffsetChannel(channel);\n  const isBarOrTickBand = mark === 'bar' && (channel === 'x' ? orient === 'vertical' : orient === 'horizontal') || mark === 'tick' && (channel === 'y' ? orient === 'vertical' : orient === 'horizontal');\n  // x, x2, and width -- we must specify two of these in all conditions\n  if (isFieldDef(channelDef) && (isBinning(channelDef.bin) || isBinned(channelDef.bin) || channelDef.timeUnit && !channelDef2) && !(hasSizeDef && !isRelativeBandSize(hasSizeDef)) && !encoding[offsetScaleChannel] && !hasDiscreteDomain(scaleType)) {\n    return rectBinPosition({\n      fieldDef: channelDef,\n      fieldDef2: channelDef2,\n      channel,\n      model\n    });\n  } else if ((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType) || isBarOrTickBand) && !channelDef2) {\n    return positionAndSize(channelDef, channel, model);\n  } else {\n    return rangePosition(channel, model, {\n      defaultPos: 'zeroOrMax',\n      defaultPos2: 'zeroOrMin'\n    });\n  }\n}\nfunction defaultSizeRef(sizeChannel, scaleName, scale, config, bandSize, hasFieldDef, mark) {\n  if (isRelativeBandSize(bandSize)) {\n    if (scale) {\n      const scaleType = scale.get('type');\n      if (scaleType === 'band') {\n        let bandWidth = `bandwidth('${scaleName}')`;\n        if (bandSize.band !== 1) {\n          bandWidth = `${bandSize.band} * ${bandWidth}`;\n        }\n        const minBandSize = getMarkConfig('minBandSize', {\n          type: mark\n        }, config);\n        return {\n          signal: minBandSize ? `max(${signalOrStringValue(minBandSize)}, ${bandWidth})` : bandWidth\n        };\n      } else if (bandSize.band !== 1) {\n        log.warn(log.message.cannotUseRelativeBandSizeWithNonBandScale(scaleType));\n        bandSize = undefined;\n      }\n    } else {\n      return {\n        mult: bandSize.band,\n        field: {\n          group: sizeChannel\n        }\n      };\n    }\n  } else if (isSignalRef(bandSize)) {\n    return bandSize;\n  } else if (bandSize) {\n    return {\n      value: bandSize\n    };\n  }\n  // no valid band size\n  if (scale) {\n    const scaleRange = scale.get('range');\n    if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n      return {\n        value: scaleRange.step - 2\n      };\n    }\n  }\n  if (!hasFieldDef) {\n    const {\n      bandPaddingInner,\n      barBandPaddingInner,\n      rectBandPaddingInner,\n      tickBandPaddingInner\n    } = config.scale;\n    const padding = getFirstDefined(bandPaddingInner, mark === 'tick' ? tickBandPaddingInner : mark === 'bar' ? barBandPaddingInner : rectBandPaddingInner); // this part is like paddingInner in scale.ts\n    if (isSignalRef(padding)) {\n      return {\n        signal: `(1 - (${padding.signal})) * ${sizeChannel}`\n      };\n    } else if (isNumber(padding)) {\n      return {\n        signal: `${1 - padding} * ${sizeChannel}`\n      };\n    }\n  }\n  const defaultStep = getViewConfigDiscreteStep(config.view, sizeChannel);\n  return {\n    value: defaultStep - 2\n  };\n}\n/**\n * Output position encoding and its size encoding for continuous, point, and band scales.\n */\nfunction positionAndSize(fieldDef, channel, model) {\n  const {\n    markDef,\n    encoding,\n    config,\n    stack\n  } = model;\n  const orient = markDef.orient;\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n  const vgSizeChannel = getSizeChannel(channel);\n  const channel2 = getSecondaryRangeChannel(channel);\n  const offsetScaleChannel = getOffsetChannel(channel);\n  const offsetScaleName = model.scaleName(offsetScaleChannel);\n  const offsetScale = model.getScaleComponent(getOffsetScaleChannel(channel));\n  const useVlSizeChannel =\n  // Always uses size channel for ticks, because tick only calls rectPosition() for the size channel\n  markDef.type === 'tick' ||\n  // use \"size\" channel for bars, if there is orient and the channel matches the right orientation\n  orient === 'horizontal' && channel === 'y' || orient === 'vertical' && channel === 'x';\n  // Use size encoding / mark property / config if it exists\n  let sizeMixins;\n  if (encoding.size || markDef.size) {\n    if (useVlSizeChannel) {\n      sizeMixins = nonPosition('size', model, {\n        vgChannel: vgSizeChannel,\n        defaultRef: signalOrValueRef(markDef.size)\n      });\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(markDef.type));\n    }\n  }\n  const hasSizeFromMarkOrEncoding = !!sizeMixins;\n  // Otherwise, apply default value\n  const bandSize = getBandSize({\n    channel,\n    fieldDef,\n    markDef,\n    config,\n    scaleType: (scale || offsetScale)?.get('type'),\n    useVlSizeChannel\n  });\n  sizeMixins = sizeMixins || {\n    [vgSizeChannel]: defaultSizeRef(vgSizeChannel, offsetScaleName || scaleName, offsetScale || scale, config, bandSize, !!fieldDef, markDef.type)\n  };\n  /*\n    Band scales with size value and all point scales, use xc/yc + band=0.5\n       Otherwise (band scales that has size based on a band ref), use x/y with position band = (1 - size_band) / 2.\n    In this case, size_band is the band specified in the x/y-encoding.\n    By default band is 1, so `(1 - band) / 2` = 0.\n    If band is 0.6, the the x/y position in such case should be `(1 - band) / 2` = 0.2\n   */\n  const defaultBandAlign = (scale || offsetScale)?.get('type') === 'band' && isRelativeBandSize(bandSize) && !hasSizeFromMarkOrEncoding ? 'top' : 'middle';\n  const vgChannel = vgAlignedPositionChannel(channel, markDef, config, defaultBandAlign);\n  const center = vgChannel === 'xc' || vgChannel === 'yc';\n  const {\n    offset,\n    offsetType\n  } = positionOffset({\n    channel,\n    markDef,\n    encoding,\n    model,\n    bandPosition: center ? 0.5 : 0\n  });\n  const posRef = ref.midPointRefWithPositionInvalidTest({\n    channel,\n    channelDef: fieldDef,\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: pointPositionDefaultRef({\n      model,\n      defaultPos: 'mid',\n      channel,\n      scaleName,\n      scale\n    }),\n    bandPosition: center ? offsetType === 'encoding' ? 0 : 0.5 : isSignalRef(bandSize) ? {\n      signal: `(1-${bandSize})/2`\n    } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0\n  });\n  if (vgSizeChannel) {\n    return {\n      [vgChannel]: posRef,\n      ...sizeMixins\n    };\n  } else {\n    // otherwise, we must simulate size by setting position2 = position + size\n    // (for theta/radius since Vega doesn't have thetaWidth/radiusWidth)\n    const vgChannel2 = getVgPositionChannel(channel2);\n    const sizeRef = sizeMixins[vgSizeChannel];\n    const sizeOffset = offset ? {\n      ...sizeRef,\n      offset\n    } : sizeRef;\n    return {\n      [vgChannel]: posRef,\n      // posRef might be an array that wraps position invalid test\n      [vgChannel2]: isArray(posRef) ? [posRef[0], {\n        ...posRef[1],\n        offset: sizeOffset\n      }] : {\n        ...posRef,\n        offset: sizeOffset\n      }\n    };\n  }\n}\nfunction getBinSpacing(channel, spacing, reverse, axisTranslate, offset, minBandSize, bandSizeExpr) {\n  if (isPolarPositionChannel(channel)) {\n    return 0;\n  }\n  const isEnd = channel === 'x' || channel === 'y2';\n  const spacingOffset = isEnd ? -spacing / 2 : spacing / 2;\n  if (isSignalRef(reverse) || isSignalRef(offset) || isSignalRef(axisTranslate) || minBandSize) {\n    const reverseExpr = signalOrStringValue(reverse);\n    const offsetExpr = signalOrStringValue(offset);\n    const axisTranslateExpr = signalOrStringValue(axisTranslate);\n    const minBandSizeExpr = signalOrStringValue(minBandSize);\n    const sign = isEnd ? '' : '-';\n    const spacingAndSizeOffset = minBandSize ? `(${bandSizeExpr} < ${minBandSizeExpr} ? ${sign}0.5 * (${minBandSizeExpr} - (${bandSizeExpr})) : ${spacingOffset})` : spacingOffset;\n    const t = axisTranslateExpr ? `${axisTranslateExpr} + ` : '';\n    const r = reverseExpr ? `(${reverseExpr} ? -1 : 1) * ` : '';\n    const o = offsetExpr ? `(${offsetExpr} + ${spacingAndSizeOffset})` : spacingAndSizeOffset;\n    return {\n      signal: t + r + o\n    };\n  } else {\n    offset = offset || 0;\n    return axisTranslate + (reverse ? -offset - spacingOffset : +offset + spacingOffset);\n  }\n}\nfunction rectBinPosition(_ref) {\n  let {\n    fieldDef,\n    fieldDef2,\n    channel,\n    model\n  } = _ref;\n  const {\n    config,\n    markDef,\n    encoding\n  } = model;\n  const scale = model.getScaleComponent(channel);\n  const scaleName = model.scaleName(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n  const reverse = scale.get('reverse');\n  const bandSize = getBandSize({\n    channel,\n    fieldDef,\n    markDef,\n    config,\n    scaleType\n  });\n  const axis = model.component.axes[channel]?.[0];\n  const axisTranslate = axis?.get('translate') ?? 0.5; // vega default is 0.5\n  const spacing = isXorY(channel) ? getMarkPropOrConfig('binSpacing', markDef, config) ?? 0 : 0;\n  const channel2 = getSecondaryRangeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n  const vgChannel2 = getVgPositionChannel(channel2);\n  const minBandSize = getMarkConfig('minBandSize', markDef, config);\n  const {\n    offset\n  } = positionOffset({\n    channel,\n    markDef,\n    encoding,\n    model,\n    bandPosition: 0\n  });\n  const {\n    offset: offset2\n  } = positionOffset({\n    channel: channel2,\n    markDef,\n    encoding,\n    model,\n    bandPosition: 0\n  });\n  const bandSizeExpr = ref.binSizeExpr({\n    fieldDef,\n    scaleName\n  });\n  const binSpacingOffset = getBinSpacing(channel, spacing, reverse, axisTranslate, offset, minBandSize, bandSizeExpr);\n  const binSpacingOffset2 = getBinSpacing(channel2, spacing, reverse, axisTranslate, offset2 ?? offset, minBandSize, bandSizeExpr);\n  const bandPositionForBandSize = isSignalRef(bandSize) ? {\n    signal: `(1-${bandSize.signal})/2`\n  } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0.5;\n  const bandPosition = getBandPosition({\n    fieldDef,\n    fieldDef2,\n    markDef,\n    config\n  });\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n    const useRectOffsetField = fieldDef.timeUnit && bandPosition !== 0.5;\n    return {\n      [vgChannel2]: rectBinRef({\n        fieldDef,\n        scaleName,\n        bandPosition: bandPositionForBandSize,\n        offset: binSpacingOffset2,\n        useRectOffsetField\n      }),\n      [vgChannel]: rectBinRef({\n        fieldDef,\n        scaleName,\n        bandPosition: isSignalRef(bandPositionForBandSize) ? {\n          signal: `1-${bandPositionForBandSize.signal}`\n        } : 1 - bandPositionForBandSize,\n        offset: binSpacingOffset,\n        useRectOffsetField\n      })\n    };\n  } else if (isBinned(fieldDef.bin)) {\n    const startRef = ref.valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, {\n      offset: binSpacingOffset2\n    });\n    if (isFieldDef(fieldDef2)) {\n      return {\n        [vgChannel2]: startRef,\n        [vgChannel]: ref.valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, {\n          offset: binSpacingOffset\n        })\n      };\n    } else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {\n      return {\n        [vgChannel2]: startRef,\n        [vgChannel]: {\n          signal: `scale(\"${scaleName}\", ${vgField(fieldDef, {\n            expr: 'datum'\n          })} + ${fieldDef.bin.step})`,\n          offset: binSpacingOffset\n        }\n      };\n    }\n  }\n  log.warn(log.message.channelRequiredForBinned(channel2));\n  return undefined;\n}\n/**\n * Value Ref for binned fields\n */\nfunction rectBinRef(_ref2) {\n  let {\n    fieldDef,\n    scaleName,\n    bandPosition,\n    offset,\n    useRectOffsetField\n  } = _ref2;\n  return ref.interpolatedSignalRef({\n    scaleName,\n    fieldOrDatumDef: fieldDef,\n    bandPosition,\n    offset,\n    ...(useRectOffsetField ? {\n      startSuffix: OFFSETTED_RECT_START_SUFFIX,\n      endSuffix: OFFSETTED_RECT_END_SUFFIX\n    } : {})\n  });\n}","map":{"version":3,"names":["isArray","isNumber","isBinned","isBinning","isBinParams","getOffsetChannel","getSecondaryRangeChannel","getSizeChannel","getVgPositionChannel","isPolarPositionChannel","isXorY","getBandPosition","getBandSize","isFieldDef","isFieldOrDatumDef","vgField","getViewConfigDiscreteStep","log","isRelativeBandSize","hasDiscreteDomain","isSignalRef","isVgRangeStep","getMarkConfig","getMarkPropOrConfig","signalOrStringValue","signalOrValueRef","nonPosition","positionOffset","vgAlignedPositionChannel","pointPositionDefaultRef","rangePosition","ref","getOffsetScaleChannel","getFirstDefined","OFFSETTED_RECT_END_SUFFIX","OFFSETTED_RECT_START_SUFFIX","rectPosition","model","channel","config","encoding","markDef","mark","type","channel2","sizeChannel","channelDef","channelDef2","scale","getScaleComponent","scaleType","get","undefined","orient","hasSizeDef","size","vgChannel","offsetScaleChannel","isBarOrTickBand","bin","timeUnit","rectBinPosition","fieldDef","fieldDef2","positionAndSize","defaultPos","defaultPos2","defaultSizeRef","scaleName","bandSize","hasFieldDef","bandWidth","band","minBandSize","signal","warn","message","cannotUseRelativeBandSizeWithNonBandScale","mult","field","group","value","scaleRange","step","bandPaddingInner","barBandPaddingInner","rectBandPaddingInner","tickBandPaddingInner","padding","defaultStep","view","stack","vgSizeChannel","offsetScaleName","offsetScale","useVlSizeChannel","sizeMixins","defaultRef","cannotApplySizeToNonOrientedMark","hasSizeFromMarkOrEncoding","defaultBandAlign","center","offset","offsetType","bandPosition","posRef","midPointRefWithPositionInvalidTest","vgChannel2","sizeRef","sizeOffset","getBinSpacing","spacing","reverse","axisTranslate","bandSizeExpr","isEnd","spacingOffset","reverseExpr","offsetExpr","axisTranslateExpr","minBandSizeExpr","sign","spacingAndSizeOffset","t","r","o","_ref","axis","component","axes","offset2","binSizeExpr","binSpacingOffset","binSpacingOffset2","bandPositionForBandSize","useRectOffsetField","rectBinRef","startRef","valueRefForFieldOrDatumDef","expr","channelRequiredForBinned","_ref2","interpolatedSignalRef","fieldOrDatumDef","startSuffix","endSuffix"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\mark\\encode\\position-rect.ts"],"sourcesContent":["import type {SignalRef} from 'vega';\nimport {isArray, isNumber} from 'vega-util';\nimport {isBinned, isBinning, isBinParams} from '../../../bin';\nimport {\n  getOffsetChannel,\n  getSecondaryRangeChannel,\n  getSizeChannel,\n  getVgPositionChannel,\n  isPolarPositionChannel,\n  isXorY,\n  PolarPositionChannel,\n  PositionChannel\n} from '../../../channel';\nimport {getBandPosition, getBandSize, isFieldDef, isFieldOrDatumDef, TypedFieldDef, vgField} from '../../../channeldef';\nimport {Config, getViewConfigDiscreteStep} from '../../../config';\nimport {Encoding} from '../../../encoding';\nimport * as log from '../../../log';\nimport {BandSize, isRelativeBandSize} from '../../../mark';\nimport {hasDiscreteDomain} from '../../../scale';\nimport {isSignalRef, isVgRangeStep, VgEncodeEntry, VgValueRef} from '../../../vega.schema';\nimport {getMarkConfig, getMarkPropOrConfig, signalOrStringValue, signalOrValueRef} from '../../common';\nimport {ScaleComponent} from '../../scale/component';\nimport {UnitModel} from '../../unit';\nimport {nonPosition} from './nonposition';\nimport {positionOffset} from './offset';\nimport {vgAlignedPositionChannel} from './position-align';\nimport {pointPositionDefaultRef} from './position-point';\nimport {rangePosition} from './position-range';\nimport * as ref from './valueref';\nimport {getOffsetScaleChannel} from '../../../channel';\nimport {getFirstDefined} from '../../../util';\nimport {Mark} from '../../../mark';\nimport {OFFSETTED_RECT_END_SUFFIX, OFFSETTED_RECT_START_SUFFIX} from '../../data/timeunit';\n\nexport function rectPosition(model: UnitModel, channel: 'x' | 'y' | 'theta' | 'radius'): VgEncodeEntry {\n  const {config, encoding, markDef} = model;\n  const mark = markDef.type;\n\n  const channel2 = getSecondaryRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n  const channelDef = encoding[channel];\n  const channelDef2 = encoding[channel2];\n\n  const scale = model.getScaleComponent(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n\n  const orient = markDef.orient;\n  const hasSizeDef =\n    (encoding as any)[sizeChannel] ??\n    encoding.size ??\n    getMarkPropOrConfig('size', markDef, config, {vgChannel: sizeChannel});\n\n  const offsetScaleChannel = getOffsetChannel(channel);\n\n  const isBarOrTickBand =\n    (mark === 'bar' && (channel === 'x' ? orient === 'vertical' : orient === 'horizontal')) ||\n    (mark === 'tick' && (channel === 'y' ? orient === 'vertical' : orient === 'horizontal'));\n\n  // x, x2, and width -- we must specify two of these in all conditions\n  if (\n    isFieldDef(channelDef) &&\n    (isBinning(channelDef.bin) || isBinned(channelDef.bin) || (channelDef.timeUnit && !channelDef2)) &&\n    !(hasSizeDef && !isRelativeBandSize(hasSizeDef)) &&\n    !(encoding as any)[offsetScaleChannel] &&\n    !hasDiscreteDomain(scaleType)\n  ) {\n    return rectBinPosition({\n      fieldDef: channelDef,\n      fieldDef2: channelDef2,\n      channel,\n      model\n    });\n  } else if (((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType)) || isBarOrTickBand) && !channelDef2) {\n    return positionAndSize(channelDef, channel, model);\n  } else {\n    return rangePosition(channel, model, {defaultPos: 'zeroOrMax', defaultPos2: 'zeroOrMin'});\n  }\n}\n\nfunction defaultSizeRef(\n  sizeChannel: 'width' | 'height',\n  scaleName: string,\n  scale: ScaleComponent,\n  config: Config<SignalRef>,\n  bandSize: BandSize,\n  hasFieldDef: boolean,\n  mark: Mark\n): VgValueRef {\n  if (isRelativeBandSize(bandSize)) {\n    if (scale) {\n      const scaleType = scale.get('type');\n      if (scaleType === 'band') {\n        let bandWidth = `bandwidth('${scaleName}')`;\n        if (bandSize.band !== 1) {\n          bandWidth = `${bandSize.band} * ${bandWidth}`;\n        }\n        const minBandSize = getMarkConfig('minBandSize', {type: mark}, config);\n        return {signal: minBandSize ? `max(${signalOrStringValue(minBandSize)}, ${bandWidth})` : bandWidth};\n      } else if (bandSize.band !== 1) {\n        log.warn(log.message.cannotUseRelativeBandSizeWithNonBandScale(scaleType));\n        bandSize = undefined;\n      }\n    } else {\n      return {\n        mult: bandSize.band,\n        field: {group: sizeChannel}\n      };\n    }\n  } else if (isSignalRef(bandSize)) {\n    return bandSize;\n  } else if (bandSize) {\n    return {value: bandSize};\n  }\n\n  // no valid band size\n  if (scale) {\n    const scaleRange = scale.get('range');\n    if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n      return {value: scaleRange.step - 2};\n    }\n  }\n  if (!hasFieldDef) {\n    const {bandPaddingInner, barBandPaddingInner, rectBandPaddingInner, tickBandPaddingInner} = config.scale;\n    const padding = getFirstDefined(\n      bandPaddingInner,\n      mark === 'tick' ? tickBandPaddingInner : mark === 'bar' ? barBandPaddingInner : rectBandPaddingInner\n    ); // this part is like paddingInner in scale.ts\n    if (isSignalRef(padding)) {\n      return {signal: `(1 - (${padding.signal})) * ${sizeChannel}`};\n    } else if (isNumber(padding)) {\n      return {signal: `${1 - padding} * ${sizeChannel}`};\n    }\n  }\n  const defaultStep = getViewConfigDiscreteStep(config.view, sizeChannel);\n  return {value: defaultStep - 2};\n}\n\n/**\n * Output position encoding and its size encoding for continuous, point, and band scales.\n */\nfunction positionAndSize(\n  fieldDef: Encoding<string>['x' | 'y' | 'theta' | 'radius'],\n  channel: 'x' | 'y' | 'theta' | 'radius',\n  model: UnitModel\n) {\n  const {markDef, encoding, config, stack} = model;\n  const orient = markDef.orient;\n\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n  const vgSizeChannel = getSizeChannel(channel);\n  const channel2 = getSecondaryRangeChannel(channel);\n\n  const offsetScaleChannel = getOffsetChannel(channel);\n  const offsetScaleName = model.scaleName(offsetScaleChannel);\n  const offsetScale = model.getScaleComponent(getOffsetScaleChannel(channel));\n\n  const useVlSizeChannel =\n    // Always uses size channel for ticks, because tick only calls rectPosition() for the size channel\n    markDef.type === 'tick' ||\n    // use \"size\" channel for bars, if there is orient and the channel matches the right orientation\n    (orient === 'horizontal' && channel === 'y') ||\n    (orient === 'vertical' && channel === 'x');\n\n  // Use size encoding / mark property / config if it exists\n  let sizeMixins;\n  if (encoding.size || markDef.size) {\n    if (useVlSizeChannel) {\n      sizeMixins = nonPosition('size', model, {\n        vgChannel: vgSizeChannel,\n        defaultRef: signalOrValueRef(markDef.size)\n      });\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(markDef.type));\n    }\n  }\n  const hasSizeFromMarkOrEncoding = !!sizeMixins;\n\n  // Otherwise, apply default value\n  const bandSize = getBandSize({\n    channel,\n    fieldDef,\n    markDef,\n    config,\n    scaleType: (scale || offsetScale)?.get('type'),\n    useVlSizeChannel\n  });\n\n  sizeMixins = sizeMixins || {\n    [vgSizeChannel]: defaultSizeRef(\n      vgSizeChannel,\n      offsetScaleName || scaleName,\n      offsetScale || scale,\n      config,\n      bandSize,\n      !!fieldDef,\n      markDef.type\n    )\n  };\n\n  /*\n    Band scales with size value and all point scales, use xc/yc + band=0.5\n\n    Otherwise (band scales that has size based on a band ref), use x/y with position band = (1 - size_band) / 2.\n    In this case, size_band is the band specified in the x/y-encoding.\n    By default band is 1, so `(1 - band) / 2` = 0.\n    If band is 0.6, the the x/y position in such case should be `(1 - band) / 2` = 0.2\n   */\n\n  const defaultBandAlign =\n    (scale || offsetScale)?.get('type') === 'band' && isRelativeBandSize(bandSize) && !hasSizeFromMarkOrEncoding\n      ? 'top'\n      : 'middle';\n\n  const vgChannel = vgAlignedPositionChannel(channel, markDef, config, defaultBandAlign);\n  const center = vgChannel === 'xc' || vgChannel === 'yc';\n  const {offset, offsetType} = positionOffset({channel, markDef, encoding, model, bandPosition: center ? 0.5 : 0});\n\n  const posRef = ref.midPointRefWithPositionInvalidTest({\n    channel,\n    channelDef: fieldDef,\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: pointPositionDefaultRef({model, defaultPos: 'mid', channel, scaleName, scale}),\n    bandPosition: center\n      ? offsetType === 'encoding'\n        ? 0\n        : 0.5\n      : isSignalRef(bandSize)\n        ? {signal: `(1-${bandSize})/2`}\n        : isRelativeBandSize(bandSize)\n          ? (1 - bandSize.band) / 2\n          : 0\n  });\n\n  if (vgSizeChannel) {\n    return {[vgChannel]: posRef, ...sizeMixins};\n  } else {\n    // otherwise, we must simulate size by setting position2 = position + size\n    // (for theta/radius since Vega doesn't have thetaWidth/radiusWidth)\n    const vgChannel2 = getVgPositionChannel(channel2);\n    const sizeRef = sizeMixins[vgSizeChannel];\n    const sizeOffset = offset ? {...sizeRef, offset} : sizeRef;\n    return {\n      [vgChannel]: posRef,\n\n      // posRef might be an array that wraps position invalid test\n      [vgChannel2]: isArray(posRef)\n        ? [posRef[0], {...posRef[1], offset: sizeOffset}]\n        : {\n            ...posRef,\n            offset: sizeOffset\n          }\n    };\n  }\n}\n\nfunction getBinSpacing(\n  channel: PositionChannel | PolarPositionChannel,\n  spacing: number,\n  reverse: boolean | SignalRef,\n  axisTranslate: number | SignalRef,\n  offset: number | VgValueRef,\n  minBandSize: number | SignalRef,\n  bandSizeExpr: string\n) {\n  if (isPolarPositionChannel(channel)) {\n    return 0;\n  }\n\n  const isEnd = channel === 'x' || channel === 'y2';\n\n  const spacingOffset = isEnd ? -spacing / 2 : spacing / 2;\n\n  if (isSignalRef(reverse) || isSignalRef(offset) || isSignalRef(axisTranslate) || minBandSize) {\n    const reverseExpr = signalOrStringValue(reverse);\n    const offsetExpr = signalOrStringValue(offset);\n    const axisTranslateExpr = signalOrStringValue(axisTranslate);\n    const minBandSizeExpr = signalOrStringValue(minBandSize);\n\n    const sign = isEnd ? '' : '-';\n\n    const spacingAndSizeOffset = minBandSize\n      ? `(${bandSizeExpr} < ${minBandSizeExpr} ? ${sign}0.5 * (${minBandSizeExpr} - (${bandSizeExpr})) : ${spacingOffset})`\n      : spacingOffset;\n\n    const t = axisTranslateExpr ? `${axisTranslateExpr} + ` : '';\n    const r = reverseExpr ? `(${reverseExpr} ? -1 : 1) * ` : '';\n    const o = offsetExpr ? `(${offsetExpr} + ${spacingAndSizeOffset})` : spacingAndSizeOffset;\n\n    return {\n      signal: t + r + o\n    };\n  } else {\n    offset = offset || 0;\n    return axisTranslate + (reverse ? -offset - spacingOffset : +offset + spacingOffset);\n  }\n}\n\nfunction rectBinPosition({\n  fieldDef,\n  fieldDef2,\n  channel,\n  model\n}: {\n  fieldDef: TypedFieldDef<string>;\n  fieldDef2?: Encoding<string>['x2' | 'y2'];\n  channel: 'x' | 'y' | 'theta' | 'radius';\n  model: UnitModel;\n}) {\n  const {config, markDef, encoding} = model;\n\n  const scale = model.getScaleComponent(channel);\n  const scaleName = model.scaleName(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n  const reverse = scale.get('reverse');\n\n  const bandSize = getBandSize({channel, fieldDef, markDef, config, scaleType});\n\n  const axis = (model.component.axes as any)[channel]?.[0];\n  const axisTranslate = axis?.get('translate') ?? 0.5; // vega default is 0.5\n\n  const spacing = isXorY(channel) ? (getMarkPropOrConfig('binSpacing', markDef, config) ?? 0) : 0;\n\n  const channel2 = getSecondaryRangeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n  const vgChannel2 = getVgPositionChannel(channel2);\n  const minBandSize = getMarkConfig('minBandSize', markDef, config);\n\n  const {offset} = positionOffset({channel, markDef, encoding, model, bandPosition: 0});\n  const {offset: offset2} = positionOffset({channel: channel2, markDef, encoding, model, bandPosition: 0});\n\n  const bandSizeExpr = ref.binSizeExpr({fieldDef, scaleName});\n  const binSpacingOffset = getBinSpacing(channel, spacing, reverse, axisTranslate, offset, minBandSize, bandSizeExpr);\n  const binSpacingOffset2 = getBinSpacing(\n    channel2,\n    spacing,\n    reverse,\n    axisTranslate,\n    offset2 ?? offset,\n    minBandSize,\n    bandSizeExpr\n  );\n\n  const bandPositionForBandSize = isSignalRef(bandSize)\n    ? {signal: `(1-${bandSize.signal})/2`}\n    : isRelativeBandSize(bandSize)\n      ? (1 - bandSize.band) / 2\n      : 0.5;\n\n  const bandPosition = getBandPosition({fieldDef, fieldDef2, markDef, config});\n\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n    const useRectOffsetField = fieldDef.timeUnit && bandPosition !== 0.5;\n\n    return {\n      [vgChannel2]: rectBinRef({\n        fieldDef,\n        scaleName,\n        bandPosition: bandPositionForBandSize,\n        offset: binSpacingOffset2,\n        useRectOffsetField\n      }),\n      [vgChannel]: rectBinRef({\n        fieldDef,\n        scaleName,\n        bandPosition: isSignalRef(bandPositionForBandSize)\n          ? {signal: `1-${bandPositionForBandSize.signal}`}\n          : 1 - bandPositionForBandSize,\n        offset: binSpacingOffset,\n        useRectOffsetField\n      })\n    };\n  } else if (isBinned(fieldDef.bin)) {\n    const startRef = ref.valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, {offset: binSpacingOffset2});\n\n    if (isFieldDef(fieldDef2)) {\n      return {\n        [vgChannel2]: startRef,\n        [vgChannel]: ref.valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, {offset: binSpacingOffset})\n      };\n    } else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {\n      return {\n        [vgChannel2]: startRef,\n        [vgChannel]: {\n          signal: `scale(\"${scaleName}\", ${vgField(fieldDef, {expr: 'datum'})} + ${fieldDef.bin.step})`,\n          offset: binSpacingOffset\n        }\n      };\n    }\n  }\n  log.warn(log.message.channelRequiredForBinned(channel2));\n  return undefined;\n}\n\n/**\n * Value Ref for binned fields\n */\nfunction rectBinRef({\n  fieldDef,\n  scaleName,\n  bandPosition,\n  offset,\n  useRectOffsetField\n}: {\n  fieldDef: TypedFieldDef<string>;\n  scaleName: string;\n  bandPosition: number | SignalRef;\n  offset?: number | SignalRef;\n  useRectOffsetField: boolean;\n}) {\n  return ref.interpolatedSignalRef({\n    scaleName,\n    fieldOrDatumDef: fieldDef,\n    bandPosition,\n    offset,\n    ...(useRectOffsetField\n      ? {\n          startSuffix: OFFSETTED_RECT_START_SUFFIX,\n          endSuffix: OFFSETTED_RECT_END_SUFFIX\n        }\n      : {})\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}