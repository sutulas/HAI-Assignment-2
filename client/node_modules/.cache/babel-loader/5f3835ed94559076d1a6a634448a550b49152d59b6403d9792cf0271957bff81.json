{"ast":null,"code":"import { normalizeEncoding } from '../encoding';\nimport * as log from '../log';\nimport { CompositeMarkNormalizer } from './base';\nimport { makeCompositeAggregatePartFactory } from './common';\nimport { errorBarParams } from './errorbar';\nexport const ERRORBAND = 'errorband';\nexport const ERRORBAND_PARTS = ['band', 'borders'];\nexport const errorBandNormalizer = new CompositeMarkNormalizer(ERRORBAND, normalizeErrorBand);\nexport function normalizeErrorBand(spec, _ref) {\n  let {\n    config\n  } = _ref;\n  // Need to initEncoding first so we can infer type\n  spec = {\n    ...spec,\n    encoding: normalizeEncoding(spec.encoding, config)\n  };\n  const {\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    markDef,\n    outerSpec,\n    tooltipEncoding\n  } = errorBarParams(spec, ERRORBAND, config);\n  const errorBandDef = markDef;\n  const makeErrorBandPart = makeCompositeAggregatePartFactory(errorBandDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorband);\n  const is2D = spec.encoding.x !== undefined && spec.encoding.y !== undefined;\n  let bandMark = {\n    type: is2D ? 'area' : 'rect'\n  };\n  let bordersMark = {\n    type: is2D ? 'line' : 'rule'\n  };\n  const interpolate = {\n    ...(errorBandDef.interpolate ? {\n      interpolate: errorBandDef.interpolate\n    } : {}),\n    ...(errorBandDef.tension && errorBandDef.interpolate ? {\n      tension: errorBandDef.tension\n    } : {})\n  };\n  if (is2D) {\n    bandMark = {\n      ...bandMark,\n      ...interpolate,\n      ariaRoleDescription: 'errorband'\n    };\n    bordersMark = {\n      ...bordersMark,\n      ...interpolate,\n      aria: false\n    };\n  } else if (errorBandDef.interpolate) {\n    log.warn(log.message.errorBand1DNotSupport('interpolate'));\n  } else if (errorBandDef.tension) {\n    log.warn(log.message.errorBand1DNotSupport('tension'));\n  }\n  return {\n    ...outerSpec,\n    transform,\n    layer: [...makeErrorBandPart({\n      partName: 'band',\n      mark: bandMark,\n      positionPrefix: 'lower',\n      endPositionPrefix: 'upper',\n      extraEncoding: tooltipEncoding\n    }), ...makeErrorBandPart({\n      partName: 'borders',\n      mark: bordersMark,\n      positionPrefix: 'lower',\n      extraEncoding: tooltipEncoding\n    }), ...makeErrorBandPart({\n      partName: 'borders',\n      mark: bordersMark,\n      positionPrefix: 'upper',\n      extraEncoding: tooltipEncoding\n    })]\n  };\n}","map":{"version":3,"names":["normalizeEncoding","log","CompositeMarkNormalizer","makeCompositeAggregatePartFactory","errorBarParams","ERRORBAND","ERRORBAND_PARTS","errorBandNormalizer","normalizeErrorBand","spec","_ref","config","encoding","transform","continuousAxisChannelDef","continuousAxis","encodingWithoutContinuousAxis","markDef","outerSpec","tooltipEncoding","errorBandDef","makeErrorBandPart","errorband","is2D","x","undefined","y","bandMark","type","bordersMark","interpolate","tension","ariaRoleDescription","aria","warn","message","errorBand1DNotSupport","layer","partName","mark","positionPrefix","endPositionPrefix","extraEncoding"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compositemark\\errorband.ts"],"sourcesContent":["import {Interpolate, Orientation} from 'vega';\nimport {Field} from '../channeldef';\nimport {Encoding, normalizeEncoding} from '../encoding';\nimport * as log from '../log';\nimport {MarkDef} from '../mark';\nimport {NormalizerParams} from '../normalize';\nimport {GenericUnitSpec, NormalizedLayerSpec} from '../spec';\nimport {CompositeMarkNormalizer} from './base';\nimport {GenericCompositeMarkDef, makeCompositeAggregatePartFactory, PartsMixins} from './common';\nimport {ErrorBarCenter, ErrorBarExtent, errorBarParams, ErrorEncoding} from './errorbar';\n\nexport type ErrorBandUnitSpec<\n  EE = undefined // extra encoding parameter (for faceted composite unit spec)\n> = GenericUnitSpec<ErrorEncoding<Field> & EE, ErrorBand | ErrorBandDef>;\n\nexport const ERRORBAND = 'errorband' as const;\nexport type ErrorBand = typeof ERRORBAND;\n\nexport const ERRORBAND_PARTS = ['band', 'borders'] as const;\n\ntype ErrorBandPart = (typeof ERRORBAND_PARTS)[number];\n\nexport type ErrorBandPartsMixins = PartsMixins<ErrorBandPart>;\n\nexport interface ErrorBandConfig extends ErrorBandPartsMixins {\n  /**\n   * The center of the error band. Available options include:\n   * - `\"mean\"`: the mean of the data points.\n   * - `\"median\"`: the median of the data points.\n   *\n   * __Default value:__ `\"mean\"`.\n   * @hidden\n   */\n\n  // center is not needed right now but will be added back to the schema if future features require it.\n  center?: ErrorBarCenter;\n\n  /**\n   * The extent of the band. Available options include:\n   * - `\"ci\"`: Extend the band to the confidence interval of the mean.\n   * - `\"stderr\"`: The size of band are set to the value of standard error, extending from the mean.\n   * - `\"stdev\"`: The size of band are set to the value of standard deviation, extending from the mean.\n   * - `\"iqr\"`: Extend the band to the q1 and q3.\n   *\n   * __Default value:__ `\"stderr\"`.\n   */\n  extent?: ErrorBarExtent;\n\n  /**\n   * The line interpolation method for the error band. One of the following:\n   * - `\"linear\"`: piecewise linear segments, as in a polyline.\n   * - `\"linear-closed\"`: close the linear segments to form a polygon.\n   * - `\"step\"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes at the midpoint of each pair of adjacent x-values.\n   * - `\"step-before\"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes before the x-value.\n   * - `\"step-after\"`: a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes after the x-value.\n   * - `\"basis\"`: a B-spline, with control point duplication on the ends.\n   * - `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n   * - `\"basis-closed\"`: a closed B-spline, as in a loop.\n   * - `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n   * - `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n   * - `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n   * - `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n   * - `\"monotone\"`: cubic interpolation that preserves monotonicity in y.\n   */\n  interpolate?: Interpolate;\n\n  /**\n   * The tension parameter for the interpolation type of the error band.\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  tension?: number;\n}\n\nexport type ErrorBandDef = GenericCompositeMarkDef<ErrorBand> &\n  ErrorBandConfig & {\n    /**\n     * Orientation of the error band. This is normally automatically determined, but can be specified when the orientation is ambiguous and cannot be automatically determined.\n     */\n    orient?: Orientation;\n  };\n\nexport interface ErrorBandConfigMixins {\n  /**\n   * ErrorBand Config\n   */\n  errorband?: ErrorBandConfig;\n}\n\nexport const errorBandNormalizer = new CompositeMarkNormalizer(ERRORBAND, normalizeErrorBand);\n\nexport function normalizeErrorBand(\n  spec: GenericUnitSpec<Encoding<string>, ErrorBand | ErrorBandDef>,\n  {config}: NormalizerParams\n): NormalizedLayerSpec {\n  // Need to initEncoding first so we can infer type\n  spec = {\n    ...spec,\n    encoding: normalizeEncoding(spec.encoding, config)\n  };\n\n  const {\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    markDef,\n    outerSpec,\n    tooltipEncoding\n  } = errorBarParams(spec, ERRORBAND, config);\n  const errorBandDef: ErrorBandDef = markDef;\n\n  const makeErrorBandPart = makeCompositeAggregatePartFactory<ErrorBandPartsMixins>(\n    errorBandDef,\n    continuousAxis,\n    continuousAxisChannelDef,\n    encodingWithoutContinuousAxis,\n    config.errorband\n  );\n\n  const is2D = spec.encoding.x !== undefined && spec.encoding.y !== undefined;\n\n  let bandMark: MarkDef = {type: is2D ? 'area' : 'rect'};\n  let bordersMark: MarkDef = {type: is2D ? 'line' : 'rule'};\n  const interpolate = {\n    ...(errorBandDef.interpolate ? {interpolate: errorBandDef.interpolate} : {}),\n    ...(errorBandDef.tension && errorBandDef.interpolate ? {tension: errorBandDef.tension} : {})\n  };\n\n  if (is2D) {\n    bandMark = {\n      ...bandMark,\n      ...interpolate,\n      ariaRoleDescription: 'errorband'\n    };\n    bordersMark = {\n      ...bordersMark,\n      ...interpolate,\n      aria: false\n    };\n  } else if (errorBandDef.interpolate) {\n    log.warn(log.message.errorBand1DNotSupport('interpolate'));\n  } else if (errorBandDef.tension) {\n    log.warn(log.message.errorBand1DNotSupport('tension'));\n  }\n\n  return {\n    ...outerSpec,\n    transform,\n    layer: [\n      ...makeErrorBandPart({\n        partName: 'band',\n        mark: bandMark,\n        positionPrefix: 'lower',\n        endPositionPrefix: 'upper',\n        extraEncoding: tooltipEncoding\n      }),\n      ...makeErrorBandPart({\n        partName: 'borders',\n        mark: bordersMark,\n        positionPrefix: 'lower',\n\n        extraEncoding: tooltipEncoding\n      }),\n      ...makeErrorBandPart({\n        partName: 'borders',\n        mark: bordersMark,\n        positionPrefix: 'upper',\n        extraEncoding: tooltipEncoding\n      })\n    ]\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}