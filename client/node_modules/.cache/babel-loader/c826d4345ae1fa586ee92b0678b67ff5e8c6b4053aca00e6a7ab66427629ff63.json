{"ast":null,"code":"import { hasOwnProperty, isString } from 'vega-util';\nimport { contains, hasProperty } from './util';\nconst AGGREGATE_OP_INDEX = {\n  argmax: 1,\n  argmin: 1,\n  average: 1,\n  count: 1,\n  distinct: 1,\n  exponential: 1,\n  exponentialb: 1,\n  product: 1,\n  max: 1,\n  mean: 1,\n  median: 1,\n  min: 1,\n  missing: 1,\n  q1: 1,\n  q3: 1,\n  ci0: 1,\n  ci1: 1,\n  stderr: 1,\n  stdev: 1,\n  stdevp: 1,\n  sum: 1,\n  valid: 1,\n  values: 1,\n  variance: 1,\n  variancep: 1\n};\nexport const MULTIDOMAIN_SORT_OP_INDEX = {\n  count: 1,\n  min: 1,\n  max: 1\n};\nexport function isArgminDef(a) {\n  return hasProperty(a, 'argmin');\n}\nexport function isArgmaxDef(a) {\n  return hasProperty(a, 'argmax');\n}\nexport function isAggregateOp(a) {\n  return isString(a) && hasOwnProperty(AGGREGATE_OP_INDEX, a);\n}\nexport const COUNTING_OPS = new Set(['count', 'valid', 'missing', 'distinct']);\nexport function isCountingAggregateOp(aggregate) {\n  return isString(aggregate) && COUNTING_OPS.has(aggregate);\n}\nexport function isMinMaxOp(aggregate) {\n  return isString(aggregate) && contains(['min', 'max'], aggregate);\n}\n/** Additive-based aggregation operations. These can be applied to stack. */\nexport const SUM_OPS = new Set(['count', 'sum', 'distinct', 'valid', 'missing']);\n/**\n * Aggregation operators that always produce values within the range [domainMin, domainMax].\n */\nexport const SHARED_DOMAIN_OPS = new Set(['mean', 'average', 'median', 'q1', 'q3', 'min', 'max']);","map":{"version":3,"names":["hasOwnProperty","isString","contains","hasProperty","AGGREGATE_OP_INDEX","argmax","argmin","average","count","distinct","exponential","exponentialb","product","max","mean","median","min","missing","q1","q3","ci0","ci1","stderr","stdev","stdevp","sum","valid","values","variance","variancep","MULTIDOMAIN_SORT_OP_INDEX","isArgminDef","a","isArgmaxDef","isAggregateOp","COUNTING_OPS","Set","isCountingAggregateOp","aggregate","has","isMinMaxOp","SUM_OPS","SHARED_DOMAIN_OPS"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\aggregate.ts"],"sourcesContent":["import type {AggregateOp} from 'vega';\nimport {hasOwnProperty, isString} from 'vega-util';\nimport {FieldName} from './channeldef';\nimport {contains, Flag, hasProperty} from './util';\n\nconst AGGREGATE_OP_INDEX: Flag<AggregateOp> = {\n  argmax: 1,\n  argmin: 1,\n  average: 1,\n  count: 1,\n  distinct: 1,\n  exponential: 1,\n  exponentialb: 1,\n  product: 1,\n  max: 1,\n  mean: 1,\n  median: 1,\n  min: 1,\n  missing: 1,\n  q1: 1,\n  q3: 1,\n  ci0: 1,\n  ci1: 1,\n  stderr: 1,\n  stdev: 1,\n  stdevp: 1,\n  sum: 1,\n  valid: 1,\n  values: 1,\n  variance: 1,\n  variancep: 1\n};\n\nexport const MULTIDOMAIN_SORT_OP_INDEX = {\n  count: 1,\n  min: 1,\n  max: 1\n};\n\nexport interface ArgminDef {\n  argmin: FieldName;\n}\n\nexport interface ArgmaxDef {\n  argmax: FieldName;\n}\n\nexport type NonArgAggregateOp = Exclude<AggregateOp, 'argmin' | 'argmax'>;\n\nexport type Aggregate = NonArgAggregateOp | ArgmaxDef | ArgminDef;\n\nexport function isArgminDef(a: Aggregate | string): a is ArgminDef {\n  return hasProperty(a, 'argmin');\n}\n\nexport function isArgmaxDef(a: Aggregate | string): a is ArgmaxDef {\n  return hasProperty(a, 'argmax');\n}\n\nexport function isAggregateOp(a: string | ArgminDef | ArgmaxDef): a is AggregateOp {\n  return isString(a) && hasOwnProperty(AGGREGATE_OP_INDEX, a);\n}\n\nexport const COUNTING_OPS = new Set<NonArgAggregateOp>([\n  'count',\n  'valid',\n  'missing',\n  'distinct'\n]) as ReadonlySet<NonArgAggregateOp>;\n\nexport function isCountingAggregateOp(aggregate?: string | Aggregate): boolean {\n  return isString(aggregate) && COUNTING_OPS.has(aggregate as any);\n}\n\nexport function isMinMaxOp(aggregate?: Aggregate | string): boolean {\n  return isString(aggregate) && contains(['min', 'max'], aggregate);\n}\n\n/** Additive-based aggregation operations. These can be applied to stack. */\nexport const SUM_OPS = new Set<NonArgAggregateOp>([\n  'count',\n  'sum',\n  'distinct',\n  'valid',\n  'missing'\n]) as ReadonlySet<NonArgAggregateOp>;\n\n/**\n * Aggregation operators that always produce values within the range [domainMin, domainMax].\n */\nexport const SHARED_DOMAIN_OPS = new Set<AggregateOp>([\n  'mean',\n  'average',\n  'median',\n  'q1',\n  'q3',\n  'min',\n  'max'\n]) as ReadonlySet<AggregateOp>;\n"],"mappings":"AACA,SAAQA,cAAc,EAAEC,QAAQ,QAAO,WAAW;AAElD,SAAQC,QAAQ,EAAQC,WAAW,QAAO,QAAQ;AAElD,MAAMC,kBAAkB,GAAsB;EAC5CC,MAAM,EAAE,CAAC;EACTC,MAAM,EAAE,CAAC;EACTC,OAAO,EAAE,CAAC;EACVC,KAAK,EAAE,CAAC;EACRC,QAAQ,EAAE,CAAC;EACXC,WAAW,EAAE,CAAC;EACdC,YAAY,EAAE,CAAC;EACfC,OAAO,EAAE,CAAC;EACVC,GAAG,EAAE,CAAC;EACNC,IAAI,EAAE,CAAC;EACPC,MAAM,EAAE,CAAC;EACTC,GAAG,EAAE,CAAC;EACNC,OAAO,EAAE,CAAC;EACVC,EAAE,EAAE,CAAC;EACLC,EAAE,EAAE,CAAC;EACLC,GAAG,EAAE,CAAC;EACNC,GAAG,EAAE,CAAC;EACNC,MAAM,EAAE,CAAC;EACTC,KAAK,EAAE,CAAC;EACRC,MAAM,EAAE,CAAC;EACTC,GAAG,EAAE,CAAC;EACNC,KAAK,EAAE,CAAC;EACRC,MAAM,EAAE,CAAC;EACTC,QAAQ,EAAE,CAAC;EACXC,SAAS,EAAE;CACZ;AAED,OAAO,MAAMC,yBAAyB,GAAG;EACvCtB,KAAK,EAAE,CAAC;EACRQ,GAAG,EAAE,CAAC;EACNH,GAAG,EAAE;CACN;AAcD,OAAM,SAAUkB,WAAWA,CAACC,CAAqB;EAC/C,OAAO7B,WAAW,CAAC6B,CAAC,EAAE,QAAQ,CAAC;AACjC;AAEA,OAAM,SAAUC,WAAWA,CAACD,CAAqB;EAC/C,OAAO7B,WAAW,CAAC6B,CAAC,EAAE,QAAQ,CAAC;AACjC;AAEA,OAAM,SAAUE,aAAaA,CAACF,CAAiC;EAC7D,OAAO/B,QAAQ,CAAC+B,CAAC,CAAC,IAAIhC,cAAc,CAACI,kBAAkB,EAAE4B,CAAC,CAAC;AAC7D;AAEA,OAAO,MAAMG,YAAY,GAAG,IAAIC,GAAG,CAAoB,CACrD,OAAO,EACP,OAAO,EACP,SAAS,EACT,UAAU,CACX,CAAmC;AAEpC,OAAM,SAAUC,qBAAqBA,CAACC,SAA8B;EAClE,OAAOrC,QAAQ,CAACqC,SAAS,CAAC,IAAIH,YAAY,CAACI,GAAG,CAACD,SAAgB,CAAC;AAClE;AAEA,OAAM,SAAUE,UAAUA,CAACF,SAA8B;EACvD,OAAOrC,QAAQ,CAACqC,SAAS,CAAC,IAAIpC,QAAQ,CAAC,CAAC,KAAK,EAAE,KAAK,CAAC,EAAEoC,SAAS,CAAC;AACnE;AAEA;AACA,OAAO,MAAMG,OAAO,GAAG,IAAIL,GAAG,CAAoB,CAChD,OAAO,EACP,KAAK,EACL,UAAU,EACV,OAAO,EACP,SAAS,CACV,CAAmC;AAEpC;;;AAGA,OAAO,MAAMM,iBAAiB,GAAG,IAAIN,GAAG,CAAc,CACpD,MAAM,EACN,SAAS,EACT,QAAQ,EACR,IAAI,EACJ,IAAI,EACJ,KAAK,EACL,KAAK,CACN,CAA6B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}