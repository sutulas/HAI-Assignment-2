{"ast":null,"code":"import { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isXorY } from '../../../channel';\nimport { isFieldDef, isFieldOrDatumDef } from '../../../channeldef';\nimport { getMarkPropOrConfig } from '../../common';\nimport { positionOffset } from './offset';\nimport * as ref from './valueref';\nimport { scaledZeroOrMinOrMax } from './scaledZeroOrMinOrMax';\n/**\n * Return encode for point (non-band) position channels.\n */\nexport function pointPosition(channel, model, _ref) {\n  let {\n    defaultPos,\n    vgChannel\n  } = _ref;\n  const {\n    encoding,\n    markDef,\n    config,\n    stack\n  } = model;\n  const channelDef = encoding[channel];\n  const channel2Def = encoding[getSecondaryRangeChannel(channel)];\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n  const {\n    offset,\n    offsetType\n  } = positionOffset({\n    channel,\n    markDef,\n    encoding,\n    model,\n    bandPosition: 0.5\n  });\n  // Get default position or position from mark def\n  const defaultRef = pointPositionDefaultRef({\n    model,\n    defaultPos,\n    channel,\n    scaleName,\n    scale\n  });\n  const valueRef = !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude) ?\n  // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n  {\n    field: model.getName(channel)\n  } : positionRef({\n    channel,\n    channelDef,\n    channel2Def,\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef,\n    bandPosition: offsetType === 'encoding' ? 0 : undefined\n  });\n  return valueRef ? {\n    [vgChannel || channel]: valueRef\n  } : undefined;\n}\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated. For now, this is a huge step moving forward.\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\nexport function positionRef(params) {\n  const {\n    channel,\n    channelDef,\n    scaleName,\n    stack,\n    offset,\n    markDef\n  } = params;\n  // This isn't a part of midPoint because we use midPoint for non-position too\n  if (isFieldOrDatumDef(channelDef) && stack && channel === stack.fieldChannel) {\n    if (isFieldDef(channelDef)) {\n      let bandPosition = channelDef.bandPosition;\n      if (bandPosition === undefined && markDef.type === 'text' && (channel === 'radius' || channel === 'theta')) {\n        // theta and radius of text mark should use bandPosition = 0.5 by default\n        // so that labels for arc marks are centered automatically\n        bandPosition = 0.5;\n      }\n      if (bandPosition !== undefined) {\n        return ref.interpolatedSignalRef({\n          scaleName,\n          fieldOrDatumDef: channelDef,\n          // positionRef always have type\n          startSuffix: 'start',\n          bandPosition,\n          offset\n        });\n      }\n    }\n    // x or y use stack_end so that stacked line's point mark use stack_end too.\n    return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, {\n      suffix: 'end'\n    }, {\n      offset\n    });\n  }\n  return ref.midPointRefWithPositionInvalidTest(params);\n}\nexport function pointPositionDefaultRef(_ref2) {\n  let {\n    model,\n    defaultPos,\n    channel,\n    scaleName,\n    scale\n  } = _ref2;\n  const {\n    markDef,\n    config\n  } = model;\n  return () => {\n    const mainChannel = getMainRangeChannel(channel);\n    const vgChannel = getVgPositionChannel(channel);\n    const definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, {\n      vgChannel\n    });\n    if (definedValueOrConfig !== undefined) {\n      return ref.widthHeightValueOrSignalRef(channel, definedValueOrConfig);\n    }\n    switch (defaultPos) {\n      case 'zeroOrMin':\n        return zeroOrMinOrMaxPosition({\n          scaleName,\n          scale,\n          mode: 'zeroOrMin',\n          mainChannel,\n          config\n        });\n      case 'zeroOrMax':\n        return zeroOrMinOrMaxPosition({\n          scaleName,\n          scale,\n          mode: {\n            zeroOrMax: {\n              widthSignal: model.width.signal,\n              heightSignal: model.height.signal\n            }\n          },\n          mainChannel,\n          config\n        });\n      case 'mid':\n        {\n          const sizeRef = model[getSizeChannel(channel)];\n          return {\n            ...sizeRef,\n            mult: 0.5\n          };\n        }\n    }\n    // defaultPos === null\n    return undefined;\n  };\n}\nfunction zeroOrMinOrMaxPosition(_ref3) {\n  let {\n    mainChannel,\n    config,\n    ...otherProps\n  } = _ref3;\n  const scaledValueRef = scaledZeroOrMinOrMax(otherProps);\n  const {\n    mode\n  } = otherProps;\n  if (scaledValueRef) {\n    return scaledValueRef;\n  }\n  switch (mainChannel) {\n    case 'radius':\n      {\n        if (mode === 'zeroOrMin') {\n          return {\n            value: 0\n          }; // min value\n        }\n        const {\n          widthSignal,\n          heightSignal\n        } = mode.zeroOrMax;\n        // max of radius is min(width, height) / 2\n        return {\n          signal: `min(${widthSignal},${heightSignal})/2`\n        };\n      }\n    case 'theta':\n      return mode === 'zeroOrMin' ? {\n        value: 0\n      } : {\n        signal: '2*PI'\n      };\n    case 'x':\n      return mode === 'zeroOrMin' ? {\n        value: 0\n      } : {\n        field: {\n          group: 'width'\n        }\n      };\n    case 'y':\n      return mode === 'zeroOrMin' ? {\n        field: {\n          group: 'height'\n        }\n      } : {\n        value: 0\n      };\n  }\n}","map":{"version":3,"names":["getMainRangeChannel","getSecondaryRangeChannel","getSizeChannel","getVgPositionChannel","isXorY","isFieldDef","isFieldOrDatumDef","getMarkPropOrConfig","positionOffset","ref","scaledZeroOrMinOrMax","pointPosition","channel","model","_ref","defaultPos","vgChannel","encoding","markDef","config","stack","channelDef","channel2Def","scaleName","scale","getScaleComponent","offset","offsetType","bandPosition","defaultRef","pointPositionDefaultRef","valueRef","latitude","longitude","field","getName","positionRef","undefined","params","fieldChannel","type","interpolatedSignalRef","fieldOrDatumDef","startSuffix","valueRefForFieldOrDatumDef","suffix","midPointRefWithPositionInvalidTest","_ref2","mainChannel","definedValueOrConfig","widthHeightValueOrSignalRef","zeroOrMinOrMaxPosition","mode","zeroOrMax","widthSignal","width","signal","heightSignal","height","sizeRef","mult","_ref3","otherProps","scaledValueRef","value","group"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\mark\\encode\\position-point.ts"],"sourcesContent":["import {\n  getMainRangeChannel,\n  getSecondaryRangeChannel,\n  getSizeChannel,\n  getVgPositionChannel,\n  isXorY,\n  PolarPositionChannel,\n  PolarPositionScaleChannel,\n  PositionChannel,\n  PositionScaleChannel\n} from '../../../channel';\nimport {isFieldDef, isFieldOrDatumDef, TypedFieldDef} from '../../../channeldef';\nimport {Config} from '../../../config';\nimport {VgValueRef} from '../../../vega.schema';\nimport {getMarkPropOrConfig} from '../../common';\nimport {ScaleComponent} from '../../scale/component';\nimport {UnitModel} from '../../unit';\nimport {positionOffset} from './offset';\nimport * as ref from './valueref';\nimport {scaledZeroOrMinOrMax, ScaledZeroOrMinOrMaxProps} from './scaledZeroOrMinOrMax';\n\n/**\n * Return encode for point (non-band) position channels.\n */\nexport function pointPosition(\n  channel: 'x' | 'y' | 'theta' | 'radius',\n  model: UnitModel,\n  {\n    defaultPos,\n    vgChannel\n  }: {\n    defaultPos: 'mid' | 'zeroOrMin' | 'zeroOrMax' | null;\n    vgChannel?: 'x' | 'y' | 'xc' | 'yc';\n  }\n) {\n  const {encoding, markDef, config, stack} = model;\n\n  const channelDef = encoding[channel];\n  const channel2Def = encoding[getSecondaryRangeChannel(channel)];\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n\n  const {offset, offsetType} = positionOffset({\n    channel,\n    markDef,\n    encoding,\n    model,\n    bandPosition: 0.5\n  });\n\n  // Get default position or position from mark def\n  const defaultRef = pointPositionDefaultRef({\n    model,\n    defaultPos,\n    channel,\n    scaleName,\n    scale\n  });\n\n  const valueRef =\n    !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude)\n      ? // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n        {field: model.getName(channel)}\n      : positionRef({\n          channel,\n          channelDef,\n          channel2Def,\n          markDef,\n          config,\n          scaleName,\n          scale,\n          stack,\n          offset,\n          defaultRef,\n          bandPosition: offsetType === 'encoding' ? 0 : undefined\n        });\n\n  return valueRef ? {[vgChannel || channel]: valueRef} : undefined;\n}\n\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated. For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\nexport function positionRef(\n  params: ref.MidPointParams & {\n    channel: 'x' | 'y' | 'radius' | 'theta';\n  }\n): VgValueRef | VgValueRef[] {\n  const {channel, channelDef, scaleName, stack, offset, markDef} = params;\n\n  // This isn't a part of midPoint because we use midPoint for non-position too\n  if (isFieldOrDatumDef(channelDef) && stack && channel === stack.fieldChannel) {\n    if (isFieldDef(channelDef)) {\n      let bandPosition = channelDef.bandPosition;\n\n      if (bandPosition === undefined && markDef.type === 'text' && (channel === 'radius' || channel === 'theta')) {\n        // theta and radius of text mark should use bandPosition = 0.5 by default\n        // so that labels for arc marks are centered automatically\n        bandPosition = 0.5;\n      }\n\n      if (bandPosition !== undefined) {\n        return ref.interpolatedSignalRef({\n          scaleName,\n          fieldOrDatumDef: channelDef as TypedFieldDef<string>, // positionRef always have type\n          startSuffix: 'start',\n          bandPosition,\n          offset\n        });\n      }\n    }\n    // x or y use stack_end so that stacked line's point mark use stack_end too.\n    return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, {suffix: 'end'}, {offset});\n  }\n\n  return ref.midPointRefWithPositionInvalidTest(params);\n}\n\nexport function pointPositionDefaultRef({\n  model,\n  defaultPos,\n  channel,\n  scaleName,\n  scale\n}: {\n  model: UnitModel;\n  defaultPos: 'mid' | 'zeroOrMin' | 'zeroOrMax' | null;\n  channel: PositionChannel | PolarPositionChannel;\n  scaleName: string;\n  scale: ScaleComponent;\n}): () => VgValueRef {\n  const {markDef, config} = model;\n  return () => {\n    const mainChannel = getMainRangeChannel(channel);\n    const vgChannel = getVgPositionChannel(channel);\n\n    const definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, {vgChannel});\n    if (definedValueOrConfig !== undefined) {\n      return ref.widthHeightValueOrSignalRef(channel, definedValueOrConfig);\n    }\n\n    switch (defaultPos) {\n      case 'zeroOrMin':\n        return zeroOrMinOrMaxPosition({scaleName, scale, mode: 'zeroOrMin', mainChannel, config});\n      case 'zeroOrMax':\n        return zeroOrMinOrMaxPosition({\n          scaleName,\n          scale,\n          mode: {zeroOrMax: {widthSignal: model.width.signal, heightSignal: model.height.signal}},\n          mainChannel,\n          config\n        });\n      case 'mid': {\n        const sizeRef = model[getSizeChannel(channel)];\n        return {...sizeRef, mult: 0.5};\n      }\n    }\n    // defaultPos === null\n    return undefined;\n  };\n}\n\nfunction zeroOrMinOrMaxPosition({\n  mainChannel,\n  config,\n  ...otherProps\n}: ScaledZeroOrMinOrMaxProps & {\n  mainChannel: PositionScaleChannel | PolarPositionScaleChannel;\n  config: Config;\n}): VgValueRef {\n  const scaledValueRef = scaledZeroOrMinOrMax(otherProps);\n  const {mode} = otherProps;\n\n  if (scaledValueRef) {\n    return scaledValueRef;\n  }\n\n  switch (mainChannel) {\n    case 'radius': {\n      if (mode === 'zeroOrMin') {\n        return {value: 0}; // min value\n      }\n      const {widthSignal, heightSignal} = mode.zeroOrMax;\n      // max of radius is min(width, height) / 2\n      return {\n        signal: `min(${widthSignal},${heightSignal})/2`\n      };\n    }\n    case 'theta':\n      return mode === 'zeroOrMin' ? {value: 0} : {signal: '2*PI'};\n    case 'x':\n      return mode === 'zeroOrMin' ? {value: 0} : {field: {group: 'width'}};\n    case 'y':\n      return mode === 'zeroOrMin' ? {field: {group: 'height'}} : {value: 0};\n  }\n}\n"],"mappings":"AAAA,SACEA,mBAAmB,EACnBC,wBAAwB,EACxBC,cAAc,EACdC,oBAAoB,EACpBC,MAAM,QAKD,kBAAkB;AACzB,SAAQC,UAAU,EAAEC,iBAAiB,QAAsB,qBAAqB;AAGhF,SAAQC,mBAAmB,QAAO,cAAc;AAGhD,SAAQC,cAAc,QAAO,UAAU;AACvC,OAAO,KAAKC,GAAG,MAAM,YAAY;AACjC,SAAQC,oBAAoB,QAAkC,wBAAwB;AAEtF;;;AAGA,OAAM,SAAUC,aAAaA,CAC3BC,OAAuC,EACvCC,KAAgB,EAAAC,IAAA,EAOf;EAAA,IAND;IACEC,UAAU;IACVC;EAAS,CAIV,GAAAF,IAAA;EAED,MAAM;IAACG,QAAQ;IAAEC,OAAO;IAAEC,MAAM;IAAEC;EAAK,CAAC,GAAGP,KAAK;EAEhD,MAAMQ,UAAU,GAAGJ,QAAQ,CAACL,OAAO,CAAC;EACpC,MAAMU,WAAW,GAAGL,QAAQ,CAAChB,wBAAwB,CAACW,OAAO,CAAC,CAAC;EAC/D,MAAMW,SAAS,GAAGV,KAAK,CAACU,SAAS,CAACX,OAAO,CAAC;EAC1C,MAAMY,KAAK,GAAGX,KAAK,CAACY,iBAAiB,CAACb,OAAO,CAAC;EAE9C,MAAM;IAACc,MAAM;IAAEC;EAAU,CAAC,GAAGnB,cAAc,CAAC;IAC1CI,OAAO;IACPM,OAAO;IACPD,QAAQ;IACRJ,KAAK;IACLe,YAAY,EAAE;GACf,CAAC;EAEF;EACA,MAAMC,UAAU,GAAGC,uBAAuB,CAAC;IACzCjB,KAAK;IACLE,UAAU;IACVH,OAAO;IACPW,SAAS;IACTC;GACD,CAAC;EAEF,MAAMO,QAAQ,GACZ,CAACV,UAAU,IAAIjB,MAAM,CAACQ,OAAO,CAAC,KAAKK,QAAQ,CAACe,QAAQ,IAAIf,QAAQ,CAACgB,SAAS,CAAC;EACvE;EACA;IAACC,KAAK,EAAErB,KAAK,CAACsB,OAAO,CAACvB,OAAO;EAAC,CAAC,GAC/BwB,WAAW,CAAC;IACVxB,OAAO;IACPS,UAAU;IACVC,WAAW;IACXJ,OAAO;IACPC,MAAM;IACNI,SAAS;IACTC,KAAK;IACLJ,KAAK;IACLM,MAAM;IACNG,UAAU;IACVD,YAAY,EAAED,UAAU,KAAK,UAAU,GAAG,CAAC,GAAGU;GAC/C,CAAC;EAER,OAAON,QAAQ,GAAG;IAAC,CAACf,SAAS,IAAIJ,OAAO,GAAGmB;EAAQ,CAAC,GAAGM,SAAS;AAClE;AAEA;AACA;AAEA;;;AAGA,OAAM,SAAUD,WAAWA,CACzBE,MAEC;EAED,MAAM;IAAC1B,OAAO;IAAES,UAAU;IAAEE,SAAS;IAAEH,KAAK;IAAEM,MAAM;IAAER;EAAO,CAAC,GAAGoB,MAAM;EAEvE;EACA,IAAIhC,iBAAiB,CAACe,UAAU,CAAC,IAAID,KAAK,IAAIR,OAAO,KAAKQ,KAAK,CAACmB,YAAY,EAAE;IAC5E,IAAIlC,UAAU,CAACgB,UAAU,CAAC,EAAE;MAC1B,IAAIO,YAAY,GAAGP,UAAU,CAACO,YAAY;MAE1C,IAAIA,YAAY,KAAKS,SAAS,IAAInB,OAAO,CAACsB,IAAI,KAAK,MAAM,KAAK5B,OAAO,KAAK,QAAQ,IAAIA,OAAO,KAAK,OAAO,CAAC,EAAE;QAC1G;QACA;QACAgB,YAAY,GAAG,GAAG;MACpB;MAEA,IAAIA,YAAY,KAAKS,SAAS,EAAE;QAC9B,OAAO5B,GAAG,CAACgC,qBAAqB,CAAC;UAC/BlB,SAAS;UACTmB,eAAe,EAAErB,UAAmC;UAAE;UACtDsB,WAAW,EAAE,OAAO;UACpBf,YAAY;UACZF;SACD,CAAC;MACJ;IACF;IACA;IACA,OAAOjB,GAAG,CAACmC,0BAA0B,CAACvB,UAAU,EAAEE,SAAS,EAAE;MAACsB,MAAM,EAAE;IAAK,CAAC,EAAE;MAACnB;IAAM,CAAC,CAAC;EACzF;EAEA,OAAOjB,GAAG,CAACqC,kCAAkC,CAACR,MAAM,CAAC;AACvD;AAEA,OAAM,SAAUR,uBAAuBA,CAAAiB,KAAA,EAYtC;EAAA,IAZuC;IACtClC,KAAK;IACLE,UAAU;IACVH,OAAO;IACPW,SAAS;IACTC;EAAK,CAON,GAAAuB,KAAA;EACC,MAAM;IAAC7B,OAAO;IAAEC;EAAM,CAAC,GAAGN,KAAK;EAC/B,OAAO,MAAK;IACV,MAAMmC,WAAW,GAAGhD,mBAAmB,CAACY,OAAO,CAAC;IAChD,MAAMI,SAAS,GAAGb,oBAAoB,CAACS,OAAO,CAAC;IAE/C,MAAMqC,oBAAoB,GAAG1C,mBAAmB,CAACK,OAAO,EAAEM,OAAO,EAAEC,MAAM,EAAE;MAACH;IAAS,CAAC,CAAC;IACvF,IAAIiC,oBAAoB,KAAKZ,SAAS,EAAE;MACtC,OAAO5B,GAAG,CAACyC,2BAA2B,CAACtC,OAAO,EAAEqC,oBAAoB,CAAC;IACvE;IAEA,QAAQlC,UAAU;MAChB,KAAK,WAAW;QACd,OAAOoC,sBAAsB,CAAC;UAAC5B,SAAS;UAAEC,KAAK;UAAE4B,IAAI,EAAE,WAAW;UAAEJ,WAAW;UAAE7B;QAAM,CAAC,CAAC;MAC3F,KAAK,WAAW;QACd,OAAOgC,sBAAsB,CAAC;UAC5B5B,SAAS;UACTC,KAAK;UACL4B,IAAI,EAAE;YAACC,SAAS,EAAE;cAACC,WAAW,EAAEzC,KAAK,CAAC0C,KAAK,CAACC,MAAM;cAAEC,YAAY,EAAE5C,KAAK,CAAC6C,MAAM,CAACF;YAAM;UAAC,CAAC;UACvFR,WAAW;UACX7B;SACD,CAAC;MACJ,KAAK,KAAK;QAAE;UACV,MAAMwC,OAAO,GAAG9C,KAAK,CAACX,cAAc,CAACU,OAAO,CAAC,CAAC;UAC9C,OAAO;YAAC,GAAG+C,OAAO;YAAEC,IAAI,EAAE;UAAG,CAAC;QAChC;IACF;IACA;IACA,OAAOvB,SAAS;EAClB,CAAC;AACH;AAEA,SAASc,sBAAsBA,CAAAU,KAAA,EAO9B;EAAA,IAP+B;IAC9Bb,WAAW;IACX7B,MAAM;IACN,GAAG2C;EAAU,CAId,GAAAD,KAAA;EACC,MAAME,cAAc,GAAGrD,oBAAoB,CAACoD,UAAU,CAAC;EACvD,MAAM;IAACV;EAAI,CAAC,GAAGU,UAAU;EAEzB,IAAIC,cAAc,EAAE;IAClB,OAAOA,cAAc;EACvB;EAEA,QAAQf,WAAW;IACjB,KAAK,QAAQ;MAAE;QACb,IAAII,IAAI,KAAK,WAAW,EAAE;UACxB,OAAO;YAACY,KAAK,EAAE;UAAC,CAAC,CAAC,CAAC;QACrB;QACA,MAAM;UAACV,WAAW;UAAEG;QAAY,CAAC,GAAGL,IAAI,CAACC,SAAS;QAClD;QACA,OAAO;UACLG,MAAM,EAAE,OAAOF,WAAW,IAAIG,YAAY;SAC3C;MACH;IACA,KAAK,OAAO;MACV,OAAOL,IAAI,KAAK,WAAW,GAAG;QAACY,KAAK,EAAE;MAAC,CAAC,GAAG;QAACR,MAAM,EAAE;MAAM,CAAC;IAC7D,KAAK,GAAG;MACN,OAAOJ,IAAI,KAAK,WAAW,GAAG;QAACY,KAAK,EAAE;MAAC,CAAC,GAAG;QAAC9B,KAAK,EAAE;UAAC+B,KAAK,EAAE;QAAO;MAAC,CAAC;IACtE,KAAK,GAAG;MACN,OAAOb,IAAI,KAAK,WAAW,GAAG;QAAClB,KAAK,EAAE;UAAC+B,KAAK,EAAE;QAAQ;MAAC,CAAC,GAAG;QAACD,KAAK,EAAE;MAAC,CAAC;EACzE;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}