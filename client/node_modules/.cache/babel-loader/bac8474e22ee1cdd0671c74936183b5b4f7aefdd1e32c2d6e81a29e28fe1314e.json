{"ast":null,"code":"import { regressionLoess, sampleCurve, regressionConstant, regressionLinear, regressionLog, regressionExp, regressionPow, regressionQuad, regressionPoly } from 'vega-statistics';\nimport { Transform, ingest } from 'vega-dataflow';\nimport { inherits, accessorName, hasOwnProperty, error, extent } from 'vega-util';\nfunction partition(data, groupby) {\n  var groups = [],\n    get = function (f) {\n      return f(t);\n    },\n    map,\n    i,\n    n,\n    t,\n    k,\n    g;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n      if (!g) {\n        map[k] = g = [];\n        g.dims = k;\n        groups.push(g);\n      }\n      g.push(t);\n    }\n  }\n  return groups;\n}\n\n/**\n * Compute locally-weighted regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\n */\nfunction Loess(params) {\n  Transform.call(this, null, params);\n}\nLoess.Definition = {\n  'type': 'Loess',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'default': 0.3\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Loess, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n        groups = partition(source, _.groupby),\n        names = (_.groupby || []).map(accessorName),\n        m = names.length,\n        as = _.as || [accessorName(_.x), accessorName(_.y)],\n        values = [];\n      groups.forEach(g => {\n        regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {\n          const t = {};\n          for (let i = 0; i < m; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n          t[as[0]] = p[0];\n          t[as[1]] = p[1];\n          values.push(ingest(t));\n        });\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n    return out;\n  }\n});\nconst Methods = {\n  constant: regressionConstant,\n  linear: regressionLinear,\n  log: regressionLog,\n  exp: regressionExp,\n  pow: regressionPow,\n  quad: regressionQuad,\n  poly: regressionPoly\n};\nconst degreesOfFreedom = (method, order) => method === 'poly' ? order : method === 'quad' ? 2 : 1;\n\n/**\n * Compute regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {string} [params.method='linear'] - The regression method to apply.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.\n * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.\n */\nfunction Regression(params) {\n  Transform.call(this, null, params);\n}\nRegression.Definition = {\n  'type': 'Regression',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'method',\n    'type': 'string',\n    'default': 'linear',\n    'values': Object.keys(Methods)\n  }, {\n    'name': 'order',\n    'type': 'number',\n    'default': 3\n  }, {\n    'name': 'extent',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'params',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Regression, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n        groups = partition(source, _.groupby),\n        names = (_.groupby || []).map(accessorName),\n        method = _.method || 'linear',\n        order = _.order == null ? 3 : _.order,\n        dof = degreesOfFreedom(method, order),\n        as = _.as || [accessorName(_.x), accessorName(_.y)],\n        fit = Methods[method],\n        values = [];\n      let domain = _.extent;\n      if (!hasOwnProperty(Methods, method)) {\n        error('Invalid regression method: ' + method);\n      }\n      if (domain != null) {\n        if (method === 'log' && domain[0] <= 0) {\n          pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');\n          domain = null;\n        }\n      }\n      groups.forEach(g => {\n        const n = g.length;\n        if (n <= dof) {\n          pulse.dataflow.warn('Skipping regression with more parameters than data points.');\n          return;\n        }\n        const model = fit(g, _.x, _.y, order);\n        if (_.params) {\n          // if parameter vectors requested return those\n          values.push(ingest({\n            keys: g.dims,\n            coef: model.coef,\n            rSquared: model.rSquared\n          }));\n          return;\n        }\n        const dom = domain || extent(g, _.x),\n          add = p => {\n            const t = {};\n            for (let i = 0; i < names.length; ++i) {\n              t[names[i]] = g.dims[i];\n            }\n            t[as[0]] = p[0];\n            t[as[1]] = p[1];\n            values.push(ingest(t));\n          };\n        if (method === 'linear' || method === 'constant') {\n          // for linear or constant regression we only need the end points\n          dom.forEach(x => add([x, model.predict(x)]));\n        } else {\n          // otherwise return trend line sample points\n          sampleCurve(model.predict, dom, 25, 200).forEach(add);\n        }\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n    return out;\n  }\n});\nexport { Loess as loess, Regression as regression };","map":{"version":3,"names":["regressionLoess","sampleCurve","regressionConstant","regressionLinear","regressionLog","regressionExp","regressionPow","regressionQuad","regressionPoly","Transform","ingest","inherits","accessorName","hasOwnProperty","error","extent","partition","data","groupby","groups","get","f","t","map","i","n","k","g","push","length","dims","Loess","params","call","Definition","transform","_","pulse","out","fork","NO_SOURCE","NO_FIELDS","value","changed","modified","source","materialize","SOURCE","names","m","as","x","y","values","forEach","bandwidth","p","rem","add","Methods","constant","linear","log","exp","pow","quad","poly","degreesOfFreedom","method","order","Regression","Object","keys","dof","fit","domain","dataflow","warn","model","coef","rSquared","dom","predict","loess","regression"],"sources":["C:/Users/sutul/node_modules/vega-regression/build/vega-regression.module.js"],"sourcesContent":["import { regressionLoess, sampleCurve, regressionConstant, regressionLinear, regressionLog, regressionExp, regressionPow, regressionQuad, regressionPoly } from 'vega-statistics';\nimport { Transform, ingest } from 'vega-dataflow';\nimport { inherits, accessorName, hasOwnProperty, error, extent } from 'vega-util';\n\nfunction partition (data, groupby) {\n  var groups = [],\n    get = function (f) {\n      return f(t);\n    },\n    map,\n    i,\n    n,\n    t,\n    k,\n    g;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n      if (!g) {\n        map[k] = g = [];\n        g.dims = k;\n        groups.push(g);\n      }\n      g.push(t);\n    }\n  }\n  return groups;\n}\n\n/**\n * Compute locally-weighted regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\n */\nfunction Loess(params) {\n  Transform.call(this, null, params);\n}\nLoess.Definition = {\n  'type': 'Loess',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'default': 0.3\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Loess, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n        groups = partition(source, _.groupby),\n        names = (_.groupby || []).map(accessorName),\n        m = names.length,\n        as = _.as || [accessorName(_.x), accessorName(_.y)],\n        values = [];\n      groups.forEach(g => {\n        regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {\n          const t = {};\n          for (let i = 0; i < m; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n          t[as[0]] = p[0];\n          t[as[1]] = p[1];\n          values.push(ingest(t));\n        });\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n    return out;\n  }\n});\n\nconst Methods = {\n  constant: regressionConstant,\n  linear: regressionLinear,\n  log: regressionLog,\n  exp: regressionExp,\n  pow: regressionPow,\n  quad: regressionQuad,\n  poly: regressionPoly\n};\nconst degreesOfFreedom = (method, order) => method === 'poly' ? order : method === 'quad' ? 2 : 1;\n\n/**\n * Compute regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {string} [params.method='linear'] - The regression method to apply.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.\n * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.\n */\nfunction Regression(params) {\n  Transform.call(this, null, params);\n}\nRegression.Definition = {\n  'type': 'Regression',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'method',\n    'type': 'string',\n    'default': 'linear',\n    'values': Object.keys(Methods)\n  }, {\n    'name': 'order',\n    'type': 'number',\n    'default': 3\n  }, {\n    'name': 'extent',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'params',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Regression, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n        groups = partition(source, _.groupby),\n        names = (_.groupby || []).map(accessorName),\n        method = _.method || 'linear',\n        order = _.order == null ? 3 : _.order,\n        dof = degreesOfFreedom(method, order),\n        as = _.as || [accessorName(_.x), accessorName(_.y)],\n        fit = Methods[method],\n        values = [];\n      let domain = _.extent;\n      if (!hasOwnProperty(Methods, method)) {\n        error('Invalid regression method: ' + method);\n      }\n      if (domain != null) {\n        if (method === 'log' && domain[0] <= 0) {\n          pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');\n          domain = null;\n        }\n      }\n      groups.forEach(g => {\n        const n = g.length;\n        if (n <= dof) {\n          pulse.dataflow.warn('Skipping regression with more parameters than data points.');\n          return;\n        }\n        const model = fit(g, _.x, _.y, order);\n        if (_.params) {\n          // if parameter vectors requested return those\n          values.push(ingest({\n            keys: g.dims,\n            coef: model.coef,\n            rSquared: model.rSquared\n          }));\n          return;\n        }\n        const dom = domain || extent(g, _.x),\n          add = p => {\n            const t = {};\n            for (let i = 0; i < names.length; ++i) {\n              t[names[i]] = g.dims[i];\n            }\n            t[as[0]] = p[0];\n            t[as[1]] = p[1];\n            values.push(ingest(t));\n          };\n        if (method === 'linear' || method === 'constant') {\n          // for linear or constant regression we only need the end points\n          dom.forEach(x => add([x, model.predict(x)]));\n        } else {\n          // otherwise return trend line sample points\n          sampleCurve(model.predict, dom, 25, 200).forEach(add);\n        }\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n    return out;\n  }\n});\n\nexport { Loess as loess, Regression as regression };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}