{"ast":null,"code":"import * as log from '../../log';\nimport { uniqueId } from '../../util';\n/**\n * A node in the dataflow tree.\n */\nexport class DataFlowNode {\n  constructor(parent, debugName) {\n    this.debugName = debugName;\n    this._children = [];\n    this._parent = null;\n    if (parent) {\n      this.parent = parent;\n    }\n  }\n  /**\n   * Clone this node with a deep copy but don't clone links to children or parents.\n   */\n  clone() {\n    throw new Error('Cannot clone node');\n  }\n  get parent() {\n    return this._parent;\n  }\n  /**\n   * Set the parent of the node and also add this node to the parent's children.\n   */\n  set parent(parent) {\n    this._parent = parent;\n    if (parent) {\n      parent.addChild(this);\n    }\n  }\n  get children() {\n    return this._children;\n  }\n  numChildren() {\n    return this._children.length;\n  }\n  addChild(child, loc) {\n    // do not add the same child twice\n    if (this._children.includes(child)) {\n      log.warn(log.message.ADD_SAME_CHILD_TWICE);\n      return;\n    }\n    if (loc !== undefined) {\n      this._children.splice(loc, 0, child);\n    } else {\n      this._children.push(child);\n    }\n  }\n  removeChild(oldChild) {\n    const loc = this._children.indexOf(oldChild);\n    this._children.splice(loc, 1);\n    return loc;\n  }\n  /**\n   * Remove node from the dataflow.\n   */\n  remove() {\n    let loc = this._parent.removeChild(this);\n    for (const child of this._children) {\n      // do not use the set method because we want to insert at a particular location\n      child._parent = this._parent;\n      this._parent.addChild(child, loc++);\n    }\n  }\n  /**\n   * Insert another node as a parent of this node.\n   */\n  insertAsParentOf(other) {\n    const parent = other.parent;\n    parent.removeChild(this);\n    this.parent = parent;\n    other.parent = this;\n  }\n  swapWithParent() {\n    const parent = this._parent;\n    const newParent = parent.parent;\n    // reconnect the children\n    for (const child of this._children) {\n      child.parent = parent;\n    }\n    // remove old links\n    this._children = []; // equivalent to removing every child link one by one\n    parent.removeChild(this);\n    const loc = parent.parent.removeChild(parent);\n    // swap two nodes but maintain order in children\n    this._parent = newParent;\n    newParent.addChild(this, loc);\n    parent.parent = this;\n  }\n}\nexport class OutputNode extends DataFlowNode {\n  clone() {\n    const cloneObj = new this.constructor();\n    cloneObj.debugName = `clone_${this.debugName}`;\n    cloneObj._source = this._source;\n    cloneObj._name = `clone_${this._name}`;\n    cloneObj.type = this.type;\n    cloneObj.refCounts = this.refCounts;\n    cloneObj.refCounts[cloneObj._name] = 0;\n    return cloneObj;\n  }\n  /**\n   * @param source The name of the source. Will change in assemble.\n   * @param type The type of the output node.\n   * @param refCounts A global ref counter map.\n   */\n  constructor(parent, source, type, refCounts) {\n    super(parent, source);\n    this.type = type;\n    this.refCounts = refCounts;\n    this._source = this._name = source;\n    if (this.refCounts && !(this._name in this.refCounts)) {\n      this.refCounts[this._name] = 0;\n    }\n  }\n  dependentFields() {\n    return new Set();\n  }\n  producedFields() {\n    return new Set();\n  }\n  hash() {\n    if (this._hash === undefined) {\n      this._hash = `Output ${uniqueId()}`;\n    }\n    return this._hash;\n  }\n  /**\n   * Request the datasource name and increase the ref counter.\n   *\n   * During the parsing phase, this will return the simple name such as 'main' or 'raw'.\n   * It is crucial to request the name from an output node to mark it as a required node.\n   * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.\n   *\n   * In the assemble phase, this will return the correct name.\n   */\n  getSource() {\n    this.refCounts[this._name]++;\n    return this._source;\n  }\n  isRequired() {\n    return !!this.refCounts[this._name];\n  }\n  setSource(source) {\n    this._source = source;\n  }\n}","map":{"version":3,"names":["log","uniqueId","DataFlowNode","constructor","parent","debugName","_children","_parent","clone","Error","addChild","children","numChildren","length","child","loc","includes","warn","message","ADD_SAME_CHILD_TWICE","undefined","splice","push","removeChild","oldChild","indexOf","remove","insertAsParentOf","other","swapWithParent","newParent","OutputNode","cloneObj","_source","_name","type","refCounts","source","dependentFields","Set","producedFields","hash","_hash","getSource","isRequired","setSource"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\data\\dataflow.ts"],"sourcesContent":["import {DataSourceType} from '../../data';\nimport * as log from '../../log';\nimport {Dict, uniqueId} from '../../util';\n\n/**\n * A node in the dataflow tree.\n */\nexport abstract class DataFlowNode {\n  private _children: DataFlowNode[] = [];\n\n  private _parent: DataFlowNode = null;\n\n  protected _hash: string | number;\n\n  constructor(\n    parent: DataFlowNode,\n    public readonly debugName?: string\n  ) {\n    if (parent) {\n      this.parent = parent;\n    }\n  }\n\n  /**\n   * Clone this node with a deep copy but don't clone links to children or parents.\n   */\n  public clone(): DataFlowNode {\n    throw new Error('Cannot clone node');\n  }\n\n  /**\n   * Return a hash of the node.\n   */\n  public abstract hash(): string | number;\n\n  /**\n   * Set of fields that this node depends on.\n   */\n  public abstract dependentFields(): Set<string>;\n\n  /**\n   * Set of fields that are being created by this node.\n   */\n  public abstract producedFields(): Set<string>;\n\n  get parent() {\n    return this._parent;\n  }\n\n  /**\n   * Set the parent of the node and also add this node to the parent's children.\n   */\n  set parent(parent: DataFlowNode) {\n    this._parent = parent;\n    if (parent) {\n      parent.addChild(this);\n    }\n  }\n\n  get children() {\n    return this._children;\n  }\n\n  public numChildren() {\n    return this._children.length;\n  }\n\n  public addChild(child: DataFlowNode, loc?: number) {\n    // do not add the same child twice\n    if (this._children.includes(child)) {\n      log.warn(log.message.ADD_SAME_CHILD_TWICE);\n      return;\n    }\n\n    if (loc !== undefined) {\n      this._children.splice(loc, 0, child);\n    } else {\n      this._children.push(child);\n    }\n  }\n\n  public removeChild(oldChild: DataFlowNode) {\n    const loc = this._children.indexOf(oldChild);\n    this._children.splice(loc, 1);\n    return loc;\n  }\n\n  /**\n   * Remove node from the dataflow.\n   */\n  public remove() {\n    let loc = this._parent.removeChild(this);\n    for (const child of this._children) {\n      // do not use the set method because we want to insert at a particular location\n      child._parent = this._parent;\n      this._parent.addChild(child, loc++);\n    }\n  }\n\n  /**\n   * Insert another node as a parent of this node.\n   */\n  public insertAsParentOf(other: DataFlowNode) {\n    const parent = other.parent;\n    parent.removeChild(this);\n    this.parent = parent;\n    other.parent = this;\n  }\n\n  public swapWithParent() {\n    const parent = this._parent;\n    const newParent = parent.parent;\n\n    // reconnect the children\n    for (const child of this._children) {\n      child.parent = parent;\n    }\n\n    // remove old links\n    this._children = []; // equivalent to removing every child link one by one\n    parent.removeChild(this);\n    const loc = parent.parent.removeChild(parent);\n\n    // swap two nodes but maintain order in children\n    this._parent = newParent;\n    newParent.addChild(this, loc);\n\n    parent.parent = this;\n  }\n}\n\nexport class OutputNode extends DataFlowNode {\n  private _source: string;\n\n  private _name: string;\n\n  public clone(): this {\n    const cloneObj = new (this.constructor as any)();\n    cloneObj.debugName = `clone_${this.debugName}`;\n    cloneObj._source = this._source;\n    cloneObj._name = `clone_${this._name}`;\n    cloneObj.type = this.type;\n    cloneObj.refCounts = this.refCounts;\n    cloneObj.refCounts[cloneObj._name] = 0;\n    return cloneObj;\n  }\n\n  /**\n   * @param source The name of the source. Will change in assemble.\n   * @param type The type of the output node.\n   * @param refCounts A global ref counter map.\n   */\n  constructor(\n    parent: DataFlowNode,\n    source: string,\n    public readonly type: DataSourceType,\n    private readonly refCounts: Dict<number>\n  ) {\n    super(parent, source);\n\n    this._source = this._name = source;\n\n    if (this.refCounts && !(this._name in this.refCounts)) {\n      this.refCounts[this._name] = 0;\n    }\n  }\n\n  public dependentFields() {\n    return new Set<string>();\n  }\n\n  public producedFields() {\n    return new Set<string>();\n  }\n\n  public hash() {\n    if (this._hash === undefined) {\n      this._hash = `Output ${uniqueId()}`;\n    }\n    return this._hash;\n  }\n\n  /**\n   * Request the datasource name and increase the ref counter.\n   *\n   * During the parsing phase, this will return the simple name such as 'main' or 'raw'.\n   * It is crucial to request the name from an output node to mark it as a required node.\n   * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.\n   *\n   * In the assemble phase, this will return the correct name.\n   */\n  public getSource() {\n    this.refCounts[this._name]++;\n    return this._source;\n  }\n\n  public isRequired(): boolean {\n    return !!this.refCounts[this._name];\n  }\n\n  public setSource(source: string) {\n    this._source = source;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}