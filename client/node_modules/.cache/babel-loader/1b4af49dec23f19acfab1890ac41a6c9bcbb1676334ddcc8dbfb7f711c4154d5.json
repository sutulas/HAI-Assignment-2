{"ast":null,"code":"import { parseSelector } from 'vega-event-selector';\nimport { stringValue } from 'vega-util';\nimport { X, Y } from '../../channel';\nimport { BRUSH as INTERVAL_BRUSH } from './interval';\nimport { default as scalesCompiler, domain } from './scales';\nconst ANCHOR = '_zoom_anchor';\nconst DELTA = '_zoom_delta';\nconst zoom = {\n  defined: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.zoom;\n  },\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const boundScales = scalesCompiler.defined(selCmpt);\n    const delta = name + DELTA;\n    const {\n      x,\n      y\n    } = selCmpt.project.hasChannel;\n    const sx = stringValue(model.scaleName(X));\n    const sy = stringValue(model.scaleName(Y));\n    let events = parseSelector(selCmpt.zoom, 'scope');\n    if (!boundScales) {\n      events = events.map(e => (e.markname = name + INTERVAL_BRUSH, e));\n    }\n    signals.push({\n      name: name + ANCHOR,\n      on: [{\n        events,\n        update: !boundScales ? `{x: x(unit), y: y(unit)}` : '{' + [sx ? `x: invert(${sx}, x(unit))` : '', sy ? `y: invert(${sy}, y(unit))` : ''].filter(expr => expr).join(', ') + '}'\n      }]\n    }, {\n      name: delta,\n      on: [{\n        events,\n        force: true,\n        update: 'pow(1.001, event.deltaY * pow(16, event.deltaMode))'\n      }]\n    });\n    if (x !== undefined) {\n      onDelta(model, selCmpt, x, 'width', signals);\n    }\n    if (y !== undefined) {\n      onDelta(model, selCmpt, y, 'height', signals);\n    }\n    return signals;\n  }\n};\nexport default zoom;\nfunction onDelta(model, selCmpt, proj, size, signals) {\n  const name = selCmpt.name;\n  const channel = proj.channel;\n  const boundScales = scalesCompiler.defined(selCmpt);\n  const signal = signals.find(s => s.name === proj.signals[boundScales ? 'data' : 'visual']);\n  const sizeSg = model.getSizeSignalRef(size).signal;\n  const scaleCmpt = model.getScaleComponent(channel);\n  const scaleType = scaleCmpt && scaleCmpt.get('type');\n  const base = boundScales ? domain(model, channel) : signal.name;\n  const delta = name + DELTA;\n  const anchor = `${name}${ANCHOR}.${channel}`;\n  const zoomFn = !boundScales || !scaleCmpt ? 'zoomLinear' : scaleType === 'log' ? 'zoomLog' : scaleType === 'symlog' ? 'zoomSymlog' : scaleType === 'pow' ? 'zoomPow' : 'zoomLinear';\n  const arg = !boundScales ? '' : scaleType === 'pow' ? `, ${scaleCmpt.get('exponent') ?? 1}` : scaleType === 'symlog' ? `, ${scaleCmpt.get('constant') ?? 1}` : '';\n  const update = `${zoomFn}(${base}, ${anchor}, ${delta}${arg})`;\n  signal.on.push({\n    events: {\n      signal: delta\n    },\n    update: boundScales ? update : `clampRange(${update}, 0, ${sizeSg})`\n  });\n}","map":{"version":3,"names":["parseSelector","stringValue","X","Y","BRUSH","INTERVAL_BRUSH","default","scalesCompiler","domain","ANCHOR","DELTA","zoom","defined","selCmpt","type","signals","model","name","boundScales","delta","x","y","project","hasChannel","sx","scaleName","sy","events","map","e","markname","push","on","update","filter","expr","join","force","undefined","onDelta","proj","size","channel","signal","find","s","sizeSg","getSizeSignalRef","scaleCmpt","getScaleComponent","scaleType","get","base","anchor","zoomFn","arg"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\selection\\zoom.ts"],"sourcesContent":["import {NewSignal} from 'vega';\nimport {parseSelector} from 'vega-event-selector';\nimport {stringValue} from 'vega-util';\nimport {SelectionComponent} from '.';\nimport {ScaleChannel, X, Y} from '../../channel';\nimport {UnitModel} from '../unit';\nimport {BRUSH as INTERVAL_BRUSH} from './interval';\nimport {SelectionProjection} from './project';\nimport {default as scalesCompiler, domain} from './scales';\nimport {SelectionCompiler} from '.';\n\nconst ANCHOR = '_zoom_anchor';\nconst DELTA = '_zoom_delta';\n\nconst zoom: SelectionCompiler<'interval'> = {\n  defined: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.zoom;\n  },\n\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const boundScales = scalesCompiler.defined(selCmpt);\n    const delta = name + DELTA;\n    const {x, y} = selCmpt.project.hasChannel;\n    const sx = stringValue(model.scaleName(X));\n    const sy = stringValue(model.scaleName(Y));\n    let events = parseSelector(selCmpt.zoom, 'scope');\n\n    if (!boundScales) {\n      events = events.map(e => ((e.markname = name + INTERVAL_BRUSH), e));\n    }\n\n    signals.push(\n      {\n        name: name + ANCHOR,\n        on: [\n          {\n            events,\n            update: !boundScales\n              ? `{x: x(unit), y: y(unit)}`\n              : '{' +\n                [sx ? `x: invert(${sx}, x(unit))` : '', sy ? `y: invert(${sy}, y(unit))` : '']\n                  .filter(expr => expr)\n                  .join(', ') +\n                '}'\n          }\n        ]\n      },\n      {\n        name: delta,\n        on: [\n          {\n            events,\n            force: true,\n            update: 'pow(1.001, event.deltaY * pow(16, event.deltaMode))'\n          }\n        ]\n      }\n    );\n\n    if (x !== undefined) {\n      onDelta(model, selCmpt, x, 'width', signals);\n    }\n\n    if (y !== undefined) {\n      onDelta(model, selCmpt, y, 'height', signals);\n    }\n\n    return signals;\n  }\n};\n\nexport default zoom;\n\nfunction onDelta(\n  model: UnitModel,\n  selCmpt: SelectionComponent,\n  proj: SelectionProjection,\n  size: 'width' | 'height',\n  signals: NewSignal[]\n) {\n  const name = selCmpt.name;\n  const channel = proj.channel as ScaleChannel;\n  const boundScales = scalesCompiler.defined(selCmpt);\n  const signal = signals.find(s => s.name === proj.signals[boundScales ? 'data' : 'visual']);\n  const sizeSg = model.getSizeSignalRef(size).signal;\n  const scaleCmpt = model.getScaleComponent(channel);\n  const scaleType = scaleCmpt && scaleCmpt.get('type');\n  const base = boundScales ? domain(model, channel) : signal.name;\n  const delta = name + DELTA;\n  const anchor = `${name}${ANCHOR}.${channel}`;\n  const zoomFn =\n    !boundScales || !scaleCmpt\n      ? 'zoomLinear'\n      : scaleType === 'log'\n        ? 'zoomLog'\n        : scaleType === 'symlog'\n          ? 'zoomSymlog'\n          : scaleType === 'pow'\n            ? 'zoomPow'\n            : 'zoomLinear';\n  const arg = !boundScales\n    ? ''\n    : scaleType === 'pow'\n      ? `, ${scaleCmpt.get('exponent') ?? 1}`\n      : scaleType === 'symlog'\n        ? `, ${scaleCmpt.get('constant') ?? 1}`\n        : '';\n  const update = `${zoomFn}(${base}, ${anchor}, ${delta}${arg})`;\n\n  signal.on.push({\n    events: {signal: delta},\n    update: boundScales ? update : `clampRange(${update}, 0, ${sizeSg})`\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}