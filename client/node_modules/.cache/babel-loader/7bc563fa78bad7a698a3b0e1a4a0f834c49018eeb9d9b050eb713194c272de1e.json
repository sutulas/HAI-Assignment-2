{"ast":null,"code":"import { isArray, isString } from 'vega-util';\nimport { getFieldDef, isFieldDef, isOrderOnlyDef, vgField } from '../../channeldef';\nimport { duplicate, getFirstDefined, hash } from '../../util';\nimport { sortParams } from '../common';\nimport { DataFlowNode } from './dataflow';\nimport { isValidFiniteNumberExpr } from './filterinvalid';\nfunction getStackByFields(model) {\n  return model.stack.stackBy.reduce((fields, by) => {\n    const fieldDef = by.fieldDef;\n    const _field = vgField(fieldDef);\n    if (_field) {\n      fields.push(_field);\n    }\n    return fields;\n  }, []);\n}\nfunction isValidAsArray(as) {\n  return isArray(as) && as.every(s => isString(s)) && as.length > 1;\n}\nexport class StackNode extends DataFlowNode {\n  clone() {\n    return new StackNode(null, duplicate(this._stack));\n  }\n  constructor(parent, stack) {\n    super(parent);\n    this._stack = stack;\n  }\n  static makeFromTransform(parent, stackTransform) {\n    const {\n      stack,\n      groupby,\n      as,\n      offset = 'zero'\n    } = stackTransform;\n    const sortFields = [];\n    const sortOrder = [];\n    if (stackTransform.sort !== undefined) {\n      for (const sortField of stackTransform.sort) {\n        sortFields.push(sortField.field);\n        sortOrder.push(getFirstDefined(sortField.order, 'ascending'));\n      }\n    }\n    const sort = {\n      field: sortFields,\n      order: sortOrder\n    };\n    let normalizedAs;\n    if (isValidAsArray(as)) {\n      normalizedAs = as;\n    } else if (isString(as)) {\n      normalizedAs = [as, `${as}_end`];\n    } else {\n      normalizedAs = [`${stackTransform.stack}_start`, `${stackTransform.stack}_end`];\n    }\n    return new StackNode(parent, {\n      dimensionFieldDefs: [],\n      stackField: stack,\n      groupby,\n      offset,\n      sort,\n      facetby: [],\n      as: normalizedAs\n    });\n  }\n  static makeFromEncoding(parent, model) {\n    const stackProperties = model.stack;\n    const {\n      encoding\n    } = model;\n    if (!stackProperties) {\n      return null;\n    }\n    const {\n      groupbyChannels,\n      fieldChannel,\n      offset,\n      impute\n    } = stackProperties;\n    const dimensionFieldDefs = groupbyChannels.map(groupbyChannel => {\n      const cDef = encoding[groupbyChannel];\n      return getFieldDef(cDef);\n    }).filter(def => !!def);\n    const stackby = getStackByFields(model);\n    const orderDef = model.encoding.order;\n    let sort;\n    if (isArray(orderDef) || isFieldDef(orderDef)) {\n      sort = sortParams(orderDef);\n    } else {\n      const sortOrder = isOrderOnlyDef(orderDef) ? orderDef.sort : fieldChannel === 'y' ? 'descending' : 'ascending';\n      // default = descending by stackFields\n      // FIXME is the default here correct for binned fields?\n      sort = stackby.reduce((s, field) => {\n        if (!s.field.includes(field)) {\n          s.field.push(field);\n          s.order.push(sortOrder);\n        }\n        return s;\n      }, {\n        field: [],\n        order: []\n      });\n    }\n    return new StackNode(parent, {\n      dimensionFieldDefs,\n      stackField: model.vgField(fieldChannel),\n      facetby: [],\n      stackby,\n      sort,\n      offset,\n      impute,\n      as: [model.vgField(fieldChannel, {\n        suffix: 'start',\n        forAs: true\n      }), model.vgField(fieldChannel, {\n        suffix: 'end',\n        forAs: true\n      })]\n    });\n  }\n  get stack() {\n    return this._stack;\n  }\n  addDimensions(fields) {\n    this._stack.facetby.push(...fields);\n  }\n  dependentFields() {\n    const out = new Set();\n    out.add(this._stack.stackField);\n    this.getGroupbyFields().forEach(out.add, out);\n    this._stack.facetby.forEach(out.add, out);\n    this._stack.sort.field.forEach(out.add, out);\n    return out;\n  }\n  producedFields() {\n    return new Set(this._stack.as);\n  }\n  hash() {\n    return `Stack ${hash(this._stack)}`;\n  }\n  getGroupbyFields() {\n    const {\n      dimensionFieldDefs,\n      impute,\n      groupby\n    } = this._stack;\n    if (dimensionFieldDefs.length > 0) {\n      return dimensionFieldDefs.map(dimensionFieldDef => {\n        if (dimensionFieldDef.bin) {\n          if (impute) {\n            // For binned group by field with impute, we calculate bin_mid\n            // as we cannot impute two fields simultaneously\n            return [vgField(dimensionFieldDef, {\n              binSuffix: 'mid'\n            })];\n          }\n          return [\n          // For binned group by field without impute, we need both bin (start) and bin_end\n          vgField(dimensionFieldDef, {}), vgField(dimensionFieldDef, {\n            binSuffix: 'end'\n          })];\n        }\n        return [vgField(dimensionFieldDef)];\n      }).flat();\n    }\n    return groupby ?? [];\n  }\n  assemble() {\n    const transform = [];\n    const {\n      facetby,\n      dimensionFieldDefs,\n      stackField: field,\n      stackby,\n      sort,\n      offset,\n      impute,\n      as\n    } = this._stack;\n    // Impute\n    if (impute) {\n      for (const dimensionFieldDef of dimensionFieldDefs) {\n        const {\n          bandPosition = 0.5,\n          bin\n        } = dimensionFieldDef;\n        if (bin) {\n          // As we can only impute one field at a time, we need to calculate\n          // mid point for a binned field\n          const binStart = vgField(dimensionFieldDef, {\n            expr: 'datum'\n          });\n          const binEnd = vgField(dimensionFieldDef, {\n            expr: 'datum',\n            binSuffix: 'end'\n          });\n          transform.push({\n            type: 'formula',\n            expr: `${isValidFiniteNumberExpr(binStart)} ? ${bandPosition}*${binStart}+${1 - bandPosition}*${binEnd} : ${binStart}`,\n            as: vgField(dimensionFieldDef, {\n              binSuffix: 'mid',\n              forAs: true\n            })\n          });\n        }\n        transform.push({\n          type: 'impute',\n          field,\n          groupby: [...stackby, ...facetby],\n          key: vgField(dimensionFieldDef, {\n            binSuffix: 'mid'\n          }),\n          method: 'value',\n          value: 0\n        });\n      }\n    }\n    // Stack\n    transform.push({\n      type: 'stack',\n      groupby: [...this.getGroupbyFields(), ...facetby],\n      field,\n      sort,\n      as,\n      offset\n    });\n    return transform;\n  }\n}","map":{"version":3,"names":["isArray","isString","getFieldDef","isFieldDef","isOrderOnlyDef","vgField","duplicate","getFirstDefined","hash","sortParams","DataFlowNode","isValidFiniteNumberExpr","getStackByFields","model","stack","stackBy","reduce","fields","by","fieldDef","_field","push","isValidAsArray","as","every","s","length","StackNode","clone","_stack","constructor","parent","makeFromTransform","stackTransform","groupby","offset","sortFields","sortOrder","sort","undefined","sortField","field","order","normalizedAs","dimensionFieldDefs","stackField","facetby","makeFromEncoding","stackProperties","encoding","groupbyChannels","fieldChannel","impute","map","groupbyChannel","cDef","filter","def","stackby","orderDef","includes","suffix","forAs","addDimensions","dependentFields","out","Set","add","getGroupbyFields","forEach","producedFields","dimensionFieldDef","bin","binSuffix","flat","assemble","transform","bandPosition","binStart","expr","binEnd","type","key","method","value"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\data\\stack.ts"],"sourcesContent":["import {Transforms as VgTransform} from 'vega';\nimport {isArray, isString} from 'vega-util';\nimport {FieldDef, FieldName, getFieldDef, isFieldDef, isOrderOnlyDef, vgField} from '../../channeldef';\nimport {SortFields, SortOrder} from '../../sort';\nimport {StackOffset} from '../../stack';\nimport {StackTransform} from '../../transform';\nimport {duplicate, getFirstDefined, hash} from '../../util';\nimport {sortParams} from '../common';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\nimport {isValidFiniteNumberExpr} from './filterinvalid';\n\nfunction getStackByFields(model: UnitModel): string[] {\n  return model.stack.stackBy.reduce((fields, by) => {\n    const fieldDef = by.fieldDef;\n\n    const _field = vgField(fieldDef);\n    if (_field) {\n      fields.push(_field);\n    }\n    return fields;\n  }, [] as string[]);\n}\n\nexport interface StackComponent {\n  /**\n   * Faceted field.\n   */\n  facetby: string[];\n\n  dimensionFieldDefs: FieldDef<string>[];\n\n  /**\n   * Stack measure's field. Used in makeFromEncoding.\n   */\n  stackField: string;\n\n  /**\n   * Level of detail fields for each level in the stacked charts such as color or detail.\n   * Used in makeFromEncoding.\n   */\n  stackby?: string[];\n\n  /**\n   * Field that determines order of levels in the stacked charts.\n   * Used in both but optional in transform.\n   */\n  sort: SortFields;\n\n  /** Mode for stacking marks.\n   */\n  offset: StackOffset;\n\n  /**\n   * Whether to impute the data before stacking. Used only in makeFromEncoding.\n   */\n  impute?: boolean;\n\n  /**\n   * The data fields to group by.\n   */\n  groupby?: FieldName[];\n  /**\n   * Output field names of each stack field.\n   */\n  as: [FieldName, FieldName];\n}\n\nfunction isValidAsArray(as: string[] | string): as is string[] {\n  return isArray(as) && as.every(s => isString(s)) && as.length > 1;\n}\n\nexport class StackNode extends DataFlowNode {\n  private _stack: StackComponent;\n\n  public clone() {\n    return new StackNode(null, duplicate(this._stack));\n  }\n\n  constructor(parent: DataFlowNode, stack: StackComponent) {\n    super(parent);\n\n    this._stack = stack;\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, stackTransform: StackTransform) {\n    const {stack, groupby, as, offset = 'zero'} = stackTransform;\n\n    const sortFields: string[] = [];\n    const sortOrder: SortOrder[] = [];\n    if (stackTransform.sort !== undefined) {\n      for (const sortField of stackTransform.sort) {\n        sortFields.push(sortField.field);\n        sortOrder.push(getFirstDefined(sortField.order, 'ascending'));\n      }\n    }\n    const sort: SortFields = {\n      field: sortFields,\n      order: sortOrder\n    };\n    let normalizedAs: [string, string];\n    if (isValidAsArray(as)) {\n      normalizedAs = as;\n    } else if (isString(as)) {\n      normalizedAs = [as, `${as}_end`];\n    } else {\n      normalizedAs = [`${stackTransform.stack}_start`, `${stackTransform.stack}_end`];\n    }\n\n    return new StackNode(parent, {\n      dimensionFieldDefs: [],\n      stackField: stack,\n      groupby,\n      offset,\n      sort,\n      facetby: [],\n      as: normalizedAs\n    });\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: UnitModel) {\n    const stackProperties = model.stack;\n    const {encoding} = model;\n\n    if (!stackProperties) {\n      return null;\n    }\n\n    const {groupbyChannels, fieldChannel, offset, impute} = stackProperties;\n\n    const dimensionFieldDefs = groupbyChannels\n      .map(groupbyChannel => {\n        const cDef = encoding[groupbyChannel];\n        return getFieldDef(cDef);\n      })\n      .filter(def => !!def);\n\n    const stackby = getStackByFields(model);\n    const orderDef = model.encoding.order;\n\n    let sort: SortFields;\n    if (isArray(orderDef) || isFieldDef(orderDef)) {\n      sort = sortParams(orderDef);\n    } else {\n      const sortOrder = isOrderOnlyDef(orderDef) ? orderDef.sort : fieldChannel === 'y' ? 'descending' : 'ascending';\n      // default = descending by stackFields\n      // FIXME is the default here correct for binned fields?\n      sort = stackby.reduce(\n        (s, field) => {\n          if (!s.field.includes(field)) {\n            s.field.push(field);\n            s.order.push(sortOrder);\n          }\n          return s;\n        },\n        {field: [], order: []}\n      );\n    }\n\n    return new StackNode(parent, {\n      dimensionFieldDefs,\n      stackField: model.vgField(fieldChannel),\n      facetby: [],\n      stackby,\n      sort,\n      offset,\n      impute,\n      as: [\n        model.vgField(fieldChannel, {suffix: 'start', forAs: true}),\n        model.vgField(fieldChannel, {suffix: 'end', forAs: true})\n      ]\n    });\n  }\n\n  get stack(): StackComponent {\n    return this._stack;\n  }\n\n  public addDimensions(fields: string[]) {\n    this._stack.facetby.push(...fields);\n  }\n\n  public dependentFields() {\n    const out = new Set<string>();\n\n    out.add(this._stack.stackField);\n\n    this.getGroupbyFields().forEach(out.add, out);\n    this._stack.facetby.forEach(out.add, out);\n    this._stack.sort.field.forEach(out.add, out);\n\n    return out;\n  }\n\n  public producedFields() {\n    return new Set(this._stack.as);\n  }\n\n  public hash() {\n    return `Stack ${hash(this._stack)}`;\n  }\n\n  private getGroupbyFields() {\n    const {dimensionFieldDefs, impute, groupby} = this._stack;\n\n    if (dimensionFieldDefs.length > 0) {\n      return dimensionFieldDefs\n        .map(dimensionFieldDef => {\n          if (dimensionFieldDef.bin) {\n            if (impute) {\n              // For binned group by field with impute, we calculate bin_mid\n              // as we cannot impute two fields simultaneously\n              return [vgField(dimensionFieldDef, {binSuffix: 'mid'})];\n            }\n            return [\n              // For binned group by field without impute, we need both bin (start) and bin_end\n              vgField(dimensionFieldDef, {}),\n              vgField(dimensionFieldDef, {binSuffix: 'end'})\n            ];\n          }\n          return [vgField(dimensionFieldDef)];\n        })\n        .flat();\n    }\n    return groupby ?? [];\n  }\n\n  public assemble(): VgTransform[] {\n    const transform: VgTransform[] = [];\n    const {facetby, dimensionFieldDefs, stackField: field, stackby, sort, offset, impute, as} = this._stack;\n\n    // Impute\n    if (impute) {\n      for (const dimensionFieldDef of dimensionFieldDefs) {\n        const {bandPosition = 0.5, bin} = dimensionFieldDef;\n        if (bin) {\n          // As we can only impute one field at a time, we need to calculate\n          // mid point for a binned field\n\n          const binStart = vgField(dimensionFieldDef, {expr: 'datum'});\n          const binEnd = vgField(dimensionFieldDef, {expr: 'datum', binSuffix: 'end'});\n          transform.push({\n            type: 'formula',\n            expr: `${isValidFiniteNumberExpr(binStart)} ? ${bandPosition}*${binStart}+${1 - bandPosition}*${binEnd} : ${binStart}`,\n            as: vgField(dimensionFieldDef, {binSuffix: 'mid', forAs: true})\n          });\n        }\n\n        transform.push({\n          type: 'impute',\n          field,\n          groupby: [...stackby, ...facetby],\n          key: vgField(dimensionFieldDef, {binSuffix: 'mid'}),\n          method: 'value',\n          value: 0\n        });\n      }\n    }\n\n    // Stack\n    transform.push({\n      type: 'stack',\n      groupby: [...this.getGroupbyFields(), ...facetby],\n      field,\n      sort,\n      as,\n      offset\n    });\n\n    return transform;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}