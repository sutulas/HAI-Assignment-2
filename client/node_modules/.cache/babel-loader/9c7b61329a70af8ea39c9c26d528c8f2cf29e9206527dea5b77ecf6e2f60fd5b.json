{"ast":null,"code":"import { bisectLeft, bisectRight, permute } from 'd3-array';\nimport { Transform } from 'vega-dataflow';\nimport { inherits } from 'vega-util';\nconst array8 = n => new Uint8Array(n);\nconst array16 = n => new Uint16Array(n);\nconst array32 = n => new Uint32Array(n);\n\n/**\n * Maintains CrossFilter state.\n */\nfunction Bitmaps() {\n  let width = 8,\n    data = [],\n    seen = array32(0),\n    curr = array(0, width),\n    prev = array(0, width);\n  return {\n    data: () => data,\n    seen: () => seen = lengthen(seen, data.length),\n    add(array) {\n      for (let i = 0, j = data.length, n = array.length, t; i < n; ++i) {\n        t = array[i];\n        t._index = j++;\n        data.push(t);\n      }\n    },\n    remove(num, map) {\n      // map: index -> boolean (true => remove)\n      const n = data.length,\n        copy = Array(n - num),\n        reindex = data; // reuse old data array for index map\n      let t, i, j;\n\n      // seek forward to first removal\n      for (i = 0; !map[i] && i < n; ++i) {\n        copy[i] = data[i];\n        reindex[i] = i;\n      }\n\n      // condense arrays\n      for (j = i; i < n; ++i) {\n        t = data[i];\n        if (!map[i]) {\n          reindex[i] = j;\n          curr[j] = curr[i];\n          prev[j] = prev[i];\n          copy[j] = t;\n          t._index = j++;\n        } else {\n          reindex[i] = -1;\n        }\n        curr[i] = 0; // clear unused bits\n      }\n      data = copy;\n      return reindex;\n    },\n    size: () => data.length,\n    curr: () => curr,\n    prev: () => prev,\n    reset: k => prev[k] = curr[k],\n    all: () => width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff,\n    set(k, one) {\n      curr[k] |= one;\n    },\n    clear(k, one) {\n      curr[k] &= ~one;\n    },\n    resize(n, m) {\n      const k = curr.length;\n      if (n > k || m > width) {\n        width = Math.max(m, width);\n        curr = array(n, width, curr);\n        prev = array(n, width);\n      }\n    }\n  };\n}\nfunction lengthen(array, length, copy) {\n  if (array.length >= length) return array;\n  copy = copy || new array.constructor(length);\n  copy.set(array);\n  return copy;\n}\nfunction array(n, m, array) {\n  const copy = (m < 0x101 ? array8 : m < 0x10001 ? array16 : array32)(n);\n  if (array) copy.set(array);\n  return copy;\n}\nfunction Dimension(index, i, query) {\n  const bit = 1 << i;\n  return {\n    one: bit,\n    zero: ~bit,\n    range: query.slice(),\n    bisect: index.bisect,\n    index: index.index,\n    size: index.size,\n    onAdd(added, curr) {\n      const dim = this,\n        range = dim.bisect(dim.range, added.value),\n        idx = added.index,\n        lo = range[0],\n        hi = range[1],\n        n1 = idx.length;\n      let i;\n      for (i = 0; i < lo; ++i) curr[idx[i]] |= bit;\n      for (i = hi; i < n1; ++i) curr[idx[i]] |= bit;\n      return dim;\n    }\n  };\n}\n\n/**\n * Maintains a list of values, sorted by key.\n */\nfunction SortedIndex() {\n  let index = array32(0),\n    value = [],\n    size = 0;\n  function insert(key, data, base) {\n    if (!data.length) return [];\n    const n0 = size,\n      n1 = data.length,\n      addi = array32(n1);\n    let addv = Array(n1),\n      oldv,\n      oldi,\n      i;\n    for (i = 0; i < n1; ++i) {\n      addv[i] = key(data[i]);\n      addi[i] = i;\n    }\n    addv = sort(addv, addi);\n    if (n0) {\n      oldv = value;\n      oldi = index;\n      value = Array(n0 + n1);\n      index = array32(n0 + n1);\n      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);\n    } else {\n      if (base > 0) for (i = 0; i < n1; ++i) {\n        addi[i] += base;\n      }\n      value = addv;\n      index = addi;\n    }\n    size = n0 + n1;\n    return {\n      index: addi,\n      value: addv\n    };\n  }\n  function remove(num, map) {\n    // map: index -> remove\n    const n = size;\n    let idx, i, j;\n\n    // seek forward to first removal\n    for (i = 0; !map[index[i]] && i < n; ++i);\n\n    // condense index and value arrays\n    for (j = i; i < n; ++i) {\n      if (!map[idx = index[i]]) {\n        index[j] = idx;\n        value[j] = value[i];\n        ++j;\n      }\n    }\n    size = n - num;\n  }\n  function reindex(map) {\n    for (let i = 0, n = size; i < n; ++i) {\n      index[i] = map[index[i]];\n    }\n  }\n  function bisect(range, array) {\n    let n;\n    if (array) {\n      n = array.length;\n    } else {\n      array = value;\n      n = size;\n    }\n    return [bisectLeft(array, range[0], 0, n), bisectRight(array, range[1], 0, n)];\n  }\n  return {\n    insert: insert,\n    remove: remove,\n    bisect: bisect,\n    reindex: reindex,\n    index: () => index,\n    size: () => size\n  };\n}\nfunction sort(values, index) {\n  values.sort.call(index, (a, b) => {\n    const x = values[a],\n      y = values[b];\n    return x < y ? -1 : x > y ? 1 : 0;\n  });\n  return permute(values, index);\n}\nfunction merge(base, value0, index0, n0, value1, index1, n1, value, index) {\n  let i0 = 0,\n    i1 = 0,\n    i;\n  for (i = 0; i0 < n0 && i1 < n1; ++i) {\n    if (value0[i0] < value1[i1]) {\n      value[i] = value0[i0];\n      index[i] = index0[i0++];\n    } else {\n      value[i] = value1[i1];\n      index[i] = index1[i1++] + base;\n    }\n  }\n  for (; i0 < n0; ++i0, ++i) {\n    value[i] = value0[i0];\n    index[i] = index0[i0];\n  }\n  for (; i1 < n1; ++i1, ++i) {\n    value[i] = value1[i1];\n    index[i] = index1[i1] + base;\n  }\n}\n\n/**\n * An indexed multi-dimensional filter.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n * @param {Array} params.query - An array of per-dimension range queries.\n */\nfunction CrossFilter(params) {\n  Transform.call(this, Bitmaps(), params);\n  this._indices = null;\n  this._dims = null;\n}\nCrossFilter.Definition = {\n  'type': 'CrossFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true\n  }, {\n    'name': 'query',\n    'type': 'array',\n    'array': true,\n    'required': true,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }]\n};\ninherits(CrossFilter, Transform, {\n  transform(_, pulse) {\n    if (!this._dims) {\n      return this.init(_, pulse);\n    } else {\n      var init = _.modified('fields') || _.fields.some(f => pulse.modified(f.fields));\n      return init ? this.reinit(_, pulse) : this.eval(_, pulse);\n    }\n  },\n  init(_, pulse) {\n    const fields = _.fields,\n      query = _.query,\n      indices = this._indices = {},\n      dims = this._dims = [],\n      m = query.length;\n    let i = 0,\n      key,\n      index;\n\n    // instantiate indices and dimensions\n    for (; i < m; ++i) {\n      key = fields[i].fname;\n      index = indices[key] || (indices[key] = SortedIndex());\n      dims.push(Dimension(index, i, query[i]));\n    }\n    return this.eval(_, pulse);\n  },\n  reinit(_, pulse) {\n    const output = pulse.materialize().fork(),\n      fields = _.fields,\n      query = _.query,\n      indices = this._indices,\n      dims = this._dims,\n      bits = this.value,\n      curr = bits.curr(),\n      prev = bits.prev(),\n      all = bits.all(),\n      out = output.rem = output.add,\n      mod = output.mod,\n      m = query.length,\n      adds = {};\n    let add, index, key, mods, remMap, modMap, i, n, f;\n\n    // set prev to current state\n    prev.set(curr);\n\n    // if pulse has remove tuples, process them first\n    if (pulse.rem.length) {\n      remMap = this.remove(_, pulse, output);\n    }\n\n    // if pulse has added tuples, add them to state\n    if (pulse.add.length) {\n      bits.add(pulse.add);\n    }\n\n    // if pulse has modified tuples, create an index map\n    if (pulse.mod.length) {\n      modMap = {};\n      for (mods = pulse.mod, i = 0, n = mods.length; i < n; ++i) {\n        modMap[mods[i]._index] = 1;\n      }\n    }\n\n    // re-initialize indices as needed, update curr bitmap\n    for (i = 0; i < m; ++i) {\n      f = fields[i];\n      if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n        key = f.fname;\n        if (!(add = adds[key])) {\n          indices[key] = index = SortedIndex();\n          adds[key] = add = index.insert(f, pulse.source, 0);\n        }\n        dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\n      }\n    }\n\n    // visit each tuple\n    // if filter state changed, push index to add/rem\n    // else if in mod and passes a filter, push index to mod\n    for (i = 0, n = bits.data().length; i < n; ++i) {\n      if (remMap[i]) {\n        // skip if removed tuple\n        continue;\n      } else if (prev[i] !== curr[i]) {\n        // add if state changed\n        out.push(i);\n      } else if (modMap[i] && curr[i] !== all) {\n        // otherwise, pass mods through\n        mod.push(i);\n      }\n    }\n    bits.mask = (1 << m) - 1;\n    return output;\n  },\n  eval(_, pulse) {\n    const output = pulse.materialize().fork(),\n      m = this._dims.length;\n    let mask = 0;\n    if (pulse.rem.length) {\n      this.remove(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n    if (_.modified('query') && !_.modified('fields')) {\n      mask |= this.update(_, pulse, output);\n    }\n    if (pulse.add.length) {\n      this.insert(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n    if (pulse.mod.length) {\n      this.modify(pulse, output);\n      mask |= (1 << m) - 1;\n    }\n    this.value.mask = mask;\n    return output;\n  },\n  insert(_, pulse, output) {\n    const tuples = pulse.add,\n      bits = this.value,\n      dims = this._dims,\n      indices = this._indices,\n      fields = _.fields,\n      adds = {},\n      out = output.add,\n      n = bits.size() + tuples.length,\n      m = dims.length;\n    let k = bits.size(),\n      j,\n      key,\n      add;\n\n    // resize bitmaps and add tuples as needed\n    bits.resize(n, m);\n    bits.add(tuples);\n    const curr = bits.curr(),\n      prev = bits.prev(),\n      all = bits.all();\n\n    // add to dimensional indices\n    for (j = 0; j < m; ++j) {\n      key = fields[j].fname;\n      add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n      dims[j].onAdd(add, curr);\n    }\n\n    // set previous filters, output if passes at least one filter\n    for (; k < n; ++k) {\n      prev[k] = all;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n  modify(pulse, output) {\n    const out = output.mod,\n      bits = this.value,\n      curr = bits.curr(),\n      all = bits.all(),\n      tuples = pulse.mod;\n    let i, n, k;\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n  remove(_, pulse, output) {\n    const indices = this._indices,\n      bits = this.value,\n      curr = bits.curr(),\n      prev = bits.prev(),\n      all = bits.all(),\n      map = {},\n      out = output.rem,\n      tuples = pulse.rem;\n    let i, n, k, f;\n\n    // process tuples, output if passes at least one filter\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      map[k] = 1; // build index map\n      prev[k] = f = curr[k];\n      curr[k] = all;\n      if (f !== all) out.push(k);\n    }\n\n    // remove from dimensional indices\n    for (k in indices) {\n      indices[k].remove(n, map);\n    }\n    this.reindex(pulse, n, map);\n    return map;\n  },\n  // reindex filters and indices after propagation completes\n  reindex(pulse, num, map) {\n    const indices = this._indices,\n      bits = this.value;\n    pulse.runAfter(() => {\n      const indexMap = bits.remove(num, map);\n      for (const key in indices) indices[key].reindex(indexMap);\n    });\n  },\n  update(_, pulse, output) {\n    const dims = this._dims,\n      query = _.query,\n      stamp = pulse.stamp,\n      m = dims.length;\n    let mask = 0,\n      i,\n      q;\n\n    // survey how many queries have changed\n    output.filters = 0;\n    for (q = 0; q < m; ++q) {\n      if (_.modified('query', q)) {\n        i = q;\n        ++mask;\n      }\n    }\n    if (mask === 1) {\n      // only one query changed, use more efficient update\n      mask = dims[i].one;\n      this.incrementOne(dims[i], query[i], output.add, output.rem);\n    } else {\n      // multiple queries changed, perform full record keeping\n      for (q = 0, mask = 0; q < m; ++q) {\n        if (!_.modified('query', q)) continue;\n        mask |= dims[q].one;\n        this.incrementAll(dims[q], query[q], stamp, output.add);\n        output.rem = output.add; // duplicate add/rem for downstream resolve\n      }\n    }\n    return mask;\n  },\n  incrementAll(dim, query, stamp, out) {\n    const bits = this.value,\n      seen = bits.seen(),\n      curr = bits.curr(),\n      prev = bits.prev(),\n      index = dim.index(),\n      old = dim.bisect(dim.range),\n      range = dim.bisect(query),\n      lo1 = range[0],\n      hi1 = range[1],\n      lo0 = old[0],\n      hi0 = old[1],\n      one = dim.one;\n    let i, j, k;\n\n    // Fast incremental update based on previous lo index.\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    }\n\n    // Fast incremental update based on previous hi index.\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    }\n    dim.range = query.slice();\n  },\n  incrementOne(dim, query, add, rem) {\n    const bits = this.value,\n      curr = bits.curr(),\n      index = dim.index(),\n      old = dim.bisect(dim.range),\n      range = dim.bisect(query),\n      lo1 = range[0],\n      hi1 = range[1],\n      lo0 = old[0],\n      hi0 = old[1],\n      one = dim.one;\n    let i, j, k;\n\n    // Fast incremental update based on previous lo index.\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n\n    // Fast incremental update based on previous hi index.\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n    dim.range = query.slice();\n  }\n});\n\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\nfunction ResolveFilter(params) {\n  Transform.call(this, null, params);\n}\nResolveFilter.Definition = {\n  'type': 'ResolveFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'ignore',\n    'type': 'number',\n    'required': true,\n    'description': 'A bit mask indicating which filters to ignore.'\n  }, {\n    'name': 'filter',\n    'type': 'object',\n    'required': true,\n    'description': 'Per-tuple filter bitmaps from a CrossFilter transform.'\n  }]\n};\ninherits(ResolveFilter, Transform, {\n  transform(_, pulse) {\n    const ignore = ~(_.ignore || 0),\n      // bit mask where zeros -> dims to ignore\n      bitmap = _.filter,\n      mask = bitmap.mask;\n\n    // exit early if no relevant filter changes\n    if ((mask & ignore) === 0) return pulse.StopPropagation;\n    const output = pulse.fork(pulse.ALL),\n      data = bitmap.data(),\n      curr = bitmap.curr(),\n      prev = bitmap.prev(),\n      pass = k => !(curr[k] & ignore) ? data[k] : null;\n\n    // propagate all mod tuples that pass the filter\n    output.filter(output.MOD, pass);\n\n    // determine add & rem tuples via filter functions\n    // for efficiency, we do *not* populate new arrays,\n    // instead we add filter functions applied downstream\n\n    if (!(mask & mask - 1)) {\n      // only one filter changed\n      output.filter(output.ADD, pass);\n      output.filter(output.REM, k => (curr[k] & ignore) === mask ? data[k] : null);\n    } else {\n      // multiple filters changed\n      output.filter(output.ADD, k => {\n        const c = curr[k] & ignore,\n          f = !c && c ^ prev[k] & ignore;\n        return f ? data[k] : null;\n      });\n      output.filter(output.REM, k => {\n        const c = curr[k] & ignore,\n          f = c && !(c ^ (c ^ prev[k] & ignore));\n        return f ? data[k] : null;\n      });\n    }\n\n    // add filter to source data in case of reflow...\n    return output.filter(output.SOURCE, t => pass(t._index));\n  }\n});\nexport { CrossFilter as crossfilter, ResolveFilter as resolvefilter };","map":{"version":3,"names":["bisectLeft","bisectRight","permute","Transform","inherits","array8","n","Uint8Array","array16","Uint16Array","array32","Uint32Array","Bitmaps","width","data","seen","curr","array","prev","lengthen","length","add","i","j","t","_index","push","remove","num","map","copy","Array","reindex","size","reset","k","all","set","one","clear","resize","m","Math","max","constructor","Dimension","index","query","bit","zero","range","slice","bisect","onAdd","added","dim","value","idx","lo","hi","n1","SortedIndex","insert","key","base","n0","addi","addv","oldv","oldi","sort","merge","values","call","a","b","x","y","value0","index0","value1","index1","i0","i1","CrossFilter","params","_indices","_dims","Definition","transform","_","pulse","init","modified","fields","some","f","reinit","eval","indices","dims","fname","output","materialize","fork","bits","out","rem","mod","adds","mods","remMap","modMap","source","mask","update","modify","tuples","runAfter","indexMap","stamp","q","filters","incrementOne","incrementAll","old","lo1","hi1","lo0","hi0","min","ResolveFilter","ignore","bitmap","filter","StopPropagation","ALL","pass","MOD","ADD","REM","c","SOURCE","crossfilter","resolvefilter"],"sources":["C:/Users/sutul/node_modules/vega-crossfilter/build/vega-crossfilter.module.js"],"sourcesContent":["import { bisectLeft, bisectRight, permute } from 'd3-array';\nimport { Transform } from 'vega-dataflow';\nimport { inherits } from 'vega-util';\n\nconst array8 = n => new Uint8Array(n);\nconst array16 = n => new Uint16Array(n);\nconst array32 = n => new Uint32Array(n);\n\n/**\n * Maintains CrossFilter state.\n */\nfunction Bitmaps() {\n  let width = 8,\n    data = [],\n    seen = array32(0),\n    curr = array(0, width),\n    prev = array(0, width);\n  return {\n    data: () => data,\n    seen: () => seen = lengthen(seen, data.length),\n    add(array) {\n      for (let i = 0, j = data.length, n = array.length, t; i < n; ++i) {\n        t = array[i];\n        t._index = j++;\n        data.push(t);\n      }\n    },\n    remove(num, map) {\n      // map: index -> boolean (true => remove)\n      const n = data.length,\n        copy = Array(n - num),\n        reindex = data; // reuse old data array for index map\n      let t, i, j;\n\n      // seek forward to first removal\n      for (i = 0; !map[i] && i < n; ++i) {\n        copy[i] = data[i];\n        reindex[i] = i;\n      }\n\n      // condense arrays\n      for (j = i; i < n; ++i) {\n        t = data[i];\n        if (!map[i]) {\n          reindex[i] = j;\n          curr[j] = curr[i];\n          prev[j] = prev[i];\n          copy[j] = t;\n          t._index = j++;\n        } else {\n          reindex[i] = -1;\n        }\n        curr[i] = 0; // clear unused bits\n      }\n      data = copy;\n      return reindex;\n    },\n    size: () => data.length,\n    curr: () => curr,\n    prev: () => prev,\n    reset: k => prev[k] = curr[k],\n    all: () => width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff,\n    set(k, one) {\n      curr[k] |= one;\n    },\n    clear(k, one) {\n      curr[k] &= ~one;\n    },\n    resize(n, m) {\n      const k = curr.length;\n      if (n > k || m > width) {\n        width = Math.max(m, width);\n        curr = array(n, width, curr);\n        prev = array(n, width);\n      }\n    }\n  };\n}\nfunction lengthen(array, length, copy) {\n  if (array.length >= length) return array;\n  copy = copy || new array.constructor(length);\n  copy.set(array);\n  return copy;\n}\nfunction array(n, m, array) {\n  const copy = (m < 0x101 ? array8 : m < 0x10001 ? array16 : array32)(n);\n  if (array) copy.set(array);\n  return copy;\n}\n\nfunction Dimension (index, i, query) {\n  const bit = 1 << i;\n  return {\n    one: bit,\n    zero: ~bit,\n    range: query.slice(),\n    bisect: index.bisect,\n    index: index.index,\n    size: index.size,\n    onAdd(added, curr) {\n      const dim = this,\n        range = dim.bisect(dim.range, added.value),\n        idx = added.index,\n        lo = range[0],\n        hi = range[1],\n        n1 = idx.length;\n      let i;\n      for (i = 0; i < lo; ++i) curr[idx[i]] |= bit;\n      for (i = hi; i < n1; ++i) curr[idx[i]] |= bit;\n      return dim;\n    }\n  };\n}\n\n/**\n * Maintains a list of values, sorted by key.\n */\nfunction SortedIndex() {\n  let index = array32(0),\n    value = [],\n    size = 0;\n  function insert(key, data, base) {\n    if (!data.length) return [];\n    const n0 = size,\n      n1 = data.length,\n      addi = array32(n1);\n    let addv = Array(n1),\n      oldv,\n      oldi,\n      i;\n    for (i = 0; i < n1; ++i) {\n      addv[i] = key(data[i]);\n      addi[i] = i;\n    }\n    addv = sort(addv, addi);\n    if (n0) {\n      oldv = value;\n      oldi = index;\n      value = Array(n0 + n1);\n      index = array32(n0 + n1);\n      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);\n    } else {\n      if (base > 0) for (i = 0; i < n1; ++i) {\n        addi[i] += base;\n      }\n      value = addv;\n      index = addi;\n    }\n    size = n0 + n1;\n    return {\n      index: addi,\n      value: addv\n    };\n  }\n  function remove(num, map) {\n    // map: index -> remove\n    const n = size;\n    let idx, i, j;\n\n    // seek forward to first removal\n    for (i = 0; !map[index[i]] && i < n; ++i);\n\n    // condense index and value arrays\n    for (j = i; i < n; ++i) {\n      if (!map[idx = index[i]]) {\n        index[j] = idx;\n        value[j] = value[i];\n        ++j;\n      }\n    }\n    size = n - num;\n  }\n  function reindex(map) {\n    for (let i = 0, n = size; i < n; ++i) {\n      index[i] = map[index[i]];\n    }\n  }\n  function bisect(range, array) {\n    let n;\n    if (array) {\n      n = array.length;\n    } else {\n      array = value;\n      n = size;\n    }\n    return [bisectLeft(array, range[0], 0, n), bisectRight(array, range[1], 0, n)];\n  }\n  return {\n    insert: insert,\n    remove: remove,\n    bisect: bisect,\n    reindex: reindex,\n    index: () => index,\n    size: () => size\n  };\n}\nfunction sort(values, index) {\n  values.sort.call(index, (a, b) => {\n    const x = values[a],\n      y = values[b];\n    return x < y ? -1 : x > y ? 1 : 0;\n  });\n  return permute(values, index);\n}\nfunction merge(base, value0, index0, n0, value1, index1, n1, value, index) {\n  let i0 = 0,\n    i1 = 0,\n    i;\n  for (i = 0; i0 < n0 && i1 < n1; ++i) {\n    if (value0[i0] < value1[i1]) {\n      value[i] = value0[i0];\n      index[i] = index0[i0++];\n    } else {\n      value[i] = value1[i1];\n      index[i] = index1[i1++] + base;\n    }\n  }\n  for (; i0 < n0; ++i0, ++i) {\n    value[i] = value0[i0];\n    index[i] = index0[i0];\n  }\n  for (; i1 < n1; ++i1, ++i) {\n    value[i] = value1[i1];\n    index[i] = index1[i1] + base;\n  }\n}\n\n/**\n * An indexed multi-dimensional filter.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n * @param {Array} params.query - An array of per-dimension range queries.\n */\nfunction CrossFilter(params) {\n  Transform.call(this, Bitmaps(), params);\n  this._indices = null;\n  this._dims = null;\n}\nCrossFilter.Definition = {\n  'type': 'CrossFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true\n  }, {\n    'name': 'query',\n    'type': 'array',\n    'array': true,\n    'required': true,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }]\n};\ninherits(CrossFilter, Transform, {\n  transform(_, pulse) {\n    if (!this._dims) {\n      return this.init(_, pulse);\n    } else {\n      var init = _.modified('fields') || _.fields.some(f => pulse.modified(f.fields));\n      return init ? this.reinit(_, pulse) : this.eval(_, pulse);\n    }\n  },\n  init(_, pulse) {\n    const fields = _.fields,\n      query = _.query,\n      indices = this._indices = {},\n      dims = this._dims = [],\n      m = query.length;\n    let i = 0,\n      key,\n      index;\n\n    // instantiate indices and dimensions\n    for (; i < m; ++i) {\n      key = fields[i].fname;\n      index = indices[key] || (indices[key] = SortedIndex());\n      dims.push(Dimension(index, i, query[i]));\n    }\n    return this.eval(_, pulse);\n  },\n  reinit(_, pulse) {\n    const output = pulse.materialize().fork(),\n      fields = _.fields,\n      query = _.query,\n      indices = this._indices,\n      dims = this._dims,\n      bits = this.value,\n      curr = bits.curr(),\n      prev = bits.prev(),\n      all = bits.all(),\n      out = output.rem = output.add,\n      mod = output.mod,\n      m = query.length,\n      adds = {};\n    let add, index, key, mods, remMap, modMap, i, n, f;\n\n    // set prev to current state\n    prev.set(curr);\n\n    // if pulse has remove tuples, process them first\n    if (pulse.rem.length) {\n      remMap = this.remove(_, pulse, output);\n    }\n\n    // if pulse has added tuples, add them to state\n    if (pulse.add.length) {\n      bits.add(pulse.add);\n    }\n\n    // if pulse has modified tuples, create an index map\n    if (pulse.mod.length) {\n      modMap = {};\n      for (mods = pulse.mod, i = 0, n = mods.length; i < n; ++i) {\n        modMap[mods[i]._index] = 1;\n      }\n    }\n\n    // re-initialize indices as needed, update curr bitmap\n    for (i = 0; i < m; ++i) {\n      f = fields[i];\n      if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n        key = f.fname;\n        if (!(add = adds[key])) {\n          indices[key] = index = SortedIndex();\n          adds[key] = add = index.insert(f, pulse.source, 0);\n        }\n        dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\n      }\n    }\n\n    // visit each tuple\n    // if filter state changed, push index to add/rem\n    // else if in mod and passes a filter, push index to mod\n    for (i = 0, n = bits.data().length; i < n; ++i) {\n      if (remMap[i]) {\n        // skip if removed tuple\n        continue;\n      } else if (prev[i] !== curr[i]) {\n        // add if state changed\n        out.push(i);\n      } else if (modMap[i] && curr[i] !== all) {\n        // otherwise, pass mods through\n        mod.push(i);\n      }\n    }\n    bits.mask = (1 << m) - 1;\n    return output;\n  },\n  eval(_, pulse) {\n    const output = pulse.materialize().fork(),\n      m = this._dims.length;\n    let mask = 0;\n    if (pulse.rem.length) {\n      this.remove(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n    if (_.modified('query') && !_.modified('fields')) {\n      mask |= this.update(_, pulse, output);\n    }\n    if (pulse.add.length) {\n      this.insert(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n    if (pulse.mod.length) {\n      this.modify(pulse, output);\n      mask |= (1 << m) - 1;\n    }\n    this.value.mask = mask;\n    return output;\n  },\n  insert(_, pulse, output) {\n    const tuples = pulse.add,\n      bits = this.value,\n      dims = this._dims,\n      indices = this._indices,\n      fields = _.fields,\n      adds = {},\n      out = output.add,\n      n = bits.size() + tuples.length,\n      m = dims.length;\n    let k = bits.size(),\n      j,\n      key,\n      add;\n\n    // resize bitmaps and add tuples as needed\n    bits.resize(n, m);\n    bits.add(tuples);\n    const curr = bits.curr(),\n      prev = bits.prev(),\n      all = bits.all();\n\n    // add to dimensional indices\n    for (j = 0; j < m; ++j) {\n      key = fields[j].fname;\n      add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n      dims[j].onAdd(add, curr);\n    }\n\n    // set previous filters, output if passes at least one filter\n    for (; k < n; ++k) {\n      prev[k] = all;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n  modify(pulse, output) {\n    const out = output.mod,\n      bits = this.value,\n      curr = bits.curr(),\n      all = bits.all(),\n      tuples = pulse.mod;\n    let i, n, k;\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n  remove(_, pulse, output) {\n    const indices = this._indices,\n      bits = this.value,\n      curr = bits.curr(),\n      prev = bits.prev(),\n      all = bits.all(),\n      map = {},\n      out = output.rem,\n      tuples = pulse.rem;\n    let i, n, k, f;\n\n    // process tuples, output if passes at least one filter\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      map[k] = 1; // build index map\n      prev[k] = f = curr[k];\n      curr[k] = all;\n      if (f !== all) out.push(k);\n    }\n\n    // remove from dimensional indices\n    for (k in indices) {\n      indices[k].remove(n, map);\n    }\n    this.reindex(pulse, n, map);\n    return map;\n  },\n  // reindex filters and indices after propagation completes\n  reindex(pulse, num, map) {\n    const indices = this._indices,\n      bits = this.value;\n    pulse.runAfter(() => {\n      const indexMap = bits.remove(num, map);\n      for (const key in indices) indices[key].reindex(indexMap);\n    });\n  },\n  update(_, pulse, output) {\n    const dims = this._dims,\n      query = _.query,\n      stamp = pulse.stamp,\n      m = dims.length;\n    let mask = 0,\n      i,\n      q;\n\n    // survey how many queries have changed\n    output.filters = 0;\n    for (q = 0; q < m; ++q) {\n      if (_.modified('query', q)) {\n        i = q;\n        ++mask;\n      }\n    }\n    if (mask === 1) {\n      // only one query changed, use more efficient update\n      mask = dims[i].one;\n      this.incrementOne(dims[i], query[i], output.add, output.rem);\n    } else {\n      // multiple queries changed, perform full record keeping\n      for (q = 0, mask = 0; q < m; ++q) {\n        if (!_.modified('query', q)) continue;\n        mask |= dims[q].one;\n        this.incrementAll(dims[q], query[q], stamp, output.add);\n        output.rem = output.add; // duplicate add/rem for downstream resolve\n      }\n    }\n    return mask;\n  },\n  incrementAll(dim, query, stamp, out) {\n    const bits = this.value,\n      seen = bits.seen(),\n      curr = bits.curr(),\n      prev = bits.prev(),\n      index = dim.index(),\n      old = dim.bisect(dim.range),\n      range = dim.bisect(query),\n      lo1 = range[0],\n      hi1 = range[1],\n      lo0 = old[0],\n      hi0 = old[1],\n      one = dim.one;\n    let i, j, k;\n\n    // Fast incremental update based on previous lo index.\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    }\n\n    // Fast incremental update based on previous hi index.\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    }\n    dim.range = query.slice();\n  },\n  incrementOne(dim, query, add, rem) {\n    const bits = this.value,\n      curr = bits.curr(),\n      index = dim.index(),\n      old = dim.bisect(dim.range),\n      range = dim.bisect(query),\n      lo1 = range[0],\n      hi1 = range[1],\n      lo0 = old[0],\n      hi0 = old[1],\n      one = dim.one;\n    let i, j, k;\n\n    // Fast incremental update based on previous lo index.\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n\n    // Fast incremental update based on previous hi index.\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n    dim.range = query.slice();\n  }\n});\n\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\nfunction ResolveFilter(params) {\n  Transform.call(this, null, params);\n}\nResolveFilter.Definition = {\n  'type': 'ResolveFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'ignore',\n    'type': 'number',\n    'required': true,\n    'description': 'A bit mask indicating which filters to ignore.'\n  }, {\n    'name': 'filter',\n    'type': 'object',\n    'required': true,\n    'description': 'Per-tuple filter bitmaps from a CrossFilter transform.'\n  }]\n};\ninherits(ResolveFilter, Transform, {\n  transform(_, pulse) {\n    const ignore = ~(_.ignore || 0),\n      // bit mask where zeros -> dims to ignore\n      bitmap = _.filter,\n      mask = bitmap.mask;\n\n    // exit early if no relevant filter changes\n    if ((mask & ignore) === 0) return pulse.StopPropagation;\n    const output = pulse.fork(pulse.ALL),\n      data = bitmap.data(),\n      curr = bitmap.curr(),\n      prev = bitmap.prev(),\n      pass = k => !(curr[k] & ignore) ? data[k] : null;\n\n    // propagate all mod tuples that pass the filter\n    output.filter(output.MOD, pass);\n\n    // determine add & rem tuples via filter functions\n    // for efficiency, we do *not* populate new arrays,\n    // instead we add filter functions applied downstream\n\n    if (!(mask & mask - 1)) {\n      // only one filter changed\n      output.filter(output.ADD, pass);\n      output.filter(output.REM, k => (curr[k] & ignore) === mask ? data[k] : null);\n    } else {\n      // multiple filters changed\n      output.filter(output.ADD, k => {\n        const c = curr[k] & ignore,\n          f = !c && c ^ prev[k] & ignore;\n        return f ? data[k] : null;\n      });\n      output.filter(output.REM, k => {\n        const c = curr[k] & ignore,\n          f = c && !(c ^ (c ^ prev[k] & ignore));\n        return f ? data[k] : null;\n      });\n    }\n\n    // add filter to source data in case of reflow...\n    return output.filter(output.SOURCE, t => pass(t._index));\n  }\n});\n\nexport { CrossFilter as crossfilter, ResolveFilter as resolvefilter };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}