{"ast":null,"code":"import { hasOwnProperty } from 'vega-util';\nimport { entries, isEmpty } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { VG_MARK_INDEX } from './../../../vega.schema';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nimport { tooltipData } from './tooltip';\nexport function aria(model) {\n  const {\n    markDef,\n    config\n  } = model;\n  const enableAria = getMarkPropOrConfig('aria', markDef, config);\n  // We can ignore other aria properties if ariaHidden is true.\n  if (enableAria === false) {\n    // getMarkGroups sets aria to false already so we don't have to set it in the encode block\n    return {};\n  }\n  return {\n    ...(enableAria ? {\n      aria: enableAria\n    } : {}),\n    ...ariaRoleDescription(model),\n    ...description(model)\n  };\n}\nfunction ariaRoleDescription(model) {\n  const {\n    mark,\n    markDef,\n    config\n  } = model;\n  if (config.aria === false) {\n    return {};\n  }\n  const ariaRoleDesc = getMarkPropOrConfig('ariaRoleDescription', markDef, config);\n  if (ariaRoleDesc != null) {\n    return {\n      ariaRoleDescription: {\n        value: ariaRoleDesc\n      }\n    };\n  }\n  return hasOwnProperty(VG_MARK_INDEX, mark) ? {} : {\n    ariaRoleDescription: {\n      value: mark\n    }\n  };\n}\nexport function description(model) {\n  const {\n    encoding,\n    markDef,\n    config,\n    stack\n  } = model;\n  const channelDef = encoding.description;\n  if (channelDef) {\n    return wrapCondition({\n      model,\n      channelDef,\n      vgChannel: 'description',\n      mainRefFn: cDef => textRef(cDef, model.config),\n      invalidValueRef: undefined // aria encoding doesn't have continuous scales and thus can't have invalid values\n    });\n  }\n  // Use default from mark def or config if defined.\n  // Functions in encode usually just return undefined but since we are defining a default below, we need to check the default here.\n  const descriptionValue = getMarkPropOrConfig('description', markDef, config);\n  if (descriptionValue != null) {\n    return {\n      description: signalOrValueRef(descriptionValue)\n    };\n  }\n  if (config.aria === false) {\n    return {};\n  }\n  const data = tooltipData(encoding, stack, config);\n  if (isEmpty(data)) {\n    return undefined;\n  }\n  return {\n    description: {\n      signal: entries(data).map((_ref, index) => {\n        let [key, value] = _ref;\n        return `\"${index > 0 ? '; ' : ''}${key}: \" + (${value})`;\n      }).join(' + ')\n    }\n  };\n}","map":{"version":3,"names":["hasOwnProperty","entries","isEmpty","getMarkPropOrConfig","signalOrValueRef","VG_MARK_INDEX","wrapCondition","textRef","tooltipData","aria","model","markDef","config","enableAria","ariaRoleDescription","description","mark","ariaRoleDesc","value","encoding","stack","channelDef","vgChannel","mainRefFn","cDef","invalidValueRef","undefined","descriptionValue","data","signal","map","_ref","index","key","join"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\mark\\encode\\aria.ts"],"sourcesContent":["import {hasOwnProperty} from 'vega-util';\nimport {entries, isEmpty} from '../../../util';\nimport {getMarkPropOrConfig, signalOrValueRef} from '../../common';\nimport {VG_MARK_INDEX} from './../../../vega.schema';\nimport {UnitModel} from './../../unit';\nimport {wrapCondition} from './conditional';\nimport {textRef} from './text';\nimport {tooltipData} from './tooltip';\n\nexport function aria(model: UnitModel) {\n  const {markDef, config} = model;\n\n  const enableAria = getMarkPropOrConfig('aria', markDef, config);\n\n  // We can ignore other aria properties if ariaHidden is true.\n  if (enableAria === false) {\n    // getMarkGroups sets aria to false already so we don't have to set it in the encode block\n    return {};\n  }\n\n  return {\n    ...(enableAria ? {aria: enableAria} : {}),\n    ...ariaRoleDescription(model),\n    ...description(model)\n  };\n}\n\nfunction ariaRoleDescription(model: UnitModel) {\n  const {mark, markDef, config} = model;\n\n  if (config.aria === false) {\n    return {};\n  }\n\n  const ariaRoleDesc = getMarkPropOrConfig('ariaRoleDescription', markDef, config);\n\n  if (ariaRoleDesc != null) {\n    return {ariaRoleDescription: {value: ariaRoleDesc}};\n  }\n\n  return hasOwnProperty(VG_MARK_INDEX, mark) ? {} : {ariaRoleDescription: {value: mark}};\n}\n\nexport function description(model: UnitModel) {\n  const {encoding, markDef, config, stack} = model;\n  const channelDef = encoding.description;\n\n  if (channelDef) {\n    return wrapCondition({\n      model,\n      channelDef,\n      vgChannel: 'description',\n      mainRefFn: cDef => textRef(cDef, model.config),\n      invalidValueRef: undefined // aria encoding doesn't have continuous scales and thus can't have invalid values\n    });\n  }\n\n  // Use default from mark def or config if defined.\n  // Functions in encode usually just return undefined but since we are defining a default below, we need to check the default here.\n  const descriptionValue = getMarkPropOrConfig('description', markDef, config);\n  if (descriptionValue != null) {\n    return {\n      description: signalOrValueRef(descriptionValue)\n    };\n  }\n\n  if (config.aria === false) {\n    return {};\n  }\n\n  const data = tooltipData(encoding, stack, config);\n\n  if (isEmpty(data)) {\n    return undefined;\n  }\n\n  return {\n    description: {\n      signal: entries(data)\n        .map(([key, value], index) => `\"${index > 0 ? '; ' : ''}${key}: \" + (${value})`)\n        .join(' + ')\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}