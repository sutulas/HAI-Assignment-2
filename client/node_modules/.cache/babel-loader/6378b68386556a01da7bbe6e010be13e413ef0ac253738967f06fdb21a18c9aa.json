{"ast":null,"code":"import { array } from 'vega-util';\nimport { isQuantitative } from '../../scale';\nimport { keys, titleCase } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getStyleConfig, signalOrStringValue } from '../common';\nfunction getAxisConfigFromConfigTypes(configTypes, config, channel, orient) {\n  // TODO: add special casing to add conditional value based on orient signal\n  return Object.assign.apply(null, [{}, ...configTypes.map(configType => {\n    if (configType === 'axisOrient') {\n      const orient1 = channel === 'x' ? 'bottom' : 'left';\n      const orientConfig1 = config[channel === 'x' ? 'axisBottom' : 'axisLeft'] || {};\n      const orientConfig2 = config[channel === 'x' ? 'axisTop' : 'axisRight'] || {};\n      const props = new Set([...keys(orientConfig1), ...keys(orientConfig2)]);\n      const conditionalOrientAxisConfig = {};\n      for (const prop of props.values()) {\n        conditionalOrientAxisConfig[prop] = {\n          // orient is surely signal in this case\n          signal: `${orient['signal']} === \"${orient1}\" ? ${signalOrStringValue(orientConfig1[prop])} : ${signalOrStringValue(orientConfig2[prop])}`\n        };\n      }\n      return conditionalOrientAxisConfig;\n    }\n    return config[configType];\n  })]);\n}\nexport function getAxisConfigs(channel, scaleType, orient, config) {\n  const typeBasedConfigTypes = scaleType === 'band' ? ['axisDiscrete', 'axisBand'] : scaleType === 'point' ? ['axisDiscrete', 'axisPoint'] : isQuantitative(scaleType) ? ['axisQuantitative'] : scaleType === 'time' || scaleType === 'utc' ? ['axisTemporal'] : [];\n  const axisChannel = channel === 'x' ? 'axisX' : 'axisY';\n  const axisOrient = isSignalRef(orient) ? 'axisOrient' : `axis${titleCase(orient)}`; // axisTop, axisBottom, ...\n  const vlOnlyConfigTypes = [\n  // technically Vega does have axisBand, but if we make another separation here,\n  // it will further introduce complexity in the code\n  ...typeBasedConfigTypes, ...typeBasedConfigTypes.map(c => axisChannel + c.substr(4))];\n  const vgConfigTypes = ['axis', axisOrient, axisChannel];\n  return {\n    vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config, channel, orient),\n    vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config, channel, orient),\n    axisConfigStyle: getAxisConfigStyle([...vgConfigTypes, ...vlOnlyConfigTypes], config)\n  };\n}\nexport function getAxisConfigStyle(axisConfigTypes, config) {\n  const toMerge = [{}];\n  for (const configType of axisConfigTypes) {\n    // TODO: add special casing to add conditional value based on orient signal\n    let style = config[configType]?.style;\n    if (style) {\n      style = array(style);\n      for (const s of style) {\n        toMerge.push(config.style[s]);\n      }\n    }\n  }\n  return Object.assign.apply(null, toMerge);\n}\nexport function getAxisConfig(property, styleConfigIndex, style) {\n  let axisConfigs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const styleConfig = getStyleConfig(property, style, styleConfigIndex);\n  if (styleConfig !== undefined) {\n    return {\n      configFrom: 'style',\n      configValue: styleConfig\n    };\n  }\n  for (const configFrom of ['vlOnlyAxisConfig', 'vgAxisConfig', 'axisConfigStyle']) {\n    if (axisConfigs[configFrom]?.[property] !== undefined) {\n      return {\n        configFrom,\n        configValue: axisConfigs[configFrom][property]\n      };\n    }\n  }\n  return {};\n}","map":{"version":3,"names":["array","isQuantitative","keys","titleCase","isSignalRef","getStyleConfig","signalOrStringValue","getAxisConfigFromConfigTypes","configTypes","config","channel","orient","Object","assign","apply","map","configType","orient1","orientConfig1","orientConfig2","props","Set","conditionalOrientAxisConfig","prop","values","signal","getAxisConfigs","scaleType","typeBasedConfigTypes","axisChannel","axisOrient","vlOnlyConfigTypes","c","substr","vgConfigTypes","vlOnlyAxisConfig","vgAxisConfig","axisConfigStyle","getAxisConfigStyle","axisConfigTypes","toMerge","style","s","push","getAxisConfig","property","styleConfigIndex","axisConfigs","arguments","length","undefined","styleConfig","configFrom","configValue"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\axis\\config.ts"],"sourcesContent":["import {ScaleType, SignalRef} from 'vega';\nimport {array} from 'vega-util';\nimport {AxisConfig} from '../../axis';\nimport {PositionScaleChannel} from '../../channel';\nimport {Config, StyleConfigIndex} from '../../config';\nimport {isQuantitative} from '../../scale';\nimport {keys, titleCase} from '../../util';\nimport {isSignalRef} from '../../vega.schema';\nimport {getStyleConfig, signalOrStringValue} from '../common';\n\nfunction getAxisConfigFromConfigTypes(\n  configTypes: string[],\n  config: Config,\n  channel: 'x' | 'y',\n  orient: string | SignalRef\n) {\n  // TODO: add special casing to add conditional value based on orient signal\n  return Object.assign.apply(null, [\n    {},\n    ...configTypes.map(configType => {\n      if (configType === 'axisOrient') {\n        const orient1 = channel === 'x' ? 'bottom' : 'left';\n        const orientConfig1 = config[channel === 'x' ? 'axisBottom' : 'axisLeft'] || {};\n        const orientConfig2 = config[channel === 'x' ? 'axisTop' : 'axisRight'] || {};\n\n        const props = new Set([...keys(orientConfig1), ...keys(orientConfig2)]);\n\n        const conditionalOrientAxisConfig = {};\n        for (const prop of props.values()) {\n          (conditionalOrientAxisConfig as any)[prop] = {\n            // orient is surely signal in this case\n            signal: `${(orient as any)['signal']} === \"${orient1}\" ? ${signalOrStringValue(\n              orientConfig1[prop]\n            )} : ${signalOrStringValue(orientConfig2[prop])}`\n          };\n        }\n\n        return conditionalOrientAxisConfig;\n      }\n\n      return (config as any)[configType];\n    })\n  ]);\n}\n\nexport type AxisConfigs = ReturnType<typeof getAxisConfigs>;\n\nexport function getAxisConfigs(\n  channel: PositionScaleChannel,\n  scaleType: ScaleType,\n  orient: string | SignalRef,\n  config: Config\n) {\n  const typeBasedConfigTypes =\n    scaleType === 'band'\n      ? ['axisDiscrete', 'axisBand']\n      : scaleType === 'point'\n        ? ['axisDiscrete', 'axisPoint']\n        : isQuantitative(scaleType)\n          ? ['axisQuantitative']\n          : scaleType === 'time' || scaleType === 'utc'\n            ? ['axisTemporal']\n            : [];\n\n  const axisChannel = channel === 'x' ? 'axisX' : 'axisY';\n  const axisOrient = isSignalRef(orient) ? 'axisOrient' : `axis${titleCase(orient)}`; // axisTop, axisBottom, ...\n\n  const vlOnlyConfigTypes = [\n    // technically Vega does have axisBand, but if we make another separation here,\n    // it will further introduce complexity in the code\n    ...typeBasedConfigTypes,\n    ...typeBasedConfigTypes.map(c => axisChannel + c.substr(4))\n  ];\n\n  const vgConfigTypes = ['axis', axisOrient, axisChannel];\n\n  return {\n    vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config, channel, orient),\n    vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config, channel, orient),\n    axisConfigStyle: getAxisConfigStyle([...vgConfigTypes, ...vlOnlyConfigTypes], config)\n  };\n}\n\nexport function getAxisConfigStyle(axisConfigTypes: string[], config: Config) {\n  const toMerge = [{}];\n  for (const configType of axisConfigTypes) {\n    // TODO: add special casing to add conditional value based on orient signal\n    let style = (config as any)[configType]?.style;\n    if (style) {\n      style = array(style);\n      for (const s of style) {\n        toMerge.push(config.style[s]);\n      }\n    }\n  }\n  return Object.assign.apply(null, toMerge);\n}\nexport function getAxisConfig(\n  property: keyof AxisConfig<SignalRef>,\n  styleConfigIndex: StyleConfigIndex<SignalRef>,\n  style: string | string[],\n  axisConfigs: Partial<AxisConfigs> = {}\n): {configFrom?: string; configValue?: any} {\n  const styleConfig = getStyleConfig(property, style, styleConfigIndex);\n\n  if (styleConfig !== undefined) {\n    return {\n      configFrom: 'style',\n      configValue: styleConfig\n    };\n  }\n\n  for (const configFrom of ['vlOnlyAxisConfig', 'vgAxisConfig', 'axisConfigStyle'] as const) {\n    if (axisConfigs[configFrom]?.[property] !== undefined) {\n      return {configFrom, configValue: axisConfigs[configFrom][property]};\n    }\n  }\n  return {};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}