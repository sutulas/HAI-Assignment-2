{"ast":null,"code":"import { LEGEND_SCALE_CHANNELS } from '../../legend';\nimport { keys, replaceAll, stringify, vals } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeLegendComponent } from './parse';\nfunction setLegendEncode(legend, part, vgProp, vgRef) {\n  var _a, _b;\n  legend.encode ?? (legend.encode = {});\n  (_a = legend.encode)[part] ?? (_a[part] = {});\n  (_b = legend.encode[part]).update ?? (_b.update = {});\n  // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n  legend.encode[part].update[vgProp] = vgRef;\n}\nexport function assembleLegends(model) {\n  const legendComponentIndex = model.component.legends;\n  const legendByDomain = {};\n  for (const channel of keys(legendComponentIndex)) {\n    const scaleComponent = model.getScaleComponent(channel);\n    const domainHash = stringify(scaleComponent.get('domains'));\n    if (legendByDomain[domainHash]) {\n      for (const mergedLegendComponent of legendByDomain[domainHash]) {\n        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);\n        if (!merged) {\n          // If cannot merge, need to add this legend separately\n          legendByDomain[domainHash].push(legendComponentIndex[channel]);\n        }\n      }\n    } else {\n      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];\n    }\n  }\n  const legends = vals(legendByDomain).flat().map(l => assembleLegend(l, model.config)).filter(l => l !== undefined);\n  return legends;\n}\nexport function assembleLegend(legendCmpt, config) {\n  const {\n    disable,\n    labelExpr,\n    selections,\n    ...legend\n  } = legendCmpt.combine();\n  if (disable) {\n    return undefined;\n  }\n  if (config.aria === false && legend.aria == undefined) {\n    legend.aria = false;\n  }\n  if (legend.encode?.symbols) {\n    const out = legend.encode.symbols.update;\n    if (out.fill && out.fill['value'] !== 'transparent' && !out.stroke && !legend.stroke) {\n      // For non color channel's legend, we need to override symbol stroke config from Vega config if stroke channel is not used.\n      out.stroke = {\n        value: 'transparent'\n      };\n    }\n    // Remove properties that the legend is encoding.\n    for (const property of LEGEND_SCALE_CHANNELS) {\n      if (legend[property]) {\n        delete out[property];\n      }\n    }\n  }\n  if (!legend.title) {\n    // title schema doesn't include null, ''\n    delete legend.title;\n  }\n  if (labelExpr !== undefined) {\n    let expr = labelExpr;\n    if (legend.encode?.labels?.update && isSignalRef(legend.encode.labels.update.text)) {\n      expr = replaceAll(labelExpr, 'datum.label', legend.encode.labels.update.text.signal);\n    }\n    setLegendEncode(legend, 'labels', 'text', {\n      signal: expr\n    });\n  }\n  return legend;\n}","map":{"version":3,"names":["LEGEND_SCALE_CHANNELS","keys","replaceAll","stringify","vals","isSignalRef","mergeLegendComponent","setLegendEncode","legend","part","vgProp","vgRef","encode","_a","_b","update","assembleLegends","model","legendComponentIndex","component","legends","legendByDomain","channel","scaleComponent","getScaleComponent","domainHash","get","mergedLegendComponent","merged","push","clone","flat","map","l","assembleLegend","config","filter","undefined","legendCmpt","disable","labelExpr","selections","combine","aria","symbols","out","fill","stroke","value","property","title","expr","labels","text","signal"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\legend\\assemble.ts"],"sourcesContent":["import {Legend as VgLegend, LegendEncode} from 'vega';\nimport {Config} from '../../config';\nimport {LEGEND_SCALE_CHANNELS} from '../../legend';\nimport {keys, replaceAll, stringify, vals} from '../../util';\nimport {isSignalRef, VgEncodeChannel, VgValueRef} from '../../vega.schema';\nimport {Model} from '../model';\nimport {LegendComponent} from './component';\nimport {mergeLegendComponent} from './parse';\n\nfunction setLegendEncode(\n  legend: VgLegend,\n  part: keyof LegendEncode,\n  vgProp: VgEncodeChannel,\n  vgRef: VgValueRef | VgValueRef[]\n) {\n  legend.encode ??= {};\n  legend.encode[part] ??= {};\n  legend.encode[part].update ??= {};\n  // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n  (legend.encode[part].update[vgProp] as any) = vgRef;\n}\n\nexport function assembleLegends(model: Model): VgLegend[] {\n  const legendComponentIndex = model.component.legends;\n  const legendByDomain: Record<string, LegendComponent[]> = {};\n\n  for (const channel of keys(legendComponentIndex)) {\n    const scaleComponent = model.getScaleComponent(channel);\n    const domainHash = stringify(scaleComponent.get('domains'));\n    if (legendByDomain[domainHash]) {\n      for (const mergedLegendComponent of legendByDomain[domainHash]) {\n        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);\n        if (!merged) {\n          // If cannot merge, need to add this legend separately\n          legendByDomain[domainHash].push(legendComponentIndex[channel]);\n        }\n      }\n    } else {\n      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];\n    }\n  }\n\n  const legends = vals(legendByDomain)\n    .flat()\n    .map(l => assembleLegend(l, model.config))\n    .filter(l => l !== undefined);\n\n  return legends;\n}\n\nexport function assembleLegend(legendCmpt: LegendComponent, config: Config) {\n  const {disable, labelExpr, selections, ...legend} = legendCmpt.combine();\n\n  if (disable) {\n    return undefined;\n  }\n\n  if (config.aria === false && legend.aria == undefined) {\n    legend.aria = false;\n  }\n\n  if (legend.encode?.symbols) {\n    const out = legend.encode.symbols.update;\n    if (out.fill && (out.fill as any)['value'] !== 'transparent' && !out.stroke && !legend.stroke) {\n      // For non color channel's legend, we need to override symbol stroke config from Vega config if stroke channel is not used.\n      out.stroke = {value: 'transparent'};\n    }\n\n    // Remove properties that the legend is encoding.\n    for (const property of LEGEND_SCALE_CHANNELS) {\n      if (legend[property]) {\n        delete out[property];\n      }\n    }\n  }\n\n  if (!legend.title) {\n    // title schema doesn't include null, ''\n    delete legend.title;\n  }\n\n  if (labelExpr !== undefined) {\n    let expr = labelExpr;\n    if (legend.encode?.labels?.update && isSignalRef(legend.encode.labels.update.text)) {\n      expr = replaceAll(labelExpr, 'datum.label', legend.encode.labels.update.text.signal);\n    }\n    setLegendEncode(legend, 'labels', 'text', {signal: expr});\n  }\n\n  return legend;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}