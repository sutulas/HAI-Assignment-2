{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isConditionalAxisValue } from '../axis';\nimport { GEOPOSITION_CHANNELS, NONPOSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, SCALE_CHANNELS, supportLegend, X, Y } from '../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldOrDatumDef, isTypedFieldDef } from '../channeldef';\nimport { isGraticuleGenerator } from '../data';\nimport * as vlEncoding from '../encoding';\nimport { initEncoding } from '../encoding';\nimport { replaceExprRef } from '../expr';\nimport { GEOSHAPE, isMarkDef } from '../mark';\nimport { isSelectionParameter } from '../selection';\nimport { isFrameMixins } from '../spec/base';\nimport { stack } from '../stack';\nimport { keys } from '../util';\nimport { assembleAxisSignals } from './axis/assemble';\nimport { parseUnitAxes } from './axis/parse';\nimport { signalOrValueRefWithCondition, signalRefOrValue } from './common';\nimport { parseData } from './data/parse';\nimport { assembleLayoutSignals } from './layoutsize/assemble';\nimport { initLayoutSize } from './layoutsize/init';\nimport { parseUnitLayoutSize } from './layoutsize/parse';\nimport { defaultFilled, initMarkdef } from './mark/init';\nimport { parseMarkGroups } from './mark/mark';\nimport { isLayerModel, ModelWithField } from './model';\nimport { assembleTopLevelSignals, assembleUnitSelectionData, assembleUnitSelectionMarks, assembleUnitSelectionSignals } from './selection/assemble';\nimport { parseUnitSelection } from './selection/parse';\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\nexport class UnitModel extends ModelWithField {\n  constructor(spec, parent, parentGivenName) {\n    let parentGivenSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let config = arguments.length > 4 ? arguments[4] : undefined;\n    super(spec, 'unit', parent, parentGivenName, config, undefined, isFrameMixins(spec) ? spec.view : undefined);\n    this.specifiedScales = {};\n    this.specifiedAxes = {};\n    this.specifiedLegends = {};\n    this.specifiedProjection = {};\n    this.selection = [];\n    this.children = [];\n    const markDef = isMarkDef(spec.mark) ? {\n      ...spec.mark\n    } : {\n      type: spec.mark\n    };\n    const mark = markDef.type;\n    // Need to init filled before other mark properties because encoding depends on filled but other mark properties depend on types inside encoding\n    if (markDef.filled === undefined) {\n      markDef.filled = defaultFilled(markDef, config, {\n        graticule: spec.data && isGraticuleGenerator(spec.data)\n      });\n    }\n    const encoding = this.encoding = initEncoding(spec.encoding || {}, mark, markDef.filled, config);\n    this.markDef = initMarkdef(markDef, encoding, config);\n    this.size = initLayoutSize({\n      encoding,\n      size: isFrameMixins(spec) ? {\n        ...parentGivenSize,\n        ...(spec.width ? {\n          width: spec.width\n        } : {}),\n        ...(spec.height ? {\n          height: spec.height\n        } : {})\n      } : parentGivenSize\n    });\n    // calculate stack properties\n    this.stack = stack(this.markDef, encoding);\n    this.specifiedScales = this.initScales(mark, encoding);\n    this.specifiedAxes = this.initAxes(encoding);\n    this.specifiedLegends = this.initLegends(encoding);\n    this.specifiedProjection = spec.projection;\n    // Selections will be initialized upon parse.\n    this.selection = (spec.params ?? []).filter(p => isSelectionParameter(p));\n  }\n  get hasProjection() {\n    const {\n      encoding\n    } = this;\n    const isGeoShapeMark = this.mark === GEOSHAPE;\n    const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(channel => isFieldOrDatumDef(encoding[channel]));\n    return isGeoShapeMark || hasGeoPosition;\n  }\n  /**\n   * Return specified Vega-Lite scale domain for a particular channel\n   * @param channel\n   */\n  scaleDomain(channel) {\n    const scale = this.specifiedScales[channel];\n    return scale ? scale.domain : undefined;\n  }\n  axis(channel) {\n    return this.specifiedAxes[channel];\n  }\n  legend(channel) {\n    return this.specifiedLegends[channel];\n  }\n  initScales(mark, encoding) {\n    return SCALE_CHANNELS.reduce((scales, channel) => {\n      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n      if (fieldOrDatumDef) {\n        scales[channel] = this.initScale(fieldOrDatumDef.scale ?? {});\n      }\n      return scales;\n    }, {});\n  }\n  initScale(scale) {\n    const {\n      domain,\n      range\n    } = scale;\n    // TODO: we could simplify this function if we had a recursive replace function\n    const scaleInternal = replaceExprRef(scale);\n    if (isArray(domain)) {\n      scaleInternal.domain = domain.map(signalRefOrValue);\n    }\n    if (isArray(range)) {\n      scaleInternal.range = range.map(signalRefOrValue);\n    }\n    return scaleInternal;\n  }\n  initAxes(encoding) {\n    return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {\n      // Position Axis\n      // TODO: handle ConditionFieldDef\n      const channelDef = encoding[channel];\n      if (isFieldOrDatumDef(channelDef) || channel === X && isFieldOrDatumDef(encoding.x2) || channel === Y && isFieldOrDatumDef(encoding.y2)) {\n        const axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : undefined;\n        _axis[channel] = axisSpec ? this.initAxis({\n          ...axisSpec\n        }) // convert truthy value to object\n        : axisSpec;\n      }\n      return _axis;\n    }, {});\n  }\n  initAxis(axis) {\n    const props = keys(axis);\n    const axisInternal = {};\n    for (const prop of props) {\n      const val = axis[prop];\n      axisInternal[prop] = isConditionalAxisValue(val) ? signalOrValueRefWithCondition(val) : signalRefOrValue(val);\n    }\n    return axisInternal;\n  }\n  initLegends(encoding) {\n    return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {\n      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n      if (fieldOrDatumDef && supportLegend(channel)) {\n        const legend = fieldOrDatumDef.legend;\n        _legend[channel] = legend ? replaceExprRef(legend) // convert truthy value to object\n        : legend;\n      }\n      return _legend;\n    }, {});\n  }\n  parseData() {\n    this.component.data = parseData(this);\n  }\n  parseLayoutSize() {\n    parseUnitLayoutSize(this);\n  }\n  parseSelections() {\n    this.component.selection = parseUnitSelection(this, this.selection);\n  }\n  parseMarkGroup() {\n    this.component.mark = parseMarkGroups(this);\n  }\n  parseAxesAndHeaders() {\n    this.component.axes = parseUnitAxes(this);\n  }\n  assembleSelectionTopLevelSignals(signals) {\n    return assembleTopLevelSignals(this, signals);\n  }\n  assembleSignals() {\n    return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];\n  }\n  assembleSelectionData(data) {\n    return assembleUnitSelectionData(this, data);\n  }\n  assembleLayout() {\n    return null;\n  }\n  assembleLayoutSignals() {\n    return assembleLayoutSignals(this);\n  }\n  assembleMarks() {\n    let marks = this.component.mark ?? [];\n    // If this unit is part of a layer, selections should augment\n    // all in concert rather than each unit individually. This\n    // ensures correct interleaving of clipping and brushed marks.\n    if (!this.parent || !isLayerModel(this.parent)) {\n      marks = assembleUnitSelectionMarks(this, marks);\n    }\n    return marks.map(this.correctDataNames);\n  }\n  assembleGroupStyle() {\n    const {\n      style\n    } = this.view || {};\n    if (style !== undefined) {\n      return style;\n    }\n    if (this.encoding.x || this.encoding.y) {\n      return 'cell';\n    } else {\n      return 'view';\n    }\n  }\n  getMapping() {\n    return this.encoding;\n  }\n  get mark() {\n    return this.markDef.type;\n  }\n  channelHasField(channel) {\n    return vlEncoding.channelHasField(this.encoding, channel);\n  }\n  fieldDef(channel) {\n    const channelDef = this.encoding[channel];\n    return getFieldDef(channelDef);\n  }\n  typedFieldDef(channel) {\n    const fieldDef = this.fieldDef(channel);\n    if (isTypedFieldDef(fieldDef)) {\n      return fieldDef;\n    }\n    return null;\n  }\n}","map":{"version":3,"names":["isArray","isConditionalAxisValue","GEOPOSITION_CHANNELS","NONPOSITION_SCALE_CHANNELS","POSITION_SCALE_CHANNELS","SCALE_CHANNELS","supportLegend","X","Y","getFieldDef","getFieldOrDatumDef","isFieldOrDatumDef","isTypedFieldDef","isGraticuleGenerator","vlEncoding","initEncoding","replaceExprRef","GEOSHAPE","isMarkDef","isSelectionParameter","isFrameMixins","stack","keys","assembleAxisSignals","parseUnitAxes","signalOrValueRefWithCondition","signalRefOrValue","parseData","assembleLayoutSignals","initLayoutSize","parseUnitLayoutSize","defaultFilled","initMarkdef","parseMarkGroups","isLayerModel","ModelWithField","assembleTopLevelSignals","assembleUnitSelectionData","assembleUnitSelectionMarks","assembleUnitSelectionSignals","parseUnitSelection","UnitModel","constructor","spec","parent","parentGivenName","parentGivenSize","arguments","length","undefined","config","view","specifiedScales","specifiedAxes","specifiedLegends","specifiedProjection","selection","children","markDef","mark","type","filled","graticule","data","encoding","size","width","height","initScales","initAxes","initLegends","projection","params","filter","p","hasProjection","isGeoShapeMark","hasGeoPosition","some","channel","scaleDomain","scale","domain","axis","legend","reduce","scales","fieldOrDatumDef","initScale","range","scaleInternal","map","_axis","channelDef","x2","y2","axisSpec","initAxis","props","axisInternal","prop","val","_legend","component","parseLayoutSize","parseSelections","parseMarkGroup","parseAxesAndHeaders","axes","assembleSelectionTopLevelSignals","signals","assembleSignals","assembleSelectionData","assembleLayout","assembleMarks","marks","correctDataNames","assembleGroupStyle","style","x","y","getMapping","channelHasField","fieldDef","typedFieldDef"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\unit.ts"],"sourcesContent":["import {NewSignal, SignalRef} from 'vega';\nimport {isArray} from 'vega-util';\nimport {Axis, AxisInternal, isConditionalAxisValue} from '../axis';\nimport {\n  Channel,\n  GEOPOSITION_CHANNELS,\n  NonPositionScaleChannel,\n  NONPOSITION_SCALE_CHANNELS,\n  PositionChannel,\n  POSITION_SCALE_CHANNELS,\n  ScaleChannel,\n  SCALE_CHANNELS,\n  SingleDefChannel,\n  supportLegend,\n  X,\n  Y\n} from '../channel';\nimport {\n  getFieldDef,\n  getFieldOrDatumDef,\n  isFieldOrDatumDef,\n  isTypedFieldDef,\n  MarkPropFieldOrDatumDef,\n  PositionFieldDef\n} from '../channeldef';\nimport {Config} from '../config';\nimport {isGraticuleGenerator} from '../data';\nimport * as vlEncoding from '../encoding';\nimport {Encoding, initEncoding} from '../encoding';\nimport {ExprRef, replaceExprRef} from '../expr';\nimport {LegendInternal} from '../legend';\nimport {GEOSHAPE, isMarkDef, Mark, MarkDef} from '../mark';\nimport {Projection} from '../projection';\nimport {Domain, Scale} from '../scale';\nimport {isSelectionParameter, SelectionParameter} from '../selection';\nimport {LayoutSizeMixins, NormalizedUnitSpec} from '../spec';\nimport {isFrameMixins} from '../spec/base';\nimport {stack, StackProperties} from '../stack';\nimport {keys} from '../util';\nimport {VgData, VgLayout} from '../vega.schema';\nimport {assembleAxisSignals} from './axis/assemble';\nimport {AxisInternalIndex} from './axis/component';\nimport {parseUnitAxes} from './axis/parse';\nimport {signalOrValueRefWithCondition, signalRefOrValue} from './common';\nimport {parseData} from './data/parse';\nimport {assembleLayoutSignals} from './layoutsize/assemble';\nimport {initLayoutSize} from './layoutsize/init';\nimport {parseUnitLayoutSize} from './layoutsize/parse';\nimport {LegendInternalIndex} from './legend/component';\nimport {defaultFilled, initMarkdef} from './mark/init';\nimport {parseMarkGroups} from './mark/mark';\nimport {isLayerModel, Model, ModelWithField} from './model';\nimport {ScaleIndex} from './scale/component';\nimport {\n  assembleTopLevelSignals,\n  assembleUnitSelectionData,\n  assembleUnitSelectionMarks,\n  assembleUnitSelectionSignals\n} from './selection/assemble';\nimport {parseUnitSelection} from './selection/parse';\n\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\nexport class UnitModel extends ModelWithField {\n  public readonly markDef: MarkDef<Mark, SignalRef>;\n  public readonly encoding: Encoding<string>;\n\n  public readonly specifiedScales: ScaleIndex = {};\n\n  public readonly stack: StackProperties;\n\n  protected specifiedAxes: AxisInternalIndex = {};\n\n  protected specifiedLegends: LegendInternalIndex = {};\n\n  public specifiedProjection: Projection<ExprRef | SignalRef> = {};\n\n  public readonly selection: SelectionParameter[] = [];\n  public children: Model[] = [];\n\n  constructor(\n    spec: NormalizedUnitSpec,\n    parent: Model,\n    parentGivenName: string,\n    parentGivenSize: LayoutSizeMixins = {},\n    config: Config<SignalRef>\n  ) {\n    super(spec, 'unit', parent, parentGivenName, config, undefined, isFrameMixins(spec) ? spec.view : undefined);\n\n    const markDef = isMarkDef(spec.mark) ? {...spec.mark} : {type: spec.mark};\n    const mark = markDef.type;\n\n    // Need to init filled before other mark properties because encoding depends on filled but other mark properties depend on types inside encoding\n    if (markDef.filled === undefined) {\n      markDef.filled = defaultFilled(markDef, config, {\n        graticule: spec.data && isGraticuleGenerator(spec.data)\n      });\n    }\n\n    const encoding = (this.encoding = initEncoding(spec.encoding || {}, mark, markDef.filled, config));\n    this.markDef = initMarkdef(markDef, encoding, config);\n\n    this.size = initLayoutSize({\n      encoding,\n      size: isFrameMixins(spec)\n        ? {\n            ...parentGivenSize,\n            ...(spec.width ? {width: spec.width} : {}),\n            ...(spec.height ? {height: spec.height} : {})\n          }\n        : parentGivenSize\n    });\n\n    // calculate stack properties\n    this.stack = stack(this.markDef, encoding);\n    this.specifiedScales = this.initScales(mark, encoding);\n\n    this.specifiedAxes = this.initAxes(encoding);\n    this.specifiedLegends = this.initLegends(encoding);\n    this.specifiedProjection = spec.projection;\n\n    // Selections will be initialized upon parse.\n    this.selection = (spec.params ?? []).filter(p => isSelectionParameter(p)) as SelectionParameter[];\n  }\n\n  public get hasProjection(): boolean {\n    const {encoding} = this;\n    const isGeoShapeMark = this.mark === GEOSHAPE;\n    const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(channel => isFieldOrDatumDef(encoding[channel]));\n    return isGeoShapeMark || hasGeoPosition;\n  }\n\n  /**\n   * Return specified Vega-Lite scale domain for a particular channel\n   * @param channel\n   */\n  public scaleDomain(channel: ScaleChannel): Domain {\n    const scale = this.specifiedScales[channel];\n    return scale ? scale.domain : undefined;\n  }\n\n  public axis(channel: PositionChannel): AxisInternal {\n    return (this.specifiedAxes as any)[channel];\n  }\n\n  public legend(channel: NonPositionScaleChannel): LegendInternal {\n    return this.specifiedLegends[channel];\n  }\n\n  private initScales(mark: Mark, encoding: Encoding<string>): ScaleIndex {\n    return SCALE_CHANNELS.reduce((scales, channel) => {\n      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) as\n        | PositionFieldDef<string>\n        | MarkPropFieldOrDatumDef<string>;\n      if (fieldOrDatumDef) {\n        scales[channel] = this.initScale(fieldOrDatumDef.scale ?? {});\n      }\n      return scales;\n    }, {} as ScaleIndex);\n  }\n\n  private initScale(scale: Scale<ExprRef | SignalRef>): Scale<SignalRef> {\n    const {domain, range} = scale;\n    // TODO: we could simplify this function if we had a recursive replace function\n    const scaleInternal = replaceExprRef(scale);\n    if (isArray(domain)) {\n      scaleInternal.domain = domain.map(signalRefOrValue);\n    }\n    if (isArray(range)) {\n      scaleInternal.range = range.map(signalRefOrValue);\n    }\n    return scaleInternal as Scale<SignalRef>;\n  }\n\n  private initAxes(encoding: Encoding<string>): AxisInternalIndex {\n    return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {\n      // Position Axis\n\n      // TODO: handle ConditionFieldDef\n      const channelDef = encoding[channel];\n      if (\n        isFieldOrDatumDef(channelDef) ||\n        (channel === X && isFieldOrDatumDef(encoding.x2)) ||\n        (channel === Y && isFieldOrDatumDef(encoding.y2))\n      ) {\n        const axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : undefined;\n\n        _axis[channel] = axisSpec\n          ? this.initAxis({...axisSpec}) // convert truthy value to object\n          : axisSpec;\n      }\n      return _axis;\n    }, {} as any);\n  }\n\n  private initAxis(axis: Axis<ExprRef | SignalRef>): Axis<SignalRef> {\n    const props = keys(axis);\n    const axisInternal: any = {};\n    for (const prop of props) {\n      const val = axis[prop];\n      axisInternal[prop] = isConditionalAxisValue<any, ExprRef | SignalRef>(val)\n        ? signalOrValueRefWithCondition<any>(val)\n        : signalRefOrValue(val);\n    }\n    return axisInternal;\n  }\n\n  private initLegends(encoding: Encoding<string>): LegendInternalIndex {\n    return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {\n      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) as MarkPropFieldOrDatumDef<string>;\n\n      if (fieldOrDatumDef && supportLegend(channel)) {\n        const legend = fieldOrDatumDef.legend;\n        _legend[channel] = legend\n          ? replaceExprRef(legend) // convert truthy value to object\n          : legend;\n      }\n\n      return _legend;\n    }, {} as any);\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n  }\n\n  public parseLayoutSize() {\n    parseUnitLayoutSize(this);\n  }\n\n  public parseSelections() {\n    this.component.selection = parseUnitSelection(this, this.selection);\n  }\n\n  public parseMarkGroup() {\n    this.component.mark = parseMarkGroups(this);\n  }\n\n  public parseAxesAndHeaders() {\n    this.component.axes = parseUnitAxes(this);\n  }\n\n  public assembleSelectionTopLevelSignals(signals: any[]): NewSignal[] {\n    return assembleTopLevelSignals(this, signals);\n  }\n\n  public assembleSignals(): NewSignal[] {\n    return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];\n  }\n\n  public assembleSelectionData(data: readonly VgData[]): VgData[] {\n    return assembleUnitSelectionData(this, data);\n  }\n\n  public assembleLayout(): VgLayout {\n    return null;\n  }\n\n  public assembleLayoutSignals(): NewSignal[] {\n    return assembleLayoutSignals(this);\n  }\n\n  public assembleMarks() {\n    let marks = this.component.mark ?? [];\n\n    // If this unit is part of a layer, selections should augment\n    // all in concert rather than each unit individually. This\n    // ensures correct interleaving of clipping and brushed marks.\n    if (!this.parent || !isLayerModel(this.parent)) {\n      marks = assembleUnitSelectionMarks(this, marks);\n    }\n\n    return marks.map(this.correctDataNames);\n  }\n  public assembleGroupStyle(): string | string[] {\n    const {style} = this.view || {};\n    if (style !== undefined) {\n      return style;\n    }\n    if (this.encoding.x || this.encoding.y) {\n      return 'cell';\n    } else {\n      return 'view';\n    }\n  }\n\n  protected getMapping() {\n    return this.encoding;\n  }\n\n  public get mark(): Mark {\n    return this.markDef.type;\n  }\n\n  public channelHasField(channel: Channel) {\n    return vlEncoding.channelHasField(this.encoding, channel);\n  }\n\n  public fieldDef(channel: SingleDefChannel) {\n    const channelDef = (this.encoding as any)[channel];\n    return getFieldDef<string>(channelDef);\n  }\n\n  public typedFieldDef(channel: SingleDefChannel) {\n    const fieldDef = this.fieldDef(channel);\n    if (isTypedFieldDef(fieldDef)) {\n      return fieldDef;\n    }\n    return null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}