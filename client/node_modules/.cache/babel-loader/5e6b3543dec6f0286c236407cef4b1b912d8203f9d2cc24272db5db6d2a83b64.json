{"ast":null,"code":"import { getBandPosition, vgField } from '../../channeldef';\nimport { getDateTimePartAndStep, getSmallestTimeUnitPart, getTimeUnitParts, isBinnedTimeUnit, normalizeTimeUnit } from '../../timeunit';\nimport { duplicate, entries, hash, isEmpty, replacePathInField, vals } from '../../util';\nimport { isUnitModel } from '../model';\nimport { DataFlowNode } from './dataflow';\nimport { isRectBasedMark } from '../../mark';\nimport { isXorY } from '../../channel';\nfunction isTimeUnitTransformComponent(timeUnitComponent) {\n  return timeUnitComponent.as !== undefined;\n}\nfunction offsetAs(field) {\n  return `${field}_end`;\n}\nexport class TimeUnitNode extends DataFlowNode {\n  clone() {\n    return new TimeUnitNode(null, duplicate(this.timeUnits));\n  }\n  constructor(parent, timeUnits) {\n    super(parent);\n    this.timeUnits = timeUnits;\n  }\n  static makeFromEncoding(parent, model) {\n    const formula = model.reduceFieldDef((timeUnitComponent, fieldDef, channel) => {\n      const {\n        field,\n        timeUnit\n      } = fieldDef;\n      if (timeUnit) {\n        let component;\n        if (isBinnedTimeUnit(timeUnit)) {\n          // For binned time unit, only produce end if the mark is a rect-based mark (rect, bar, image, arc), which needs \"range\".\n          if (isUnitModel(model)) {\n            const {\n              mark,\n              markDef,\n              config\n            } = model;\n            const bandPosition = getBandPosition({\n              fieldDef,\n              markDef,\n              config\n            });\n            if (isRectBasedMark(mark) || !!bandPosition) {\n              component = {\n                timeUnit: normalizeTimeUnit(timeUnit),\n                field\n              };\n            }\n          }\n        } else {\n          component = {\n            as: vgField(fieldDef, {\n              forAs: true\n            }),\n            field,\n            timeUnit\n          };\n        }\n        if (isUnitModel(model)) {\n          const {\n            mark,\n            markDef,\n            config\n          } = model;\n          const bandPosition = getBandPosition({\n            fieldDef,\n            markDef,\n            config\n          });\n          if (isRectBasedMark(mark) && isXorY(channel) && bandPosition !== 0.5) {\n            component.rectBandPosition = bandPosition;\n          }\n        }\n        if (component) {\n          timeUnitComponent[hash(component)] = component;\n        }\n      }\n      return timeUnitComponent;\n    }, {});\n    if (isEmpty(formula)) {\n      return null;\n    }\n    return new TimeUnitNode(parent, formula);\n  }\n  static makeFromTransform(parent, t) {\n    const {\n      timeUnit,\n      ...other\n    } = {\n      ...t\n    };\n    const normalizedTimeUnit = normalizeTimeUnit(timeUnit);\n    const component = {\n      ...other,\n      timeUnit: normalizedTimeUnit\n    };\n    return new TimeUnitNode(parent, {\n      [hash(component)]: component\n    });\n  }\n  /**\n   * Merge together TimeUnitNodes assigning the children of `other` to `this`\n   * and removing `other`.\n   */\n  merge(other) {\n    this.timeUnits = {\n      ...this.timeUnits\n    };\n    // if the same hash happen twice, merge\n    for (const key in other.timeUnits) {\n      if (!this.timeUnits[key]) {\n        // copy if it's not a duplicate\n        this.timeUnits[key] = other.timeUnits[key];\n      }\n    }\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n    other.remove();\n  }\n  /**\n   * Remove time units coming from the other node.\n   */\n  removeFormulas(fields) {\n    const newFormula = {};\n    for (const [key, timeUnitComponent] of entries(this.timeUnits)) {\n      const fieldAs = isTimeUnitTransformComponent(timeUnitComponent) ? timeUnitComponent.as : `${timeUnitComponent.field}_end`;\n      if (!fields.has(fieldAs)) {\n        newFormula[key] = timeUnitComponent;\n      }\n    }\n    this.timeUnits = newFormula;\n  }\n  producedFields() {\n    return new Set(vals(this.timeUnits).map(f => {\n      return isTimeUnitTransformComponent(f) ? f.as : offsetAs(f.field);\n    }));\n  }\n  dependentFields() {\n    return new Set(vals(this.timeUnits).map(f => f.field));\n  }\n  hash() {\n    return `TimeUnit ${hash(this.timeUnits)}`;\n  }\n  assemble() {\n    const transforms = [];\n    for (const f of vals(this.timeUnits)) {\n      const {\n        rectBandPosition\n      } = f;\n      const normalizedTimeUnit = normalizeTimeUnit(f.timeUnit);\n      if (isTimeUnitTransformComponent(f)) {\n        const {\n          field,\n          as\n        } = f;\n        const {\n          unit,\n          utc,\n          ...params\n        } = normalizedTimeUnit;\n        const startEnd = [as, `${as}_end`];\n        transforms.push({\n          field: replacePathInField(field),\n          type: 'timeunit',\n          ...(unit ? {\n            units: getTimeUnitParts(unit)\n          } : {}),\n          ...(utc ? {\n            timezone: 'utc'\n          } : {}),\n          ...params,\n          as: startEnd\n        });\n        transforms.push(...offsetedRectFormulas(startEnd, rectBandPosition, normalizedTimeUnit));\n      } else if (f) {\n        const {\n          field: escapedField\n        } = f;\n        // since this is a expression, we want the unescaped field name\n        const field = escapedField.replaceAll('\\\\.', '.');\n        const expr = offsetExpr({\n          timeUnit: normalizedTimeUnit,\n          field\n        });\n        const endAs = offsetAs(field);\n        transforms.push({\n          type: 'formula',\n          expr,\n          as: endAs\n        });\n        transforms.push(...offsetedRectFormulas([field, endAs], rectBandPosition, normalizedTimeUnit));\n      }\n    }\n    return transforms;\n  }\n}\nexport const OFFSETTED_RECT_START_SUFFIX = 'offsetted_rect_start';\nexport const OFFSETTED_RECT_END_SUFFIX = 'offsetted_rect_end';\nfunction offsetExpr(_ref) {\n  let {\n    timeUnit,\n    field,\n    reverse\n  } = _ref;\n  const {\n    unit,\n    utc\n  } = timeUnit;\n  const smallestUnit = getSmallestTimeUnitPart(unit);\n  const {\n    part,\n    step\n  } = getDateTimePartAndStep(smallestUnit, timeUnit.step);\n  const offsetFn = utc ? 'utcOffset' : 'timeOffset';\n  const expr = `${offsetFn}('${part}', datum['${field}'], ${reverse ? -step : step})`;\n  return expr;\n}\nfunction offsetedRectFormulas(_ref2, rectBandPosition, timeUnit) {\n  let [startField, endField] = _ref2;\n  if (rectBandPosition !== undefined && rectBandPosition !== 0.5) {\n    const startExpr = `datum['${startField}']`;\n    const endExpr = `datum['${endField}']`;\n    return [{\n      type: 'formula',\n      expr: interpolateExpr([offsetExpr({\n        timeUnit,\n        field: startField,\n        reverse: true\n      }), startExpr], rectBandPosition + 0.5),\n      as: `${startField}_${OFFSETTED_RECT_START_SUFFIX}`\n    }, {\n      type: 'formula',\n      expr: interpolateExpr([startExpr, endExpr], rectBandPosition + 0.5),\n      as: `${startField}_${OFFSETTED_RECT_END_SUFFIX}`\n    }];\n  }\n  return [];\n}\nfunction interpolateExpr(_ref3, fraction) {\n  let [start, end] = _ref3;\n  return `${1 - fraction} * ${start} + ${fraction} * ${end}`;\n}","map":{"version":3,"names":["getBandPosition","vgField","getDateTimePartAndStep","getSmallestTimeUnitPart","getTimeUnitParts","isBinnedTimeUnit","normalizeTimeUnit","duplicate","entries","hash","isEmpty","replacePathInField","vals","isUnitModel","DataFlowNode","isRectBasedMark","isXorY","isTimeUnitTransformComponent","timeUnitComponent","as","undefined","offsetAs","field","TimeUnitNode","clone","timeUnits","constructor","parent","makeFromEncoding","model","formula","reduceFieldDef","fieldDef","channel","timeUnit","component","mark","markDef","config","bandPosition","forAs","rectBandPosition","makeFromTransform","t","other","normalizedTimeUnit","merge","key","child","children","removeChild","remove","removeFormulas","fields","newFormula","fieldAs","has","producedFields","Set","map","f","dependentFields","assemble","transforms","unit","utc","params","startEnd","push","type","units","timezone","offsetedRectFormulas","escapedField","replaceAll","expr","offsetExpr","endAs","OFFSETTED_RECT_START_SUFFIX","OFFSETTED_RECT_END_SUFFIX","_ref","reverse","smallestUnit","part","step","offsetFn","_ref2","startField","endField","startExpr","endExpr","interpolateExpr","_ref3","fraction","start","end"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\data\\timeunit.ts"],"sourcesContent":["import {TimeUnitTransform as VgTimeUnitTransform} from 'vega';\nimport {FormulaTransform as VgFormulaTransform} from 'vega';\nimport {FieldName, getBandPosition, vgField} from '../../channeldef';\nimport {\n  TimeUnitParams,\n  getDateTimePartAndStep,\n  getSmallestTimeUnitPart,\n  getTimeUnitParts,\n  isBinnedTimeUnit,\n  normalizeTimeUnit\n} from '../../timeunit';\nimport {TimeUnitTransform} from '../../transform';\nimport {Dict, duplicate, entries, hash, isEmpty, replacePathInField, vals} from '../../util';\nimport {ModelWithField, isUnitModel} from '../model';\nimport {DataFlowNode} from './dataflow';\nimport {isRectBasedMark} from '../../mark';\nimport {isXorY} from '../../channel';\n\nexport type TimeUnitComponent = (TimeUnitTransform | BinnedTimeUnitOffset) & {\n  rectBandPosition?: number;\n};\n\nexport interface BinnedTimeUnitOffset {\n  timeUnit: TimeUnitParams;\n  field: FieldName;\n}\n\nfunction isTimeUnitTransformComponent(timeUnitComponent: TimeUnitComponent): timeUnitComponent is TimeUnitTransform {\n  return (timeUnitComponent as TimeUnitTransform).as !== undefined;\n}\n\nfunction offsetAs(field: FieldName) {\n  return `${field}_end`;\n}\n\nexport class TimeUnitNode extends DataFlowNode {\n  public clone() {\n    return new TimeUnitNode(null, duplicate(this.timeUnits));\n  }\n\n  constructor(\n    parent: DataFlowNode,\n    private timeUnits: Dict<TimeUnitComponent>\n  ) {\n    super(parent);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: ModelWithField) {\n    const formula = model.reduceFieldDef((timeUnitComponent: TimeUnitComponent, fieldDef, channel) => {\n      const {field, timeUnit} = fieldDef;\n\n      if (timeUnit) {\n        let component: TimeUnitComponent | undefined;\n\n        if (isBinnedTimeUnit(timeUnit)) {\n          // For binned time unit, only produce end if the mark is a rect-based mark (rect, bar, image, arc), which needs \"range\".\n\n          if (isUnitModel(model)) {\n            const {mark, markDef, config} = model;\n            const bandPosition = getBandPosition({fieldDef, markDef, config});\n            if (isRectBasedMark(mark) || !!bandPosition) {\n              component = {\n                timeUnit: normalizeTimeUnit(timeUnit),\n                field\n              };\n            }\n          }\n        } else {\n          component = {\n            as: vgField(fieldDef, {forAs: true}),\n            field,\n            timeUnit\n          };\n        }\n\n        if (isUnitModel(model)) {\n          const {mark, markDef, config} = model;\n          const bandPosition = getBandPosition({fieldDef, markDef, config});\n          if (isRectBasedMark(mark) && isXorY(channel) && bandPosition !== 0.5) {\n            component.rectBandPosition = bandPosition;\n          }\n        }\n\n        if (component) {\n          (timeUnitComponent as any)[hash(component)] = component;\n        }\n      }\n      return timeUnitComponent;\n    }, {} as Dict<TimeUnitComponent>);\n\n    if (isEmpty(formula)) {\n      return null;\n    }\n\n    return new TimeUnitNode(parent, formula);\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, t: TimeUnitTransform) {\n    const {timeUnit, ...other} = {...t};\n\n    const normalizedTimeUnit = normalizeTimeUnit(timeUnit);\n\n    const component = {\n      ...other,\n      timeUnit: normalizedTimeUnit\n    };\n\n    return new TimeUnitNode(parent, {\n      [hash(component)]: component\n    });\n  }\n\n  /**\n   * Merge together TimeUnitNodes assigning the children of `other` to `this`\n   * and removing `other`.\n   */\n  public merge(other: TimeUnitNode) {\n    this.timeUnits = {...this.timeUnits};\n\n    // if the same hash happen twice, merge\n    for (const key in other.timeUnits) {\n      if (!this.timeUnits[key]) {\n        // copy if it's not a duplicate\n        this.timeUnits[key] = other.timeUnits[key];\n      }\n    }\n\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n\n    other.remove();\n  }\n\n  /**\n   * Remove time units coming from the other node.\n   */\n  public removeFormulas(fields: Set<string>) {\n    const newFormula: Dict<TimeUnitComponent> = {};\n\n    for (const [key, timeUnitComponent] of entries(this.timeUnits)) {\n      const fieldAs = isTimeUnitTransformComponent(timeUnitComponent)\n        ? timeUnitComponent.as\n        : `${timeUnitComponent.field}_end`;\n      if (!fields.has(fieldAs)) {\n        newFormula[key] = timeUnitComponent;\n      }\n    }\n\n    this.timeUnits = newFormula;\n  }\n\n  public producedFields() {\n    return new Set(\n      vals(this.timeUnits).map(f => {\n        return isTimeUnitTransformComponent(f) ? f.as : offsetAs(f.field);\n      })\n    );\n  }\n\n  public dependentFields() {\n    return new Set(vals(this.timeUnits).map(f => f.field));\n  }\n\n  public hash() {\n    return `TimeUnit ${hash(this.timeUnits)}`;\n  }\n\n  public assemble() {\n    const transforms: (VgTimeUnitTransform | VgFormulaTransform)[] = [];\n\n    for (const f of vals(this.timeUnits)) {\n      const {rectBandPosition} = f;\n      const normalizedTimeUnit = normalizeTimeUnit(f.timeUnit);\n\n      if (isTimeUnitTransformComponent(f)) {\n        const {field, as} = f;\n        const {unit, utc, ...params} = normalizedTimeUnit;\n\n        const startEnd: [string, string] = [as, `${as}_end`];\n\n        transforms.push({\n          field: replacePathInField(field),\n          type: 'timeunit',\n          ...(unit ? {units: getTimeUnitParts(unit)} : {}),\n          ...(utc ? {timezone: 'utc'} : {}),\n          ...params,\n          as: startEnd\n        });\n\n        transforms.push(...offsetedRectFormulas(startEnd, rectBandPosition, normalizedTimeUnit));\n      } else if (f) {\n        const {field: escapedField} = f;\n        // since this is a expression, we want the unescaped field name\n        const field = escapedField.replaceAll('\\\\.', '.');\n        const expr = offsetExpr({timeUnit: normalizedTimeUnit, field});\n        const endAs = offsetAs(field);\n        transforms.push({\n          type: 'formula',\n          expr,\n          as: endAs\n        });\n\n        transforms.push(...offsetedRectFormulas([field, endAs], rectBandPosition, normalizedTimeUnit));\n      }\n    }\n\n    return transforms;\n  }\n}\n\nexport const OFFSETTED_RECT_START_SUFFIX = 'offsetted_rect_start';\nexport const OFFSETTED_RECT_END_SUFFIX = 'offsetted_rect_end';\n\nfunction offsetExpr({timeUnit, field, reverse}: {timeUnit: TimeUnitParams; field: string; reverse?: boolean}) {\n  const {unit, utc} = timeUnit;\n  const smallestUnit = getSmallestTimeUnitPart(unit);\n  const {part, step} = getDateTimePartAndStep(smallestUnit, timeUnit.step);\n  const offsetFn = utc ? 'utcOffset' : 'timeOffset';\n  const expr = `${offsetFn}('${part}', datum['${field}'], ${reverse ? -step : step})`;\n  return expr;\n}\n\nfunction offsetedRectFormulas(\n  [startField, endField]: [string, string],\n  rectBandPosition: number | undefined,\n  timeUnit: TimeUnitParams\n): VgFormulaTransform[] {\n  if (rectBandPosition !== undefined && rectBandPosition !== 0.5) {\n    const startExpr = `datum['${startField}']`;\n    const endExpr = `datum['${endField}']`;\n    return [\n      {\n        type: 'formula',\n        expr: interpolateExpr(\n          [\n            offsetExpr({\n              timeUnit,\n              field: startField,\n              reverse: true\n            }),\n            startExpr\n          ],\n          rectBandPosition + 0.5\n        ),\n        as: `${startField}_${OFFSETTED_RECT_START_SUFFIX}`\n      },\n      {\n        type: 'formula',\n        expr: interpolateExpr([startExpr, endExpr], rectBandPosition + 0.5),\n        as: `${startField}_${OFFSETTED_RECT_END_SUFFIX}`\n      }\n    ];\n  }\n  return [];\n}\n\nfunction interpolateExpr([start, end]: [string, string], fraction: number) {\n  return `${1 - fraction} * ${start} + ${fraction} * ${end}`;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}