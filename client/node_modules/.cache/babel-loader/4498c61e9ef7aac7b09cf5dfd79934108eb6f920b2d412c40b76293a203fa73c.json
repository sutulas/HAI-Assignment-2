{"ast":null,"code":"import * as log from '../log';\nimport { deepEqual, duplicate, getFirstDefined, keys } from '../util';\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport class Split {\n  constructor() {\n    let explicit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let implicit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.explicit = explicit;\n    this.implicit = implicit;\n  }\n  clone() {\n    return new Split(duplicate(this.explicit), duplicate(this.implicit));\n  }\n  combine() {\n    return {\n      ...this.explicit,\n      // Explicit properties comes first\n      ...this.implicit\n    };\n  }\n  get(key) {\n    // Explicit has higher precedence\n    return getFirstDefined(this.explicit[key], this.implicit[key]);\n  }\n  getWithExplicit(key) {\n    // Explicit has higher precedence\n    if (this.explicit[key] !== undefined) {\n      return {\n        explicit: true,\n        value: this.explicit[key]\n      };\n    } else if (this.implicit[key] !== undefined) {\n      return {\n        explicit: false,\n        value: this.implicit[key]\n      };\n    }\n    return {\n      explicit: false,\n      value: undefined\n    };\n  }\n  setWithExplicit(key, _ref) {\n    let {\n      value,\n      explicit\n    } = _ref;\n    if (value !== undefined) {\n      this.set(key, value, explicit);\n    }\n  }\n  set(key, value, explicit) {\n    delete this[explicit ? 'implicit' : 'explicit'][key];\n    this[explicit ? 'explicit' : 'implicit'][key] = value;\n    return this;\n  }\n  copyKeyFromSplit(key, _ref2) {\n    let {\n      explicit,\n      implicit\n    } = _ref2;\n    // Explicit has higher precedence\n    if (explicit[key] !== undefined) {\n      this.set(key, explicit[key], true);\n    } else if (implicit[key] !== undefined) {\n      this.set(key, implicit[key], false);\n    }\n  }\n  copyKeyFromObject(key, s) {\n    // Explicit has higher precedence\n    if (s[key] !== undefined) {\n      this.set(key, s[key], true);\n    }\n  }\n  /**\n   * Merge split object into this split object. Properties from the other split\n   * overwrite properties from this split.\n   */\n  copyAll(other) {\n    for (const key of keys(other.combine())) {\n      const val = other.getWithExplicit(key);\n      this.setWithExplicit(key, val);\n    }\n  }\n}\nexport function makeExplicit(value) {\n  return {\n    explicit: true,\n    value\n  };\n}\nexport function makeImplicit(value) {\n  return {\n    explicit: false,\n    value\n  };\n}\nexport function tieBreakByComparing(compare) {\n  return (v1, v2, property, propertyOf) => {\n    const diff = compare(v1.value, v2.value);\n    if (diff > 0) {\n      return v1;\n    } else if (diff < 0) {\n      return v2;\n    }\n    return defaultTieBreaker(v1, v2, property, propertyOf);\n  };\n}\nexport function defaultTieBreaker(v1, v2, property, propertyOf) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n  }\n  // If equal score, prefer v1.\n  return v1;\n}\nexport function mergeValuesWithExplicit(v1, v2, property, propertyOf) {\n  let tieBreaker = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : defaultTieBreaker;\n  if (v1 === undefined || v1.value === undefined) {\n    // For first run\n    return v2;\n  }\n  if (v1.explicit && !v2.explicit) {\n    return v1;\n  } else if (v2.explicit && !v1.explicit) {\n    return v2;\n  } else if (deepEqual(v1.value, v2.value)) {\n    return v1;\n  } else {\n    return tieBreaker(v1, v2, property, propertyOf);\n  }\n}","map":{"version":3,"names":["log","deepEqual","duplicate","getFirstDefined","keys","Split","constructor","explicit","arguments","length","undefined","implicit","clone","combine","get","key","getWithExplicit","value","setWithExplicit","_ref","set","copyKeyFromSplit","_ref2","copyKeyFromObject","s","copyAll","other","val","makeExplicit","makeImplicit","tieBreakByComparing","compare","v1","v2","property","propertyOf","diff","defaultTieBreaker","warn","message","mergeConflictingProperty","mergeValuesWithExplicit","tieBreaker"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\split.ts"],"sourcesContent":["import * as log from '../log';\nimport {deepEqual, duplicate, getFirstDefined, keys} from '../util';\n\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport class Split<T extends object> {\n  constructor(\n    public readonly explicit: Partial<T> = {},\n    public readonly implicit: Partial<T> = {}\n  ) {}\n\n  public clone() {\n    return new Split(duplicate(this.explicit), duplicate(this.implicit));\n  }\n\n  public combine(): Partial<T> {\n    return {\n      ...this.explicit, // Explicit properties comes first\n      ...this.implicit\n    };\n  }\n\n  public get<K extends keyof T>(key: K): T[K] {\n    // Explicit has higher precedence\n    return getFirstDefined(this.explicit[key], this.implicit[key]);\n  }\n\n  public getWithExplicit<K extends keyof T>(key: K): Explicit<T[K]> {\n    // Explicit has higher precedence\n    if (this.explicit[key] !== undefined) {\n      return {explicit: true, value: this.explicit[key]};\n    } else if (this.implicit[key] !== undefined) {\n      return {explicit: false, value: this.implicit[key]};\n    }\n    return {explicit: false, value: undefined};\n  }\n\n  public setWithExplicit<K extends keyof T>(key: K, {value, explicit}: Explicit<T[K]>) {\n    if (value !== undefined) {\n      this.set(key, value, explicit);\n    }\n  }\n\n  public set<K extends keyof T>(key: K, value: T[K], explicit: boolean) {\n    delete this[explicit ? 'implicit' : 'explicit'][key];\n    this[explicit ? 'explicit' : 'implicit'][key] = value;\n    return this;\n  }\n\n  public copyKeyFromSplit<S extends T>(key: keyof T, {explicit, implicit}: Split<S>) {\n    // Explicit has higher precedence\n    if (explicit[key] !== undefined) {\n      this.set(key, explicit[key], true);\n    } else if (implicit[key] !== undefined) {\n      this.set(key, implicit[key], false);\n    }\n  }\n  public copyKeyFromObject<S extends T>(key: keyof T, s: Partial<S>) {\n    // Explicit has higher precedence\n    if (s[key] !== undefined) {\n      this.set(key, s[key], true);\n    }\n  }\n\n  /**\n   * Merge split object into this split object. Properties from the other split\n   * overwrite properties from this split.\n   */\n  public copyAll(other: Split<T>) {\n    for (const key of keys(other.combine())) {\n      const val = other.getWithExplicit(key);\n      this.setWithExplicit(key, val);\n    }\n  }\n}\n\nexport interface Explicit<T> {\n  explicit: boolean;\n  value: T;\n}\n\nexport function makeExplicit<T>(value: T): Explicit<T> {\n  return {\n    explicit: true,\n    value\n  };\n}\n\nexport function makeImplicit<T>(value: T): Explicit<T> {\n  return {\n    explicit: false,\n    value\n  };\n}\n\nexport type SplitParentProperty = 'scale' | 'axis' | 'legend' | '';\n\nexport function tieBreakByComparing<S, T>(compare: (v1: T, v2: T) => number) {\n  return (\n    v1: Explicit<T>,\n    v2: Explicit<T>,\n    property: keyof S | never,\n    propertyOf: SplitParentProperty\n  ): Explicit<T> => {\n    const diff = compare(v1.value, v2.value);\n    if (diff > 0) {\n      return v1;\n    } else if (diff < 0) {\n      return v2;\n    }\n    return defaultTieBreaker<S, T>(v1, v2, property, propertyOf);\n  };\n}\n\nexport function defaultTieBreaker<S, T>(\n  v1: Explicit<T>,\n  v2: Explicit<T>,\n  property: keyof S,\n  propertyOf: SplitParentProperty\n) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n  }\n  // If equal score, prefer v1.\n  return v1;\n}\n\nexport function mergeValuesWithExplicit<S, T>(\n  v1: Explicit<T>,\n  v2: Explicit<T>,\n  property: keyof S,\n  propertyOf: SplitParentProperty,\n  tieBreaker: (\n    v1: Explicit<T>,\n    v2: Explicit<T>,\n    property: keyof S,\n    propertyOf: string\n  ) => Explicit<T> = defaultTieBreaker\n) {\n  if (v1 === undefined || v1.value === undefined) {\n    // For first run\n    return v2;\n  }\n\n  if (v1.explicit && !v2.explicit) {\n    return v1;\n  } else if (v2.explicit && !v1.explicit) {\n    return v2;\n  } else if (deepEqual(v1.value, v2.value)) {\n    return v1;\n  } else {\n    return tieBreaker(v1, v2, property, propertyOf);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}