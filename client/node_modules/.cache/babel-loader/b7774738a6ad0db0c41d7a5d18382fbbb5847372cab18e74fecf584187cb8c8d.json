{"ast":null,"code":"import * as log from '../log';\nimport { isConcatSpec, isHConcatSpec, isVConcatSpec } from './concat';\nimport { isFacetSpec } from './facet';\nimport { isLayerSpec } from './layer';\nimport { isRepeatSpec } from './repeat';\nimport { isUnitSpec } from './unit';\nexport class SpecMapper {\n  map(spec, params) {\n    if (isFacetSpec(spec)) {\n      return this.mapFacet(spec, params);\n    } else if (isRepeatSpec(spec)) {\n      return this.mapRepeat(spec, params);\n    } else if (isHConcatSpec(spec)) {\n      return this.mapHConcat(spec, params);\n    } else if (isVConcatSpec(spec)) {\n      return this.mapVConcat(spec, params);\n    } else if (isConcatSpec(spec)) {\n      return this.mapConcat(spec, params);\n    } else {\n      return this.mapLayerOrUnit(spec, params);\n    }\n  }\n  mapLayerOrUnit(spec, params) {\n    if (isLayerSpec(spec)) {\n      return this.mapLayer(spec, params);\n    } else if (isUnitSpec(spec)) {\n      return this.mapUnit(spec, params);\n    }\n    throw new Error(log.message.invalidSpec(spec));\n  }\n  mapLayer(spec, params) {\n    return {\n      ...spec,\n      layer: spec.layer.map(subspec => this.mapLayerOrUnit(subspec, params))\n    };\n  }\n  mapHConcat(spec, params) {\n    return {\n      ...spec,\n      hconcat: spec.hconcat.map(subspec => this.map(subspec, params))\n    };\n  }\n  mapVConcat(spec, params) {\n    return {\n      ...spec,\n      vconcat: spec.vconcat.map(subspec => this.map(subspec, params))\n    };\n  }\n  mapConcat(spec, params) {\n    const {\n      concat,\n      ...rest\n    } = spec;\n    return {\n      ...rest,\n      concat: concat.map(subspec => this.map(subspec, params))\n    };\n  }\n  mapFacet(spec, params) {\n    return {\n      // as any is required here since TS cannot infer that FO may only be FieldName or Field, but not RepeatRef\n      ...spec,\n      // TODO: remove \"any\" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760\n      spec: this.map(spec.spec, params)\n    };\n  }\n  mapRepeat(spec, params) {\n    return {\n      ...spec,\n      // as any is required here since TS cannot infer that the output type satisfies the input type\n      spec: this.map(spec.spec, params)\n    };\n  }\n}","map":{"version":3,"names":["log","isConcatSpec","isHConcatSpec","isVConcatSpec","isFacetSpec","isLayerSpec","isRepeatSpec","isUnitSpec","SpecMapper","map","spec","params","mapFacet","mapRepeat","mapHConcat","mapVConcat","mapConcat","mapLayerOrUnit","mapLayer","mapUnit","Error","message","invalidSpec","layer","subspec","hconcat","vconcat","concat","rest"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\spec\\map.ts"],"sourcesContent":["import {GenericSpec} from '.';\nimport * as log from '../log';\nimport {Field, FieldName} from '../channeldef';\nimport {\n  GenericConcatSpec,\n  GenericHConcatSpec,\n  GenericVConcatSpec,\n  isConcatSpec,\n  isHConcatSpec,\n  isVConcatSpec\n} from './concat';\nimport {GenericFacetSpec, isFacetSpec} from './facet';\nimport {GenericLayerSpec, isLayerSpec} from './layer';\nimport {isRepeatSpec, RepeatSpec} from './repeat';\nimport {GenericUnitSpec, isUnitSpec, NormalizedUnitSpec} from './unit';\n\nexport abstract class SpecMapper<\n  P,\n  UI extends GenericUnitSpec<any, any>,\n  LI extends GenericLayerSpec<any> = GenericLayerSpec<UI>,\n  UO extends GenericUnitSpec<any, any> = NormalizedUnitSpec,\n  RO extends RepeatSpec = never,\n  FO extends Field = FieldName\n> {\n  public map(spec: GenericSpec<UI, LI, RepeatSpec, Field>, params: P): GenericSpec<UO, GenericLayerSpec<UO>, RO, FO> {\n    if (isFacetSpec(spec)) {\n      return this.mapFacet(spec, params);\n    } else if (isRepeatSpec(spec)) {\n      return this.mapRepeat(spec, params);\n    } else if (isHConcatSpec(spec)) {\n      return this.mapHConcat(spec, params);\n    } else if (isVConcatSpec(spec)) {\n      return this.mapVConcat(spec, params);\n    } else if (isConcatSpec(spec)) {\n      return this.mapConcat(spec, params);\n    } else {\n      return this.mapLayerOrUnit(spec, params);\n    }\n  }\n\n  public mapLayerOrUnit(spec: UI | LI, params: P): UO | GenericLayerSpec<UO> {\n    if (isLayerSpec(spec)) {\n      return this.mapLayer(spec, params);\n    } else if (isUnitSpec(spec)) {\n      return this.mapUnit(spec, params);\n    }\n    throw new Error(log.message.invalidSpec(spec));\n  }\n\n  public abstract mapUnit(spec: UI, params: P): UO | GenericLayerSpec<UO>;\n\n  protected mapLayer(spec: LI, params: P): GenericLayerSpec<UO> {\n    return {\n      ...spec,\n      layer: spec.layer.map(subspec => this.mapLayerOrUnit(subspec, params))\n    };\n  }\n\n  protected mapHConcat(\n    spec: GenericHConcatSpec<GenericSpec<UI, LI, RepeatSpec, Field>>,\n    params: P\n  ): GenericHConcatSpec<GenericSpec<UO, GenericLayerSpec<UO>, RO, FO>> {\n    return {\n      ...spec,\n      hconcat: spec.hconcat.map(subspec => this.map(subspec, params))\n    };\n  }\n\n  protected mapVConcat(\n    spec: GenericVConcatSpec<GenericSpec<UI, LI, RepeatSpec, Field>>,\n    params: P\n  ): GenericVConcatSpec<GenericSpec<UO, GenericLayerSpec<UO>, RO, FO>> {\n    return {\n      ...spec,\n      vconcat: spec.vconcat.map(subspec => this.map(subspec, params))\n    };\n  }\n\n  protected mapConcat(\n    spec: GenericConcatSpec<GenericSpec<UI, LI, RepeatSpec, Field>>,\n    params: P\n  ): GenericConcatSpec<GenericSpec<UO, GenericLayerSpec<UO>, RO, FO>> {\n    const {concat, ...rest} = spec;\n\n    return {\n      ...rest,\n      concat: concat.map(subspec => this.map(subspec, params))\n    };\n  }\n\n  protected mapFacet(spec: GenericFacetSpec<UI, LI, Field>, params: P): GenericFacetSpec<UO, GenericLayerSpec<UO>, FO> {\n    return {\n      // as any is required here since TS cannot infer that FO may only be FieldName or Field, but not RepeatRef\n      ...(spec as any),\n      // TODO: remove \"any\" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760\n      spec: this.map(spec.spec, params) as any\n    };\n  }\n\n  protected mapRepeat(spec: RepeatSpec, params: P): GenericSpec<UO, any, RO, FO> {\n    return {\n      ...spec,\n      // as any is required here since TS cannot infer that the output type satisfies the input type\n      spec: this.map(spec.spec as any, params)\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}