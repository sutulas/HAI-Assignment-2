{"ast":null,"code":"import { isObject } from 'vega-util';\nimport { isXorY } from '../../channel';\nimport { keys } from '../../util';\nimport { isDataRefDomain, isVgRangeStep } from '../../vega.schema';\nimport { isConcatModel, isLayerModel } from '../model';\nimport { assembleSelectionScaleDomain } from '../selection/assemble';\nimport { assembleDomain } from './domain';\nexport function assembleScales(model) {\n  if (isLayerModel(model) || isConcatModel(model)) {\n    // For concat and layer, include scales of children too\n    return model.children.reduce((scales, child) => {\n      return scales.concat(assembleScales(child));\n    }, assembleScalesForModel(model));\n  } else {\n    // For facet, child scales would not be included in the parent's scope.\n    // For unit, there is no child.\n    return assembleScalesForModel(model);\n  }\n}\nexport function assembleScalesForModel(model) {\n  return keys(model.component.scales).reduce((scales, channel) => {\n    const scaleComponent = model.component.scales[channel];\n    if (scaleComponent.merged) {\n      // Skipped merged scales\n      return scales;\n    }\n    const scale = scaleComponent.combine();\n    const {\n      name,\n      type,\n      selectionExtent,\n      domains: _d,\n      range: _r,\n      reverse,\n      ...otherScaleProps\n    } = scale;\n    const range = assembleScaleRange(scale.range, name, channel, model);\n    const domain = assembleDomain(model, channel);\n    const domainRaw = selectionExtent ? assembleSelectionScaleDomain(model, selectionExtent, scaleComponent, domain) : null;\n    scales.push({\n      name,\n      type,\n      ...(domain ? {\n        domain\n      } : {}),\n      ...(domainRaw ? {\n        domainRaw\n      } : {}),\n      range,\n      ...(reverse !== undefined ? {\n        reverse: reverse\n      } : {}),\n      ...otherScaleProps\n    });\n    return scales;\n  }, []);\n}\nexport function assembleScaleRange(scaleRange, scaleName, channel, model) {\n  // add signals to x/y range\n  if (isXorY(channel)) {\n    if (isVgRangeStep(scaleRange)) {\n      // For width/height step, use a signal created in layout assemble instead of a constant step.\n      return {\n        step: {\n          signal: `${scaleName}_step`\n        }\n      };\n    }\n  } else if (isObject(scaleRange) && isDataRefDomain(scaleRange)) {\n    return {\n      ...scaleRange,\n      data: model.lookupDataSource(scaleRange.data)\n    };\n  }\n  return scaleRange;\n}","map":{"version":3,"names":["isObject","isXorY","keys","isDataRefDomain","isVgRangeStep","isConcatModel","isLayerModel","assembleSelectionScaleDomain","assembleDomain","assembleScales","model","children","reduce","scales","child","concat","assembleScalesForModel","component","channel","scaleComponent","merged","scale","combine","name","type","selectionExtent","domains","_d","range","_r","reverse","otherScaleProps","assembleScaleRange","domain","domainRaw","push","undefined","scaleRange","scaleName","step","signal","data","lookupDataSource"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\scale\\assemble.ts"],"sourcesContent":["import {isObject} from 'vega-util';\nimport {isXorY, ScaleChannel} from '../../channel';\nimport {keys} from '../../util';\nimport {isDataRefDomain, isVgRangeStep, VgRange, VgScale} from '../../vega.schema';\nimport {isConcatModel, isLayerModel, Model} from '../model';\nimport {assembleSelectionScaleDomain} from '../selection/assemble';\nimport {assembleDomain} from './domain';\n\nexport function assembleScales(model: Model): VgScale[] {\n  if (isLayerModel(model) || isConcatModel(model)) {\n    // For concat and layer, include scales of children too\n    return model.children.reduce((scales, child) => {\n      return scales.concat(assembleScales(child));\n    }, assembleScalesForModel(model));\n  } else {\n    // For facet, child scales would not be included in the parent's scope.\n    // For unit, there is no child.\n    return assembleScalesForModel(model);\n  }\n}\n\nexport function assembleScalesForModel(model: Model): VgScale[] {\n  return keys(model.component.scales).reduce((scales: VgScale[], channel: ScaleChannel) => {\n    const scaleComponent = model.component.scales[channel];\n    if (scaleComponent.merged) {\n      // Skipped merged scales\n      return scales;\n    }\n\n    const scale = scaleComponent.combine();\n    const {name, type, selectionExtent, domains: _d, range: _r, reverse, ...otherScaleProps} = scale;\n    const range = assembleScaleRange(scale.range, name, channel, model);\n\n    const domain = assembleDomain(model, channel);\n    const domainRaw = selectionExtent\n      ? assembleSelectionScaleDomain(model, selectionExtent, scaleComponent, domain)\n      : null;\n\n    scales.push({\n      name,\n      type,\n      ...(domain ? {domain} : {}),\n      ...(domainRaw ? {domainRaw} : {}),\n      range,\n      ...(reverse !== undefined ? {reverse: reverse as any} : {}),\n      ...otherScaleProps\n    });\n\n    return scales;\n  }, [] as VgScale[]);\n}\n\nexport function assembleScaleRange(\n  scaleRange: VgRange,\n  scaleName: string,\n  channel: ScaleChannel,\n  model?: Model\n): VgRange {\n  // add signals to x/y range\n  if (isXorY(channel)) {\n    if (isVgRangeStep(scaleRange)) {\n      // For width/height step, use a signal created in layout assemble instead of a constant step.\n      return {\n        step: {signal: `${scaleName}_step`}\n      };\n    }\n  } else if (isObject(scaleRange) && isDataRefDomain(scaleRange)) {\n    return {\n      ...scaleRange,\n      data: model.lookupDataSource(scaleRange.data)\n    };\n  }\n  return scaleRange;\n}\n"],"mappings":"AAAA,SAAQA,QAAQ,QAAO,WAAW;AAClC,SAAQC,MAAM,QAAqB,eAAe;AAClD,SAAQC,IAAI,QAAO,YAAY;AAC/B,SAAQC,eAAe,EAAEC,aAAa,QAAyB,mBAAmB;AAClF,SAAQC,aAAa,EAAEC,YAAY,QAAc,UAAU;AAC3D,SAAQC,4BAA4B,QAAO,uBAAuB;AAClE,SAAQC,cAAc,QAAO,UAAU;AAEvC,OAAM,SAAUC,cAAcA,CAACC,KAAY;EACzC,IAAIJ,YAAY,CAACI,KAAK,CAAC,IAAIL,aAAa,CAACK,KAAK,CAAC,EAAE;IAC/C;IACA,OAAOA,KAAK,CAACC,QAAQ,CAACC,MAAM,CAAC,CAACC,MAAM,EAAEC,KAAK,KAAI;MAC7C,OAAOD,MAAM,CAACE,MAAM,CAACN,cAAc,CAACK,KAAK,CAAC,CAAC;IAC7C,CAAC,EAAEE,sBAAsB,CAACN,KAAK,CAAC,CAAC;EACnC,CAAC,MAAM;IACL;IACA;IACA,OAAOM,sBAAsB,CAACN,KAAK,CAAC;EACtC;AACF;AAEA,OAAM,SAAUM,sBAAsBA,CAACN,KAAY;EACjD,OAAOR,IAAI,CAACQ,KAAK,CAACO,SAAS,CAACJ,MAAM,CAAC,CAACD,MAAM,CAAC,CAACC,MAAiB,EAAEK,OAAqB,KAAI;IACtF,MAAMC,cAAc,GAAGT,KAAK,CAACO,SAAS,CAACJ,MAAM,CAACK,OAAO,CAAC;IACtD,IAAIC,cAAc,CAACC,MAAM,EAAE;MACzB;MACA,OAAOP,MAAM;IACf;IAEA,MAAMQ,KAAK,GAAGF,cAAc,CAACG,OAAO,EAAE;IACtC,MAAM;MAACC,IAAI;MAAEC,IAAI;MAAEC,eAAe;MAAEC,OAAO,EAAEC,EAAE;MAAEC,KAAK,EAAEC,EAAE;MAAEC,OAAO;MAAE,GAAGC;IAAe,CAAC,GAAGV,KAAK;IAChG,MAAMO,KAAK,GAAGI,kBAAkB,CAACX,KAAK,CAACO,KAAK,EAAEL,IAAI,EAAEL,OAAO,EAAER,KAAK,CAAC;IAEnE,MAAMuB,MAAM,GAAGzB,cAAc,CAACE,KAAK,EAAEQ,OAAO,CAAC;IAC7C,MAAMgB,SAAS,GAAGT,eAAe,GAC7BlB,4BAA4B,CAACG,KAAK,EAAEe,eAAe,EAAEN,cAAc,EAAEc,MAAM,CAAC,GAC5E,IAAI;IAERpB,MAAM,CAACsB,IAAI,CAAC;MACVZ,IAAI;MACJC,IAAI;MACJ,IAAIS,MAAM,GAAG;QAACA;MAAM,CAAC,GAAG,EAAE,CAAC;MAC3B,IAAIC,SAAS,GAAG;QAACA;MAAS,CAAC,GAAG,EAAE,CAAC;MACjCN,KAAK;MACL,IAAIE,OAAO,KAAKM,SAAS,GAAG;QAACN,OAAO,EAAEA;MAAc,CAAC,GAAG,EAAE,CAAC;MAC3D,GAAGC;KACJ,CAAC;IAEF,OAAOlB,MAAM;EACf,CAAC,EAAE,EAAe,CAAC;AACrB;AAEA,OAAM,SAAUmB,kBAAkBA,CAChCK,UAAmB,EACnBC,SAAiB,EACjBpB,OAAqB,EACrBR,KAAa;EAEb;EACA,IAAIT,MAAM,CAACiB,OAAO,CAAC,EAAE;IACnB,IAAId,aAAa,CAACiC,UAAU,CAAC,EAAE;MAC7B;MACA,OAAO;QACLE,IAAI,EAAE;UAACC,MAAM,EAAE,GAAGF,SAAS;QAAO;OACnC;IACH;EACF,CAAC,MAAM,IAAItC,QAAQ,CAACqC,UAAU,CAAC,IAAIlC,eAAe,CAACkC,UAAU,CAAC,EAAE;IAC9D,OAAO;MACL,GAAGA,UAAU;MACbI,IAAI,EAAE/B,KAAK,CAACgC,gBAAgB,CAACL,UAAU,CAACI,IAAI;KAC7C;EACH;EACA,OAAOJ,UAAU;AACnB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}