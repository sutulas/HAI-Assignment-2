{"ast":null,"code":"import { Transform } from 'vega-dataflow';\nimport { Marks, boundClip, GroupItem, Item, Bounds, multiLineOffset, boundStroke } from 'vega-scenegraph';\nimport { inherits, peek, isObject } from 'vega-util';\nconst Top = 'top';\nconst Left = 'left';\nconst Right = 'right';\nconst Bottom = 'bottom';\nconst TopLeft = 'top-left';\nconst TopRight = 'top-right';\nconst BottomLeft = 'bottom-left';\nconst BottomRight = 'bottom-right';\nconst Start = 'start';\nconst Middle = 'middle';\nconst End = 'end';\nconst X = 'x';\nconst Y = 'y';\nconst Group = 'group';\nconst AxisRole = 'axis';\nconst TitleRole = 'title';\nconst FrameRole = 'frame';\nconst ScopeRole = 'scope';\nconst LegendRole = 'legend';\nconst RowHeader = 'row-header';\nconst RowFooter = 'row-footer';\nconst RowTitle = 'row-title';\nconst ColHeader = 'column-header';\nconst ColFooter = 'column-footer';\nconst ColTitle = 'column-title';\nconst Padding = 'padding';\nconst Symbols = 'symbol';\nconst Fit = 'fit';\nconst FitX = 'fit-x';\nconst FitY = 'fit-y';\nconst Pad = 'pad';\nconst None = 'none';\nconst All = 'all';\nconst Each = 'each';\nconst Flush = 'flush';\nconst Column = 'column';\nconst Row = 'row';\n\n/**\n * Calculate bounding boxes for scenegraph items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - The scenegraph mark instance to bound.\n */\nfunction Bound(params) {\n  Transform.call(this, null, params);\n}\ninherits(Bound, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow,\n      mark = _.mark,\n      type = mark.marktype,\n      entry = Marks[type],\n      bound = entry.bound;\n    let markBounds = mark.bounds,\n      rebound;\n    if (entry.nested) {\n      // multi-item marks have a single bounds instance\n      if (mark.items.length) view.dirty(mark.items[0]);\n      markBounds = boundItem(mark, bound);\n      mark.items.forEach(item => {\n        item.bounds.clear().union(markBounds);\n      });\n    } else if (type === Group || _.modified()) {\n      // operator parameters modified -> re-bound all items\n      // updates group bounds in response to modified group content\n      pulse.visit(pulse.MOD, item => view.dirty(item));\n      markBounds.clear();\n      mark.items.forEach(item => markBounds.union(boundItem(item, bound)));\n\n      // force reflow for axes/legends/titles to propagate any layout changes\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          pulse.reflow();\n      }\n    } else {\n      // incrementally update bounds, re-bound mark as needed\n      rebound = pulse.changed(pulse.REM);\n      pulse.visit(pulse.ADD, item => {\n        markBounds.union(boundItem(item, bound));\n      });\n      pulse.visit(pulse.MOD, item => {\n        rebound = rebound || markBounds.alignsWith(item.bounds);\n        view.dirty(item);\n        markBounds.union(boundItem(item, bound));\n      });\n      if (rebound) {\n        markBounds.clear();\n        mark.items.forEach(item => markBounds.union(item.bounds));\n      }\n    }\n\n    // ensure mark bounds do not exceed any clipping region\n    boundClip(mark);\n    return pulse.modifies('bounds');\n  }\n});\nfunction boundItem(item, bound, opt) {\n  return bound(item.bounds.clear(), item, opt);\n}\nconst COUNTER_NAME = ':vega_identifier:';\n\n/**\n * Adds a unique identifier to all added tuples.\n * This transform creates a new signal that serves as an id counter.\n * As a result, the id counter is shared across all instances of this\n * transform, generating unique ids across multiple data streams. In\n * addition, this signal value can be included in a snapshot of the\n * dataflow state, enabling correct resumption of id allocation.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.as - The field name for the generated identifier.\n */\nfunction Identifier(params) {\n  Transform.call(this, 0, params);\n}\nIdentifier.Definition = {\n  'type': 'Identifier',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'as',\n    'type': 'string',\n    'required': true\n  }]\n};\ninherits(Identifier, Transform, {\n  transform(_, pulse) {\n    const counter = getCounter(pulse.dataflow),\n      as = _.as;\n    let id = counter.value;\n    pulse.visit(pulse.ADD, t => t[as] = t[as] || ++id);\n    counter.set(this.value = id);\n    return pulse;\n  }\n});\nfunction getCounter(view) {\n  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));\n}\n\n/**\n * Bind scenegraph items to a scenegraph mark instance.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.markdef - The mark definition for creating the mark.\n *   This is an object of legal scenegraph mark properties which *must* include\n *   the 'marktype' property.\n */\nfunction Mark(params) {\n  Transform.call(this, null, params);\n}\ninherits(Mark, Transform, {\n  transform(_, pulse) {\n    let mark = this.value;\n\n    // acquire mark on first invocation, bind context and group\n    if (!mark) {\n      mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup$1(_), _.index);\n      mark.group.context = _.context;\n      if (!_.context.group) _.context.group = mark.group;\n      mark.source = this.source; // point to upstream collector\n      mark.clip = _.clip;\n      mark.interactive = _.interactive;\n      this.value = mark;\n    }\n\n    // initialize entering items\n    const Init = mark.marktype === Group ? GroupItem : Item;\n    pulse.visit(pulse.ADD, item => Init.call(item, mark));\n\n    // update clipping and/or interactive status\n    if (_.modified('clip') || _.modified('interactive')) {\n      mark.clip = _.clip;\n      mark.interactive = !!_.interactive;\n      mark.zdirty = true; // force scenegraph re-eval\n      pulse.reflow();\n    }\n\n    // bind items array to scenegraph mark\n    mark.items = pulse.source;\n    return pulse;\n  }\n});\nfunction lookup$1(_) {\n  const g = _.groups,\n    p = _.parent;\n  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;\n}\n\n/**\n * Analyze items for overlap, changing opacity to hide items with\n * overlapping bounding boxes. This transform will preserve at least\n * two items (e.g., first and last) even if overlap persists.\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting items.\n * @param {object} [params.method] - The overlap removal method to apply.\n *   One of 'parity' (default, hide every other item until there is no\n *   more overlap) or 'greedy' (sequentially scan and hide and items that\n *   overlap with the last visible item).\n * @param {object} [params.boundScale] - A scale whose range should be used\n *   to bound the items. Items exceeding the bounds of the scale range\n *   will be treated as overlapping. If null or undefined, no bounds check\n *   will be applied.\n * @param {object} [params.boundOrient] - The orientation of the scale\n *   (top, bottom, left, or right) used to bound items. This parameter is\n *   ignored if boundScale is null or undefined.\n * @param {object} [params.boundTolerance] - The tolerance in pixels for\n *   bound inclusion testing (default 1). This specifies by how many pixels\n *   an item's bounds may exceed the scale range bounds and not be culled.\n * @constructor\n */\nfunction Overlap(params) {\n  Transform.call(this, null, params);\n}\nconst methods = {\n  parity: items => items.filter((item, i) => i % 2 ? item.opacity = 0 : 1),\n  greedy: (items, sep) => {\n    let a;\n    return items.filter((b, i) => !i || !intersect(a.bounds, b.bounds, sep) ? (a = b, 1) : b.opacity = 0);\n  }\n};\n\n// compute bounding box intersection\n// including padding pixels of separation\nconst intersect = (a, b, sep) => sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);\nconst hasOverlap = (items, pad) => {\n  for (var i = 1, n = items.length, a = items[0].bounds, b; i < n; a = b, ++i) {\n    if (intersect(a, b = items[i].bounds, pad)) return true;\n  }\n};\nconst hasBounds = item => {\n  const b = item.bounds;\n  return b.width() > 1 && b.height() > 1;\n};\nconst boundTest = (scale, orient, tolerance) => {\n  var range = scale.range(),\n    b = new Bounds();\n  if (orient === Top || orient === Bottom) {\n    b.set(range[0], -Infinity, range[1], +Infinity);\n  } else {\n    b.set(-Infinity, range[0], +Infinity, range[1]);\n  }\n  b.expand(tolerance || 1);\n  return item => b.encloses(item.bounds);\n};\n\n// reset all items to be fully opaque\nconst reset = source => {\n  source.forEach(item => item.opacity = 1);\n  return source;\n};\n\n// add all tuples to mod, fork pulse if parameters were modified\n// fork prevents cross-stream tuple pollution (e.g., pulse from scale)\nconst reflow = (pulse, _) => pulse.reflow(_.modified()).modifies('opacity');\ninherits(Overlap, Transform, {\n  transform(_, pulse) {\n    const reduce = methods[_.method] || methods.parity,\n      sep = _.separation || 0;\n    let source = pulse.materialize(pulse.SOURCE).source,\n      items,\n      test;\n    if (!source || !source.length) return;\n    if (!_.method) {\n      // early exit if method is falsy\n      if (_.modified('method')) {\n        reset(source);\n        pulse = reflow(pulse, _);\n      }\n      return pulse;\n    }\n\n    // skip labels with no content\n    source = source.filter(hasBounds);\n\n    // early exit, nothing to do\n    if (!source.length) return;\n    if (_.sort) {\n      source = source.slice().sort(_.sort);\n    }\n    items = reset(source);\n    pulse = reflow(pulse, _);\n    if (items.length >= 3 && hasOverlap(items, sep)) {\n      do {\n        items = reduce(items, sep);\n      } while (items.length >= 3 && hasOverlap(items, sep));\n      if (items.length < 3 && !peek(source).opacity) {\n        if (items.length > 1) peek(items).opacity = 0;\n        peek(source).opacity = 1;\n      }\n    }\n    if (_.boundScale && _.boundTolerance >= 0) {\n      test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);\n      source.forEach(item => {\n        if (!test(item)) item.opacity = 0;\n      });\n    }\n\n    // re-calculate mark bounds\n    const bounds = items[0].mark.bounds.clear();\n    source.forEach(item => {\n      if (item.opacity) bounds.union(item.bounds);\n    });\n    return pulse;\n  }\n});\n\n/**\n * Queue modified scenegraph items for rendering.\n * @constructor\n */\nfunction Render(params) {\n  Transform.call(this, null, params);\n}\ninherits(Render, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n    pulse.visit(pulse.ALL, item => view.dirty(item));\n\n    // set z-index dirty flag as needed\n    if (pulse.fields && pulse.fields['zindex']) {\n      const item = pulse.source && pulse.source[0];\n      if (item) item.mark.zdirty = true;\n    }\n  }\n});\nconst tempBounds = new Bounds();\nfunction set(item, property, value) {\n  return item[property] === value ? 0 : (item[property] = value, 1);\n}\nfunction isYAxis(mark) {\n  var orient = mark.items[0].orient;\n  return orient === Left || orient === Right;\n}\nfunction axisIndices(datum) {\n  let index = +datum.grid;\n  return [datum.ticks ? index++ : -1,\n  // ticks index\n  datum.labels ? index++ : -1,\n  // labels index\n  index + +datum.domain // title index\n  ];\n}\nfunction axisLayout(view, axis, width, height) {\n  var item = axis.items[0],\n    datum = item.datum,\n    delta = item.translate != null ? item.translate : 0.5,\n    orient = item.orient,\n    indices = axisIndices(datum),\n    range = item.range,\n    offset = item.offset,\n    position = item.position,\n    minExtent = item.minExtent,\n    maxExtent = item.maxExtent,\n    title = datum.title && item.items[indices[2]].items[0],\n    titlePadding = item.titlePadding,\n    bounds = item.bounds,\n    dl = title && multiLineOffset(title),\n    x = 0,\n    y = 0,\n    i,\n    s;\n  tempBounds.clear().union(bounds);\n  bounds.clear();\n  if ((i = indices[0]) > -1) bounds.union(item.items[i].bounds);\n  if ((i = indices[1]) > -1) bounds.union(item.items[i].bounds);\n\n  // position axis group and title\n  switch (orient) {\n    case Top:\n      x = position || 0;\n      y = -offset;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));\n      bounds.add(0, -s).add(range, 0);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds);\n      break;\n    case Left:\n      x = -offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));\n      bounds.add(-s, 0).add(0, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds);\n      break;\n    case Right:\n      x = width + offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));\n      bounds.add(0, 0).add(s, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds);\n      break;\n    case Bottom:\n      x = position || 0;\n      y = height + offset;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));\n      bounds.add(0, 0).add(range, s);\n      if (title) axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds);\n      break;\n    default:\n      x = item.x;\n      y = item.y;\n  }\n\n  // update bounds\n  boundStroke(bounds.translate(x, y), item);\n  if (set(item, 'x', x + delta) | set(item, 'y', y + delta)) {\n    item.bounds = tempBounds;\n    view.dirty(item);\n    item.bounds = bounds;\n    view.dirty(item);\n  }\n  return item.mark.bounds.clear().union(bounds);\n}\nfunction axisTitleLayout(view, title, offset, pad, dl, isYAxis, sign, bounds) {\n  const b = title.bounds;\n  if (title.auto) {\n    const v = sign * (offset + dl + pad);\n    let dx = 0,\n      dy = 0;\n    view.dirty(title);\n    isYAxis ? dx = (title.x || 0) - (title.x = v) : dy = (title.y || 0) - (title.y = v);\n    title.mark.bounds.clear().union(b.translate(-dx, -dy));\n    view.dirty(title);\n  }\n  bounds.union(b);\n}\n\n// aggregation functions for grid margin determination\nconst min = (a, b) => Math.floor(Math.min(a, b));\nconst max = (a, b) => Math.ceil(Math.max(a, b));\nfunction gridLayoutGroups(group) {\n  var groups = group.items,\n    n = groups.length,\n    i = 0,\n    mark,\n    items;\n  const views = {\n    marks: [],\n    rowheaders: [],\n    rowfooters: [],\n    colheaders: [],\n    colfooters: [],\n    rowtitle: null,\n    coltitle: null\n  };\n\n  // layout axes, gather legends, collect bounds\n  for (; i < n; ++i) {\n    mark = groups[i];\n    items = mark.items;\n    if (mark.marktype === Group) {\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          break;\n        case RowHeader:\n          views.rowheaders.push(...items);\n          break;\n        case RowFooter:\n          views.rowfooters.push(...items);\n          break;\n        case ColHeader:\n          views.colheaders.push(...items);\n          break;\n        case ColFooter:\n          views.colfooters.push(...items);\n          break;\n        case RowTitle:\n          views.rowtitle = items[0];\n          break;\n        case ColTitle:\n          views.coltitle = items[0];\n          break;\n        default:\n          views.marks.push(...items);\n      }\n    }\n  }\n  return views;\n}\nfunction bboxFlush(item) {\n  return new Bounds().set(0, 0, item.width || 0, item.height || 0);\n}\nfunction bboxFull(item) {\n  const b = item.bounds.clone();\n  return b.empty() ? b.set(0, 0, 0, 0) : b.translate(-(item.x || 0), -(item.y || 0));\n}\nfunction get(opt, key, d) {\n  const v = isObject(opt) ? opt[key] : opt;\n  return v != null ? v : d !== undefined ? d : 0;\n}\nfunction offsetValue(v) {\n  return v < 0 ? Math.ceil(-v) : 0;\n}\nfunction gridLayout(view, groups, opt) {\n  var dirty = !opt.nodirty,\n    bbox = opt.bounds === Flush ? bboxFlush : bboxFull,\n    bounds = tempBounds.set(0, 0, 0, 0),\n    alignCol = get(opt.align, Column),\n    alignRow = get(opt.align, Row),\n    padCol = get(opt.padding, Column),\n    padRow = get(opt.padding, Row),\n    ncols = opt.columns || groups.length,\n    nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n    n = groups.length,\n    xOffset = Array(n),\n    xExtent = Array(ncols),\n    xMax = 0,\n    yOffset = Array(n),\n    yExtent = Array(nrows),\n    yMax = 0,\n    dx = Array(n),\n    dy = Array(n),\n    boxes = Array(n),\n    m,\n    i,\n    c,\n    r,\n    b,\n    g,\n    px,\n    py,\n    x,\n    y,\n    offset;\n  for (i = 0; i < ncols; ++i) xExtent[i] = 0;\n  for (i = 0; i < nrows; ++i) yExtent[i] = 0;\n\n  // determine offsets for each group\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    b = boxes[i] = bbox(g);\n    g.x = g.x || 0;\n    dx[i] = 0;\n    g.y = g.y || 0;\n    dy[i] = 0;\n    c = i % ncols;\n    r = ~~(i / ncols);\n    xMax = Math.max(xMax, px = Math.ceil(b.x2));\n    yMax = Math.max(yMax, py = Math.ceil(b.y2));\n    xExtent[c] = Math.max(xExtent[c], px);\n    yExtent[r] = Math.max(yExtent[r], py);\n    xOffset[i] = padCol + offsetValue(b.x1);\n    yOffset[i] = padRow + offsetValue(b.y1);\n    if (dirty) view.dirty(groups[i]);\n  }\n\n  // set initial alignment offsets\n  for (i = 0; i < n; ++i) {\n    if (i % ncols === 0) xOffset[i] = 0;\n    if (i < ncols) yOffset[i] = 0;\n  }\n\n  // enforce column alignment constraints\n  if (alignCol === Each) {\n    for (c = 1; c < ncols; ++c) {\n      for (offset = 0, i = c; i < n; i += ncols) {\n        if (offset < xOffset[i]) offset = xOffset[i];\n      }\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] = offset + xExtent[c - 1];\n      }\n    }\n  } else if (alignCol === All) {\n    for (offset = 0, i = 0; i < n; ++i) {\n      if (i % ncols && offset < xOffset[i]) offset = xOffset[i];\n    }\n    for (i = 0; i < n; ++i) {\n      if (i % ncols) xOffset[i] = offset + xMax;\n    }\n  } else {\n    for (alignCol = false, c = 1; c < ncols; ++c) {\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] += xExtent[c - 1];\n      }\n    }\n  }\n\n  // enforce row alignment constraints\n  if (alignRow === Each) {\n    for (r = 1; r < nrows; ++r) {\n      for (offset = 0, i = r * ncols, m = i + ncols; i < m; ++i) {\n        if (offset < yOffset[i]) offset = yOffset[i];\n      }\n      for (i = r * ncols; i < m; ++i) {\n        yOffset[i] = offset + yExtent[r - 1];\n      }\n    }\n  } else if (alignRow === All) {\n    for (offset = 0, i = ncols; i < n; ++i) {\n      if (offset < yOffset[i]) offset = yOffset[i];\n    }\n    for (i = ncols; i < n; ++i) {\n      yOffset[i] = offset + yMax;\n    }\n  } else {\n    for (alignRow = false, r = 1; r < nrows; ++r) {\n      for (i = r * ncols, m = i + ncols; i < m; ++i) {\n        yOffset[i] += yExtent[r - 1];\n      }\n    }\n  }\n\n  // perform horizontal grid layout\n  for (x = 0, i = 0; i < n; ++i) {\n    x = xOffset[i] + (i % ncols ? x : 0);\n    dx[i] += x - groups[i].x;\n  }\n\n  // perform vertical grid layout\n  for (c = 0; c < ncols; ++c) {\n    for (y = 0, i = c; i < n; i += ncols) {\n      y += yOffset[i];\n      dy[i] += y - groups[i].y;\n    }\n  }\n\n  // perform horizontal centering\n  if (alignCol && get(opt.center, Column) && nrows > 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignCol === All ? xMax : xExtent[i % ncols];\n      x = b - boxes[i].x2 - groups[i].x - dx[i];\n      if (x > 0) dx[i] += x / 2;\n    }\n  }\n\n  // perform vertical centering\n  if (alignRow && get(opt.center, Row) && ncols !== 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignRow === All ? yMax : yExtent[~~(i / ncols)];\n      y = b - boxes[i].y2 - groups[i].y - dy[i];\n      if (y > 0) dy[i] += y / 2;\n    }\n  }\n\n  // position grid relative to anchor\n  for (i = 0; i < n; ++i) {\n    bounds.union(boxes[i].translate(dx[i], dy[i]));\n  }\n  x = get(opt.anchor, X);\n  y = get(opt.anchor, Y);\n  switch (get(opt.anchor, Column)) {\n    case End:\n      x -= bounds.width();\n      break;\n    case Middle:\n      x -= bounds.width() / 2;\n  }\n  switch (get(opt.anchor, Row)) {\n    case End:\n      y -= bounds.height();\n      break;\n    case Middle:\n      y -= bounds.height() / 2;\n  }\n  x = Math.round(x);\n  y = Math.round(y);\n\n  // update mark positions, bounds, dirty\n  bounds.clear();\n  for (i = 0; i < n; ++i) {\n    groups[i].mark.bounds.clear();\n  }\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    g.x += dx[i] += x;\n    g.y += dy[i] += y;\n    bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));\n    if (dirty) view.dirty(g);\n  }\n  return bounds;\n}\nfunction trellisLayout(view, group, opt) {\n  var views = gridLayoutGroups(group),\n    groups = views.marks,\n    bbox = opt.bounds === Flush ? boundFlush : boundFull,\n    off = opt.offset,\n    ncols = opt.columns || groups.length,\n    nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n    cells = nrows * ncols,\n    x,\n    y,\n    x2,\n    y2,\n    anchor,\n    band,\n    offset;\n\n  // -- initial grid layout\n  const bounds = gridLayout(view, groups, opt);\n  if (bounds.empty()) bounds.set(0, 0, 0, 0); // empty grid\n\n  // -- layout grid headers and footers --\n\n  // perform row header layout\n  if (views.rowheaders) {\n    band = get(opt.headerBand, Row, null);\n    x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);\n  }\n\n  // perform column header layout\n  if (views.colheaders) {\n    band = get(opt.headerBand, Column, null);\n    y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);\n  }\n\n  // perform row footer layout\n  if (views.rowfooters) {\n    band = get(opt.footerBand, Row, null);\n    x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols - 1, ncols, 1, band);\n  }\n\n  // perform column footer layout\n  if (views.colfooters) {\n    band = get(opt.footerBand, Column, null);\n    y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get(off, 'columnFooter'), max, 1, bbox, 'y2', cells - ncols, 1, ncols, band);\n  }\n\n  // perform row title layout\n  if (views.rowtitle) {\n    anchor = get(opt.titleAnchor, Row);\n    offset = get(off, 'rowTitle');\n    offset = anchor === End ? x2 + offset : x - offset;\n    band = get(opt.titleBand, Row, 0.5);\n    layoutTitle(view, views.rowtitle, offset, 0, bounds, band);\n  }\n\n  // perform column title layout\n  if (views.coltitle) {\n    anchor = get(opt.titleAnchor, Column);\n    offset = get(off, 'columnTitle');\n    offset = anchor === End ? y2 + offset : y - offset;\n    band = get(opt.titleBand, Column, 0.5);\n    layoutTitle(view, views.coltitle, offset, 1, bounds, band);\n  }\n}\nfunction boundFlush(item, field) {\n  return field === 'x1' ? item.x || 0 : field === 'y1' ? item.y || 0 : field === 'x2' ? (item.x || 0) + (item.width || 0) : field === 'y2' ? (item.y || 0) + (item.height || 0) : undefined;\n}\nfunction boundFull(item, field) {\n  return item.bounds[field];\n}\nfunction layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {\n  var n = groups.length,\n    init = 0,\n    edge = 0,\n    i,\n    j,\n    k,\n    m,\n    b,\n    h,\n    g,\n    x,\n    y;\n\n  // if no groups, early exit and return 0\n  if (!n) return init;\n\n  // compute margin\n  for (i = start; i < n; i += stride) {\n    if (groups[i]) init = agg(init, bound(groups[i], bf));\n  }\n\n  // if no headers, return margin calculation\n  if (!headers.length) return init;\n\n  // check if number of headers exceeds number of rows or columns\n  if (headers.length > limit) {\n    view.warn('Grid headers exceed limit: ' + limit);\n    headers = headers.slice(0, limit);\n  }\n\n  // apply offset\n  init += offset;\n\n  // clear mark bounds for all headers\n  for (j = 0, m = headers.length; j < m; ++j) {\n    view.dirty(headers[j]);\n    headers[j].mark.bounds.clear();\n  }\n\n  // layout each header\n  for (i = start, j = 0, m = headers.length; j < m; ++j, i += stride) {\n    h = headers[j];\n    b = h.mark.bounds;\n\n    // search for nearest group to align to\n    // necessary if table has empty cells\n    for (k = i; k >= 0 && (g = groups[k]) == null; k -= back);\n\n    // assign coordinates and update bounds\n    if (isX) {\n      x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());\n      y = init;\n    } else {\n      x = init;\n      y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());\n    }\n    b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));\n    h.x = x;\n    h.y = y;\n    view.dirty(h);\n\n    // update current edge of layout bounds\n    edge = agg(edge, b[bf]);\n  }\n  return edge;\n}\nfunction layoutTitle(view, g, offset, isX, bounds, band) {\n  if (!g) return;\n  view.dirty(g);\n\n  // compute title coordinates\n  var x = offset,\n    y = offset;\n  isX ? x = Math.round(bounds.x1 + band * bounds.width()) : y = Math.round(bounds.y1 + band * bounds.height());\n\n  // assign coordinates and update bounds\n  g.bounds.translate(x - (g.x || 0), y - (g.y || 0));\n  g.mark.bounds.clear().union(g.bounds);\n  g.x = x;\n  g.y = y;\n\n  // queue title for redraw\n  view.dirty(g);\n}\n\n// utility for looking up legend layout configuration\nfunction lookup(config, orient) {\n  const opt = config[orient] || {};\n  return (key, d) => opt[key] != null ? opt[key] : config[key] != null ? config[key] : d;\n}\n\n// if legends specify offset directly, use the maximum specified value\nfunction offsets(legends, value) {\n  let max = -Infinity;\n  legends.forEach(item => {\n    if (item.offset != null) max = Math.max(max, item.offset);\n  });\n  return max > -Infinity ? max : value;\n}\nfunction legendParams(g, orient, config, xb, yb, w, h) {\n  const _ = lookup(config, orient),\n    offset = offsets(g, _('offset', 0)),\n    anchor = _('anchor', Start),\n    mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;\n  const p = {\n    align: Each,\n    bounds: _('bounds', Flush),\n    columns: _('direction') === 'vertical' ? 1 : g.length,\n    padding: _('margin', 8),\n    center: _('center'),\n    nodirty: true\n  };\n  switch (orient) {\n    case Left:\n      p.anchor = {\n        x: Math.floor(xb.x1) - offset,\n        column: End,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n    case Right:\n      p.anchor = {\n        x: Math.ceil(xb.x2) + offset,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n    case Top:\n      p.anchor = {\n        y: Math.floor(yb.y1) - offset,\n        row: End,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n    case Bottom:\n      p.anchor = {\n        y: Math.ceil(yb.y2) + offset,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n    case TopLeft:\n      p.anchor = {\n        x: offset,\n        y: offset\n      };\n      break;\n    case TopRight:\n      p.anchor = {\n        x: w - offset,\n        y: offset,\n        column: End\n      };\n      break;\n    case BottomLeft:\n      p.anchor = {\n        x: offset,\n        y: h - offset,\n        row: End\n      };\n      break;\n    case BottomRight:\n      p.anchor = {\n        x: w - offset,\n        y: h - offset,\n        column: End,\n        row: End\n      };\n      break;\n  }\n  return p;\n}\nfunction legendLayout(view, legend) {\n  var item = legend.items[0],\n    datum = item.datum,\n    orient = item.orient,\n    bounds = item.bounds,\n    x = item.x,\n    y = item.y,\n    w,\n    h;\n\n  // cache current bounds for later comparison\n  item._bounds ? item._bounds.clear().union(bounds) : item._bounds = bounds.clone();\n  bounds.clear();\n\n  // adjust legend to accommodate padding and title\n  legendGroupLayout(view, item, item.items[0].items[0]);\n\n  // aggregate bounds to determine size, and include origin\n  bounds = legendBounds(item, bounds);\n  w = 2 * item.padding;\n  h = 2 * item.padding;\n  if (!bounds.empty()) {\n    w = Math.ceil(bounds.width() + w);\n    h = Math.ceil(bounds.height() + h);\n  }\n  if (datum.type === Symbols) {\n    legendEntryLayout(item.items[0].items[0].items[0].items);\n  }\n  if (orient !== None) {\n    item.x = x = 0;\n    item.y = y = 0;\n  }\n  item.width = w;\n  item.height = h;\n  boundStroke(bounds.set(x, y, x + w, y + h), item);\n  item.mark.bounds.clear().union(bounds);\n  return item;\n}\nfunction legendBounds(item, b) {\n  // aggregate item bounds\n  item.items.forEach(_ => b.union(_.bounds));\n\n  // anchor to legend origin\n  b.x1 = item.padding;\n  b.y1 = item.padding;\n  return b;\n}\nfunction legendGroupLayout(view, item, entry) {\n  var pad = item.padding,\n    ex = pad - entry.x,\n    ey = pad - entry.y;\n  if (!item.datum.title) {\n    if (ex || ey) translate(view, entry, ex, ey);\n  } else {\n    var title = item.items[1].items[0],\n      anchor = title.anchor,\n      tpad = item.titlePadding || 0,\n      tx = pad - title.x,\n      ty = pad - title.y;\n    switch (title.orient) {\n      case Left:\n        ex += Math.ceil(title.bounds.width()) + tpad;\n        break;\n      case Right:\n      case Bottom:\n        break;\n      default:\n        ey += title.bounds.height() + tpad;\n    }\n    if (ex || ey) translate(view, entry, ex, ey);\n    switch (title.orient) {\n      case Left:\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n      case Right:\n        tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n      case Bottom:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n        ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;\n        break;\n      default:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n    }\n    if (tx || ty) translate(view, title, tx, ty);\n\n    // translate legend if title pushes into negative coordinates\n    if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {\n      translate(view, entry, -tx, 0);\n      translate(view, title, -tx, 0);\n    }\n  }\n}\nfunction legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {\n  const grad = item.datum.type !== 'symbol',\n    vgrad = title.datum.vgrad,\n    e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,\n    s = e.bounds[y ? 'y2' : 'x2'] - item.padding,\n    u = vgrad && lr ? s : 0,\n    v = vgrad && lr ? 0 : s,\n    o = y <= 0 ? 0 : multiLineOffset(title);\n  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s - o));\n}\nfunction translate(view, item, dx, dy) {\n  item.x += dx;\n  item.y += dy;\n  item.bounds.translate(dx, dy);\n  item.mark.bounds.translate(dx, dy);\n  view.dirty(item);\n}\nfunction legendEntryLayout(entries) {\n  // get max widths for each column\n  const widths = entries.reduce((w, g) => {\n    w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);\n    return w;\n  }, {});\n\n  // set dimensions of legend entry groups\n  entries.forEach(g => {\n    g.width = widths[g.column];\n    g.height = g.bounds.y2 - g.y;\n  });\n}\nfunction titleLayout(view, mark, width, height, viewBounds) {\n  var group = mark.items[0],\n    frame = group.frame,\n    orient = group.orient,\n    anchor = group.anchor,\n    offset = group.offset,\n    padding = group.padding,\n    title = group.items[0].items[0],\n    subtitle = group.items[1] && group.items[1].items[0],\n    end = orient === Left || orient === Right ? height : width,\n    start = 0,\n    x = 0,\n    y = 0,\n    sx = 0,\n    sy = 0,\n    pos;\n  if (frame !== Group) {\n    orient === Left ? (start = viewBounds.y2, end = viewBounds.y1) : orient === Right ? (start = viewBounds.y1, end = viewBounds.y2) : (start = viewBounds.x1, end = viewBounds.x2);\n  } else if (orient === Left) {\n    start = height, end = 0;\n  }\n  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;\n  if (subtitle && subtitle.text) {\n    // position subtitle\n    switch (orient) {\n      case Top:\n      case Bottom:\n        sy = title.bounds.height() + padding;\n        break;\n      case Left:\n        sx = title.bounds.width() + padding;\n        break;\n      case Right:\n        sx = -title.bounds.width() - padding;\n        break;\n    }\n    tempBounds.clear().union(subtitle.bounds);\n    tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));\n    if (set(subtitle, 'x', sx) | set(subtitle, 'y', sy)) {\n      view.dirty(subtitle);\n      subtitle.bounds.clear().union(tempBounds);\n      subtitle.mark.bounds.clear().union(tempBounds);\n      view.dirty(subtitle);\n    }\n    tempBounds.clear().union(subtitle.bounds);\n  } else {\n    tempBounds.clear();\n  }\n  tempBounds.union(title.bounds);\n\n  // position title group\n  switch (orient) {\n    case Top:\n      x = pos;\n      y = viewBounds.y1 - tempBounds.height() - offset;\n      break;\n    case Left:\n      x = viewBounds.x1 - tempBounds.width() - offset;\n      y = pos;\n      break;\n    case Right:\n      x = viewBounds.x2 + tempBounds.width() + offset;\n      y = pos;\n      break;\n    case Bottom:\n      x = pos;\n      y = viewBounds.y2 + offset;\n      break;\n    default:\n      x = group.x;\n      y = group.y;\n  }\n  if (set(group, 'x', x) | set(group, 'y', y)) {\n    tempBounds.translate(x, y);\n    view.dirty(group);\n    group.bounds.clear().union(tempBounds);\n    mark.bounds.clear().union(tempBounds);\n    view.dirty(group);\n  }\n  return group.bounds;\n}\n\n/**\n * Layout view elements such as axes and legends.\n * Also performs size adjustments.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - Scenegraph mark of groups to layout.\n */\nfunction ViewLayout(params) {\n  Transform.call(this, null, params);\n}\ninherits(ViewLayout, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n    _.mark.items.forEach(group => {\n      if (_.layout) trellisLayout(view, group, _.layout);\n      layoutGroup(view, group, _);\n    });\n    return shouldReflow(_.mark.group) ? pulse.reflow() : pulse;\n  }\n});\nfunction shouldReflow(group) {\n  // We typically should reflow if layout is invoked (#2568), as child items\n  // may have resized and reflow ensures group bounds are re-calculated.\n  // However, legend entries have a special exception to avoid instability.\n  // For example, if a selected legend symbol gains a stroke on hover,\n  // we don't want to re-position subsequent elements in the legend.\n  return group && group.mark.role !== 'legend-entry';\n}\nfunction layoutGroup(view, group, _) {\n  var items = group.items,\n    width = Math.max(0, group.width || 0),\n    height = Math.max(0, group.height || 0),\n    viewBounds = new Bounds().set(0, 0, width, height),\n    xBounds = viewBounds.clone(),\n    yBounds = viewBounds.clone(),\n    legends = [],\n    title,\n    mark,\n    orient,\n    b,\n    i,\n    n;\n\n  // layout axes, gather legends, collect bounds\n  for (i = 0, n = items.length; i < n; ++i) {\n    mark = items[i];\n    switch (mark.role) {\n      case AxisRole:\n        b = isYAxis(mark) ? xBounds : yBounds;\n        b.union(axisLayout(view, mark, width, height));\n        break;\n      case TitleRole:\n        title = mark;\n        break;\n      case LegendRole:\n        legends.push(legendLayout(view, mark));\n        break;\n      case FrameRole:\n      case ScopeRole:\n      case RowHeader:\n      case RowFooter:\n      case RowTitle:\n      case ColHeader:\n      case ColFooter:\n      case ColTitle:\n        xBounds.union(mark.bounds);\n        yBounds.union(mark.bounds);\n        break;\n      default:\n        viewBounds.union(mark.bounds);\n    }\n  }\n\n  // layout legends, adjust viewBounds\n  if (legends.length) {\n    // group legends by orient\n    const l = {};\n    legends.forEach(item => {\n      orient = item.orient || Right;\n      if (orient !== None) (l[orient] || (l[orient] = [])).push(item);\n    });\n\n    // perform grid layout for each orient group\n    for (const orient in l) {\n      const g = l[orient];\n      gridLayout(view, g, legendParams(g, orient, _.legends, xBounds, yBounds, width, height));\n    }\n\n    // update view bounds\n    legends.forEach(item => {\n      const b = item.bounds;\n      if (!b.equals(item._bounds)) {\n        item.bounds = item._bounds;\n        view.dirty(item); // dirty previous location\n        item.bounds = b;\n        view.dirty(item);\n      }\n      if (_.autosize && (_.autosize.type === Fit || _.autosize.type === FitX || _.autosize.type === FitY)) {\n        // For autosize fit, incorporate the orthogonal dimension only.\n        // Legends that overrun the chart area will then be clipped;\n        // otherwise the chart area gets reduced to nothing!\n        switch (item.orient) {\n          case Left:\n          case Right:\n            viewBounds.add(b.x1, 0).add(b.x2, 0);\n            break;\n          case Top:\n          case Bottom:\n            viewBounds.add(0, b.y1).add(0, b.y2);\n        }\n      } else {\n        viewBounds.union(b);\n      }\n    });\n  }\n\n  // combine bounding boxes\n  viewBounds.union(xBounds).union(yBounds);\n\n  // layout title, adjust bounds\n  if (title) {\n    viewBounds.union(titleLayout(view, title, width, height, viewBounds));\n  }\n\n  // override aggregated view bounds if content is clipped\n  if (group.clip) {\n    viewBounds.set(0, 0, group.width || 0, group.height || 0);\n  }\n\n  // perform size adjustment\n  viewSizeLayout(view, group, viewBounds, _);\n}\nfunction viewSizeLayout(view, group, viewBounds, _) {\n  const auto = _.autosize || {},\n    type = auto.type;\n  if (view._autosize < 1 || !type) return;\n  let viewWidth = view._width,\n    viewHeight = view._height,\n    width = Math.max(0, group.width || 0),\n    left = Math.max(0, Math.ceil(-viewBounds.x1)),\n    height = Math.max(0, group.height || 0),\n    top = Math.max(0, Math.ceil(-viewBounds.y1));\n  const right = Math.max(0, Math.ceil(viewBounds.x2 - width)),\n    bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));\n  if (auto.contains === Padding) {\n    const padding = view.padding();\n    viewWidth -= padding.left + padding.right;\n    viewHeight -= padding.top + padding.bottom;\n  }\n  if (type === None) {\n    left = 0;\n    top = 0;\n    width = viewWidth;\n    height = viewHeight;\n  } else if (type === Fit) {\n    width = Math.max(0, viewWidth - left - right);\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === FitX) {\n    width = Math.max(0, viewWidth - left - right);\n    viewHeight = height + top + bottom;\n  } else if (type === FitY) {\n    viewWidth = width + left + right;\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === Pad) {\n    viewWidth = width + left + right;\n    viewHeight = height + top + bottom;\n  }\n  view._resizeView(viewWidth, viewHeight, width, height, [left, top], auto.resize);\n}\nexport { Bound as bound, Identifier as identifier, Mark as mark, Overlap as overlap, Render as render, ViewLayout as viewlayout };","map":{"version":3,"names":["Transform","Marks","boundClip","GroupItem","Item","Bounds","multiLineOffset","boundStroke","inherits","peek","isObject","Top","Left","Right","Bottom","TopLeft","TopRight","BottomLeft","BottomRight","Start","Middle","End","X","Y","Group","AxisRole","TitleRole","FrameRole","ScopeRole","LegendRole","RowHeader","RowFooter","RowTitle","ColHeader","ColFooter","ColTitle","Padding","Symbols","Fit","FitX","FitY","Pad","None","All","Each","Flush","Column","Row","Bound","params","call","transform","_","pulse","view","dataflow","mark","type","marktype","entry","bound","markBounds","bounds","rebound","nested","items","length","dirty","boundItem","forEach","item","clear","union","modified","visit","MOD","role","reflow","changed","REM","ADD","alignsWith","modifies","opt","COUNTER_NAME","Identifier","Definition","counter","getCounter","as","id","value","t","set","_signals","add","Mark","scenegraph","markdef","lookup$1","index","group","context","source","clip","interactive","Init","zdirty","g","groups","p","parent","size","get","Object","keys","object","lookup","Overlap","methods","parity","filter","i","opacity","greedy","sep","a","b","intersect","Math","max","x1","x2","y1","y2","hasOverlap","pad","n","hasBounds","width","height","boundTest","scale","orient","tolerance","range","Infinity","expand","encloses","reset","reduce","method","separation","materialize","SOURCE","test","sort","slice","boundScale","boundTolerance","boundOrient","Render","ALL","fields","tempBounds","property","isYAxis","axisIndices","datum","grid","ticks","labels","domain","axisLayout","axis","delta","translate","indices","offset","position","minExtent","maxExtent","title","titlePadding","dl","x","y","s","min","axisTitleLayout","sign","auto","v","dx","dy","floor","ceil","gridLayoutGroups","views","marks","rowheaders","rowfooters","colheaders","colfooters","rowtitle","coltitle","push","bboxFlush","bboxFull","clone","empty","key","d","undefined","offsetValue","gridLayout","nodirty","bbox","alignCol","align","alignRow","padCol","padding","padRow","ncols","columns","nrows","xOffset","Array","xExtent","xMax","yOffset","yExtent","yMax","boxes","m","c","r","px","py","center","anchor","round","trellisLayout","boundFlush","boundFull","off","cells","band","headerBand","layoutHeaders","footerBand","titleAnchor","titleBand","layoutTitle","field","headers","limit","agg","isX","bf","start","stride","back","init","edge","j","k","h","warn","config","offsets","legends","legendParams","xb","yb","w","mult","column","row","legendLayout","legend","_bounds","legendGroupLayout","legendBounds","legendEntryLayout","ex","ey","tpad","tx","ty","legendTitleOffset","lr","noBar","grad","vgrad","e","u","o","entries","widths","titleLayout","viewBounds","frame","subtitle","end","sx","sy","pos","text","ViewLayout","layout","layoutGroup","shouldReflow","xBounds","yBounds","l","equals","autosize","viewSizeLayout","_autosize","viewWidth","_width","viewHeight","_height","left","top","right","bottom","contains","_resizeView","resize","identifier","overlap","render","viewlayout"],"sources":["C:/Users/sutul/node_modules/vega-view-transforms/build/vega-view-transforms.module.js"],"sourcesContent":["import { Transform } from 'vega-dataflow';\nimport { Marks, boundClip, GroupItem, Item, Bounds, multiLineOffset, boundStroke } from 'vega-scenegraph';\nimport { inherits, peek, isObject } from 'vega-util';\n\nconst Top = 'top';\nconst Left = 'left';\nconst Right = 'right';\nconst Bottom = 'bottom';\nconst TopLeft = 'top-left';\nconst TopRight = 'top-right';\nconst BottomLeft = 'bottom-left';\nconst BottomRight = 'bottom-right';\nconst Start = 'start';\nconst Middle = 'middle';\nconst End = 'end';\nconst X = 'x';\nconst Y = 'y';\nconst Group = 'group';\nconst AxisRole = 'axis';\nconst TitleRole = 'title';\nconst FrameRole = 'frame';\nconst ScopeRole = 'scope';\nconst LegendRole = 'legend';\nconst RowHeader = 'row-header';\nconst RowFooter = 'row-footer';\nconst RowTitle = 'row-title';\nconst ColHeader = 'column-header';\nconst ColFooter = 'column-footer';\nconst ColTitle = 'column-title';\nconst Padding = 'padding';\nconst Symbols = 'symbol';\nconst Fit = 'fit';\nconst FitX = 'fit-x';\nconst FitY = 'fit-y';\nconst Pad = 'pad';\nconst None = 'none';\nconst All = 'all';\nconst Each = 'each';\nconst Flush = 'flush';\nconst Column = 'column';\nconst Row = 'row';\n\n/**\n * Calculate bounding boxes for scenegraph items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - The scenegraph mark instance to bound.\n */\nfunction Bound(params) {\n  Transform.call(this, null, params);\n}\ninherits(Bound, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow,\n      mark = _.mark,\n      type = mark.marktype,\n      entry = Marks[type],\n      bound = entry.bound;\n    let markBounds = mark.bounds,\n      rebound;\n    if (entry.nested) {\n      // multi-item marks have a single bounds instance\n      if (mark.items.length) view.dirty(mark.items[0]);\n      markBounds = boundItem(mark, bound);\n      mark.items.forEach(item => {\n        item.bounds.clear().union(markBounds);\n      });\n    } else if (type === Group || _.modified()) {\n      // operator parameters modified -> re-bound all items\n      // updates group bounds in response to modified group content\n      pulse.visit(pulse.MOD, item => view.dirty(item));\n      markBounds.clear();\n      mark.items.forEach(item => markBounds.union(boundItem(item, bound)));\n\n      // force reflow for axes/legends/titles to propagate any layout changes\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          pulse.reflow();\n      }\n    } else {\n      // incrementally update bounds, re-bound mark as needed\n      rebound = pulse.changed(pulse.REM);\n      pulse.visit(pulse.ADD, item => {\n        markBounds.union(boundItem(item, bound));\n      });\n      pulse.visit(pulse.MOD, item => {\n        rebound = rebound || markBounds.alignsWith(item.bounds);\n        view.dirty(item);\n        markBounds.union(boundItem(item, bound));\n      });\n      if (rebound) {\n        markBounds.clear();\n        mark.items.forEach(item => markBounds.union(item.bounds));\n      }\n    }\n\n    // ensure mark bounds do not exceed any clipping region\n    boundClip(mark);\n    return pulse.modifies('bounds');\n  }\n});\nfunction boundItem(item, bound, opt) {\n  return bound(item.bounds.clear(), item, opt);\n}\n\nconst COUNTER_NAME = ':vega_identifier:';\n\n/**\n * Adds a unique identifier to all added tuples.\n * This transform creates a new signal that serves as an id counter.\n * As a result, the id counter is shared across all instances of this\n * transform, generating unique ids across multiple data streams. In\n * addition, this signal value can be included in a snapshot of the\n * dataflow state, enabling correct resumption of id allocation.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.as - The field name for the generated identifier.\n */\nfunction Identifier(params) {\n  Transform.call(this, 0, params);\n}\nIdentifier.Definition = {\n  'type': 'Identifier',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'as',\n    'type': 'string',\n    'required': true\n  }]\n};\ninherits(Identifier, Transform, {\n  transform(_, pulse) {\n    const counter = getCounter(pulse.dataflow),\n      as = _.as;\n    let id = counter.value;\n    pulse.visit(pulse.ADD, t => t[as] = t[as] || ++id);\n    counter.set(this.value = id);\n    return pulse;\n  }\n});\nfunction getCounter(view) {\n  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));\n}\n\n/**\n * Bind scenegraph items to a scenegraph mark instance.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.markdef - The mark definition for creating the mark.\n *   This is an object of legal scenegraph mark properties which *must* include\n *   the 'marktype' property.\n */\nfunction Mark(params) {\n  Transform.call(this, null, params);\n}\ninherits(Mark, Transform, {\n  transform(_, pulse) {\n    let mark = this.value;\n\n    // acquire mark on first invocation, bind context and group\n    if (!mark) {\n      mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup$1(_), _.index);\n      mark.group.context = _.context;\n      if (!_.context.group) _.context.group = mark.group;\n      mark.source = this.source; // point to upstream collector\n      mark.clip = _.clip;\n      mark.interactive = _.interactive;\n      this.value = mark;\n    }\n\n    // initialize entering items\n    const Init = mark.marktype === Group ? GroupItem : Item;\n    pulse.visit(pulse.ADD, item => Init.call(item, mark));\n\n    // update clipping and/or interactive status\n    if (_.modified('clip') || _.modified('interactive')) {\n      mark.clip = _.clip;\n      mark.interactive = !!_.interactive;\n      mark.zdirty = true; // force scenegraph re-eval\n      pulse.reflow();\n    }\n\n    // bind items array to scenegraph mark\n    mark.items = pulse.source;\n    return pulse;\n  }\n});\nfunction lookup$1(_) {\n  const g = _.groups,\n    p = _.parent;\n  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;\n}\n\n/**\n * Analyze items for overlap, changing opacity to hide items with\n * overlapping bounding boxes. This transform will preserve at least\n * two items (e.g., first and last) even if overlap persists.\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting items.\n * @param {object} [params.method] - The overlap removal method to apply.\n *   One of 'parity' (default, hide every other item until there is no\n *   more overlap) or 'greedy' (sequentially scan and hide and items that\n *   overlap with the last visible item).\n * @param {object} [params.boundScale] - A scale whose range should be used\n *   to bound the items. Items exceeding the bounds of the scale range\n *   will be treated as overlapping. If null or undefined, no bounds check\n *   will be applied.\n * @param {object} [params.boundOrient] - The orientation of the scale\n *   (top, bottom, left, or right) used to bound items. This parameter is\n *   ignored if boundScale is null or undefined.\n * @param {object} [params.boundTolerance] - The tolerance in pixels for\n *   bound inclusion testing (default 1). This specifies by how many pixels\n *   an item's bounds may exceed the scale range bounds and not be culled.\n * @constructor\n */\nfunction Overlap(params) {\n  Transform.call(this, null, params);\n}\nconst methods = {\n  parity: items => items.filter((item, i) => i % 2 ? item.opacity = 0 : 1),\n  greedy: (items, sep) => {\n    let a;\n    return items.filter((b, i) => !i || !intersect(a.bounds, b.bounds, sep) ? (a = b, 1) : b.opacity = 0);\n  }\n};\n\n// compute bounding box intersection\n// including padding pixels of separation\nconst intersect = (a, b, sep) => sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);\nconst hasOverlap = (items, pad) => {\n  for (var i = 1, n = items.length, a = items[0].bounds, b; i < n; a = b, ++i) {\n    if (intersect(a, b = items[i].bounds, pad)) return true;\n  }\n};\nconst hasBounds = item => {\n  const b = item.bounds;\n  return b.width() > 1 && b.height() > 1;\n};\nconst boundTest = (scale, orient, tolerance) => {\n  var range = scale.range(),\n    b = new Bounds();\n  if (orient === Top || orient === Bottom) {\n    b.set(range[0], -Infinity, range[1], +Infinity);\n  } else {\n    b.set(-Infinity, range[0], +Infinity, range[1]);\n  }\n  b.expand(tolerance || 1);\n  return item => b.encloses(item.bounds);\n};\n\n// reset all items to be fully opaque\nconst reset = source => {\n  source.forEach(item => item.opacity = 1);\n  return source;\n};\n\n// add all tuples to mod, fork pulse if parameters were modified\n// fork prevents cross-stream tuple pollution (e.g., pulse from scale)\nconst reflow = (pulse, _) => pulse.reflow(_.modified()).modifies('opacity');\ninherits(Overlap, Transform, {\n  transform(_, pulse) {\n    const reduce = methods[_.method] || methods.parity,\n      sep = _.separation || 0;\n    let source = pulse.materialize(pulse.SOURCE).source,\n      items,\n      test;\n    if (!source || !source.length) return;\n    if (!_.method) {\n      // early exit if method is falsy\n      if (_.modified('method')) {\n        reset(source);\n        pulse = reflow(pulse, _);\n      }\n      return pulse;\n    }\n\n    // skip labels with no content\n    source = source.filter(hasBounds);\n\n    // early exit, nothing to do\n    if (!source.length) return;\n    if (_.sort) {\n      source = source.slice().sort(_.sort);\n    }\n    items = reset(source);\n    pulse = reflow(pulse, _);\n    if (items.length >= 3 && hasOverlap(items, sep)) {\n      do {\n        items = reduce(items, sep);\n      } while (items.length >= 3 && hasOverlap(items, sep));\n      if (items.length < 3 && !peek(source).opacity) {\n        if (items.length > 1) peek(items).opacity = 0;\n        peek(source).opacity = 1;\n      }\n    }\n    if (_.boundScale && _.boundTolerance >= 0) {\n      test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);\n      source.forEach(item => {\n        if (!test(item)) item.opacity = 0;\n      });\n    }\n\n    // re-calculate mark bounds\n    const bounds = items[0].mark.bounds.clear();\n    source.forEach(item => {\n      if (item.opacity) bounds.union(item.bounds);\n    });\n    return pulse;\n  }\n});\n\n/**\n * Queue modified scenegraph items for rendering.\n * @constructor\n */\nfunction Render(params) {\n  Transform.call(this, null, params);\n}\ninherits(Render, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n    pulse.visit(pulse.ALL, item => view.dirty(item));\n\n    // set z-index dirty flag as needed\n    if (pulse.fields && pulse.fields['zindex']) {\n      const item = pulse.source && pulse.source[0];\n      if (item) item.mark.zdirty = true;\n    }\n  }\n});\n\nconst tempBounds = new Bounds();\nfunction set(item, property, value) {\n  return item[property] === value ? 0 : (item[property] = value, 1);\n}\n\nfunction isYAxis(mark) {\n  var orient = mark.items[0].orient;\n  return orient === Left || orient === Right;\n}\nfunction axisIndices(datum) {\n  let index = +datum.grid;\n  return [datum.ticks ? index++ : -1,\n  // ticks index\n  datum.labels ? index++ : -1,\n  // labels index\n  index + +datum.domain // title index\n  ];\n}\nfunction axisLayout(view, axis, width, height) {\n  var item = axis.items[0],\n    datum = item.datum,\n    delta = item.translate != null ? item.translate : 0.5,\n    orient = item.orient,\n    indices = axisIndices(datum),\n    range = item.range,\n    offset = item.offset,\n    position = item.position,\n    minExtent = item.minExtent,\n    maxExtent = item.maxExtent,\n    title = datum.title && item.items[indices[2]].items[0],\n    titlePadding = item.titlePadding,\n    bounds = item.bounds,\n    dl = title && multiLineOffset(title),\n    x = 0,\n    y = 0,\n    i,\n    s;\n  tempBounds.clear().union(bounds);\n  bounds.clear();\n  if ((i = indices[0]) > -1) bounds.union(item.items[i].bounds);\n  if ((i = indices[1]) > -1) bounds.union(item.items[i].bounds);\n\n  // position axis group and title\n  switch (orient) {\n    case Top:\n      x = position || 0;\n      y = -offset;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));\n      bounds.add(0, -s).add(range, 0);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds);\n      break;\n    case Left:\n      x = -offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));\n      bounds.add(-s, 0).add(0, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds);\n      break;\n    case Right:\n      x = width + offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));\n      bounds.add(0, 0).add(s, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds);\n      break;\n    case Bottom:\n      x = position || 0;\n      y = height + offset;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));\n      bounds.add(0, 0).add(range, s);\n      if (title) axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds);\n      break;\n    default:\n      x = item.x;\n      y = item.y;\n  }\n\n  // update bounds\n  boundStroke(bounds.translate(x, y), item);\n  if (set(item, 'x', x + delta) | set(item, 'y', y + delta)) {\n    item.bounds = tempBounds;\n    view.dirty(item);\n    item.bounds = bounds;\n    view.dirty(item);\n  }\n  return item.mark.bounds.clear().union(bounds);\n}\nfunction axisTitleLayout(view, title, offset, pad, dl, isYAxis, sign, bounds) {\n  const b = title.bounds;\n  if (title.auto) {\n    const v = sign * (offset + dl + pad);\n    let dx = 0,\n      dy = 0;\n    view.dirty(title);\n    isYAxis ? dx = (title.x || 0) - (title.x = v) : dy = (title.y || 0) - (title.y = v);\n    title.mark.bounds.clear().union(b.translate(-dx, -dy));\n    view.dirty(title);\n  }\n  bounds.union(b);\n}\n\n// aggregation functions for grid margin determination\nconst min = (a, b) => Math.floor(Math.min(a, b));\nconst max = (a, b) => Math.ceil(Math.max(a, b));\nfunction gridLayoutGroups(group) {\n  var groups = group.items,\n    n = groups.length,\n    i = 0,\n    mark,\n    items;\n  const views = {\n    marks: [],\n    rowheaders: [],\n    rowfooters: [],\n    colheaders: [],\n    colfooters: [],\n    rowtitle: null,\n    coltitle: null\n  };\n\n  // layout axes, gather legends, collect bounds\n  for (; i < n; ++i) {\n    mark = groups[i];\n    items = mark.items;\n    if (mark.marktype === Group) {\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          break;\n        case RowHeader:\n          views.rowheaders.push(...items);\n          break;\n        case RowFooter:\n          views.rowfooters.push(...items);\n          break;\n        case ColHeader:\n          views.colheaders.push(...items);\n          break;\n        case ColFooter:\n          views.colfooters.push(...items);\n          break;\n        case RowTitle:\n          views.rowtitle = items[0];\n          break;\n        case ColTitle:\n          views.coltitle = items[0];\n          break;\n        default:\n          views.marks.push(...items);\n      }\n    }\n  }\n  return views;\n}\nfunction bboxFlush(item) {\n  return new Bounds().set(0, 0, item.width || 0, item.height || 0);\n}\nfunction bboxFull(item) {\n  const b = item.bounds.clone();\n  return b.empty() ? b.set(0, 0, 0, 0) : b.translate(-(item.x || 0), -(item.y || 0));\n}\nfunction get(opt, key, d) {\n  const v = isObject(opt) ? opt[key] : opt;\n  return v != null ? v : d !== undefined ? d : 0;\n}\nfunction offsetValue(v) {\n  return v < 0 ? Math.ceil(-v) : 0;\n}\nfunction gridLayout(view, groups, opt) {\n  var dirty = !opt.nodirty,\n    bbox = opt.bounds === Flush ? bboxFlush : bboxFull,\n    bounds = tempBounds.set(0, 0, 0, 0),\n    alignCol = get(opt.align, Column),\n    alignRow = get(opt.align, Row),\n    padCol = get(opt.padding, Column),\n    padRow = get(opt.padding, Row),\n    ncols = opt.columns || groups.length,\n    nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n    n = groups.length,\n    xOffset = Array(n),\n    xExtent = Array(ncols),\n    xMax = 0,\n    yOffset = Array(n),\n    yExtent = Array(nrows),\n    yMax = 0,\n    dx = Array(n),\n    dy = Array(n),\n    boxes = Array(n),\n    m,\n    i,\n    c,\n    r,\n    b,\n    g,\n    px,\n    py,\n    x,\n    y,\n    offset;\n  for (i = 0; i < ncols; ++i) xExtent[i] = 0;\n  for (i = 0; i < nrows; ++i) yExtent[i] = 0;\n\n  // determine offsets for each group\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    b = boxes[i] = bbox(g);\n    g.x = g.x || 0;\n    dx[i] = 0;\n    g.y = g.y || 0;\n    dy[i] = 0;\n    c = i % ncols;\n    r = ~~(i / ncols);\n    xMax = Math.max(xMax, px = Math.ceil(b.x2));\n    yMax = Math.max(yMax, py = Math.ceil(b.y2));\n    xExtent[c] = Math.max(xExtent[c], px);\n    yExtent[r] = Math.max(yExtent[r], py);\n    xOffset[i] = padCol + offsetValue(b.x1);\n    yOffset[i] = padRow + offsetValue(b.y1);\n    if (dirty) view.dirty(groups[i]);\n  }\n\n  // set initial alignment offsets\n  for (i = 0; i < n; ++i) {\n    if (i % ncols === 0) xOffset[i] = 0;\n    if (i < ncols) yOffset[i] = 0;\n  }\n\n  // enforce column alignment constraints\n  if (alignCol === Each) {\n    for (c = 1; c < ncols; ++c) {\n      for (offset = 0, i = c; i < n; i += ncols) {\n        if (offset < xOffset[i]) offset = xOffset[i];\n      }\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] = offset + xExtent[c - 1];\n      }\n    }\n  } else if (alignCol === All) {\n    for (offset = 0, i = 0; i < n; ++i) {\n      if (i % ncols && offset < xOffset[i]) offset = xOffset[i];\n    }\n    for (i = 0; i < n; ++i) {\n      if (i % ncols) xOffset[i] = offset + xMax;\n    }\n  } else {\n    for (alignCol = false, c = 1; c < ncols; ++c) {\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] += xExtent[c - 1];\n      }\n    }\n  }\n\n  // enforce row alignment constraints\n  if (alignRow === Each) {\n    for (r = 1; r < nrows; ++r) {\n      for (offset = 0, i = r * ncols, m = i + ncols; i < m; ++i) {\n        if (offset < yOffset[i]) offset = yOffset[i];\n      }\n      for (i = r * ncols; i < m; ++i) {\n        yOffset[i] = offset + yExtent[r - 1];\n      }\n    }\n  } else if (alignRow === All) {\n    for (offset = 0, i = ncols; i < n; ++i) {\n      if (offset < yOffset[i]) offset = yOffset[i];\n    }\n    for (i = ncols; i < n; ++i) {\n      yOffset[i] = offset + yMax;\n    }\n  } else {\n    for (alignRow = false, r = 1; r < nrows; ++r) {\n      for (i = r * ncols, m = i + ncols; i < m; ++i) {\n        yOffset[i] += yExtent[r - 1];\n      }\n    }\n  }\n\n  // perform horizontal grid layout\n  for (x = 0, i = 0; i < n; ++i) {\n    x = xOffset[i] + (i % ncols ? x : 0);\n    dx[i] += x - groups[i].x;\n  }\n\n  // perform vertical grid layout\n  for (c = 0; c < ncols; ++c) {\n    for (y = 0, i = c; i < n; i += ncols) {\n      y += yOffset[i];\n      dy[i] += y - groups[i].y;\n    }\n  }\n\n  // perform horizontal centering\n  if (alignCol && get(opt.center, Column) && nrows > 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignCol === All ? xMax : xExtent[i % ncols];\n      x = b - boxes[i].x2 - groups[i].x - dx[i];\n      if (x > 0) dx[i] += x / 2;\n    }\n  }\n\n  // perform vertical centering\n  if (alignRow && get(opt.center, Row) && ncols !== 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignRow === All ? yMax : yExtent[~~(i / ncols)];\n      y = b - boxes[i].y2 - groups[i].y - dy[i];\n      if (y > 0) dy[i] += y / 2;\n    }\n  }\n\n  // position grid relative to anchor\n  for (i = 0; i < n; ++i) {\n    bounds.union(boxes[i].translate(dx[i], dy[i]));\n  }\n  x = get(opt.anchor, X);\n  y = get(opt.anchor, Y);\n  switch (get(opt.anchor, Column)) {\n    case End:\n      x -= bounds.width();\n      break;\n    case Middle:\n      x -= bounds.width() / 2;\n  }\n  switch (get(opt.anchor, Row)) {\n    case End:\n      y -= bounds.height();\n      break;\n    case Middle:\n      y -= bounds.height() / 2;\n  }\n  x = Math.round(x);\n  y = Math.round(y);\n\n  // update mark positions, bounds, dirty\n  bounds.clear();\n  for (i = 0; i < n; ++i) {\n    groups[i].mark.bounds.clear();\n  }\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    g.x += dx[i] += x;\n    g.y += dy[i] += y;\n    bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));\n    if (dirty) view.dirty(g);\n  }\n  return bounds;\n}\nfunction trellisLayout(view, group, opt) {\n  var views = gridLayoutGroups(group),\n    groups = views.marks,\n    bbox = opt.bounds === Flush ? boundFlush : boundFull,\n    off = opt.offset,\n    ncols = opt.columns || groups.length,\n    nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n    cells = nrows * ncols,\n    x,\n    y,\n    x2,\n    y2,\n    anchor,\n    band,\n    offset;\n\n  // -- initial grid layout\n  const bounds = gridLayout(view, groups, opt);\n  if (bounds.empty()) bounds.set(0, 0, 0, 0); // empty grid\n\n  // -- layout grid headers and footers --\n\n  // perform row header layout\n  if (views.rowheaders) {\n    band = get(opt.headerBand, Row, null);\n    x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);\n  }\n\n  // perform column header layout\n  if (views.colheaders) {\n    band = get(opt.headerBand, Column, null);\n    y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);\n  }\n\n  // perform row footer layout\n  if (views.rowfooters) {\n    band = get(opt.footerBand, Row, null);\n    x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols - 1, ncols, 1, band);\n  }\n\n  // perform column footer layout\n  if (views.colfooters) {\n    band = get(opt.footerBand, Column, null);\n    y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get(off, 'columnFooter'), max, 1, bbox, 'y2', cells - ncols, 1, ncols, band);\n  }\n\n  // perform row title layout\n  if (views.rowtitle) {\n    anchor = get(opt.titleAnchor, Row);\n    offset = get(off, 'rowTitle');\n    offset = anchor === End ? x2 + offset : x - offset;\n    band = get(opt.titleBand, Row, 0.5);\n    layoutTitle(view, views.rowtitle, offset, 0, bounds, band);\n  }\n\n  // perform column title layout\n  if (views.coltitle) {\n    anchor = get(opt.titleAnchor, Column);\n    offset = get(off, 'columnTitle');\n    offset = anchor === End ? y2 + offset : y - offset;\n    band = get(opt.titleBand, Column, 0.5);\n    layoutTitle(view, views.coltitle, offset, 1, bounds, band);\n  }\n}\nfunction boundFlush(item, field) {\n  return field === 'x1' ? item.x || 0 : field === 'y1' ? item.y || 0 : field === 'x2' ? (item.x || 0) + (item.width || 0) : field === 'y2' ? (item.y || 0) + (item.height || 0) : undefined;\n}\nfunction boundFull(item, field) {\n  return item.bounds[field];\n}\nfunction layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {\n  var n = groups.length,\n    init = 0,\n    edge = 0,\n    i,\n    j,\n    k,\n    m,\n    b,\n    h,\n    g,\n    x,\n    y;\n\n  // if no groups, early exit and return 0\n  if (!n) return init;\n\n  // compute margin\n  for (i = start; i < n; i += stride) {\n    if (groups[i]) init = agg(init, bound(groups[i], bf));\n  }\n\n  // if no headers, return margin calculation\n  if (!headers.length) return init;\n\n  // check if number of headers exceeds number of rows or columns\n  if (headers.length > limit) {\n    view.warn('Grid headers exceed limit: ' + limit);\n    headers = headers.slice(0, limit);\n  }\n\n  // apply offset\n  init += offset;\n\n  // clear mark bounds for all headers\n  for (j = 0, m = headers.length; j < m; ++j) {\n    view.dirty(headers[j]);\n    headers[j].mark.bounds.clear();\n  }\n\n  // layout each header\n  for (i = start, j = 0, m = headers.length; j < m; ++j, i += stride) {\n    h = headers[j];\n    b = h.mark.bounds;\n\n    // search for nearest group to align to\n    // necessary if table has empty cells\n    for (k = i; k >= 0 && (g = groups[k]) == null; k -= back);\n\n    // assign coordinates and update bounds\n    if (isX) {\n      x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());\n      y = init;\n    } else {\n      x = init;\n      y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());\n    }\n    b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));\n    h.x = x;\n    h.y = y;\n    view.dirty(h);\n\n    // update current edge of layout bounds\n    edge = agg(edge, b[bf]);\n  }\n  return edge;\n}\nfunction layoutTitle(view, g, offset, isX, bounds, band) {\n  if (!g) return;\n  view.dirty(g);\n\n  // compute title coordinates\n  var x = offset,\n    y = offset;\n  isX ? x = Math.round(bounds.x1 + band * bounds.width()) : y = Math.round(bounds.y1 + band * bounds.height());\n\n  // assign coordinates and update bounds\n  g.bounds.translate(x - (g.x || 0), y - (g.y || 0));\n  g.mark.bounds.clear().union(g.bounds);\n  g.x = x;\n  g.y = y;\n\n  // queue title for redraw\n  view.dirty(g);\n}\n\n// utility for looking up legend layout configuration\nfunction lookup(config, orient) {\n  const opt = config[orient] || {};\n  return (key, d) => opt[key] != null ? opt[key] : config[key] != null ? config[key] : d;\n}\n\n// if legends specify offset directly, use the maximum specified value\nfunction offsets(legends, value) {\n  let max = -Infinity;\n  legends.forEach(item => {\n    if (item.offset != null) max = Math.max(max, item.offset);\n  });\n  return max > -Infinity ? max : value;\n}\nfunction legendParams(g, orient, config, xb, yb, w, h) {\n  const _ = lookup(config, orient),\n    offset = offsets(g, _('offset', 0)),\n    anchor = _('anchor', Start),\n    mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;\n  const p = {\n    align: Each,\n    bounds: _('bounds', Flush),\n    columns: _('direction') === 'vertical' ? 1 : g.length,\n    padding: _('margin', 8),\n    center: _('center'),\n    nodirty: true\n  };\n  switch (orient) {\n    case Left:\n      p.anchor = {\n        x: Math.floor(xb.x1) - offset,\n        column: End,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n    case Right:\n      p.anchor = {\n        x: Math.ceil(xb.x2) + offset,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n    case Top:\n      p.anchor = {\n        y: Math.floor(yb.y1) - offset,\n        row: End,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n    case Bottom:\n      p.anchor = {\n        y: Math.ceil(yb.y2) + offset,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n    case TopLeft:\n      p.anchor = {\n        x: offset,\n        y: offset\n      };\n      break;\n    case TopRight:\n      p.anchor = {\n        x: w - offset,\n        y: offset,\n        column: End\n      };\n      break;\n    case BottomLeft:\n      p.anchor = {\n        x: offset,\n        y: h - offset,\n        row: End\n      };\n      break;\n    case BottomRight:\n      p.anchor = {\n        x: w - offset,\n        y: h - offset,\n        column: End,\n        row: End\n      };\n      break;\n  }\n  return p;\n}\nfunction legendLayout(view, legend) {\n  var item = legend.items[0],\n    datum = item.datum,\n    orient = item.orient,\n    bounds = item.bounds,\n    x = item.x,\n    y = item.y,\n    w,\n    h;\n\n  // cache current bounds for later comparison\n  item._bounds ? item._bounds.clear().union(bounds) : item._bounds = bounds.clone();\n  bounds.clear();\n\n  // adjust legend to accommodate padding and title\n  legendGroupLayout(view, item, item.items[0].items[0]);\n\n  // aggregate bounds to determine size, and include origin\n  bounds = legendBounds(item, bounds);\n  w = 2 * item.padding;\n  h = 2 * item.padding;\n  if (!bounds.empty()) {\n    w = Math.ceil(bounds.width() + w);\n    h = Math.ceil(bounds.height() + h);\n  }\n  if (datum.type === Symbols) {\n    legendEntryLayout(item.items[0].items[0].items[0].items);\n  }\n  if (orient !== None) {\n    item.x = x = 0;\n    item.y = y = 0;\n  }\n  item.width = w;\n  item.height = h;\n  boundStroke(bounds.set(x, y, x + w, y + h), item);\n  item.mark.bounds.clear().union(bounds);\n  return item;\n}\nfunction legendBounds(item, b) {\n  // aggregate item bounds\n  item.items.forEach(_ => b.union(_.bounds));\n\n  // anchor to legend origin\n  b.x1 = item.padding;\n  b.y1 = item.padding;\n  return b;\n}\nfunction legendGroupLayout(view, item, entry) {\n  var pad = item.padding,\n    ex = pad - entry.x,\n    ey = pad - entry.y;\n  if (!item.datum.title) {\n    if (ex || ey) translate(view, entry, ex, ey);\n  } else {\n    var title = item.items[1].items[0],\n      anchor = title.anchor,\n      tpad = item.titlePadding || 0,\n      tx = pad - title.x,\n      ty = pad - title.y;\n    switch (title.orient) {\n      case Left:\n        ex += Math.ceil(title.bounds.width()) + tpad;\n        break;\n      case Right:\n      case Bottom:\n        break;\n      default:\n        ey += title.bounds.height() + tpad;\n    }\n    if (ex || ey) translate(view, entry, ex, ey);\n    switch (title.orient) {\n      case Left:\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n      case Right:\n        tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n      case Bottom:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n        ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;\n        break;\n      default:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n    }\n    if (tx || ty) translate(view, title, tx, ty);\n\n    // translate legend if title pushes into negative coordinates\n    if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {\n      translate(view, entry, -tx, 0);\n      translate(view, title, -tx, 0);\n    }\n  }\n}\nfunction legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {\n  const grad = item.datum.type !== 'symbol',\n    vgrad = title.datum.vgrad,\n    e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,\n    s = e.bounds[y ? 'y2' : 'x2'] - item.padding,\n    u = vgrad && lr ? s : 0,\n    v = vgrad && lr ? 0 : s,\n    o = y <= 0 ? 0 : multiLineOffset(title);\n  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s - o));\n}\nfunction translate(view, item, dx, dy) {\n  item.x += dx;\n  item.y += dy;\n  item.bounds.translate(dx, dy);\n  item.mark.bounds.translate(dx, dy);\n  view.dirty(item);\n}\nfunction legendEntryLayout(entries) {\n  // get max widths for each column\n  const widths = entries.reduce((w, g) => {\n    w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);\n    return w;\n  }, {});\n\n  // set dimensions of legend entry groups\n  entries.forEach(g => {\n    g.width = widths[g.column];\n    g.height = g.bounds.y2 - g.y;\n  });\n}\n\nfunction titleLayout(view, mark, width, height, viewBounds) {\n  var group = mark.items[0],\n    frame = group.frame,\n    orient = group.orient,\n    anchor = group.anchor,\n    offset = group.offset,\n    padding = group.padding,\n    title = group.items[0].items[0],\n    subtitle = group.items[1] && group.items[1].items[0],\n    end = orient === Left || orient === Right ? height : width,\n    start = 0,\n    x = 0,\n    y = 0,\n    sx = 0,\n    sy = 0,\n    pos;\n  if (frame !== Group) {\n    orient === Left ? (start = viewBounds.y2, end = viewBounds.y1) : orient === Right ? (start = viewBounds.y1, end = viewBounds.y2) : (start = viewBounds.x1, end = viewBounds.x2);\n  } else if (orient === Left) {\n    start = height, end = 0;\n  }\n  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;\n  if (subtitle && subtitle.text) {\n    // position subtitle\n    switch (orient) {\n      case Top:\n      case Bottom:\n        sy = title.bounds.height() + padding;\n        break;\n      case Left:\n        sx = title.bounds.width() + padding;\n        break;\n      case Right:\n        sx = -title.bounds.width() - padding;\n        break;\n    }\n    tempBounds.clear().union(subtitle.bounds);\n    tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));\n    if (set(subtitle, 'x', sx) | set(subtitle, 'y', sy)) {\n      view.dirty(subtitle);\n      subtitle.bounds.clear().union(tempBounds);\n      subtitle.mark.bounds.clear().union(tempBounds);\n      view.dirty(subtitle);\n    }\n    tempBounds.clear().union(subtitle.bounds);\n  } else {\n    tempBounds.clear();\n  }\n  tempBounds.union(title.bounds);\n\n  // position title group\n  switch (orient) {\n    case Top:\n      x = pos;\n      y = viewBounds.y1 - tempBounds.height() - offset;\n      break;\n    case Left:\n      x = viewBounds.x1 - tempBounds.width() - offset;\n      y = pos;\n      break;\n    case Right:\n      x = viewBounds.x2 + tempBounds.width() + offset;\n      y = pos;\n      break;\n    case Bottom:\n      x = pos;\n      y = viewBounds.y2 + offset;\n      break;\n    default:\n      x = group.x;\n      y = group.y;\n  }\n  if (set(group, 'x', x) | set(group, 'y', y)) {\n    tempBounds.translate(x, y);\n    view.dirty(group);\n    group.bounds.clear().union(tempBounds);\n    mark.bounds.clear().union(tempBounds);\n    view.dirty(group);\n  }\n  return group.bounds;\n}\n\n/**\n * Layout view elements such as axes and legends.\n * Also performs size adjustments.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - Scenegraph mark of groups to layout.\n */\nfunction ViewLayout(params) {\n  Transform.call(this, null, params);\n}\ninherits(ViewLayout, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n    _.mark.items.forEach(group => {\n      if (_.layout) trellisLayout(view, group, _.layout);\n      layoutGroup(view, group, _);\n    });\n    return shouldReflow(_.mark.group) ? pulse.reflow() : pulse;\n  }\n});\nfunction shouldReflow(group) {\n  // We typically should reflow if layout is invoked (#2568), as child items\n  // may have resized and reflow ensures group bounds are re-calculated.\n  // However, legend entries have a special exception to avoid instability.\n  // For example, if a selected legend symbol gains a stroke on hover,\n  // we don't want to re-position subsequent elements in the legend.\n  return group && group.mark.role !== 'legend-entry';\n}\nfunction layoutGroup(view, group, _) {\n  var items = group.items,\n    width = Math.max(0, group.width || 0),\n    height = Math.max(0, group.height || 0),\n    viewBounds = new Bounds().set(0, 0, width, height),\n    xBounds = viewBounds.clone(),\n    yBounds = viewBounds.clone(),\n    legends = [],\n    title,\n    mark,\n    orient,\n    b,\n    i,\n    n;\n\n  // layout axes, gather legends, collect bounds\n  for (i = 0, n = items.length; i < n; ++i) {\n    mark = items[i];\n    switch (mark.role) {\n      case AxisRole:\n        b = isYAxis(mark) ? xBounds : yBounds;\n        b.union(axisLayout(view, mark, width, height));\n        break;\n      case TitleRole:\n        title = mark;\n        break;\n      case LegendRole:\n        legends.push(legendLayout(view, mark));\n        break;\n      case FrameRole:\n      case ScopeRole:\n      case RowHeader:\n      case RowFooter:\n      case RowTitle:\n      case ColHeader:\n      case ColFooter:\n      case ColTitle:\n        xBounds.union(mark.bounds);\n        yBounds.union(mark.bounds);\n        break;\n      default:\n        viewBounds.union(mark.bounds);\n    }\n  }\n\n  // layout legends, adjust viewBounds\n  if (legends.length) {\n    // group legends by orient\n    const l = {};\n    legends.forEach(item => {\n      orient = item.orient || Right;\n      if (orient !== None) (l[orient] || (l[orient] = [])).push(item);\n    });\n\n    // perform grid layout for each orient group\n    for (const orient in l) {\n      const g = l[orient];\n      gridLayout(view, g, legendParams(g, orient, _.legends, xBounds, yBounds, width, height));\n    }\n\n    // update view bounds\n    legends.forEach(item => {\n      const b = item.bounds;\n      if (!b.equals(item._bounds)) {\n        item.bounds = item._bounds;\n        view.dirty(item); // dirty previous location\n        item.bounds = b;\n        view.dirty(item);\n      }\n      if (_.autosize && (_.autosize.type === Fit || _.autosize.type === FitX || _.autosize.type === FitY)) {\n        // For autosize fit, incorporate the orthogonal dimension only.\n        // Legends that overrun the chart area will then be clipped;\n        // otherwise the chart area gets reduced to nothing!\n        switch (item.orient) {\n          case Left:\n          case Right:\n            viewBounds.add(b.x1, 0).add(b.x2, 0);\n            break;\n          case Top:\n          case Bottom:\n            viewBounds.add(0, b.y1).add(0, b.y2);\n        }\n      } else {\n        viewBounds.union(b);\n      }\n    });\n  }\n\n  // combine bounding boxes\n  viewBounds.union(xBounds).union(yBounds);\n\n  // layout title, adjust bounds\n  if (title) {\n    viewBounds.union(titleLayout(view, title, width, height, viewBounds));\n  }\n\n  // override aggregated view bounds if content is clipped\n  if (group.clip) {\n    viewBounds.set(0, 0, group.width || 0, group.height || 0);\n  }\n\n  // perform size adjustment\n  viewSizeLayout(view, group, viewBounds, _);\n}\nfunction viewSizeLayout(view, group, viewBounds, _) {\n  const auto = _.autosize || {},\n    type = auto.type;\n  if (view._autosize < 1 || !type) return;\n  let viewWidth = view._width,\n    viewHeight = view._height,\n    width = Math.max(0, group.width || 0),\n    left = Math.max(0, Math.ceil(-viewBounds.x1)),\n    height = Math.max(0, group.height || 0),\n    top = Math.max(0, Math.ceil(-viewBounds.y1));\n  const right = Math.max(0, Math.ceil(viewBounds.x2 - width)),\n    bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));\n  if (auto.contains === Padding) {\n    const padding = view.padding();\n    viewWidth -= padding.left + padding.right;\n    viewHeight -= padding.top + padding.bottom;\n  }\n  if (type === None) {\n    left = 0;\n    top = 0;\n    width = viewWidth;\n    height = viewHeight;\n  } else if (type === Fit) {\n    width = Math.max(0, viewWidth - left - right);\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === FitX) {\n    width = Math.max(0, viewWidth - left - right);\n    viewHeight = height + top + bottom;\n  } else if (type === FitY) {\n    viewWidth = width + left + right;\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === Pad) {\n    viewWidth = width + left + right;\n    viewHeight = height + top + bottom;\n  }\n  view._resizeView(viewWidth, viewHeight, width, height, [left, top], auto.resize);\n}\n\nexport { Bound as bound, Identifier as identifier, Mark as mark, Overlap as overlap, Render as render, ViewLayout as viewlayout };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}