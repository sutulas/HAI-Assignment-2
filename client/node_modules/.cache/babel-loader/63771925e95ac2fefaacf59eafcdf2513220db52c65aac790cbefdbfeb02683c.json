{"ast":null,"code":"import { array, hasOwnProperty, isBoolean } from 'vega-util';\nimport { SUM_OPS } from './aggregate';\nimport { getSecondaryRangeChannel, NONPOSITION_CHANNELS } from './channel';\nimport { channelDefType, getFieldDef, isFieldDef, isFieldOrDatumDef, vgField } from './channeldef';\nimport { channelHasField, isAggregate } from './encoding';\nimport * as log from './log';\nimport { ARC, AREA, BAR, CIRCLE, isMarkDef, isPathMark, LINE, POINT, RULE, SQUARE, TEXT, TICK } from './mark';\nimport { ScaleType } from './scale';\nconst STACK_OFFSET_INDEX = {\n  zero: 1,\n  center: 1,\n  normalize: 1\n};\nexport function isStackOffset(s) {\n  return hasOwnProperty(STACK_OFFSET_INDEX, s);\n}\nexport const STACKABLE_MARKS = new Set([ARC, BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK]);\nexport const STACK_BY_DEFAULT_MARKS = new Set([BAR, AREA, ARC]);\nfunction isUnbinnedQuantitative(channelDef) {\n  return isFieldDef(channelDef) && channelDefType(channelDef) === 'quantitative' && !channelDef.bin;\n}\nfunction potentialStackedChannel(encoding, x, _ref) {\n  let {\n    orient,\n    type: mark\n  } = _ref;\n  const y = x === 'x' ? 'y' : 'radius';\n  const isCartesianBarOrArea = x === 'x' && ['bar', 'area'].includes(mark);\n  const xDef = encoding[x];\n  const yDef = encoding[y];\n  if (isFieldDef(xDef) && isFieldDef(yDef)) {\n    if (isUnbinnedQuantitative(xDef) && isUnbinnedQuantitative(yDef)) {\n      if (xDef.stack) {\n        return x;\n      } else if (yDef.stack) {\n        return y;\n      }\n      const xAggregate = isFieldDef(xDef) && !!xDef.aggregate;\n      const yAggregate = isFieldDef(yDef) && !!yDef.aggregate;\n      // if there is no explicit stacking, only apply stack if there is only one aggregate for x or y\n      if (xAggregate !== yAggregate) {\n        return xAggregate ? x : y;\n      }\n      if (isCartesianBarOrArea) {\n        if (orient === 'vertical') {\n          return y;\n        } else if (orient === 'horizontal') {\n          return x;\n        }\n      }\n    } else if (isUnbinnedQuantitative(xDef)) {\n      return x;\n    } else if (isUnbinnedQuantitative(yDef)) {\n      return y;\n    }\n  } else if (isUnbinnedQuantitative(xDef)) {\n    if (isCartesianBarOrArea && orient === 'vertical') {\n      return undefined;\n    }\n    return x;\n  } else if (isUnbinnedQuantitative(yDef)) {\n    if (isCartesianBarOrArea && orient === 'horizontal') {\n      return undefined;\n    }\n    return y;\n  }\n  return undefined;\n}\nfunction getDimensionChannel(channel) {\n  switch (channel) {\n    case 'x':\n      return 'y';\n    case 'y':\n      return 'x';\n    case 'theta':\n      return 'radius';\n    case 'radius':\n      return 'theta';\n  }\n}\nexport function stack(m, encoding) {\n  const markDef = isMarkDef(m) ? m : {\n    type: m\n  };\n  const mark = markDef.type;\n  // Should have stackable mark\n  if (!STACKABLE_MARKS.has(mark)) {\n    return null;\n  }\n  // Run potential stacked twice, one for Cartesian and another for Polar,\n  // so text marks can be stacked in any of the coordinates.\n  // Note: The logic here is not perfectly correct.  If we want to support stacked dot plots where each dot is a pie chart with label, we have to change the stack logic here to separate Cartesian stacking for polar stacking.\n  // However, since we probably never want to do that, let's just note the limitation here.\n  const fieldChannel = potentialStackedChannel(encoding, 'x', markDef) || potentialStackedChannel(encoding, 'theta', markDef);\n  if (!fieldChannel) {\n    return null;\n  }\n  const stackedFieldDef = encoding[fieldChannel];\n  const stackedField = isFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : undefined;\n  const dimensionChannel = getDimensionChannel(fieldChannel);\n  const groupbyChannels = [];\n  const groupbyFields = new Set();\n  if (encoding[dimensionChannel]) {\n    const dimensionDef = encoding[dimensionChannel];\n    const dimensionField = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : undefined;\n    if (dimensionField && dimensionField !== stackedField) {\n      // avoid grouping by the stacked field\n      groupbyChannels.push(dimensionChannel);\n      groupbyFields.add(dimensionField);\n    }\n  }\n  const dimensionOffsetChannel = dimensionChannel === 'x' ? 'xOffset' : 'yOffset';\n  const dimensionOffsetDef = encoding[dimensionOffsetChannel];\n  const dimensionOffsetField = isFieldDef(dimensionOffsetDef) ? vgField(dimensionOffsetDef, {}) : undefined;\n  if (dimensionOffsetField && dimensionOffsetField !== stackedField) {\n    // avoid grouping by the stacked field\n    groupbyChannels.push(dimensionOffsetChannel);\n    groupbyFields.add(dimensionOffsetField);\n  }\n  // If the dimension has offset, don't stack anymore\n  // Should have grouping level of detail that is different from the dimension field\n  const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {\n    // Ignore tooltip in stackBy (https://github.com/vega/vega-lite/issues/4001)\n    if (channel !== 'tooltip' && channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      for (const cDef of array(channelDef)) {\n        const fieldDef = getFieldDef(cDef);\n        if (fieldDef.aggregate) {\n          continue;\n        }\n        // Check whether the channel's field is identical to x/y's field or if the channel is a repeat\n        const f = vgField(fieldDef, {});\n        if (\n        // if fielddef is a repeat, just include it in the stack by\n        !f ||\n        // otherwise, the field must be different from the groupBy fields.\n        !groupbyFields.has(f)) {\n          sc.push({\n            channel,\n            fieldDef\n          });\n        }\n      }\n    }\n    return sc;\n  }, []);\n  // Automatically determine offset\n  let offset;\n  if (stackedFieldDef.stack !== undefined) {\n    if (isBoolean(stackedFieldDef.stack)) {\n      offset = stackedFieldDef.stack ? 'zero' : null;\n    } else {\n      offset = stackedFieldDef.stack;\n    }\n  } else if (STACK_BY_DEFAULT_MARKS.has(mark)) {\n    offset = 'zero';\n  }\n  if (!offset || !isStackOffset(offset)) {\n    return null;\n  }\n  if (isAggregate(encoding) && stackBy.length === 0) {\n    return null;\n  }\n  // warn when stacking non-linear\n  if (stackedFieldDef?.scale?.type && stackedFieldDef?.scale?.type !== ScaleType.LINEAR) {\n    if (stackedFieldDef?.stack) {\n      log.warn(log.message.stackNonLinearScale(stackedFieldDef.scale.type));\n    }\n  }\n  // Check if it is a ranged mark\n  if (isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)])) {\n    if (stackedFieldDef.stack !== undefined) {\n      log.warn(log.message.cannotStackRangedMark(fieldChannel));\n    }\n    return null;\n  }\n  // Warn if stacking non-summative aggregate\n  if (isFieldDef(stackedFieldDef) && stackedFieldDef.aggregate && !SUM_OPS.has(stackedFieldDef.aggregate)) {\n    log.warn(log.message.stackNonSummativeAggregate(stackedFieldDef.aggregate));\n  }\n  return {\n    groupbyChannels,\n    groupbyFields,\n    fieldChannel,\n    impute: stackedFieldDef.impute === null ? false : isPathMark(mark),\n    stackBy,\n    offset\n  };\n}","map":{"version":3,"names":["array","hasOwnProperty","isBoolean","SUM_OPS","getSecondaryRangeChannel","NONPOSITION_CHANNELS","channelDefType","getFieldDef","isFieldDef","isFieldOrDatumDef","vgField","channelHasField","isAggregate","log","ARC","AREA","BAR","CIRCLE","isMarkDef","isPathMark","LINE","POINT","RULE","SQUARE","TEXT","TICK","ScaleType","STACK_OFFSET_INDEX","zero","center","normalize","isStackOffset","s","STACKABLE_MARKS","Set","STACK_BY_DEFAULT_MARKS","isUnbinnedQuantitative","channelDef","bin","potentialStackedChannel","encoding","x","_ref","orient","type","mark","y","isCartesianBarOrArea","includes","xDef","yDef","stack","xAggregate","aggregate","yAggregate","undefined","getDimensionChannel","channel","m","markDef","has","fieldChannel","stackedFieldDef","stackedField","dimensionChannel","groupbyChannels","groupbyFields","dimensionDef","dimensionField","push","add","dimensionOffsetChannel","dimensionOffsetDef","dimensionOffsetField","stackBy","reduce","sc","cDef","fieldDef","f","offset","length","scale","LINEAR","warn","message","stackNonLinearScale","cannotStackRangedMark","stackNonSummativeAggregate","impute"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\stack.ts"],"sourcesContent":["import {array, hasOwnProperty, isBoolean} from 'vega-util';\nimport {Aggregate, SUM_OPS} from './aggregate';\nimport {getSecondaryRangeChannel, NonPositionChannel, NONPOSITION_CHANNELS} from './channel';\nimport {\n  channelDefType,\n  FieldName,\n  getFieldDef,\n  isFieldDef,\n  isFieldOrDatumDef,\n  PositionDatumDef,\n  PositionDef,\n  PositionFieldDef,\n  TypedFieldDef,\n  vgField\n} from './channeldef';\nimport {CompositeAggregate} from './compositemark';\nimport {channelHasField, Encoding, isAggregate} from './encoding';\nimport * as log from './log';\nimport {\n  ARC,\n  AREA,\n  BAR,\n  CIRCLE,\n  isMarkDef,\n  isPathMark,\n  LINE,\n  Mark,\n  MarkDef,\n  POINT,\n  RULE,\n  SQUARE,\n  TEXT,\n  TICK\n} from './mark';\nimport {ScaleType} from './scale';\n\nconst STACK_OFFSET_INDEX = {\n  zero: 1,\n  center: 1,\n  normalize: 1\n} as const;\n\nexport type StackOffset = keyof typeof STACK_OFFSET_INDEX;\n\nexport function isStackOffset(s: string): s is StackOffset {\n  return hasOwnProperty(STACK_OFFSET_INDEX, s);\n}\n\nexport interface StackProperties {\n  /** Dimension axis of the stack. */\n  groupbyChannels: ('x' | 'y' | 'theta' | 'radius' | 'xOffset' | 'yOffset')[];\n\n  /** Field for groupbyChannel. */\n  groupbyFields: Set<FieldName>;\n\n  /** Measure axis of the stack. */\n  fieldChannel: 'x' | 'y' | 'theta' | 'radius';\n\n  /** Stack-by fields e.g., color, detail */\n  stackBy: {\n    fieldDef: TypedFieldDef<string>;\n    channel: NonPositionChannel;\n  }[];\n\n  /**\n   * See `stack` property of Position Field Def.\n   */\n  offset: StackOffset;\n\n  /**\n   * Whether this stack will produce impute transform\n   */\n  impute: boolean;\n}\n\nexport const STACKABLE_MARKS = new Set<Mark>([ARC, BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK]);\nexport const STACK_BY_DEFAULT_MARKS = new Set<Mark>([BAR, AREA, ARC]);\n\nfunction isUnbinnedQuantitative(channelDef: PositionDef<string>) {\n  return isFieldDef(channelDef) && channelDefType(channelDef) === 'quantitative' && !channelDef.bin;\n}\n\nfunction potentialStackedChannel(\n  encoding: Encoding<string>,\n  x: 'x' | 'theta',\n  {orient, type: mark}: MarkDef\n): 'x' | 'y' | 'theta' | 'radius' | undefined {\n  const y = x === 'x' ? 'y' : 'radius';\n\n  const isCartesianBarOrArea = x === 'x' && ['bar', 'area'].includes(mark);\n\n  const xDef = encoding[x];\n  const yDef = encoding[y];\n\n  if (isFieldDef(xDef) && isFieldDef(yDef)) {\n    if (isUnbinnedQuantitative(xDef) && isUnbinnedQuantitative(yDef)) {\n      if (xDef.stack) {\n        return x;\n      } else if (yDef.stack) {\n        return y;\n      }\n      const xAggregate = isFieldDef(xDef) && !!xDef.aggregate;\n      const yAggregate = isFieldDef(yDef) && !!yDef.aggregate;\n      // if there is no explicit stacking, only apply stack if there is only one aggregate for x or y\n      if (xAggregate !== yAggregate) {\n        return xAggregate ? x : y;\n      }\n\n      if (isCartesianBarOrArea) {\n        if (orient === 'vertical') {\n          return y;\n        } else if (orient === 'horizontal') {\n          return x;\n        }\n      }\n    } else if (isUnbinnedQuantitative(xDef)) {\n      return x;\n    } else if (isUnbinnedQuantitative(yDef)) {\n      return y;\n    }\n  } else if (isUnbinnedQuantitative(xDef)) {\n    if (isCartesianBarOrArea && orient === 'vertical') {\n      return undefined;\n    }\n    return x;\n  } else if (isUnbinnedQuantitative(yDef)) {\n    if (isCartesianBarOrArea && orient === 'horizontal') {\n      return undefined;\n    }\n    return y;\n  }\n  return undefined;\n}\n\nfunction getDimensionChannel(channel: 'x' | 'y' | 'theta' | 'radius') {\n  switch (channel) {\n    case 'x':\n      return 'y';\n    case 'y':\n      return 'x';\n    case 'theta':\n      return 'radius';\n    case 'radius':\n      return 'theta';\n  }\n}\n\nexport function stack(m: Mark | MarkDef, encoding: Encoding<string>): StackProperties {\n  const markDef = isMarkDef(m) ? m : {type: m};\n  const mark = markDef.type;\n\n  // Should have stackable mark\n  if (!STACKABLE_MARKS.has(mark)) {\n    return null;\n  }\n\n  // Run potential stacked twice, one for Cartesian and another for Polar,\n  // so text marks can be stacked in any of the coordinates.\n\n  // Note: The logic here is not perfectly correct.  If we want to support stacked dot plots where each dot is a pie chart with label, we have to change the stack logic here to separate Cartesian stacking for polar stacking.\n  // However, since we probably never want to do that, let's just note the limitation here.\n  const fieldChannel =\n    potentialStackedChannel(encoding, 'x', markDef) || potentialStackedChannel(encoding, 'theta', markDef);\n\n  if (!fieldChannel) {\n    return null;\n  }\n\n  const stackedFieldDef = encoding[fieldChannel] as PositionFieldDef<string> | PositionDatumDef<string>;\n  const stackedField = isFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : undefined;\n\n  const dimensionChannel: 'x' | 'y' | 'theta' | 'radius' = getDimensionChannel(fieldChannel);\n  const groupbyChannels: StackProperties['groupbyChannels'] = [];\n  const groupbyFields: Set<FieldName> = new Set();\n\n  if (encoding[dimensionChannel]) {\n    const dimensionDef = encoding[dimensionChannel];\n    const dimensionField = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : undefined;\n\n    if (dimensionField && dimensionField !== stackedField) {\n      // avoid grouping by the stacked field\n      groupbyChannels.push(dimensionChannel);\n      groupbyFields.add(dimensionField);\n    }\n  }\n\n  const dimensionOffsetChannel = dimensionChannel === 'x' ? 'xOffset' : 'yOffset';\n  const dimensionOffsetDef = encoding[dimensionOffsetChannel];\n  const dimensionOffsetField = isFieldDef(dimensionOffsetDef) ? vgField(dimensionOffsetDef, {}) : undefined;\n\n  if (dimensionOffsetField && dimensionOffsetField !== stackedField) {\n    // avoid grouping by the stacked field\n    groupbyChannels.push(dimensionOffsetChannel);\n    groupbyFields.add(dimensionOffsetField);\n  }\n\n  // If the dimension has offset, don't stack anymore\n\n  // Should have grouping level of detail that is different from the dimension field\n  const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {\n    // Ignore tooltip in stackBy (https://github.com/vega/vega-lite/issues/4001)\n    if (channel !== 'tooltip' && channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      for (const cDef of array(channelDef)) {\n        const fieldDef = getFieldDef(cDef);\n        if (fieldDef.aggregate) {\n          continue;\n        }\n\n        // Check whether the channel's field is identical to x/y's field or if the channel is a repeat\n        const f = vgField(fieldDef, {});\n        if (\n          // if fielddef is a repeat, just include it in the stack by\n          !f ||\n          // otherwise, the field must be different from the groupBy fields.\n          !groupbyFields.has(f)\n        ) {\n          sc.push({channel, fieldDef});\n        }\n      }\n    }\n    return sc;\n  }, []);\n\n  // Automatically determine offset\n  let offset: StackOffset;\n  if (stackedFieldDef.stack !== undefined) {\n    if (isBoolean(stackedFieldDef.stack)) {\n      offset = stackedFieldDef.stack ? 'zero' : null;\n    } else {\n      offset = stackedFieldDef.stack;\n    }\n  } else if (STACK_BY_DEFAULT_MARKS.has(mark)) {\n    offset = 'zero';\n  }\n\n  if (!offset || !isStackOffset(offset)) {\n    return null;\n  }\n\n  if (isAggregate(encoding) && stackBy.length === 0) {\n    return null;\n  }\n\n  // warn when stacking non-linear\n  if (stackedFieldDef?.scale?.type && stackedFieldDef?.scale?.type !== ScaleType.LINEAR) {\n    if (stackedFieldDef?.stack) {\n      log.warn(log.message.stackNonLinearScale(stackedFieldDef.scale.type));\n    }\n  }\n\n  // Check if it is a ranged mark\n  if (isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)])) {\n    if (stackedFieldDef.stack !== undefined) {\n      log.warn(log.message.cannotStackRangedMark(fieldChannel));\n    }\n    return null;\n  }\n\n  // Warn if stacking non-summative aggregate\n  if (\n    isFieldDef(stackedFieldDef) &&\n    stackedFieldDef.aggregate &&\n    !(SUM_OPS as Set<Aggregate | CompositeAggregate>).has(stackedFieldDef.aggregate)\n  ) {\n    log.warn(log.message.stackNonSummativeAggregate(stackedFieldDef.aggregate));\n  }\n\n  return {\n    groupbyChannels,\n    groupbyFields,\n    fieldChannel,\n    impute: stackedFieldDef.impute === null ? false : isPathMark(mark),\n    stackBy,\n    offset\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}