{"ast":null,"code":"import { isBinning } from '../../bin';\nimport { getSizeChannel, isColorChannel, isScaleChannel, isXorY, isXorYOffset, rangeType } from '../../channel';\nimport { isFieldDef, isPositionFieldOrDatumDef } from '../../channeldef';\nimport * as log from '../../log';\nimport { isRelativeBandSize } from '../../mark';\nimport { channelSupportScaleType, scaleTypeSupportDataType } from '../../scale';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport * as util from '../../util';\nimport { POLAR_POSITION_SCALE_CHANNEL_INDEX } from './../../channel';\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\n// NOTE: CompassQL uses this method.\nexport function scaleType(specifiedScale, channel, fieldDef, mark) {\n  let hasNestedOffsetScale = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  const defaultScaleType = defaultType(channel, fieldDef, mark, hasNestedOffsetScale);\n  const {\n    type\n  } = specifiedScale;\n  if (!isScaleChannel(channel)) {\n    // There is no scale for these channels\n    return null;\n  }\n  if (type !== undefined) {\n    // Check if explicitly specified scale type is supported by the channel\n    if (!channelSupportScaleType(channel, type)) {\n      log.warn(log.message.scaleTypeNotWorkWithChannel(channel, type, defaultScaleType));\n      return defaultScaleType;\n    }\n    // Check if explicitly specified scale type is supported by the data type\n    if (isFieldDef(fieldDef) && !scaleTypeSupportDataType(type, fieldDef.type)) {\n      log.warn(log.message.scaleTypeNotWorkWithFieldDef(type, defaultScaleType));\n      return defaultScaleType;\n    }\n    return type;\n  }\n  return defaultScaleType;\n}\n/**\n * Determine appropriate default scale type.\n */\n// NOTE: Voyager uses this method.\nfunction defaultType(channel, fieldDef, mark, hasNestedOffsetScale) {\n  switch (fieldDef.type) {\n    case 'nominal':\n    case 'ordinal':\n      {\n        if (isColorChannel(channel) || rangeType(channel) === 'discrete') {\n          if (channel === 'shape' && fieldDef.type === 'ordinal') {\n            log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n          }\n          return 'ordinal';\n        }\n        if (isXorY(channel) || isXorYOffset(channel)) {\n          if (util.contains(['rect', 'bar', 'image', 'rule', 'tick'], mark.type)) {\n            // The rect/bar/tick mark should fit into a band.\n            // For rule, using band scale to make rule align with axis ticks better https://github.com/vega/vega-lite/issues/3429\n            return 'band';\n          }\n          if (hasNestedOffsetScale) {\n            // If there is a nested offset scale, then there is a \"band\" for the span of the nested scale.\n            return 'band';\n          }\n        } else if (mark.type === 'arc' && channel in POLAR_POSITION_SCALE_CHANNEL_INDEX) {\n          return 'band';\n        }\n        const dimensionSize = mark[getSizeChannel(channel)];\n        if (isRelativeBandSize(dimensionSize)) {\n          return 'band';\n        }\n        if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis?.tickBand) {\n          return 'band';\n        }\n        // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n        return 'point';\n      }\n    case 'temporal':\n      if (isColorChannel(channel)) {\n        return 'time';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      } else if (isFieldDef(fieldDef) && fieldDef.timeUnit && normalizeTimeUnit(fieldDef.timeUnit).utc) {\n        return 'utc';\n      }\n      return 'time';\n    case 'quantitative':\n      if (isColorChannel(channel)) {\n        if (isFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n          return 'bin-ordinal';\n        }\n        return 'linear';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      }\n      return 'linear';\n    case 'geojson':\n      return undefined;\n  }\n  /* istanbul ignore next: should never reach this */\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}","map":{"version":3,"names":["isBinning","getSizeChannel","isColorChannel","isScaleChannel","isXorY","isXorYOffset","rangeType","isFieldDef","isPositionFieldOrDatumDef","log","isRelativeBandSize","channelSupportScaleType","scaleTypeSupportDataType","normalizeTimeUnit","util","POLAR_POSITION_SCALE_CHANNEL_INDEX","scaleType","specifiedScale","channel","fieldDef","mark","hasNestedOffsetScale","arguments","length","undefined","defaultScaleType","defaultType","type","warn","message","scaleTypeNotWorkWithChannel","scaleTypeNotWorkWithFieldDef","discreteChannelCannotEncode","contains","dimensionSize","axis","tickBand","timeUnit","utc","bin","Error","invalidFieldType"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\scale\\type.ts"],"sourcesContent":["import {isBinning} from '../../bin';\nimport {\n  getSizeChannel,\n  isColorChannel,\n  isScaleChannel,\n  isXorY,\n  isXorYOffset,\n  rangeType,\n  ScaleChannel\n} from '../../channel';\nimport {DatumDef, isFieldDef, isPositionFieldOrDatumDef, ScaleDatumDef, TypedFieldDef} from '../../channeldef';\nimport * as log from '../../log';\nimport {isRelativeBandSize, MarkDef} from '../../mark';\nimport {channelSupportScaleType, Scale, ScaleType, scaleTypeSupportDataType} from '../../scale';\nimport {normalizeTimeUnit} from '../../timeunit';\nimport * as util from '../../util';\nimport {POLAR_POSITION_SCALE_CHANNEL_INDEX} from './../../channel';\n\nexport type RangeType = 'continuous' | 'discrete' | 'flexible' | undefined;\n\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\n// NOTE: CompassQL uses this method.\nexport function scaleType(\n  specifiedScale: Scale,\n  channel: ScaleChannel,\n  fieldDef: TypedFieldDef<string> | DatumDef,\n  mark: MarkDef,\n  hasNestedOffsetScale = false\n): ScaleType {\n  const defaultScaleType = defaultType(channel, fieldDef, mark, hasNestedOffsetScale);\n  const {type} = specifiedScale;\n\n  if (!isScaleChannel(channel)) {\n    // There is no scale for these channels\n    return null;\n  }\n  if (type !== undefined) {\n    // Check if explicitly specified scale type is supported by the channel\n    if (!channelSupportScaleType(channel, type)) {\n      log.warn(log.message.scaleTypeNotWorkWithChannel(channel, type, defaultScaleType));\n      return defaultScaleType;\n    }\n\n    // Check if explicitly specified scale type is supported by the data type\n    if (isFieldDef(fieldDef) && !scaleTypeSupportDataType(type, fieldDef.type)) {\n      log.warn(log.message.scaleTypeNotWorkWithFieldDef(type, defaultScaleType));\n      return defaultScaleType;\n    }\n\n    return type;\n  }\n\n  return defaultScaleType;\n}\n\n/**\n * Determine appropriate default scale type.\n */\n// NOTE: Voyager uses this method.\nfunction defaultType(\n  channel: ScaleChannel,\n  fieldDef: TypedFieldDef<string> | ScaleDatumDef,\n  mark: MarkDef,\n  hasNestedOffsetScale: boolean\n): ScaleType {\n  switch (fieldDef.type) {\n    case 'nominal':\n    case 'ordinal': {\n      if (isColorChannel(channel) || rangeType(channel) === 'discrete') {\n        if (channel === 'shape' && fieldDef.type === 'ordinal') {\n          log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n        }\n        return 'ordinal';\n      }\n\n      if (isXorY(channel) || isXorYOffset(channel)) {\n        if (util.contains(['rect', 'bar', 'image', 'rule', 'tick'], mark.type)) {\n          // The rect/bar/tick mark should fit into a band.\n          // For rule, using band scale to make rule align with axis ticks better https://github.com/vega/vega-lite/issues/3429\n          return 'band';\n        }\n        if (hasNestedOffsetScale) {\n          // If there is a nested offset scale, then there is a \"band\" for the span of the nested scale.\n          return 'band';\n        }\n      } else if (mark.type === 'arc' && channel in POLAR_POSITION_SCALE_CHANNEL_INDEX) {\n        return 'band';\n      }\n\n      const dimensionSize = mark[getSizeChannel(channel)];\n      if (isRelativeBandSize(dimensionSize)) {\n        return 'band';\n      }\n\n      if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis?.tickBand) {\n        return 'band';\n      }\n      // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n      return 'point';\n    }\n\n    case 'temporal':\n      if (isColorChannel(channel)) {\n        return 'time';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      } else if (isFieldDef(fieldDef) && fieldDef.timeUnit && normalizeTimeUnit(fieldDef.timeUnit).utc) {\n        return 'utc';\n      }\n      return 'time';\n\n    case 'quantitative':\n      if (isColorChannel(channel)) {\n        if (isFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n          return 'bin-ordinal';\n        }\n\n        return 'linear';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      }\n\n      return 'linear';\n\n    case 'geojson':\n      return undefined;\n  }\n\n  /* istanbul ignore next: should never reach this */\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}