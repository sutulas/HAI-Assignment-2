{"ast":null,"code":"import { parseSelector } from 'vega-event-selector';\nimport { identity, isArray, stringValue } from 'vega-util';\nimport { MODIFY, STORE, unitName, VL_SELECTION_RESOLVE, TUPLE, selectionCompilers } from '.';\nimport { dateTimeToExpr, isDateTime, dateTimeToTimestamp } from '../../datetime';\nimport { hasContinuousDomain } from '../../scale';\nimport { SELECTION_ID } from '../../selection';\nimport { keys, replacePathInField, stringify, vals } from '../../util';\nimport { isUnitModel } from '../model';\nimport { parseSelectionExtent } from './parse';\nexport function assembleProjection(proj) {\n  const {\n    signals,\n    hasLegend,\n    index,\n    ...rest\n  } = proj;\n  rest.field = replacePathInField(rest.field);\n  return rest;\n}\nexport function assembleInit(init) {\n  let isExpr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let wrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n  if (isArray(init)) {\n    const assembled = init.map(v => assembleInit(v, isExpr, wrap));\n    return isExpr ? `[${assembled.join(', ')}]` : assembled;\n  } else if (isDateTime(init)) {\n    if (isExpr) {\n      return wrap(dateTimeToExpr(init));\n    } else {\n      return wrap(dateTimeToTimestamp(init));\n    }\n  }\n  return isExpr ? wrap(stringify(init)) : init;\n}\nexport function assembleUnitSelectionSignals(model, signals) {\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    const name = selCmpt.name;\n    let modifyExpr = `${name}${TUPLE}, ${selCmpt.resolve === 'global' ? 'true' : `{unit: ${unitName(model)}}`}`;\n    for (const c of selectionCompilers) {\n      if (!c.defined(selCmpt)) continue;\n      if (c.signals) signals = c.signals(model, selCmpt, signals);\n      if (c.modifyExpr) modifyExpr = c.modifyExpr(model, selCmpt, modifyExpr);\n    }\n    signals.push({\n      name: name + MODIFY,\n      on: [{\n        events: {\n          signal: selCmpt.name + TUPLE\n        },\n        update: `modify(${stringValue(selCmpt.name + STORE)}, ${modifyExpr})`\n      }]\n    });\n  }\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleFacetSignals(model, signals) {\n  if (model.component.selection && keys(model.component.selection).length) {\n    const name = stringValue(model.getName('cell'));\n    signals.unshift({\n      name: 'facet',\n      value: {},\n      on: [{\n        events: parseSelector('pointermove', 'scope'),\n        update: `isTuple(facet) ? facet : group(${name}).datum`\n      }]\n    });\n  }\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleTopLevelSignals(model, signals) {\n  let hasSelections = false;\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    const name = selCmpt.name;\n    const store = stringValue(name + STORE);\n    const hasSg = signals.filter(s => s.name === name);\n    if (hasSg.length === 0) {\n      const resolve = selCmpt.resolve === 'global' ? 'union' : selCmpt.resolve;\n      const isPoint = selCmpt.type === 'point' ? ', true, true)' : ')';\n      signals.push({\n        name: selCmpt.name,\n        update: `${VL_SELECTION_RESOLVE}(${store}, ${stringValue(resolve)}${isPoint}`\n      });\n    }\n    hasSelections = true;\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.topLevelSignals) {\n        signals = c.topLevelSignals(model, selCmpt, signals);\n      }\n    }\n  }\n  if (hasSelections) {\n    const hasUnit = signals.filter(s => s.name === 'unit');\n    if (hasUnit.length === 0) {\n      signals.unshift({\n        name: 'unit',\n        value: {},\n        on: [{\n          events: 'pointermove',\n          update: 'isTuple(group()) ? group() : unit'\n        }]\n      });\n    }\n  }\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleUnitSelectionData(model, data) {\n  const dataCopy = [...data];\n  const unit = unitName(model, {\n    escape: false\n  });\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    const store = {\n      name: selCmpt.name + STORE\n    };\n    if (selCmpt.project.hasSelectionId) {\n      store.transform = [{\n        type: 'collect',\n        sort: {\n          field: SELECTION_ID\n        }\n      }];\n    }\n    if (selCmpt.init) {\n      const fields = selCmpt.project.items.map(assembleProjection);\n      store.values = selCmpt.project.hasSelectionId ? selCmpt.init.map(i => ({\n        unit,\n        [SELECTION_ID]: assembleInit(i, false)[0]\n      })) : selCmpt.init.map(i => ({\n        unit,\n        fields,\n        values: assembleInit(i, false)\n      }));\n    }\n    const contains = dataCopy.filter(d => d.name === selCmpt.name + STORE);\n    if (!contains.length) {\n      dataCopy.push(store);\n    }\n  }\n  return dataCopy;\n}\nexport function assembleUnitSelectionMarks(model, marks) {\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.marks) {\n        marks = c.marks(model, selCmpt, marks);\n      }\n    }\n  }\n  return marks;\n}\nexport function assembleLayerSelectionMarks(model, marks) {\n  for (const child of model.children) {\n    if (isUnitModel(child)) {\n      marks = assembleUnitSelectionMarks(child, marks);\n    }\n  }\n  return marks;\n}\nexport function assembleSelectionScaleDomain(model, extent, scaleCmpt, domain) {\n  const parsedExtent = parseSelectionExtent(model, extent.param, extent);\n  return {\n    signal: hasContinuousDomain(scaleCmpt.get('type')) && isArray(domain) && domain[0] > domain[1] ? `isValid(${parsedExtent}) && reverse(${parsedExtent})` : parsedExtent\n  };\n}\nfunction cleanupEmptyOnArray(signals) {\n  return signals.map(s => {\n    if (s.on && !s.on.length) delete s.on;\n    return s;\n  });\n}","map":{"version":3,"names":["parseSelector","identity","isArray","stringValue","MODIFY","STORE","unitName","VL_SELECTION_RESOLVE","TUPLE","selectionCompilers","dateTimeToExpr","isDateTime","dateTimeToTimestamp","hasContinuousDomain","SELECTION_ID","keys","replacePathInField","stringify","vals","isUnitModel","parseSelectionExtent","assembleProjection","proj","signals","hasLegend","index","rest","field","assembleInit","init","isExpr","arguments","length","undefined","wrap","assembled","map","v","join","assembleUnitSelectionSignals","model","selCmpt","component","selection","name","modifyExpr","resolve","c","defined","push","on","events","signal","update","cleanupEmptyOnArray","assembleFacetSignals","getName","unshift","value","assembleTopLevelSignals","hasSelections","store","hasSg","filter","s","isPoint","type","topLevelSignals","hasUnit","assembleUnitSelectionData","data","dataCopy","unit","escape","project","hasSelectionId","transform","sort","fields","items","values","i","contains","d","assembleUnitSelectionMarks","marks","assembleLayerSelectionMarks","child","children","assembleSelectionScaleDomain","extent","scaleCmpt","domain","parsedExtent","param","get"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\selection\\assemble.ts"],"sourcesContent":["import {Signal, SignalRef} from 'vega';\nimport {parseSelector} from 'vega-event-selector';\nimport {identity, isArray, stringValue} from 'vega-util';\nimport {MODIFY, STORE, unitName, VL_SELECTION_RESOLVE, TUPLE, selectionCompilers} from '.';\nimport {dateTimeToExpr, isDateTime, dateTimeToTimestamp} from '../../datetime';\nimport {hasContinuousDomain} from '../../scale';\nimport {SelectionInit, SelectionInitInterval, ParameterExtent, SELECTION_ID} from '../../selection';\nimport {keys, replacePathInField, stringify, vals} from '../../util';\nimport {VgData, VgDomain} from '../../vega.schema';\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {isUnitModel, Model} from '../model';\nimport {ScaleComponent} from '../scale/component';\nimport {UnitModel} from '../unit';\nimport {parseSelectionExtent} from './parse';\nimport {SelectionProjection} from './project';\n\nexport function assembleProjection(proj: SelectionProjection) {\n  const {signals, hasLegend, index, ...rest} = proj;\n  rest.field = replacePathInField(rest.field);\n  return rest;\n}\n\nexport function assembleInit(\n  init: readonly (SelectionInit | readonly SelectionInit[] | SelectionInitInterval)[] | SelectionInit,\n  isExpr = true,\n  wrap: (str: string | number) => string | number = identity\n): any {\n  if (isArray(init)) {\n    const assembled = init.map(v => assembleInit(v, isExpr, wrap));\n    return isExpr ? `[${assembled.join(', ')}]` : assembled;\n  } else if (isDateTime(init)) {\n    if (isExpr) {\n      return wrap(dateTimeToExpr(init));\n    } else {\n      return wrap(dateTimeToTimestamp(init));\n    }\n  }\n  return isExpr ? wrap(stringify(init)) : init;\n}\n\nexport function assembleUnitSelectionSignals(model: UnitModel, signals: Signal[]) {\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    const name = selCmpt.name;\n    let modifyExpr = `${name}${TUPLE}, ${selCmpt.resolve === 'global' ? 'true' : `{unit: ${unitName(model)}}`}`;\n\n    for (const c of selectionCompilers) {\n      if (!c.defined(selCmpt)) continue;\n      if (c.signals) signals = c.signals(model, selCmpt, signals);\n      if (c.modifyExpr) modifyExpr = c.modifyExpr(model, selCmpt, modifyExpr);\n    }\n\n    signals.push({\n      name: name + MODIFY,\n      on: [\n        {\n          events: {signal: selCmpt.name + TUPLE},\n          update: `modify(${stringValue(selCmpt.name + STORE)}, ${modifyExpr})`\n        }\n      ]\n    });\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\n\nexport function assembleFacetSignals(model: FacetModel, signals: Signal[]) {\n  if (model.component.selection && keys(model.component.selection).length) {\n    const name = stringValue(model.getName('cell'));\n    signals.unshift({\n      name: 'facet',\n      value: {},\n      on: [\n        {\n          events: parseSelector('pointermove', 'scope'),\n          update: `isTuple(facet) ? facet : group(${name}).datum`\n        }\n      ]\n    });\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\n\nexport function assembleTopLevelSignals(model: UnitModel, signals: Signal[]) {\n  let hasSelections = false;\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    const name = selCmpt.name;\n    const store = stringValue(name + STORE);\n    const hasSg = signals.filter(s => s.name === name);\n    if (hasSg.length === 0) {\n      const resolve = selCmpt.resolve === 'global' ? 'union' : selCmpt.resolve;\n      const isPoint = selCmpt.type === 'point' ? ', true, true)' : ')';\n      signals.push({\n        name: selCmpt.name,\n        update: `${VL_SELECTION_RESOLVE}(${store}, ${stringValue(resolve)}${isPoint}`\n      });\n    }\n    hasSelections = true;\n\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.topLevelSignals) {\n        signals = c.topLevelSignals(model, selCmpt, signals);\n      }\n    }\n  }\n\n  if (hasSelections) {\n    const hasUnit = signals.filter(s => s.name === 'unit');\n    if (hasUnit.length === 0) {\n      signals.unshift({\n        name: 'unit',\n        value: {},\n        on: [{events: 'pointermove', update: 'isTuple(group()) ? group() : unit'}]\n      });\n    }\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\n\nexport function assembleUnitSelectionData(model: UnitModel, data: readonly VgData[]): VgData[] {\n  const dataCopy = [...data];\n  const unit = unitName(model, {escape: false});\n\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    const store: VgData = {name: selCmpt.name + STORE};\n\n    if (selCmpt.project.hasSelectionId) {\n      store.transform = [{type: 'collect', sort: {field: SELECTION_ID}}];\n    }\n\n    if (selCmpt.init) {\n      const fields = selCmpt.project.items.map(assembleProjection);\n\n      store.values = selCmpt.project.hasSelectionId\n        ? selCmpt.init.map(i => ({unit, [SELECTION_ID]: assembleInit(i, false)[0]}))\n        : selCmpt.init.map(i => ({unit, fields, values: assembleInit(i, false)}));\n    }\n\n    const contains = dataCopy.filter(d => d.name === selCmpt.name + STORE);\n    if (!contains.length) {\n      dataCopy.push(store);\n    }\n  }\n\n  return dataCopy;\n}\n\nexport function assembleUnitSelectionMarks(model: UnitModel, marks: any[]): any[] {\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.marks) {\n        marks = c.marks(model, selCmpt, marks);\n      }\n    }\n  }\n\n  return marks;\n}\n\nexport function assembleLayerSelectionMarks(model: LayerModel, marks: any[]): any[] {\n  for (const child of model.children) {\n    if (isUnitModel(child)) {\n      marks = assembleUnitSelectionMarks(child, marks);\n    }\n  }\n\n  return marks;\n}\n\nexport function assembleSelectionScaleDomain(\n  model: Model,\n  extent: ParameterExtent,\n  scaleCmpt: ScaleComponent,\n  domain: VgDomain\n): SignalRef {\n  const parsedExtent = parseSelectionExtent(model, extent.param, extent);\n\n  return {\n    signal:\n      hasContinuousDomain(scaleCmpt.get('type')) && isArray(domain) && domain[0] > domain[1]\n        ? `isValid(${parsedExtent}) && reverse(${parsedExtent})`\n        : parsedExtent\n  };\n}\n\nfunction cleanupEmptyOnArray(signals: Signal[]) {\n  return signals.map(s => {\n    if (s.on && !s.on.length) delete s.on;\n    return s;\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}