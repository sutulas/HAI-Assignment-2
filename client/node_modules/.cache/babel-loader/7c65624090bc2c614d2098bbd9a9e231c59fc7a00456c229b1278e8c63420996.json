{"ast":null,"code":"import { array, isArray, isObject, isString } from 'vega-util';\nimport { isBinned } from '../../../bin';\nimport { getMainRangeChannel, isXorY, THETA, RADIUS } from '../../../channel';\nimport { defaultTitle, getFieldDef, getFormatMixins, hasConditionalFieldDef, isFieldDef, isTypedFieldDef, vgField } from '../../../channeldef';\nimport { forEach } from '../../../encoding';\nimport { entries } from '../../../util';\nimport { isSignalRef } from '../../../vega.schema';\nimport { getMarkPropOrConfig } from '../../common';\nimport { binFormatExpression, formatSignalRef } from '../../format';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nexport function tooltip(model) {\n  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    encoding,\n    markDef,\n    config,\n    stack\n  } = model;\n  const channelDef = encoding.tooltip;\n  if (isArray(channelDef)) {\n    return {\n      tooltip: tooltipRefForEncoding({\n        tooltip: channelDef\n      }, stack, config, opt)\n    };\n  } else {\n    const datum = opt.reactiveGeom ? 'datum.datum' : 'datum';\n    const mainRefFn = cDef => {\n      // use valueRef based on channelDef first\n      const tooltipRefFromChannelDef = textRef(cDef, config, datum);\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n      if (cDef === null) {\n        // Allow using encoding.tooltip = null to disable tooltip\n        return undefined;\n      }\n      let markTooltip = getMarkPropOrConfig('tooltip', markDef, config);\n      if (markTooltip === true) {\n        markTooltip = {\n          content: 'encoding'\n        };\n      }\n      if (isString(markTooltip)) {\n        return {\n          value: markTooltip\n        };\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (isSignalRef(markTooltip)) {\n          return markTooltip;\n        } else if (markTooltip.content === 'encoding') {\n          return tooltipRefForEncoding(encoding, stack, config, opt);\n        } else {\n          return {\n            signal: datum\n          };\n        }\n      }\n      return undefined;\n    };\n    return wrapCondition({\n      model,\n      channelDef,\n      vgChannel: 'tooltip',\n      mainRefFn,\n      invalidValueRef: undefined // tooltip encoding doesn't have continuous scales and thus can't have invalid values\n    });\n  }\n}\nexport function tooltipData(encoding, stack, config) {\n  let {\n    reactiveGeom\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const formatConfig = {\n    ...config,\n    ...config.tooltipFormat\n  };\n  const toSkip = new Set();\n  const expr = reactiveGeom ? 'datum.datum' : 'datum';\n  const tuples = [];\n  function add(fDef, channel) {\n    const mainChannel = getMainRangeChannel(channel);\n    const fieldDef = isTypedFieldDef(fDef) ? fDef : {\n      ...fDef,\n      type: encoding[mainChannel].type // for secondary field def, copy type from main channel\n    };\n    const title = fieldDef.title || defaultTitle(fieldDef, formatConfig);\n    const key = array(title).join(', ').replaceAll(/\"/g, '\\\\\"');\n    let value;\n    if (isXorY(channel)) {\n      const channel2 = channel === 'x' ? 'x2' : 'y2';\n      const fieldDef2 = getFieldDef(encoding[channel2]);\n      if (isBinned(fieldDef.bin) && fieldDef2) {\n        const startField = vgField(fieldDef, {\n          expr\n        });\n        const endField = vgField(fieldDef2, {\n          expr\n        });\n        const {\n          format,\n          formatType\n        } = getFormatMixins(fieldDef);\n        value = binFormatExpression(startField, endField, format, formatType, formatConfig);\n        toSkip.add(channel2);\n      }\n    }\n    if ((isXorY(channel) || channel === THETA || channel === RADIUS) && stack && stack.fieldChannel === channel && stack.offset === 'normalize') {\n      const {\n        format,\n        formatType\n      } = getFormatMixins(fieldDef);\n      value = formatSignalRef({\n        fieldOrDatumDef: fieldDef,\n        format,\n        formatType,\n        expr,\n        config: formatConfig,\n        normalizeStack: true\n      }).signal;\n    }\n    value ?? (value = textRef(fieldDef, formatConfig, expr).signal);\n    tuples.push({\n      channel,\n      key,\n      value\n    });\n  }\n  forEach(encoding, (channelDef, channel) => {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n  const out = {};\n  for (const {\n    channel,\n    key,\n    value\n  } of tuples) {\n    if (!toSkip.has(channel) && !out[key]) {\n      out[key] = value;\n    }\n  }\n  return out;\n}\nexport function tooltipRefForEncoding(encoding, stack, config) {\n  let {\n    reactiveGeom\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const data = tooltipData(encoding, stack, config, {\n    reactiveGeom\n  });\n  const keyValues = entries(data).map(_ref => {\n    let [key, value] = _ref;\n    return `\"${key}\": ${value}`;\n  });\n  return keyValues.length > 0 ? {\n    signal: `{${keyValues.join(', ')}}`\n  } : undefined;\n}","map":{"version":3,"names":["array","isArray","isObject","isString","isBinned","getMainRangeChannel","isXorY","THETA","RADIUS","defaultTitle","getFieldDef","getFormatMixins","hasConditionalFieldDef","isFieldDef","isTypedFieldDef","vgField","forEach","entries","isSignalRef","getMarkPropOrConfig","binFormatExpression","formatSignalRef","wrapCondition","textRef","tooltip","model","opt","arguments","length","undefined","encoding","markDef","config","stack","channelDef","tooltipRefForEncoding","datum","reactiveGeom","mainRefFn","cDef","tooltipRefFromChannelDef","markTooltip","content","value","signal","vgChannel","invalidValueRef","tooltipData","formatConfig","tooltipFormat","toSkip","Set","expr","tuples","add","fDef","channel","mainChannel","fieldDef","type","title","key","join","replaceAll","channel2","fieldDef2","bin","startField","endField","format","formatType","fieldChannel","offset","fieldOrDatumDef","normalizeStack","push","condition","out","has","data","keyValues","map","_ref"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\mark\\encode\\tooltip.ts"],"sourcesContent":["import {array, isArray, isObject, isString} from 'vega-util';\nimport {isBinned} from '../../../bin';\nimport {getMainRangeChannel, isXorY, Channel, THETA, RADIUS} from '../../../channel';\nimport {\n  defaultTitle,\n  getFieldDef,\n  getFormatMixins,\n  hasConditionalFieldDef,\n  isFieldDef,\n  isTypedFieldDef,\n  SecondaryFieldDef,\n  TypedFieldDef,\n  vgField\n} from '../../../channeldef';\nimport {Config} from '../../../config';\nimport {Encoding, forEach} from '../../../encoding';\nimport {StackProperties} from '../../../stack';\nimport {Dict, entries} from '../../../util';\nimport {isSignalRef} from '../../../vega.schema';\nimport {getMarkPropOrConfig} from '../../common';\nimport {binFormatExpression, formatSignalRef} from '../../format';\nimport {UnitModel} from '../../unit';\nimport {wrapCondition} from './conditional';\nimport {textRef} from './text';\n\nexport function tooltip(model: UnitModel, opt: {reactiveGeom?: boolean} = {}) {\n  const {encoding, markDef, config, stack} = model;\n  const channelDef = encoding.tooltip;\n  if (isArray(channelDef)) {\n    return {tooltip: tooltipRefForEncoding({tooltip: channelDef}, stack, config, opt)};\n  } else {\n    const datum = opt.reactiveGeom ? 'datum.datum' : 'datum';\n    const mainRefFn = (cDef: Encoding<string>['tooltip']) => {\n      // use valueRef based on channelDef first\n      const tooltipRefFromChannelDef = textRef(cDef, config, datum);\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n\n      if (cDef === null) {\n        // Allow using encoding.tooltip = null to disable tooltip\n        return undefined;\n      }\n\n      let markTooltip = getMarkPropOrConfig('tooltip', markDef, config);\n\n      if (markTooltip === true) {\n        markTooltip = {content: 'encoding'};\n      }\n\n      if (isString(markTooltip)) {\n        return {value: markTooltip};\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (isSignalRef(markTooltip)) {\n          return markTooltip;\n        } else if (markTooltip.content === 'encoding') {\n          return tooltipRefForEncoding(encoding, stack, config, opt);\n        } else {\n          return {signal: datum};\n        }\n      }\n\n      return undefined;\n    };\n\n    return wrapCondition({\n      model,\n      channelDef,\n      vgChannel: 'tooltip',\n      mainRefFn,\n      invalidValueRef: undefined // tooltip encoding doesn't have continuous scales and thus can't have invalid values\n    });\n  }\n}\n\nexport function tooltipData(\n  encoding: Encoding<string>,\n  stack: StackProperties,\n  config: Config,\n  {reactiveGeom}: {reactiveGeom?: boolean} = {}\n) {\n  const formatConfig = {...config, ...config.tooltipFormat};\n  const toSkip = new Set();\n  const expr = reactiveGeom ? 'datum.datum' : 'datum';\n  const tuples: {channel: Channel; key: string; value: string}[] = [];\n\n  function add(fDef: TypedFieldDef<string> | SecondaryFieldDef<string>, channel: Channel) {\n    const mainChannel = getMainRangeChannel(channel);\n\n    const fieldDef: TypedFieldDef<string> = isTypedFieldDef(fDef)\n      ? fDef\n      : {\n          ...fDef,\n          type: (encoding[mainChannel] as TypedFieldDef<any>).type // for secondary field def, copy type from main channel\n        };\n\n    const title = fieldDef.title || defaultTitle(fieldDef, formatConfig);\n    const key = array(title).join(', ').replaceAll(/\"/g, '\\\\\"');\n\n    let value: string;\n\n    if (isXorY(channel)) {\n      const channel2 = channel === 'x' ? 'x2' : 'y2';\n      const fieldDef2 = getFieldDef(encoding[channel2]);\n\n      if (isBinned(fieldDef.bin) && fieldDef2) {\n        const startField = vgField(fieldDef, {expr});\n        const endField = vgField(fieldDef2, {expr});\n        const {format, formatType} = getFormatMixins(fieldDef);\n        value = binFormatExpression(startField, endField, format, formatType, formatConfig);\n        toSkip.add(channel2);\n      }\n    }\n\n    if (\n      (isXorY(channel) || channel === THETA || channel === RADIUS) &&\n      stack &&\n      stack.fieldChannel === channel &&\n      stack.offset === 'normalize'\n    ) {\n      const {format, formatType} = getFormatMixins(fieldDef);\n      value = formatSignalRef({\n        fieldOrDatumDef: fieldDef,\n        format,\n        formatType,\n        expr,\n        config: formatConfig,\n        normalizeStack: true\n      }).signal;\n    }\n\n    value ??= textRef(fieldDef, formatConfig, expr).signal;\n\n    tuples.push({channel, key, value});\n  }\n\n  forEach(encoding, (channelDef, channel) => {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n\n  const out: Dict<string> = {};\n  for (const {channel, key, value} of tuples) {\n    if (!toSkip.has(channel) && !out[key]) {\n      out[key] = value;\n    }\n  }\n\n  return out;\n}\n\nexport function tooltipRefForEncoding(\n  encoding: Encoding<string>,\n  stack: StackProperties,\n  config: Config,\n  {reactiveGeom}: {reactiveGeom?: boolean} = {}\n) {\n  const data = tooltipData(encoding, stack, config, {reactiveGeom});\n\n  const keyValues = entries(data).map(([key, value]) => `\"${key}\": ${value}`);\n  return keyValues.length > 0 ? {signal: `{${keyValues.join(', ')}}`} : undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}