{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isFieldDef, isValueDef, vgField } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport { pathGroupingFields } from '../../encoding';\nimport { AREA, BAR, LINE, TRAIL, isPathMark } from '../../mark';\nimport { contains, getFirstDefined, isNullOrFalse, keys, omit, pick } from '../../util';\nimport { VG_CORNERRADIUS_CHANNELS } from '../../vega.schema';\nimport { getMarkConfig, getMarkPropOrConfig, getStyles, signalOrValueRef, sortParams } from '../common';\nimport { arc } from './arc';\nimport { area } from './area';\nimport { bar } from './bar';\nimport { geoshape } from './geoshape';\nimport { image } from './image';\nimport { line, trail } from './line';\nimport { circle, point, square } from './point';\nimport { rect } from './rect';\nimport { rule } from './rule';\nimport { text } from './text';\nimport { tick } from './tick';\nconst markCompiler = {\n  arc,\n  area,\n  bar,\n  circle,\n  geoshape,\n  image,\n  line,\n  point,\n  rect,\n  rule,\n  square,\n  text,\n  tick,\n  trail\n};\nexport function parseMarkGroups(model) {\n  if (contains([LINE, AREA, TRAIL], model.mark)) {\n    const details = pathGroupingFields(model.mark, model.encoding);\n    if (details.length > 0) {\n      return getPathGroups(model, details);\n    }\n    // otherwise use standard mark groups\n  } else if (model.mark === BAR) {\n    const hasCornerRadius = VG_CORNERRADIUS_CHANNELS.some(prop => getMarkPropOrConfig(prop, model.markDef, model.config));\n    if (model.stack && !model.fieldDef('size') && hasCornerRadius) {\n      return getGroupsForStackedBarWithCornerRadius(model);\n    }\n  }\n  return getMarkGroup(model);\n}\nconst FACETED_PATH_PREFIX = 'faceted_path_';\nfunction getPathGroups(model, details) {\n  // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n  return [{\n    name: model.getName('pathgroup'),\n    type: 'group',\n    from: {\n      facet: {\n        name: FACETED_PATH_PREFIX + model.requestDataName(DataSourceType.Main),\n        data: model.requestDataName(DataSourceType.Main),\n        groupby: details\n      }\n    },\n    encode: {\n      update: {\n        width: {\n          field: {\n            group: 'width'\n          }\n        },\n        height: {\n          field: {\n            group: 'height'\n          }\n        }\n      }\n    },\n    // With subfacet for line/area group, need to use faceted data from above.\n    marks: getMarkGroup(model, {\n      fromPrefix: FACETED_PATH_PREFIX\n    })\n  }];\n}\nconst STACK_GROUP_PREFIX = 'stack_group_';\n/**\n * We need to put stacked bars into groups in order to enable cornerRadius for stacks.\n * If stack is used and the model doesn't have size encoding, we put the mark into groups,\n * and apply cornerRadius properties at the group.\n */\nfunction getGroupsForStackedBarWithCornerRadius(model) {\n  // Generate the mark\n  const [mark] = getMarkGroup(model, {\n    fromPrefix: STACK_GROUP_PREFIX\n  });\n  // Get the scale for the stacked field\n  const fieldScale = model.scaleName(model.stack.fieldChannel);\n  const stackField = function () {\n    let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return model.vgField(model.stack.fieldChannel, opt);\n  };\n  // Find the min/max of the pixel value on the stacked direction\n  const stackFieldGroup = (func, expr) => {\n    const vgFieldMinMax = [stackField({\n      prefix: 'min',\n      suffix: 'start',\n      expr\n    }), stackField({\n      prefix: 'max',\n      suffix: 'start',\n      expr\n    }), stackField({\n      prefix: 'min',\n      suffix: 'end',\n      expr\n    }), stackField({\n      prefix: 'max',\n      suffix: 'end',\n      expr\n    })];\n    return `${func}(${vgFieldMinMax.map(field => `scale('${fieldScale}',${field})`).join(',')})`;\n  };\n  let groupUpdate;\n  let innerGroupUpdate;\n  // Build the encoding for group and an inner group\n  if (model.stack.fieldChannel === 'x') {\n    // Move cornerRadius, y/yc/y2/height properties to group\n    // Group x/x2 should be the min/max of the marks within\n    groupUpdate = {\n      ...pick(mark.encode.update, ['y', 'yc', 'y2', 'height', ...VG_CORNERRADIUS_CHANNELS]),\n      x: {\n        signal: stackFieldGroup('min', 'datum')\n      },\n      x2: {\n        signal: stackFieldGroup('max', 'datum')\n      },\n      clip: {\n        value: true\n      }\n    };\n    // Inner group should revert the x translation, and pass height through\n    innerGroupUpdate = {\n      x: {\n        field: {\n          group: 'x'\n        },\n        mult: -1\n      },\n      height: {\n        field: {\n          group: 'height'\n        }\n      }\n    };\n    // The marks should use the same height as group, without y/yc/y2 properties (because it's already done by group)\n    // This is why size encoding is not supported yet\n    mark.encode.update = {\n      ...omit(mark.encode.update, ['y', 'yc', 'y2']),\n      height: {\n        field: {\n          group: 'height'\n        }\n      }\n    };\n  } else {\n    groupUpdate = {\n      ...pick(mark.encode.update, ['x', 'xc', 'x2', 'width']),\n      y: {\n        signal: stackFieldGroup('min', 'datum')\n      },\n      y2: {\n        signal: stackFieldGroup('max', 'datum')\n      },\n      clip: {\n        value: true\n      }\n    };\n    innerGroupUpdate = {\n      y: {\n        field: {\n          group: 'y'\n        },\n        mult: -1\n      },\n      width: {\n        field: {\n          group: 'width'\n        }\n      }\n    };\n    mark.encode.update = {\n      ...omit(mark.encode.update, ['x', 'xc', 'x2']),\n      width: {\n        field: {\n          group: 'width'\n        }\n      }\n    };\n  }\n  // Deal with cornerRadius properties\n  for (const key of VG_CORNERRADIUS_CHANNELS) {\n    const configValue = getMarkConfig(key, model.markDef, model.config);\n    // Move from mark to group\n    if (mark.encode.update[key]) {\n      groupUpdate[key] = mark.encode.update[key];\n      delete mark.encode.update[key];\n    } else if (configValue) {\n      groupUpdate[key] = signalOrValueRef(configValue);\n    }\n    // Overwrite any cornerRadius on mark set by config --- they are already moved to the group\n    if (configValue) {\n      mark.encode.update[key] = {\n        value: 0\n      };\n    }\n  }\n  const groupby = [];\n  if (model.stack.groupbyChannels?.length > 0) {\n    for (const groupbyChannel of model.stack.groupbyChannels) {\n      // For bin and time unit, we have to add bin/timeunit -end channels.\n      const groupByField = model.fieldDef(groupbyChannel);\n      const field = vgField(groupByField);\n      if (field) {\n        groupby.push(field);\n      }\n      if (groupByField?.bin || groupByField?.timeUnit) {\n        groupby.push(vgField(groupByField, {\n          binSuffix: 'end'\n        }));\n      }\n    }\n  }\n  const strokeProperties = ['stroke', 'strokeWidth', 'strokeJoin', 'strokeCap', 'strokeDash', 'strokeDashOffset', 'strokeMiterLimit', 'strokeOpacity'];\n  // Generate stroke properties for the group\n  groupUpdate = strokeProperties.reduce((encode, prop) => {\n    if (mark.encode.update[prop]) {\n      return {\n        ...encode,\n        [prop]: mark.encode.update[prop]\n      };\n    } else {\n      const configValue = getMarkConfig(prop, model.markDef, model.config);\n      if (configValue !== undefined) {\n        return {\n          ...encode,\n          [prop]: signalOrValueRef(configValue)\n        };\n      } else {\n        return encode;\n      }\n    }\n  }, groupUpdate);\n  // Apply strokeForeground and strokeOffset if stroke is used\n  if (groupUpdate.stroke) {\n    groupUpdate.strokeForeground = {\n      value: true\n    };\n    groupUpdate.strokeOffset = {\n      value: 0\n    };\n  }\n  return [{\n    type: 'group',\n    from: {\n      facet: {\n        data: model.requestDataName(DataSourceType.Main),\n        name: STACK_GROUP_PREFIX + model.requestDataName(DataSourceType.Main),\n        groupby,\n        aggregate: {\n          fields: [stackField({\n            suffix: 'start'\n          }), stackField({\n            suffix: 'start'\n          }), stackField({\n            suffix: 'end'\n          }), stackField({\n            suffix: 'end'\n          })],\n          ops: ['min', 'max', 'min', 'max']\n        }\n      }\n    },\n    encode: {\n      update: groupUpdate\n    },\n    marks: [{\n      type: 'group',\n      encode: {\n        update: innerGroupUpdate\n      },\n      marks: [mark]\n    }]\n  }];\n}\nexport function getSort(model) {\n  const {\n    encoding,\n    stack,\n    mark,\n    markDef,\n    config\n  } = model;\n  const order = encoding.order;\n  if (!isArray(order) && isValueDef(order) && isNullOrFalse(order.value) || !order && isNullOrFalse(getMarkPropOrConfig('order', markDef, config))) {\n    return undefined;\n  } else if ((isArray(order) || isFieldDef(order)) && !stack) {\n    // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n    return sortParams(order, {\n      expr: 'datum'\n    });\n  } else if (isPathMark(mark)) {\n    // For both line and area, we sort values based on dimension by default\n    const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n    const dimensionChannelDef = encoding[dimensionChannel];\n    if (isFieldDef(dimensionChannelDef)) {\n      return {\n        field: dimensionChannel\n      };\n    }\n  }\n  return undefined;\n}\nfunction getMarkGroup(model) {\n  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    fromPrefix: ''\n  };\n  const {\n    mark,\n    markDef,\n    encoding,\n    config\n  } = model;\n  const clip = getFirstDefined(markDef.clip, scaleClip(model), projectionClip(model));\n  const style = getStyles(markDef);\n  const key = encoding.key;\n  const sort = getSort(model);\n  const interactive = interactiveFlag(model);\n  const aria = getMarkPropOrConfig('aria', markDef, config);\n  const postEncodingTransform = markCompiler[mark].postEncodingTransform ? markCompiler[mark].postEncodingTransform(model) : null;\n  return [{\n    name: model.getName('marks'),\n    type: markCompiler[mark].vgMark,\n    ...(clip ? {\n      clip\n    } : {}),\n    ...(style ? {\n      style\n    } : {}),\n    ...(key ? {\n      key: key.field\n    } : {}),\n    ...(sort ? {\n      sort\n    } : {}),\n    ...(interactive ? interactive : {}),\n    ...(aria === false ? {\n      aria\n    } : {}),\n    from: {\n      data: opt.fromPrefix + model.requestDataName(DataSourceType.Main)\n    },\n    encode: {\n      update: markCompiler[mark].encodeEntry(model)\n    },\n    ...(postEncodingTransform ? {\n      transform: postEncodingTransform\n    } : {})\n  }];\n}\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the selectionExtent property, which gets added during scale parsing.\n */\nfunction scaleClip(model) {\n  const xScale = model.getScaleComponent('x');\n  const yScale = model.getScaleComponent('y');\n  return xScale?.get('selectionExtent') || yScale?.get('selectionExtent') ? true : undefined;\n}\n/**\n * If we use a custom projection with auto-fitting to the geodata extent,\n * we need to clip to ensure the chart size doesn't explode.\n */\nfunction projectionClip(model) {\n  const projection = model.component.projection;\n  return projection && !projection.isFit ? true : undefined;\n}\n/**\n * Only output interactive flags if we have selections defined somewhere in our model hierarchy.\n */\nfunction interactiveFlag(model) {\n  if (!model.component.selection) return null;\n  const unitCount = keys(model.component.selection).length;\n  let parentCount = unitCount;\n  let parent = model.parent;\n  while (parent && parentCount === 0) {\n    parentCount = keys(parent.component.selection).length;\n    parent = parent.parent;\n  }\n  return parentCount ? {\n    interactive: unitCount > 0 || model.mark === 'geoshape' || !!model.encoding.tooltip || !!model.markDef.tooltip\n  } : null;\n}","map":{"version":3,"names":["isArray","isFieldDef","isValueDef","vgField","DataSourceType","pathGroupingFields","AREA","BAR","LINE","TRAIL","isPathMark","contains","getFirstDefined","isNullOrFalse","keys","omit","pick","VG_CORNERRADIUS_CHANNELS","getMarkConfig","getMarkPropOrConfig","getStyles","signalOrValueRef","sortParams","arc","area","bar","geoshape","image","line","trail","circle","point","square","rect","rule","text","tick","markCompiler","parseMarkGroups","model","mark","details","encoding","length","getPathGroups","hasCornerRadius","some","prop","markDef","config","stack","fieldDef","getGroupsForStackedBarWithCornerRadius","getMarkGroup","FACETED_PATH_PREFIX","name","getName","type","from","facet","requestDataName","Main","data","groupby","encode","update","width","field","group","height","marks","fromPrefix","STACK_GROUP_PREFIX","fieldScale","scaleName","fieldChannel","stackField","opt","arguments","undefined","stackFieldGroup","func","expr","vgFieldMinMax","prefix","suffix","map","join","groupUpdate","innerGroupUpdate","x","signal","x2","clip","value","mult","y","y2","key","configValue","groupbyChannels","groupbyChannel","groupByField","push","bin","timeUnit","binSuffix","strokeProperties","reduce","stroke","strokeForeground","strokeOffset","aggregate","fields","ops","getSort","order","dimensionChannel","orient","dimensionChannelDef","scaleClip","projectionClip","style","sort","interactive","interactiveFlag","aria","postEncodingTransform","vgMark","encodeEntry","transform","xScale","getScaleComponent","yScale","get","projection","component","isFit","selection","unitCount","parentCount","parent","tooltip"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\mark\\mark.ts"],"sourcesContent":["import {isArray} from 'vega-util';\nimport {FieldRefOption, isFieldDef, isValueDef, vgField} from '../../channeldef';\nimport {DataSourceType} from '../../data';\nimport {pathGroupingFields} from '../../encoding';\nimport {AREA, BAR, LINE, Mark, TRAIL, isPathMark} from '../../mark';\nimport {contains, getFirstDefined, isNullOrFalse, keys, omit, pick} from '../../util';\nimport {VG_CORNERRADIUS_CHANNELS, VgCompare, VgEncodeEntry} from '../../vega.schema';\nimport {getMarkConfig, getMarkPropOrConfig, getStyles, signalOrValueRef, sortParams} from '../common';\nimport {UnitModel} from '../unit';\nimport {arc} from './arc';\nimport {area} from './area';\nimport {bar} from './bar';\nimport {MarkCompiler} from './base';\nimport {geoshape} from './geoshape';\nimport {image} from './image';\nimport {line, trail} from './line';\nimport {circle, point, square} from './point';\nimport {rect} from './rect';\nimport {rule} from './rule';\nimport {text} from './text';\nimport {tick} from './tick';\n\nconst markCompiler: Record<Mark, MarkCompiler> = {\n  arc,\n  area,\n  bar,\n  circle,\n  geoshape,\n  image,\n  line,\n  point,\n  rect,\n  rule,\n  square,\n  text,\n  tick,\n  trail\n};\n\nexport function parseMarkGroups(model: UnitModel): any[] {\n  if (contains([LINE, AREA, TRAIL], model.mark)) {\n    const details = pathGroupingFields(model.mark, model.encoding);\n    if (details.length > 0) {\n      return getPathGroups(model, details);\n    }\n    // otherwise use standard mark groups\n  } else if (model.mark === BAR) {\n    const hasCornerRadius = VG_CORNERRADIUS_CHANNELS.some(prop =>\n      getMarkPropOrConfig(prop, model.markDef, model.config)\n    );\n    if (model.stack && !model.fieldDef('size') && hasCornerRadius) {\n      return getGroupsForStackedBarWithCornerRadius(model);\n    }\n  }\n\n  return getMarkGroup(model);\n}\n\nconst FACETED_PATH_PREFIX = 'faceted_path_';\n\nfunction getPathGroups(model: UnitModel, details: string[]) {\n  // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n\n  return [\n    {\n      name: model.getName('pathgroup'),\n      type: 'group',\n      from: {\n        facet: {\n          name: FACETED_PATH_PREFIX + model.requestDataName(DataSourceType.Main),\n          data: model.requestDataName(DataSourceType.Main),\n          groupby: details\n        }\n      },\n      encode: {\n        update: {\n          width: {field: {group: 'width'}},\n          height: {field: {group: 'height'}}\n        }\n      },\n      // With subfacet for line/area group, need to use faceted data from above.\n      marks: getMarkGroup(model, {fromPrefix: FACETED_PATH_PREFIX})\n    }\n  ];\n}\n\nconst STACK_GROUP_PREFIX = 'stack_group_';\n\n/**\n * We need to put stacked bars into groups in order to enable cornerRadius for stacks.\n * If stack is used and the model doesn't have size encoding, we put the mark into groups,\n * and apply cornerRadius properties at the group.\n */\nfunction getGroupsForStackedBarWithCornerRadius(model: UnitModel) {\n  // Generate the mark\n  const [mark] = getMarkGroup(model, {fromPrefix: STACK_GROUP_PREFIX});\n\n  // Get the scale for the stacked field\n  const fieldScale = model.scaleName(model.stack.fieldChannel);\n  const stackField = (opt: FieldRefOption = {}) => model.vgField(model.stack.fieldChannel, opt);\n  // Find the min/max of the pixel value on the stacked direction\n  const stackFieldGroup = (func: 'min' | 'max', expr: 'datum' | 'parent') => {\n    const vgFieldMinMax = [\n      stackField({prefix: 'min', suffix: 'start', expr}),\n      stackField({prefix: 'max', suffix: 'start', expr}),\n      stackField({prefix: 'min', suffix: 'end', expr}),\n      stackField({prefix: 'max', suffix: 'end', expr})\n    ];\n    return `${func}(${vgFieldMinMax.map(field => `scale('${fieldScale}',${field})`).join(',')})`;\n  };\n\n  let groupUpdate: VgEncodeEntry;\n  let innerGroupUpdate: VgEncodeEntry;\n\n  // Build the encoding for group and an inner group\n  if (model.stack.fieldChannel === 'x') {\n    // Move cornerRadius, y/yc/y2/height properties to group\n    // Group x/x2 should be the min/max of the marks within\n    groupUpdate = {\n      ...pick(mark.encode.update, ['y', 'yc', 'y2', 'height', ...VG_CORNERRADIUS_CHANNELS]),\n      x: {signal: stackFieldGroup('min', 'datum')},\n      x2: {signal: stackFieldGroup('max', 'datum')},\n      clip: {value: true}\n    };\n    // Inner group should revert the x translation, and pass height through\n    innerGroupUpdate = {\n      x: {field: {group: 'x'}, mult: -1},\n      height: {field: {group: 'height'}}\n    };\n    // The marks should use the same height as group, without y/yc/y2 properties (because it's already done by group)\n    // This is why size encoding is not supported yet\n    mark.encode.update = {\n      ...omit(mark.encode.update, ['y', 'yc', 'y2']),\n      height: {field: {group: 'height'}}\n    };\n  } else {\n    groupUpdate = {\n      ...pick(mark.encode.update, ['x', 'xc', 'x2', 'width']),\n      y: {signal: stackFieldGroup('min', 'datum')},\n      y2: {signal: stackFieldGroup('max', 'datum')},\n      clip: {value: true}\n    };\n    innerGroupUpdate = {\n      y: {field: {group: 'y'}, mult: -1},\n      width: {field: {group: 'width'}}\n    };\n    mark.encode.update = {\n      ...omit(mark.encode.update, ['x', 'xc', 'x2']),\n      width: {field: {group: 'width'}}\n    };\n  }\n\n  // Deal with cornerRadius properties\n  for (const key of VG_CORNERRADIUS_CHANNELS) {\n    const configValue = getMarkConfig(key, model.markDef, model.config);\n    // Move from mark to group\n    if (mark.encode.update[key]) {\n      groupUpdate[key] = mark.encode.update[key];\n      delete mark.encode.update[key];\n    } else if (configValue) {\n      groupUpdate[key] = signalOrValueRef(configValue);\n    }\n    // Overwrite any cornerRadius on mark set by config --- they are already moved to the group\n    if (configValue) {\n      mark.encode.update[key] = {value: 0};\n    }\n  }\n\n  const groupby: string[] = [];\n\n  if (model.stack.groupbyChannels?.length > 0) {\n    for (const groupbyChannel of model.stack.groupbyChannels) {\n      // For bin and time unit, we have to add bin/timeunit -end channels.\n      const groupByField = model.fieldDef(groupbyChannel);\n      const field = vgField(groupByField);\n      if (field) {\n        groupby.push(field);\n      }\n\n      if (groupByField?.bin || groupByField?.timeUnit) {\n        groupby.push(vgField(groupByField, {binSuffix: 'end'}));\n      }\n    }\n  }\n\n  const strokeProperties = [\n    'stroke',\n    'strokeWidth',\n    'strokeJoin',\n    'strokeCap',\n    'strokeDash',\n    'strokeDashOffset',\n    'strokeMiterLimit',\n    'strokeOpacity'\n  ] as const;\n\n  // Generate stroke properties for the group\n  groupUpdate = strokeProperties.reduce((encode, prop) => {\n    if (mark.encode.update[prop]) {\n      return {...encode, [prop]: mark.encode.update[prop]};\n    } else {\n      const configValue = getMarkConfig(prop, model.markDef, model.config);\n      if (configValue !== undefined) {\n        return {...encode, [prop]: signalOrValueRef(configValue)};\n      } else {\n        return encode;\n      }\n    }\n  }, groupUpdate);\n\n  // Apply strokeForeground and strokeOffset if stroke is used\n  if (groupUpdate.stroke) {\n    groupUpdate.strokeForeground = {value: true};\n    groupUpdate.strokeOffset = {value: 0};\n  }\n\n  return [\n    {\n      type: 'group',\n      from: {\n        facet: {\n          data: model.requestDataName(DataSourceType.Main),\n          name: STACK_GROUP_PREFIX + model.requestDataName(DataSourceType.Main),\n          groupby,\n          aggregate: {\n            fields: [\n              stackField({suffix: 'start'}),\n              stackField({suffix: 'start'}),\n              stackField({suffix: 'end'}),\n              stackField({suffix: 'end'})\n            ],\n            ops: ['min', 'max', 'min', 'max']\n          }\n        }\n      },\n      encode: {\n        update: groupUpdate\n      },\n      marks: [\n        {\n          type: 'group',\n          encode: {update: innerGroupUpdate},\n          marks: [mark]\n        }\n      ]\n    }\n  ];\n}\n\nexport function getSort(model: UnitModel): VgCompare {\n  const {encoding, stack, mark, markDef, config} = model;\n  const order = encoding.order;\n  if (\n    (!isArray(order) && isValueDef(order) && isNullOrFalse(order.value)) ||\n    (!order && isNullOrFalse(getMarkPropOrConfig('order', markDef, config)))\n  ) {\n    return undefined;\n  } else if ((isArray(order) || isFieldDef(order)) && !stack) {\n    // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n    return sortParams(order, {expr: 'datum'});\n  } else if (isPathMark(mark)) {\n    // For both line and area, we sort values based on dimension by default\n    const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n    const dimensionChannelDef = encoding[dimensionChannel];\n    if (isFieldDef(dimensionChannelDef)) {\n      return {field: dimensionChannel};\n    }\n  }\n  return undefined;\n}\n\nfunction getMarkGroup(model: UnitModel, opt: {fromPrefix: string} = {fromPrefix: ''}) {\n  const {mark, markDef, encoding, config} = model;\n\n  const clip = getFirstDefined(markDef.clip, scaleClip(model), projectionClip(model));\n  const style = getStyles(markDef);\n  const key = encoding.key;\n  const sort = getSort(model);\n  const interactive = interactiveFlag(model);\n  const aria = getMarkPropOrConfig('aria', markDef, config);\n\n  const postEncodingTransform = markCompiler[mark].postEncodingTransform\n    ? markCompiler[mark].postEncodingTransform(model)\n    : null;\n\n  return [\n    {\n      name: model.getName('marks'),\n      type: markCompiler[mark].vgMark,\n      ...(clip ? {clip} : {}),\n      ...(style ? {style} : {}),\n      ...(key ? {key: key.field} : {}),\n      ...(sort ? {sort} : {}),\n      ...(interactive ? interactive : {}),\n      ...(aria === false ? {aria} : {}),\n      from: {data: opt.fromPrefix + model.requestDataName(DataSourceType.Main)},\n      encode: {\n        update: markCompiler[mark].encodeEntry(model)\n      },\n      ...(postEncodingTransform\n        ? {\n            transform: postEncodingTransform\n          }\n        : {})\n    }\n  ];\n}\n\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the selectionExtent property, which gets added during scale parsing.\n */\nfunction scaleClip(model: UnitModel) {\n  const xScale = model.getScaleComponent('x');\n  const yScale = model.getScaleComponent('y');\n  return xScale?.get('selectionExtent') || yScale?.get('selectionExtent') ? true : undefined;\n}\n\n/**\n * If we use a custom projection with auto-fitting to the geodata extent,\n * we need to clip to ensure the chart size doesn't explode.\n */\nfunction projectionClip(model: UnitModel) {\n  const projection = model.component.projection;\n  return projection && !projection.isFit ? true : undefined;\n}\n\n/**\n * Only output interactive flags if we have selections defined somewhere in our model hierarchy.\n */\nfunction interactiveFlag(model: UnitModel) {\n  if (!model.component.selection) return null;\n  const unitCount = keys(model.component.selection).length;\n  let parentCount = unitCount;\n  let parent = model.parent;\n  while (parent && parentCount === 0) {\n    parentCount = keys(parent.component.selection).length;\n    parent = parent.parent;\n  }\n  return parentCount\n    ? {\n        interactive: unitCount > 0 || model.mark === 'geoshape' || !!model.encoding.tooltip || !!model.markDef.tooltip\n      }\n    : null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}