{"ast":null,"code":"import { fieldIntersection, hash, hasIntersection, isEmpty, keys, some } from '../../util';\nimport { requiresSelectionId } from '../selection';\nimport { AggregateNode } from './aggregate';\nimport { BinNode } from './bin';\nimport { OutputNode } from './dataflow';\nimport { FacetNode } from './facet';\nimport { FilterNode } from './filter';\nimport { ParseNode } from './formatparse';\nimport { IdentifierNode } from './identifier';\nimport { BottomUpOptimizer, isDataSourceNode, Optimizer, TopDownOptimizer } from './optimizer';\nimport { SourceNode } from './source';\nimport { TimeUnitNode } from './timeunit';\n/**\n * Merge identical nodes at forks by comparing hashes.\n *\n * Does not need to iterate from leaves so we implement this with recursion as it's a bit simpler.\n */\nexport class MergeIdenticalNodes extends TopDownOptimizer {\n  mergeNodes(parent, nodes) {\n    const mergedNode = nodes.shift();\n    for (const node of nodes) {\n      parent.removeChild(node);\n      node.parent = mergedNode;\n      node.remove();\n    }\n  }\n  run(node) {\n    const hashes = node.children.map(x => x.hash());\n    const buckets = {};\n    for (let i = 0; i < hashes.length; i++) {\n      if (buckets[hashes[i]] === undefined) {\n        buckets[hashes[i]] = [node.children[i]];\n      } else {\n        buckets[hashes[i]].push(node.children[i]);\n      }\n    }\n    for (const k of keys(buckets)) {\n      if (buckets[k].length > 1) {\n        this.setModified();\n        this.mergeNodes(node, buckets[k]);\n      }\n    }\n  }\n}\n/**\n * Optimizer that removes identifier nodes that are not needed for selections.\n */\nexport class RemoveUnnecessaryIdentifierNodes extends TopDownOptimizer {\n  constructor(model) {\n    super();\n    this.requiresSelectionId = model && requiresSelectionId(model);\n  }\n  run(node) {\n    if (node instanceof IdentifierNode) {\n      // Only preserve IdentifierNodes if we have default discrete selections\n      // in our model tree, and if the nodes come after tuple producing nodes.\n      if (!(this.requiresSelectionId && (isDataSourceNode(node.parent) || node.parent instanceof AggregateNode || node.parent instanceof ParseNode))) {\n        this.setModified();\n        node.remove();\n      }\n    }\n  }\n}\n/**\n * Removes duplicate time unit nodes (as determined by the name of the output field) that may be generated due to\n * selections projected over time units. Only keeps the first time unit in any branch.\n *\n * This optimizer is a custom top down optimizer that keep track of produced fields in a branch.\n */\nexport class RemoveDuplicateTimeUnits extends Optimizer {\n  optimize(node) {\n    this.run(node, new Set());\n    return this.modifiedFlag;\n  }\n  run(node, timeUnitFields) {\n    let producedFields = new Set();\n    if (node instanceof TimeUnitNode) {\n      producedFields = node.producedFields();\n      if (hasIntersection(producedFields, timeUnitFields)) {\n        this.setModified();\n        node.removeFormulas(timeUnitFields);\n        if (node.producedFields.length === 0) {\n          node.remove();\n        }\n      }\n    }\n    for (const child of node.children) {\n      this.run(child, new Set([...timeUnitFields, ...producedFields]));\n    }\n  }\n}\n/**\n * Remove output nodes that are not required.\n */\nexport class RemoveUnnecessaryOutputNodes extends TopDownOptimizer {\n  constructor() {\n    super();\n  }\n  run(node) {\n    if (node instanceof OutputNode && !node.isRequired()) {\n      this.setModified();\n      node.remove();\n    }\n  }\n}\n/**\n * Move parse nodes up to forks and merges them if possible.\n */\nexport class MoveParseUp extends BottomUpOptimizer {\n  run(node) {\n    if (isDataSourceNode(node)) {\n      return;\n    }\n    if (node.numChildren() > 1) {\n      // Don't move parse further up but continue with parent.\n      return;\n    }\n    for (const child of node.children) {\n      if (child instanceof ParseNode) {\n        if (node instanceof ParseNode) {\n          this.setModified();\n          node.merge(child);\n        } else {\n          // Don't swap with nodes that produce something that the parse node depends on (e.g. lookup).\n          if (fieldIntersection(node.producedFields(), child.dependentFields())) {\n            continue;\n          }\n          this.setModified();\n          child.swapWithParent();\n        }\n      }\n    }\n    return;\n  }\n}\n/**\n * Inserts an intermediate ParseNode containing all non-conflicting parse fields and removes the empty ParseNodes.\n *\n * We assume that dependent paths that do not have a parse node can be just merged.\n */\nexport class MergeParse extends BottomUpOptimizer {\n  run(node) {\n    const originalChildren = [...node.children];\n    const parseChildren = node.children.filter(child => child instanceof ParseNode);\n    if (node.numChildren() > 1 && parseChildren.length >= 1) {\n      const commonParse = {};\n      const conflictingParse = new Set();\n      for (const parseNode of parseChildren) {\n        const parse = parseNode.parse;\n        for (const k of keys(parse)) {\n          if (!(k in commonParse)) {\n            commonParse[k] = parse[k];\n          } else if (commonParse[k] !== parse[k]) {\n            conflictingParse.add(k);\n          }\n        }\n      }\n      for (const field of conflictingParse) {\n        delete commonParse[field];\n      }\n      if (!isEmpty(commonParse)) {\n        this.setModified();\n        const mergedParseNode = new ParseNode(node, commonParse);\n        for (const childNode of originalChildren) {\n          if (childNode instanceof ParseNode) {\n            for (const key of keys(commonParse)) {\n              delete childNode.parse[key];\n            }\n          }\n          node.removeChild(childNode);\n          childNode.parent = mergedParseNode;\n          // remove empty parse nodes\n          if (childNode instanceof ParseNode && keys(childNode.parse).length === 0) {\n            childNode.remove();\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Repeatedly remove leaf nodes that are not output or facet nodes.\n * The reason is that we don't need subtrees that don't have any output nodes.\n * Facet nodes are needed for the row or column domains.\n */\nexport class RemoveUnusedSubtrees extends BottomUpOptimizer {\n  run(node) {\n    if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode) {\n      // no need to continue with parent because it is output node or will have children (there was a fork)\n    } else if (node instanceof SourceNode) {\n      // ignore empty unused sources as they will be removed in optimizationDataflowHelper\n    } else {\n      this.setModified();\n      node.remove();\n    }\n  }\n}\n/**\n * Merge adjacent time unit nodes.\n */\nexport class MergeTimeUnits extends BottomUpOptimizer {\n  run(node) {\n    const timeUnitChildren = node.children.filter(x => x instanceof TimeUnitNode);\n    const combination = timeUnitChildren.pop();\n    for (const timeUnit of timeUnitChildren) {\n      this.setModified();\n      combination.merge(timeUnit);\n    }\n  }\n}\nexport class MergeAggregates extends BottomUpOptimizer {\n  run(node) {\n    const aggChildren = node.children.filter(child => child instanceof AggregateNode);\n    // Object which we'll use to map the fields which an aggregate is grouped by to\n    // the set of aggregates with that grouping. This is useful as only aggregates\n    // with the same group by can be merged\n    const groupedAggregates = {};\n    // Build groupedAggregates\n    for (const agg of aggChildren) {\n      const groupBys = hash(agg.groupBy);\n      if (!(groupBys in groupedAggregates)) {\n        groupedAggregates[groupBys] = [];\n      }\n      groupedAggregates[groupBys].push(agg);\n    }\n    // Merge aggregateNodes with same key in groupedAggregates\n    for (const group of keys(groupedAggregates)) {\n      const mergeableAggs = groupedAggregates[group];\n      if (mergeableAggs.length > 1) {\n        const mergedAggs = mergeableAggs.pop();\n        for (const agg of mergeableAggs) {\n          if (mergedAggs.merge(agg)) {\n            node.removeChild(agg);\n            agg.parent = mergedAggs;\n            agg.remove();\n            this.setModified();\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Merge bin nodes and move them up through forks. Stop at filters, parse, identifier as we want them to stay before the bin node.\n */\nexport class MergeBins extends BottomUpOptimizer {\n  constructor(model) {\n    super();\n    this.model = model;\n  }\n  run(node) {\n    const moveBinsUp = !(isDataSourceNode(node) || node instanceof FilterNode || node instanceof ParseNode || node instanceof IdentifierNode);\n    const promotableBins = [];\n    const remainingBins = [];\n    for (const child of node.children) {\n      if (child instanceof BinNode) {\n        if (moveBinsUp && !fieldIntersection(node.producedFields(), child.dependentFields())) {\n          promotableBins.push(child);\n        } else {\n          remainingBins.push(child);\n        }\n      }\n    }\n    if (promotableBins.length > 0) {\n      const promotedBin = promotableBins.pop();\n      for (const bin of promotableBins) {\n        promotedBin.merge(bin, this.model.renameSignal.bind(this.model));\n      }\n      this.setModified();\n      if (node instanceof BinNode) {\n        node.merge(promotedBin, this.model.renameSignal.bind(this.model));\n      } else {\n        promotedBin.swapWithParent();\n      }\n    }\n    if (remainingBins.length > 1) {\n      const remainingBin = remainingBins.pop();\n      for (const bin of remainingBins) {\n        remainingBin.merge(bin, this.model.renameSignal.bind(this.model));\n      }\n      this.setModified();\n    }\n  }\n}\n/**\n * This optimizer takes output nodes that are at a fork and moves them before the fork.\n *\n * The algorithm iterates over the children and tries to find the last output node in a chain of output nodes.\n * It then moves all output nodes before that main output node. All other children (and the children of the output nodes)\n * are inserted after the main output node.\n */\nexport class MergeOutputs extends BottomUpOptimizer {\n  run(node) {\n    const children = [...node.children];\n    const hasOutputChild = some(children, child => child instanceof OutputNode);\n    if (!hasOutputChild || node.numChildren() <= 1) {\n      return;\n    }\n    const otherChildren = [];\n    // The output node we will connect all other nodes to.\n    // Output nodes will be added before the new node, other nodes after.\n    let mainOutput;\n    for (const child of children) {\n      if (child instanceof OutputNode) {\n        let lastOutput = child;\n        while (lastOutput.numChildren() === 1) {\n          const [theChild] = lastOutput.children;\n          if (theChild instanceof OutputNode) {\n            lastOutput = theChild;\n          } else {\n            break;\n          }\n        }\n        otherChildren.push(...lastOutput.children);\n        if (mainOutput) {\n          // Move the output nodes before the mainOutput. We do this by setting\n          // the parent of the first not to the parent of the main output and\n          // the main output's parent to the last output.\n          // note: the child is the first output\n          node.removeChild(child);\n          child.parent = mainOutput.parent;\n          mainOutput.parent.removeChild(mainOutput);\n          mainOutput.parent = lastOutput;\n          this.setModified();\n        } else {\n          mainOutput = lastOutput;\n        }\n      } else {\n        otherChildren.push(child);\n      }\n    }\n    if (otherChildren.length) {\n      this.setModified();\n      for (const child of otherChildren) {\n        child.parent.removeChild(child);\n        child.parent = mainOutput;\n      }\n    }\n  }\n}","map":{"version":3,"names":["fieldIntersection","hash","hasIntersection","isEmpty","keys","some","requiresSelectionId","AggregateNode","BinNode","OutputNode","FacetNode","FilterNode","ParseNode","IdentifierNode","BottomUpOptimizer","isDataSourceNode","Optimizer","TopDownOptimizer","SourceNode","TimeUnitNode","MergeIdenticalNodes","mergeNodes","parent","nodes","mergedNode","shift","node","removeChild","remove","run","hashes","children","map","x","buckets","i","length","undefined","push","k","setModified","RemoveUnnecessaryIdentifierNodes","constructor","model","RemoveDuplicateTimeUnits","optimize","Set","modifiedFlag","timeUnitFields","producedFields","removeFormulas","child","RemoveUnnecessaryOutputNodes","isRequired","MoveParseUp","numChildren","merge","dependentFields","swapWithParent","MergeParse","originalChildren","parseChildren","filter","commonParse","conflictingParse","parseNode","parse","add","field","mergedParseNode","childNode","key","RemoveUnusedSubtrees","MergeTimeUnits","timeUnitChildren","combination","pop","timeUnit","MergeAggregates","aggChildren","groupedAggregates","agg","groupBys","groupBy","group","mergeableAggs","mergedAggs","MergeBins","moveBinsUp","promotableBins","remainingBins","promotedBin","bin","renameSignal","bind","remainingBin","MergeOutputs","hasOutputChild","otherChildren","mainOutput","lastOutput","theChild"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\data\\optimizers.ts"],"sourcesContent":["import {Parse} from '../../data';\nimport {Dict, fieldIntersection, hash, hasIntersection, isEmpty, keys, some} from '../../util';\nimport {Model} from '../model';\nimport {requiresSelectionId} from '../selection';\nimport {AggregateNode} from './aggregate';\nimport {BinNode} from './bin';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {FilterNode} from './filter';\nimport {ParseNode} from './formatparse';\nimport {IdentifierNode} from './identifier';\nimport {BottomUpOptimizer, isDataSourceNode, Optimizer, TopDownOptimizer} from './optimizer';\nimport {SourceNode} from './source';\nimport {TimeUnitNode} from './timeunit';\n\n/**\n * Merge identical nodes at forks by comparing hashes.\n *\n * Does not need to iterate from leaves so we implement this with recursion as it's a bit simpler.\n */\nexport class MergeIdenticalNodes extends TopDownOptimizer {\n  public mergeNodes(parent: DataFlowNode, nodes: DataFlowNode[]) {\n    const mergedNode = nodes.shift();\n    for (const node of nodes) {\n      parent.removeChild(node);\n      node.parent = mergedNode;\n      node.remove();\n    }\n  }\n\n  public run(node: DataFlowNode) {\n    const hashes = node.children.map(x => x.hash());\n    const buckets: Record<string | number, DataFlowNode[]> = {};\n\n    for (let i = 0; i < hashes.length; i++) {\n      if (buckets[hashes[i]] === undefined) {\n        buckets[hashes[i]] = [node.children[i]];\n      } else {\n        buckets[hashes[i]].push(node.children[i]);\n      }\n    }\n\n    for (const k of keys(buckets)) {\n      if (buckets[k].length > 1) {\n        this.setModified();\n        this.mergeNodes(node, buckets[k]);\n      }\n    }\n  }\n}\n\n/**\n * Optimizer that removes identifier nodes that are not needed for selections.\n */\nexport class RemoveUnnecessaryIdentifierNodes extends TopDownOptimizer {\n  private requiresSelectionId: boolean;\n\n  constructor(model: Model) {\n    super();\n    this.requiresSelectionId = model && requiresSelectionId(model);\n  }\n\n  public run(node: DataFlowNode) {\n    if (node instanceof IdentifierNode) {\n      // Only preserve IdentifierNodes if we have default discrete selections\n      // in our model tree, and if the nodes come after tuple producing nodes.\n      if (\n        !(\n          this.requiresSelectionId &&\n          (isDataSourceNode(node.parent) || node.parent instanceof AggregateNode || node.parent instanceof ParseNode)\n        )\n      ) {\n        this.setModified();\n        node.remove();\n      }\n    }\n  }\n}\n\n/**\n * Removes duplicate time unit nodes (as determined by the name of the output field) that may be generated due to\n * selections projected over time units. Only keeps the first time unit in any branch.\n *\n * This optimizer is a custom top down optimizer that keep track of produced fields in a branch.\n */\nexport class RemoveDuplicateTimeUnits extends Optimizer {\n  public optimize(node: DataFlowNode): boolean {\n    this.run(node, new Set());\n\n    return this.modifiedFlag;\n  }\n\n  public run(node: DataFlowNode, timeUnitFields: Set<string>) {\n    let producedFields = new Set<string>();\n\n    if (node instanceof TimeUnitNode) {\n      producedFields = node.producedFields();\n      if (hasIntersection(producedFields, timeUnitFields)) {\n        this.setModified();\n        node.removeFormulas(timeUnitFields);\n        if (node.producedFields.length === 0) {\n          node.remove();\n        }\n      }\n    }\n\n    for (const child of node.children) {\n      this.run(child, new Set([...timeUnitFields, ...producedFields]));\n    }\n  }\n}\n\n/**\n * Remove output nodes that are not required.\n */\nexport class RemoveUnnecessaryOutputNodes extends TopDownOptimizer {\n  constructor() {\n    super();\n  }\n\n  public run(node: DataFlowNode) {\n    if (node instanceof OutputNode && !node.isRequired()) {\n      this.setModified();\n      node.remove();\n    }\n  }\n}\n\n/**\n * Move parse nodes up to forks and merges them if possible.\n */\nexport class MoveParseUp extends BottomUpOptimizer {\n  public run(node: DataFlowNode) {\n    if (isDataSourceNode(node)) {\n      return;\n    }\n\n    if (node.numChildren() > 1) {\n      // Don't move parse further up but continue with parent.\n      return;\n    }\n\n    for (const child of node.children) {\n      if (child instanceof ParseNode) {\n        if (node instanceof ParseNode) {\n          this.setModified();\n          node.merge(child);\n        } else {\n          // Don't swap with nodes that produce something that the parse node depends on (e.g. lookup).\n          if (fieldIntersection(node.producedFields(), child.dependentFields())) {\n            continue;\n          }\n          this.setModified();\n          child.swapWithParent();\n        }\n      }\n    }\n\n    return;\n  }\n}\n\n/**\n * Inserts an intermediate ParseNode containing all non-conflicting parse fields and removes the empty ParseNodes.\n *\n * We assume that dependent paths that do not have a parse node can be just merged.\n */\nexport class MergeParse extends BottomUpOptimizer {\n  public run(node: DataFlowNode) {\n    const originalChildren = [...node.children];\n    const parseChildren = node.children.filter((child): child is ParseNode => child instanceof ParseNode);\n\n    if (node.numChildren() > 1 && parseChildren.length >= 1) {\n      const commonParse: Parse = {};\n      const conflictingParse = new Set<string>();\n      for (const parseNode of parseChildren) {\n        const parse = parseNode.parse;\n        for (const k of keys(parse)) {\n          if (!(k in commonParse)) {\n            commonParse[k] = parse[k];\n          } else if (commonParse[k] !== parse[k]) {\n            conflictingParse.add(k);\n          }\n        }\n      }\n\n      for (const field of conflictingParse) {\n        delete commonParse[field];\n      }\n\n      if (!isEmpty(commonParse)) {\n        this.setModified();\n        const mergedParseNode = new ParseNode(node, commonParse);\n        for (const childNode of originalChildren) {\n          if (childNode instanceof ParseNode) {\n            for (const key of keys(commonParse)) {\n              delete childNode.parse[key];\n            }\n          }\n\n          node.removeChild(childNode);\n          childNode.parent = mergedParseNode;\n\n          // remove empty parse nodes\n          if (childNode instanceof ParseNode && keys(childNode.parse).length === 0) {\n            childNode.remove();\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Repeatedly remove leaf nodes that are not output or facet nodes.\n * The reason is that we don't need subtrees that don't have any output nodes.\n * Facet nodes are needed for the row or column domains.\n */\nexport class RemoveUnusedSubtrees extends BottomUpOptimizer {\n  public run(node: DataFlowNode) {\n    if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode) {\n      // no need to continue with parent because it is output node or will have children (there was a fork)\n    } else if (node instanceof SourceNode) {\n      // ignore empty unused sources as they will be removed in optimizationDataflowHelper\n    } else {\n      this.setModified();\n      node.remove();\n    }\n  }\n}\n\n/**\n * Merge adjacent time unit nodes.\n */\nexport class MergeTimeUnits extends BottomUpOptimizer {\n  public run(node: DataFlowNode) {\n    const timeUnitChildren = node.children.filter((x): x is TimeUnitNode => x instanceof TimeUnitNode);\n    const combination = timeUnitChildren.pop();\n    for (const timeUnit of timeUnitChildren) {\n      this.setModified();\n      combination.merge(timeUnit);\n    }\n  }\n}\n\nexport class MergeAggregates extends BottomUpOptimizer {\n  public run(node: DataFlowNode) {\n    const aggChildren = node.children.filter((child): child is AggregateNode => child instanceof AggregateNode);\n\n    // Object which we'll use to map the fields which an aggregate is grouped by to\n    // the set of aggregates with that grouping. This is useful as only aggregates\n    // with the same group by can be merged\n    const groupedAggregates: Dict<AggregateNode[]> = {};\n\n    // Build groupedAggregates\n    for (const agg of aggChildren) {\n      const groupBys = hash(agg.groupBy);\n      if (!(groupBys in groupedAggregates)) {\n        groupedAggregates[groupBys] = [];\n      }\n      groupedAggregates[groupBys].push(agg);\n    }\n\n    // Merge aggregateNodes with same key in groupedAggregates\n    for (const group of keys(groupedAggregates)) {\n      const mergeableAggs = groupedAggregates[group];\n      if (mergeableAggs.length > 1) {\n        const mergedAggs = mergeableAggs.pop();\n        for (const agg of mergeableAggs) {\n          if (mergedAggs.merge(agg)) {\n            node.removeChild(agg);\n            agg.parent = mergedAggs;\n            agg.remove();\n\n            this.setModified();\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Merge bin nodes and move them up through forks. Stop at filters, parse, identifier as we want them to stay before the bin node.\n */\nexport class MergeBins extends BottomUpOptimizer {\n  constructor(private model: Model) {\n    super();\n  }\n\n  public run(node: DataFlowNode) {\n    const moveBinsUp = !(\n      isDataSourceNode(node) ||\n      node instanceof FilterNode ||\n      node instanceof ParseNode ||\n      node instanceof IdentifierNode\n    );\n\n    const promotableBins: BinNode[] = [];\n    const remainingBins: BinNode[] = [];\n\n    for (const child of node.children) {\n      if (child instanceof BinNode) {\n        if (moveBinsUp && !fieldIntersection(node.producedFields(), child.dependentFields())) {\n          promotableBins.push(child);\n        } else {\n          remainingBins.push(child);\n        }\n      }\n    }\n\n    if (promotableBins.length > 0) {\n      const promotedBin = promotableBins.pop();\n      for (const bin of promotableBins) {\n        promotedBin.merge(bin, this.model.renameSignal.bind(this.model));\n      }\n      this.setModified();\n      if (node instanceof BinNode) {\n        node.merge(promotedBin, this.model.renameSignal.bind(this.model));\n      } else {\n        promotedBin.swapWithParent();\n      }\n    }\n    if (remainingBins.length > 1) {\n      const remainingBin = remainingBins.pop();\n      for (const bin of remainingBins) {\n        remainingBin.merge(bin, this.model.renameSignal.bind(this.model));\n      }\n      this.setModified();\n    }\n  }\n}\n\n/**\n * This optimizer takes output nodes that are at a fork and moves them before the fork.\n *\n * The algorithm iterates over the children and tries to find the last output node in a chain of output nodes.\n * It then moves all output nodes before that main output node. All other children (and the children of the output nodes)\n * are inserted after the main output node.\n */\nexport class MergeOutputs extends BottomUpOptimizer {\n  public run(node: DataFlowNode) {\n    const children = [...node.children];\n    const hasOutputChild = some(children, child => child instanceof OutputNode);\n\n    if (!hasOutputChild || node.numChildren() <= 1) {\n      return;\n    }\n\n    const otherChildren: DataFlowNode[] = [];\n\n    // The output node we will connect all other nodes to.\n    // Output nodes will be added before the new node, other nodes after.\n    let mainOutput: OutputNode;\n\n    for (const child of children) {\n      if (child instanceof OutputNode) {\n        let lastOutput = child;\n\n        while (lastOutput.numChildren() === 1) {\n          const [theChild] = lastOutput.children;\n          if (theChild instanceof OutputNode) {\n            lastOutput = theChild;\n          } else {\n            break;\n          }\n        }\n\n        otherChildren.push(...lastOutput.children);\n\n        if (mainOutput) {\n          // Move the output nodes before the mainOutput. We do this by setting\n          // the parent of the first not to the parent of the main output and\n          // the main output's parent to the last output.\n\n          // note: the child is the first output\n          node.removeChild(child);\n          child.parent = mainOutput.parent;\n\n          mainOutput.parent.removeChild(mainOutput);\n          mainOutput.parent = lastOutput;\n\n          this.setModified();\n        } else {\n          mainOutput = lastOutput;\n        }\n      } else {\n        otherChildren.push(child);\n      }\n    }\n\n    if (otherChildren.length) {\n      this.setModified();\n      for (const child of otherChildren) {\n        child.parent.removeChild(child);\n        child.parent = mainOutput;\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}