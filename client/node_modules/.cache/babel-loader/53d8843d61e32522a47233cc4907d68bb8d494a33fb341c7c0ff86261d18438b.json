{"ast":null,"code":"import { toSet, stringValue, error, isArray, isObject, hasOwnProperty, accessor, key, field, array, compare, truthy } from 'vega-util';\nimport { tupleid } from 'vega-dataflow';\n\n/**\n * Parse a serialized dataflow specification.\n */\nfunction parse(spec) {\n  const ctx = this,\n    operators = spec.operators || [];\n\n  // parse background\n  if (spec.background) {\n    ctx.background = spec.background;\n  }\n\n  // parse event configuration\n  if (spec.eventConfig) {\n    ctx.eventConfig = spec.eventConfig;\n  }\n\n  // parse locale configuration\n  if (spec.locale) {\n    ctx.locale = spec.locale;\n  }\n\n  // parse operators\n  operators.forEach(entry => ctx.parseOperator(entry));\n\n  // parse operator parameters\n  operators.forEach(entry => ctx.parseOperatorParameters(entry));\n\n  // parse streams\n  (spec.streams || []).forEach(entry => ctx.parseStream(entry));\n\n  // parse updates\n  (spec.updates || []).forEach(entry => ctx.parseUpdate(entry));\n  return ctx.resolve();\n}\nconst Skip = toSet(['rule']),\n  Swap = toSet(['group', 'image', 'rect']);\nfunction adjustSpatial(encode, marktype) {\n  let code = '';\n  if (Skip[marktype]) return code;\n  if (encode.x2) {\n    if (encode.x) {\n      if (Swap[marktype]) {\n        code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';\n      }\n      code += 'o.width=o.x2-o.x;';\n    } else {\n      code += 'o.x=o.x2-(o.width||0);';\n    }\n  }\n  if (encode.xc) {\n    code += 'o.x=o.xc-(o.width||0)/2;';\n  }\n  if (encode.y2) {\n    if (encode.y) {\n      if (Swap[marktype]) {\n        code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';\n      }\n      code += 'o.height=o.y2-o.y;';\n    } else {\n      code += 'o.y=o.y2-(o.height||0);';\n    }\n  }\n  if (encode.yc) {\n    code += 'o.y=o.yc-(o.height||0)/2;';\n  }\n  return code;\n}\nfunction canonicalType(type) {\n  return (type + '').toLowerCase();\n}\nfunction isOperator(type) {\n  return canonicalType(type) === 'operator';\n}\nfunction isCollect(type) {\n  return canonicalType(type) === 'collect';\n}\nfunction expression(ctx, args, code) {\n  // wrap code in return statement if expression does not terminate\n  if (!code.endsWith(';')) {\n    code = 'return(' + code + ');';\n  }\n  const fn = Function(...args.concat(code));\n  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;\n}\n\n// generate code for comparing a single field\nfunction _compare(u, v, lt, gt) {\n  return `((u = ${u}) < (v = ${v}) || u == null) && v != null ? ${lt}\n  : (u > v || v == null) && u != null ? ${gt}\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${lt}\n  : v !== v && u === u ? ${gt} : `;\n}\nvar expressionCodegen = {\n  /**\n   * Parse an expression used to update an operator value.\n   */\n  operator: (ctx, expr) => expression(ctx, ['_'], expr.code),\n  /**\n   * Parse an expression provided as an operator parameter value.\n   */\n  parameter: (ctx, expr) => expression(ctx, ['datum', '_'], expr.code),\n  /**\n   * Parse an expression applied to an event stream.\n   */\n  event: (ctx, expr) => expression(ctx, ['event'], expr.code),\n  /**\n   * Parse an expression used to handle an event-driven operator update.\n   */\n  handler: (ctx, expr) => {\n    const code = `var datum=event.item&&event.item.datum;return ${expr.code};`;\n    return expression(ctx, ['_', 'event'], code);\n  },\n  /**\n   * Parse an expression that performs visual encoding.\n   */\n  encode: (ctx, encode) => {\n    const {\n      marktype,\n      channels\n    } = encode;\n    let code = 'var o=item,datum=o.datum,m=0,$;';\n    for (const name in channels) {\n      const o = 'o[' + stringValue(name) + ']';\n      code += `$=${channels[name].code};if(${o}!==$)${o}=$,m=1;`;\n    }\n    code += adjustSpatial(channels, marktype);\n    code += 'return m;';\n    return expression(ctx, ['item', '_'], code);\n  },\n  /**\n   * Optimized code generators for access and comparison.\n   */\n  codegen: {\n    get(path) {\n      const ref = `[${path.map(stringValue).join('][')}]`;\n      const get = Function('_', `return _${ref};`);\n      get.path = ref;\n      return get;\n    },\n    comparator(fields, orders) {\n      let t;\n      const map = (f, i) => {\n        const o = orders[i];\n        let u, v;\n        if (f.path) {\n          u = `a${f.path}`;\n          v = `b${f.path}`;\n        } else {\n          (t = t || {})['f' + i] = f;\n          u = `this.f${i}(a)`;\n          v = `this.f${i}(b)`;\n        }\n        return _compare(u, v, -o, o);\n      };\n      const fn = Function('a', 'b', 'var u, v; return ' + fields.map(map).join('') + '0;');\n      return t ? fn.bind(t) : fn;\n    }\n  }\n};\n\n/**\n * Parse a dataflow operator.\n */\nfunction parseOperator(spec) {\n  const ctx = this;\n  if (isOperator(spec.type) || !spec.type) {\n    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);\n  } else {\n    ctx.transform(spec, spec.type);\n  }\n}\n\n/**\n * Parse and assign operator parameters.\n */\nfunction parseOperatorParameters(spec) {\n  const ctx = this;\n  if (spec.params) {\n    const op = ctx.get(spec.id);\n    if (!op) error('Invalid operator id: ' + spec.id);\n    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));\n  }\n}\n\n/**\n * Parse a set of operator parameters.\n */\nfunction parseParameters(spec, params) {\n  params = params || {};\n  const ctx = this;\n  for (const key in spec) {\n    const value = spec[key];\n    params[key] = isArray(value) ? value.map(v => parseParameter(v, ctx, params)) : parseParameter(value, ctx, params);\n  }\n  return params;\n}\n\n/**\n * Parse a single parameter.\n */\nfunction parseParameter(spec, ctx, params) {\n  if (!spec || !isObject(spec)) return spec;\n  for (let i = 0, n = PARSERS.length, p; i < n; ++i) {\n    p = PARSERS[i];\n    if (hasOwnProperty(spec, p.key)) {\n      return p.parse(spec, ctx, params);\n    }\n  }\n  return spec;\n}\n\n/** Reference parsers. */\nvar PARSERS = [{\n  key: '$ref',\n  parse: getOperator\n}, {\n  key: '$key',\n  parse: getKey\n}, {\n  key: '$expr',\n  parse: getExpression\n}, {\n  key: '$field',\n  parse: getField\n}, {\n  key: '$encode',\n  parse: getEncode\n}, {\n  key: '$compare',\n  parse: getCompare\n}, {\n  key: '$context',\n  parse: getContext\n}, {\n  key: '$subflow',\n  parse: getSubflow\n}, {\n  key: '$tupleid',\n  parse: getTupleId\n}];\n\n/**\n * Resolve an operator reference.\n */\nfunction getOperator(_, ctx) {\n  return ctx.get(_.$ref) || error('Operator not defined: ' + _.$ref);\n}\n\n/**\n * Resolve an expression reference.\n */\nfunction getExpression(_, ctx, params) {\n  if (_.$params) {\n    // parse expression parameters\n    ctx.parseParameters(_.$params, params);\n  }\n  const k = 'e:' + _.$expr.code;\n  return ctx.fn[k] || (ctx.fn[k] = accessor(ctx.parameterExpression(_.$expr), _.$fields));\n}\n\n/**\n * Resolve a key accessor reference.\n */\nfunction getKey(_, ctx) {\n  const k = 'k:' + _.$key + '_' + !!_.$flat;\n  return ctx.fn[k] || (ctx.fn[k] = key(_.$key, _.$flat, ctx.expr.codegen));\n}\n\n/**\n * Resolve a field accessor reference.\n */\nfunction getField(_, ctx) {\n  if (!_.$field) return null;\n  const k = 'f:' + _.$field + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = field(_.$field, _.$name, ctx.expr.codegen));\n}\n\n/**\n * Resolve a comparator function reference.\n */\nfunction getCompare(_, ctx) {\n  // As of Vega 5.5.3, $tupleid sort is no longer used.\n  // Keep here for now for backwards compatibility.\n  const k = 'c:' + _.$compare + '_' + _.$order,\n    c = array(_.$compare).map(_ => _ && _.$tupleid ? tupleid : _);\n  return ctx.fn[k] || (ctx.fn[k] = compare(c, _.$order, ctx.expr.codegen));\n}\n\n/**\n * Resolve an encode operator reference.\n */\nfunction getEncode(_, ctx) {\n  const spec = _.$encode,\n    encode = {};\n  for (const name in spec) {\n    const enc = spec[name];\n    encode[name] = accessor(ctx.encodeExpression(enc.$expr), enc.$fields);\n    encode[name].output = enc.$output;\n  }\n  return encode;\n}\n\n/**\n * Resolve a context reference.\n */\nfunction getContext(_, ctx) {\n  return ctx;\n}\n\n/**\n * Resolve a recursive subflow specification.\n */\nfunction getSubflow(_, ctx) {\n  const spec = _.$subflow;\n  return function (dataflow, key, parent) {\n    const subctx = ctx.fork().parse(spec),\n      op = subctx.get(spec.operators[0].id),\n      p = subctx.signals.parent;\n    if (p) p.set(parent);\n    op.detachSubflow = () => ctx.detach(subctx);\n    return op;\n  };\n}\n\n/**\n * Resolve a tuple id reference.\n */\nfunction getTupleId() {\n  return tupleid;\n}\n\n/**\n * Parse an event stream specification.\n */\nfunction parseStream(spec) {\n  var ctx = this,\n    filter = spec.filter != null ? ctx.eventExpression(spec.filter) : undefined,\n    stream = spec.stream != null ? ctx.get(spec.stream) : undefined,\n    args;\n  if (spec.source) {\n    stream = ctx.events(spec.source, spec.type, filter);\n  } else if (spec.merge) {\n    args = spec.merge.map(_ => ctx.get(_));\n    stream = args[0].merge.apply(args[0], args.slice(1));\n  }\n  if (spec.between) {\n    args = spec.between.map(_ => ctx.get(_));\n    stream = stream.between(args[0], args[1]);\n  }\n  if (spec.filter) {\n    stream = stream.filter(filter);\n  }\n  if (spec.throttle != null) {\n    stream = stream.throttle(+spec.throttle);\n  }\n  if (spec.debounce != null) {\n    stream = stream.debounce(+spec.debounce);\n  }\n  if (stream == null) {\n    error('Invalid stream definition: ' + JSON.stringify(spec));\n  }\n  if (spec.consume) stream.consume(true);\n  ctx.stream(spec, stream);\n}\n\n/**\n * Parse an event-driven operator update.\n */\nfunction parseUpdate(spec) {\n  var ctx = this,\n    srcid = isObject(srcid = spec.source) ? srcid.$ref : srcid,\n    source = ctx.get(srcid),\n    target = null,\n    update = spec.update,\n    params = undefined;\n  if (!source) error('Source not defined: ' + spec.source);\n  target = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);\n  if (update && update.$expr) {\n    if (update.$params) {\n      params = ctx.parseParameters(update.$params);\n    }\n    update = ctx.handlerExpression(update.$expr);\n  }\n  ctx.update(spec, source, target, update, params);\n}\nconst SKIP = {\n  skip: true\n};\nfunction getState(options) {\n  var ctx = this,\n    state = {};\n  if (options.signals) {\n    var signals = state.signals = {};\n    Object.keys(ctx.signals).forEach(key => {\n      const op = ctx.signals[key];\n      if (options.signals(key, op)) {\n        signals[key] = op.value;\n      }\n    });\n  }\n  if (options.data) {\n    var data = state.data = {};\n    Object.keys(ctx.data).forEach(key => {\n      const dataset = ctx.data[key];\n      if (options.data(key, dataset)) {\n        data[key] = dataset.input.value;\n      }\n    });\n  }\n  if (ctx.subcontext && options.recurse !== false) {\n    state.subcontext = ctx.subcontext.map(ctx => ctx.getState(options));\n  }\n  return state;\n}\nfunction setState(state) {\n  var ctx = this,\n    df = ctx.dataflow,\n    data = state.data,\n    signals = state.signals;\n  Object.keys(signals || {}).forEach(key => {\n    df.update(ctx.signals[key], signals[key], SKIP);\n  });\n  Object.keys(data || {}).forEach(key => {\n    df.pulse(ctx.data[key].input, df.changeset().remove(truthy).insert(data[key]));\n  });\n  (state.subcontext || []).forEach((substate, i) => {\n    const subctx = ctx.subcontext[i];\n    if (subctx) subctx.setState(substate);\n  });\n}\n\n/**\n * Context objects store the current parse state.\n * Enables lookup of parsed operators, event streams, accessors, etc.\n * Provides a 'fork' method for creating child contexts for subflows.\n */\nfunction context(df, transforms, functions, expr) {\n  return new Context(df, transforms, functions, expr);\n}\nfunction Context(df, transforms, functions, expr) {\n  this.dataflow = df;\n  this.transforms = transforms;\n  this.events = df.events.bind(df);\n  this.expr = expr || expressionCodegen, this.signals = {};\n  this.scales = {};\n  this.nodes = {};\n  this.data = {};\n  this.fn = {};\n  if (functions) {\n    this.functions = Object.create(functions);\n    this.functions.context = this;\n  }\n}\nfunction Subcontext(ctx) {\n  this.dataflow = ctx.dataflow;\n  this.transforms = ctx.transforms;\n  this.events = ctx.events;\n  this.expr = ctx.expr;\n  this.signals = Object.create(ctx.signals);\n  this.scales = Object.create(ctx.scales);\n  this.nodes = Object.create(ctx.nodes);\n  this.data = Object.create(ctx.data);\n  this.fn = Object.create(ctx.fn);\n  if (ctx.functions) {\n    this.functions = Object.create(ctx.functions);\n    this.functions.context = this;\n  }\n}\nContext.prototype = Subcontext.prototype = {\n  fork() {\n    const ctx = new Subcontext(this);\n    (this.subcontext || (this.subcontext = [])).push(ctx);\n    return ctx;\n  },\n  detach(ctx) {\n    this.subcontext = this.subcontext.filter(c => c !== ctx);\n\n    // disconnect all nodes in the subcontext\n    // wipe out targets first for better efficiency\n    const keys = Object.keys(ctx.nodes);\n    for (const key of keys) ctx.nodes[key]._targets = null;\n    for (const key of keys) ctx.nodes[key].detach();\n    ctx.nodes = null;\n  },\n  get(id) {\n    return this.nodes[id];\n  },\n  set(id, node) {\n    return this.nodes[id] = node;\n  },\n  add(spec, op) {\n    const ctx = this,\n      df = ctx.dataflow,\n      data = spec.value;\n    ctx.set(spec.id, op);\n    if (isCollect(spec.type) && data) {\n      if (data.$ingest) {\n        df.ingest(op, data.$ingest, data.$format);\n      } else if (data.$request) {\n        df.preload(op, data.$request, data.$format);\n      } else {\n        df.pulse(op, df.changeset().insert(data));\n      }\n    }\n    if (spec.root) {\n      ctx.root = op;\n    }\n    if (spec.parent) {\n      let p = ctx.get(spec.parent.$ref);\n      if (p) {\n        df.connect(p, [op]);\n        op.targets().add(p);\n      } else {\n        (ctx.unresolved = ctx.unresolved || []).push(() => {\n          p = ctx.get(spec.parent.$ref);\n          df.connect(p, [op]);\n          op.targets().add(p);\n        });\n      }\n    }\n    if (spec.signal) {\n      ctx.signals[spec.signal] = op;\n    }\n    if (spec.scale) {\n      ctx.scales[spec.scale] = op;\n    }\n    if (spec.data) {\n      for (const name in spec.data) {\n        const data = ctx.data[name] || (ctx.data[name] = {});\n        spec.data[name].forEach(role => data[role] = op);\n      }\n    }\n  },\n  resolve() {\n    (this.unresolved || []).forEach(fn => fn());\n    delete this.unresolved;\n    return this;\n  },\n  operator(spec, update) {\n    this.add(spec, this.dataflow.add(spec.value, update));\n  },\n  transform(spec, type) {\n    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));\n  },\n  stream(spec, stream) {\n    this.set(spec.id, stream);\n  },\n  update(spec, stream, target, update, params) {\n    this.dataflow.on(stream, target, update, params, spec.options);\n  },\n  // expression parsing\n  operatorExpression(expr) {\n    return this.expr.operator(this, expr);\n  },\n  parameterExpression(expr) {\n    return this.expr.parameter(this, expr);\n  },\n  eventExpression(expr) {\n    return this.expr.event(this, expr);\n  },\n  handlerExpression(expr) {\n    return this.expr.handler(this, expr);\n  },\n  encodeExpression(encode) {\n    return this.expr.encode(this, encode);\n  },\n  // parse methods\n  parse,\n  parseOperator,\n  parseOperatorParameters,\n  parseParameters,\n  parseStream,\n  parseUpdate,\n  // state methods\n  getState,\n  setState\n};\nexport { context };","map":{"version":3,"names":["toSet","stringValue","error","isArray","isObject","hasOwnProperty","accessor","key","field","array","compare","truthy","tupleid","parse","spec","ctx","operators","background","eventConfig","locale","forEach","entry","parseOperator","parseOperatorParameters","streams","parseStream","updates","parseUpdate","resolve","Skip","Swap","adjustSpatial","encode","marktype","code","x2","x","xc","y2","y","yc","canonicalType","type","toLowerCase","isOperator","isCollect","expression","args","endsWith","fn","Function","concat","functions","bind","_compare","u","v","lt","gt","expressionCodegen","operator","expr","parameter","event","handler","channels","name","o","codegen","get","path","ref","map","join","comparator","fields","orders","t","f","i","update","operatorExpression","transform","params","op","id","dataflow","connect","parameters","parseParameters","react","initonly","value","parseParameter","n","PARSERS","length","p","getOperator","getKey","getExpression","getField","getEncode","getCompare","getContext","getSubflow","getTupleId","_","$ref","$params","k","$expr","parameterExpression","$fields","$key","$flat","$field","$name","$compare","$order","c","$tupleid","$encode","enc","encodeExpression","output","$output","$subflow","parent","subctx","fork","signals","set","detachSubflow","detach","filter","eventExpression","undefined","stream","source","events","merge","apply","slice","between","throttle","debounce","JSON","stringify","consume","srcid","target","handlerExpression","SKIP","skip","getState","options","state","Object","keys","data","dataset","input","subcontext","recurse","setState","df","pulse","changeset","remove","insert","substate","context","transforms","Context","scales","nodes","create","Subcontext","prototype","push","_targets","node","add","$ingest","ingest","$format","$request","preload","root","targets","unresolved","signal","scale","role","on"],"sources":["C:/Users/sutul/node_modules/vega-runtime/build/vega-runtime.module.js"],"sourcesContent":["import { toSet, stringValue, error, isArray, isObject, hasOwnProperty, accessor, key, field, array, compare, truthy } from 'vega-util';\nimport { tupleid } from 'vega-dataflow';\n\n/**\n * Parse a serialized dataflow specification.\n */\nfunction parse (spec) {\n  const ctx = this,\n    operators = spec.operators || [];\n\n  // parse background\n  if (spec.background) {\n    ctx.background = spec.background;\n  }\n\n  // parse event configuration\n  if (spec.eventConfig) {\n    ctx.eventConfig = spec.eventConfig;\n  }\n\n  // parse locale configuration\n  if (spec.locale) {\n    ctx.locale = spec.locale;\n  }\n\n  // parse operators\n  operators.forEach(entry => ctx.parseOperator(entry));\n\n  // parse operator parameters\n  operators.forEach(entry => ctx.parseOperatorParameters(entry));\n\n  // parse streams\n  (spec.streams || []).forEach(entry => ctx.parseStream(entry));\n\n  // parse updates\n  (spec.updates || []).forEach(entry => ctx.parseUpdate(entry));\n  return ctx.resolve();\n}\n\nconst Skip = toSet(['rule']),\n  Swap = toSet(['group', 'image', 'rect']);\nfunction adjustSpatial(encode, marktype) {\n  let code = '';\n  if (Skip[marktype]) return code;\n  if (encode.x2) {\n    if (encode.x) {\n      if (Swap[marktype]) {\n        code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';\n      }\n      code += 'o.width=o.x2-o.x;';\n    } else {\n      code += 'o.x=o.x2-(o.width||0);';\n    }\n  }\n  if (encode.xc) {\n    code += 'o.x=o.xc-(o.width||0)/2;';\n  }\n  if (encode.y2) {\n    if (encode.y) {\n      if (Swap[marktype]) {\n        code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';\n      }\n      code += 'o.height=o.y2-o.y;';\n    } else {\n      code += 'o.y=o.y2-(o.height||0);';\n    }\n  }\n  if (encode.yc) {\n    code += 'o.y=o.yc-(o.height||0)/2;';\n  }\n  return code;\n}\nfunction canonicalType(type) {\n  return (type + '').toLowerCase();\n}\nfunction isOperator(type) {\n  return canonicalType(type) === 'operator';\n}\nfunction isCollect(type) {\n  return canonicalType(type) === 'collect';\n}\n\nfunction expression(ctx, args, code) {\n  // wrap code in return statement if expression does not terminate\n  if (!code.endsWith(';')) {\n    code = 'return(' + code + ');';\n  }\n  const fn = Function(...args.concat(code));\n  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;\n}\n\n// generate code for comparing a single field\nfunction _compare(u, v, lt, gt) {\n  return `((u = ${u}) < (v = ${v}) || u == null) && v != null ? ${lt}\n  : (u > v || v == null) && u != null ? ${gt}\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${lt}\n  : v !== v && u === u ? ${gt} : `;\n}\nvar expressionCodegen = {\n  /**\n   * Parse an expression used to update an operator value.\n   */\n  operator: (ctx, expr) => expression(ctx, ['_'], expr.code),\n  /**\n   * Parse an expression provided as an operator parameter value.\n   */\n  parameter: (ctx, expr) => expression(ctx, ['datum', '_'], expr.code),\n  /**\n   * Parse an expression applied to an event stream.\n   */\n  event: (ctx, expr) => expression(ctx, ['event'], expr.code),\n  /**\n   * Parse an expression used to handle an event-driven operator update.\n   */\n  handler: (ctx, expr) => {\n    const code = `var datum=event.item&&event.item.datum;return ${expr.code};`;\n    return expression(ctx, ['_', 'event'], code);\n  },\n  /**\n   * Parse an expression that performs visual encoding.\n   */\n  encode: (ctx, encode) => {\n    const {\n      marktype,\n      channels\n    } = encode;\n    let code = 'var o=item,datum=o.datum,m=0,$;';\n    for (const name in channels) {\n      const o = 'o[' + stringValue(name) + ']';\n      code += `$=${channels[name].code};if(${o}!==$)${o}=$,m=1;`;\n    }\n    code += adjustSpatial(channels, marktype);\n    code += 'return m;';\n    return expression(ctx, ['item', '_'], code);\n  },\n  /**\n   * Optimized code generators for access and comparison.\n   */\n  codegen: {\n    get(path) {\n      const ref = `[${path.map(stringValue).join('][')}]`;\n      const get = Function('_', `return _${ref};`);\n      get.path = ref;\n      return get;\n    },\n    comparator(fields, orders) {\n      let t;\n      const map = (f, i) => {\n        const o = orders[i];\n        let u, v;\n        if (f.path) {\n          u = `a${f.path}`;\n          v = `b${f.path}`;\n        } else {\n          (t = t || {})['f' + i] = f;\n          u = `this.f${i}(a)`;\n          v = `this.f${i}(b)`;\n        }\n        return _compare(u, v, -o, o);\n      };\n      const fn = Function('a', 'b', 'var u, v; return ' + fields.map(map).join('') + '0;');\n      return t ? fn.bind(t) : fn;\n    }\n  }\n};\n\n/**\n * Parse a dataflow operator.\n */\nfunction parseOperator(spec) {\n  const ctx = this;\n  if (isOperator(spec.type) || !spec.type) {\n    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);\n  } else {\n    ctx.transform(spec, spec.type);\n  }\n}\n\n/**\n * Parse and assign operator parameters.\n */\nfunction parseOperatorParameters(spec) {\n  const ctx = this;\n  if (spec.params) {\n    const op = ctx.get(spec.id);\n    if (!op) error('Invalid operator id: ' + spec.id);\n    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));\n  }\n}\n\n/**\n * Parse a set of operator parameters.\n */\nfunction parseParameters(spec, params) {\n  params = params || {};\n  const ctx = this;\n  for (const key in spec) {\n    const value = spec[key];\n    params[key] = isArray(value) ? value.map(v => parseParameter(v, ctx, params)) : parseParameter(value, ctx, params);\n  }\n  return params;\n}\n\n/**\n * Parse a single parameter.\n */\nfunction parseParameter(spec, ctx, params) {\n  if (!spec || !isObject(spec)) return spec;\n  for (let i = 0, n = PARSERS.length, p; i < n; ++i) {\n    p = PARSERS[i];\n    if (hasOwnProperty(spec, p.key)) {\n      return p.parse(spec, ctx, params);\n    }\n  }\n  return spec;\n}\n\n/** Reference parsers. */\nvar PARSERS = [{\n  key: '$ref',\n  parse: getOperator\n}, {\n  key: '$key',\n  parse: getKey\n}, {\n  key: '$expr',\n  parse: getExpression\n}, {\n  key: '$field',\n  parse: getField\n}, {\n  key: '$encode',\n  parse: getEncode\n}, {\n  key: '$compare',\n  parse: getCompare\n}, {\n  key: '$context',\n  parse: getContext\n}, {\n  key: '$subflow',\n  parse: getSubflow\n}, {\n  key: '$tupleid',\n  parse: getTupleId\n}];\n\n/**\n * Resolve an operator reference.\n */\nfunction getOperator(_, ctx) {\n  return ctx.get(_.$ref) || error('Operator not defined: ' + _.$ref);\n}\n\n/**\n * Resolve an expression reference.\n */\nfunction getExpression(_, ctx, params) {\n  if (_.$params) {\n    // parse expression parameters\n    ctx.parseParameters(_.$params, params);\n  }\n  const k = 'e:' + _.$expr.code;\n  return ctx.fn[k] || (ctx.fn[k] = accessor(ctx.parameterExpression(_.$expr), _.$fields));\n}\n\n/**\n * Resolve a key accessor reference.\n */\nfunction getKey(_, ctx) {\n  const k = 'k:' + _.$key + '_' + !!_.$flat;\n  return ctx.fn[k] || (ctx.fn[k] = key(_.$key, _.$flat, ctx.expr.codegen));\n}\n\n/**\n * Resolve a field accessor reference.\n */\nfunction getField(_, ctx) {\n  if (!_.$field) return null;\n  const k = 'f:' + _.$field + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = field(_.$field, _.$name, ctx.expr.codegen));\n}\n\n/**\n * Resolve a comparator function reference.\n */\nfunction getCompare(_, ctx) {\n  // As of Vega 5.5.3, $tupleid sort is no longer used.\n  // Keep here for now for backwards compatibility.\n  const k = 'c:' + _.$compare + '_' + _.$order,\n    c = array(_.$compare).map(_ => _ && _.$tupleid ? tupleid : _);\n  return ctx.fn[k] || (ctx.fn[k] = compare(c, _.$order, ctx.expr.codegen));\n}\n\n/**\n * Resolve an encode operator reference.\n */\nfunction getEncode(_, ctx) {\n  const spec = _.$encode,\n    encode = {};\n  for (const name in spec) {\n    const enc = spec[name];\n    encode[name] = accessor(ctx.encodeExpression(enc.$expr), enc.$fields);\n    encode[name].output = enc.$output;\n  }\n  return encode;\n}\n\n/**\n * Resolve a context reference.\n */\nfunction getContext(_, ctx) {\n  return ctx;\n}\n\n/**\n * Resolve a recursive subflow specification.\n */\nfunction getSubflow(_, ctx) {\n  const spec = _.$subflow;\n  return function (dataflow, key, parent) {\n    const subctx = ctx.fork().parse(spec),\n      op = subctx.get(spec.operators[0].id),\n      p = subctx.signals.parent;\n    if (p) p.set(parent);\n    op.detachSubflow = () => ctx.detach(subctx);\n    return op;\n  };\n}\n\n/**\n * Resolve a tuple id reference.\n */\nfunction getTupleId() {\n  return tupleid;\n}\n\n/**\n * Parse an event stream specification.\n */\nfunction parseStream (spec) {\n  var ctx = this,\n    filter = spec.filter != null ? ctx.eventExpression(spec.filter) : undefined,\n    stream = spec.stream != null ? ctx.get(spec.stream) : undefined,\n    args;\n  if (spec.source) {\n    stream = ctx.events(spec.source, spec.type, filter);\n  } else if (spec.merge) {\n    args = spec.merge.map(_ => ctx.get(_));\n    stream = args[0].merge.apply(args[0], args.slice(1));\n  }\n  if (spec.between) {\n    args = spec.between.map(_ => ctx.get(_));\n    stream = stream.between(args[0], args[1]);\n  }\n  if (spec.filter) {\n    stream = stream.filter(filter);\n  }\n  if (spec.throttle != null) {\n    stream = stream.throttle(+spec.throttle);\n  }\n  if (spec.debounce != null) {\n    stream = stream.debounce(+spec.debounce);\n  }\n  if (stream == null) {\n    error('Invalid stream definition: ' + JSON.stringify(spec));\n  }\n  if (spec.consume) stream.consume(true);\n  ctx.stream(spec, stream);\n}\n\n/**\n * Parse an event-driven operator update.\n */\nfunction parseUpdate (spec) {\n  var ctx = this,\n    srcid = isObject(srcid = spec.source) ? srcid.$ref : srcid,\n    source = ctx.get(srcid),\n    target = null,\n    update = spec.update,\n    params = undefined;\n  if (!source) error('Source not defined: ' + spec.source);\n  target = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);\n  if (update && update.$expr) {\n    if (update.$params) {\n      params = ctx.parseParameters(update.$params);\n    }\n    update = ctx.handlerExpression(update.$expr);\n  }\n  ctx.update(spec, source, target, update, params);\n}\n\nconst SKIP = {\n  skip: true\n};\nfunction getState(options) {\n  var ctx = this,\n    state = {};\n  if (options.signals) {\n    var signals = state.signals = {};\n    Object.keys(ctx.signals).forEach(key => {\n      const op = ctx.signals[key];\n      if (options.signals(key, op)) {\n        signals[key] = op.value;\n      }\n    });\n  }\n  if (options.data) {\n    var data = state.data = {};\n    Object.keys(ctx.data).forEach(key => {\n      const dataset = ctx.data[key];\n      if (options.data(key, dataset)) {\n        data[key] = dataset.input.value;\n      }\n    });\n  }\n  if (ctx.subcontext && options.recurse !== false) {\n    state.subcontext = ctx.subcontext.map(ctx => ctx.getState(options));\n  }\n  return state;\n}\nfunction setState(state) {\n  var ctx = this,\n    df = ctx.dataflow,\n    data = state.data,\n    signals = state.signals;\n  Object.keys(signals || {}).forEach(key => {\n    df.update(ctx.signals[key], signals[key], SKIP);\n  });\n  Object.keys(data || {}).forEach(key => {\n    df.pulse(ctx.data[key].input, df.changeset().remove(truthy).insert(data[key]));\n  });\n  (state.subcontext || []).forEach((substate, i) => {\n    const subctx = ctx.subcontext[i];\n    if (subctx) subctx.setState(substate);\n  });\n}\n\n/**\n * Context objects store the current parse state.\n * Enables lookup of parsed operators, event streams, accessors, etc.\n * Provides a 'fork' method for creating child contexts for subflows.\n */\nfunction context (df, transforms, functions, expr) {\n  return new Context(df, transforms, functions, expr);\n}\nfunction Context(df, transforms, functions, expr) {\n  this.dataflow = df;\n  this.transforms = transforms;\n  this.events = df.events.bind(df);\n  this.expr = expr || expressionCodegen, this.signals = {};\n  this.scales = {};\n  this.nodes = {};\n  this.data = {};\n  this.fn = {};\n  if (functions) {\n    this.functions = Object.create(functions);\n    this.functions.context = this;\n  }\n}\nfunction Subcontext(ctx) {\n  this.dataflow = ctx.dataflow;\n  this.transforms = ctx.transforms;\n  this.events = ctx.events;\n  this.expr = ctx.expr;\n  this.signals = Object.create(ctx.signals);\n  this.scales = Object.create(ctx.scales);\n  this.nodes = Object.create(ctx.nodes);\n  this.data = Object.create(ctx.data);\n  this.fn = Object.create(ctx.fn);\n  if (ctx.functions) {\n    this.functions = Object.create(ctx.functions);\n    this.functions.context = this;\n  }\n}\nContext.prototype = Subcontext.prototype = {\n  fork() {\n    const ctx = new Subcontext(this);\n    (this.subcontext || (this.subcontext = [])).push(ctx);\n    return ctx;\n  },\n  detach(ctx) {\n    this.subcontext = this.subcontext.filter(c => c !== ctx);\n\n    // disconnect all nodes in the subcontext\n    // wipe out targets first for better efficiency\n    const keys = Object.keys(ctx.nodes);\n    for (const key of keys) ctx.nodes[key]._targets = null;\n    for (const key of keys) ctx.nodes[key].detach();\n    ctx.nodes = null;\n  },\n  get(id) {\n    return this.nodes[id];\n  },\n  set(id, node) {\n    return this.nodes[id] = node;\n  },\n  add(spec, op) {\n    const ctx = this,\n      df = ctx.dataflow,\n      data = spec.value;\n    ctx.set(spec.id, op);\n    if (isCollect(spec.type) && data) {\n      if (data.$ingest) {\n        df.ingest(op, data.$ingest, data.$format);\n      } else if (data.$request) {\n        df.preload(op, data.$request, data.$format);\n      } else {\n        df.pulse(op, df.changeset().insert(data));\n      }\n    }\n    if (spec.root) {\n      ctx.root = op;\n    }\n    if (spec.parent) {\n      let p = ctx.get(spec.parent.$ref);\n      if (p) {\n        df.connect(p, [op]);\n        op.targets().add(p);\n      } else {\n        (ctx.unresolved = ctx.unresolved || []).push(() => {\n          p = ctx.get(spec.parent.$ref);\n          df.connect(p, [op]);\n          op.targets().add(p);\n        });\n      }\n    }\n    if (spec.signal) {\n      ctx.signals[spec.signal] = op;\n    }\n    if (spec.scale) {\n      ctx.scales[spec.scale] = op;\n    }\n    if (spec.data) {\n      for (const name in spec.data) {\n        const data = ctx.data[name] || (ctx.data[name] = {});\n        spec.data[name].forEach(role => data[role] = op);\n      }\n    }\n  },\n  resolve() {\n    (this.unresolved || []).forEach(fn => fn());\n    delete this.unresolved;\n    return this;\n  },\n  operator(spec, update) {\n    this.add(spec, this.dataflow.add(spec.value, update));\n  },\n  transform(spec, type) {\n    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));\n  },\n  stream(spec, stream) {\n    this.set(spec.id, stream);\n  },\n  update(spec, stream, target, update, params) {\n    this.dataflow.on(stream, target, update, params, spec.options);\n  },\n  // expression parsing\n  operatorExpression(expr) {\n    return this.expr.operator(this, expr);\n  },\n  parameterExpression(expr) {\n    return this.expr.parameter(this, expr);\n  },\n  eventExpression(expr) {\n    return this.expr.event(this, expr);\n  },\n  handlerExpression(expr) {\n    return this.expr.handler(this, expr);\n  },\n  encodeExpression(encode) {\n    return this.expr.encode(this, encode);\n  },\n  // parse methods\n  parse,\n  parseOperator,\n  parseOperatorParameters,\n  parseParameters,\n  parseStream,\n  parseUpdate,\n  // state methods\n  getState,\n  setState\n};\n\nexport { context };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}