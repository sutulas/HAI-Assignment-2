{"ast":null,"code":"import { isScaleChannel } from '../../channel';\nimport { vgField as fieldRef } from '../../channeldef';\nimport { hash, keys } from '../../util';\nimport { getScaleInvalidDataMode } from '../invalid/ScaleInvalidDataMode';\nimport { DataFlowNode } from './dataflow';\nimport { isCountingAggregateOp } from '../../aggregate';\nexport class FilterInvalidNode extends DataFlowNode {\n  clone() {\n    return new FilterInvalidNode(null, {\n      ...this.filter\n    });\n  }\n  constructor(parent, filter) {\n    super(parent);\n    this.filter = filter;\n  }\n  static make(parent, model, dataSourcesForHandlingInvalidValues) {\n    const {\n      config,\n      markDef\n    } = model;\n    const {\n      marks,\n      scales\n    } = dataSourcesForHandlingInvalidValues;\n    if (marks === 'include-invalid-values' && scales === 'include-invalid-values') {\n      // If neither marks nor scale domains need data source to filter null values, then don't add the filter.\n      return null;\n    }\n    const filter = model.reduceFieldDef((aggregator, fieldDef, channel) => {\n      const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);\n      if (scaleComponent) {\n        const scaleType = scaleComponent.get('type');\n        const {\n          aggregate\n        } = fieldDef;\n        const invalidDataMode = getScaleInvalidDataMode({\n          scaleChannel: channel,\n          markDef,\n          config,\n          scaleType,\n          isCountAggregate: isCountingAggregateOp(aggregate)\n        });\n        // If the invalid data mode is include or always-valid, we don't need to filter invalid values as the scale can handle invalid values.\n        if (invalidDataMode !== 'show' && invalidDataMode !== 'always-valid') {\n          aggregator[fieldDef.field] = fieldDef; // we know that the fieldDef is a typed field def\n        }\n      }\n      return aggregator;\n    }, {});\n    if (!keys(filter).length) {\n      return null;\n    }\n    return new FilterInvalidNode(parent, filter);\n  }\n  dependentFields() {\n    return new Set(keys(this.filter));\n  }\n  producedFields() {\n    return new Set(); // filter does not produce any new fields\n  }\n  hash() {\n    return `FilterInvalid ${hash(this.filter)}`;\n  }\n  /**\n   * Create the VgTransforms for each of the filtered fields.\n   */\n  assemble() {\n    const filters = keys(this.filter).reduce((vegaFilters, field) => {\n      const fieldDef = this.filter[field];\n      const ref = fieldRef(fieldDef, {\n        expr: 'datum'\n      });\n      if (fieldDef !== null) {\n        if (fieldDef.type === 'temporal') {\n          vegaFilters.push(`(isDate(${ref}) || (${isValidFiniteNumberExpr(ref)}))`);\n        } else if (fieldDef.type === 'quantitative') {\n          vegaFilters.push(isValidFiniteNumberExpr(ref));\n        } else {\n          // should never get here\n        }\n      }\n      return vegaFilters;\n    }, []);\n    return filters.length > 0 ? {\n      type: 'filter',\n      expr: filters.join(' && ')\n    } : null;\n  }\n}\nexport function isValidFiniteNumberExpr(ref) {\n  return `isValid(${ref}) && isFinite(+${ref})`;\n}","map":{"version":3,"names":["isScaleChannel","vgField","fieldRef","hash","keys","getScaleInvalidDataMode","DataFlowNode","isCountingAggregateOp","FilterInvalidNode","clone","filter","constructor","parent","make","model","dataSourcesForHandlingInvalidValues","config","markDef","marks","scales","reduceFieldDef","aggregator","fieldDef","channel","scaleComponent","getScaleComponent","scaleType","get","aggregate","invalidDataMode","scaleChannel","isCountAggregate","field","length","dependentFields","Set","producedFields","assemble","filters","reduce","vegaFilters","ref","expr","type","push","isValidFiniteNumberExpr","join"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\data\\filterinvalid.ts"],"sourcesContent":["import type {FilterTransform as VgFilterTransform} from 'vega';\nimport {isScaleChannel} from '../../channel';\nimport {TypedFieldDef, vgField as fieldRef} from '../../channeldef';\nimport {Dict, hash, keys} from '../../util';\nimport {getScaleInvalidDataMode} from '../invalid/ScaleInvalidDataMode';\nimport {DataSourcesForHandlingInvalidValues} from '../invalid/datasources';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\nimport {isCountingAggregateOp} from '../../aggregate';\n\nexport class FilterInvalidNode extends DataFlowNode {\n  public clone() {\n    return new FilterInvalidNode(null, {...this.filter});\n  }\n\n  constructor(\n    parent: DataFlowNode,\n    public readonly filter: Dict<TypedFieldDef<string>>\n  ) {\n    super(parent);\n  }\n\n  public static make(\n    parent: DataFlowNode,\n    model: UnitModel,\n    dataSourcesForHandlingInvalidValues: DataSourcesForHandlingInvalidValues\n  ): FilterInvalidNode {\n    const {config, markDef} = model;\n\n    const {marks, scales} = dataSourcesForHandlingInvalidValues;\n    if (marks === 'include-invalid-values' && scales === 'include-invalid-values') {\n      // If neither marks nor scale domains need data source to filter null values, then don't add the filter.\n      return null;\n    }\n\n    const filter = model.reduceFieldDef(\n      (aggregator: Dict<TypedFieldDef<string>>, fieldDef, channel) => {\n        const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);\n\n        if (scaleComponent) {\n          const scaleType = scaleComponent.get('type');\n          const {aggregate} = fieldDef;\n          const invalidDataMode = getScaleInvalidDataMode({\n            scaleChannel: channel,\n            markDef,\n            config,\n            scaleType,\n            isCountAggregate: isCountingAggregateOp(aggregate)\n          });\n\n          // If the invalid data mode is include or always-valid, we don't need to filter invalid values as the scale can handle invalid values.\n          if (invalidDataMode !== 'show' && invalidDataMode !== 'always-valid') {\n            aggregator[fieldDef.field] = fieldDef as any; // we know that the fieldDef is a typed field def\n          }\n        }\n\n        return aggregator;\n      },\n      {} as Dict<TypedFieldDef<string>>\n    );\n\n    if (!keys(filter).length) {\n      return null;\n    }\n\n    return new FilterInvalidNode(parent, filter);\n  }\n\n  public dependentFields() {\n    return new Set(keys(this.filter));\n  }\n\n  public producedFields() {\n    return new Set<string>(); // filter does not produce any new fields\n  }\n\n  public hash() {\n    return `FilterInvalid ${hash(this.filter)}`;\n  }\n\n  /**\n   * Create the VgTransforms for each of the filtered fields.\n   */\n  public assemble(): VgFilterTransform {\n    const filters = keys(this.filter).reduce((vegaFilters, field) => {\n      const fieldDef = this.filter[field];\n      const ref = fieldRef(fieldDef, {expr: 'datum'});\n\n      if (fieldDef !== null) {\n        if (fieldDef.type === 'temporal') {\n          vegaFilters.push(`(isDate(${ref}) || (${isValidFiniteNumberExpr(ref)}))`);\n        } else if (fieldDef.type === 'quantitative') {\n          vegaFilters.push(isValidFiniteNumberExpr(ref));\n        } else {\n          // should never get here\n        }\n      }\n      return vegaFilters;\n    }, [] as string[]);\n\n    return filters.length > 0\n      ? {\n          type: 'filter',\n          expr: filters.join(' && ')\n        }\n      : null;\n  }\n}\n\nexport function isValidFiniteNumberExpr(ref: string) {\n  return `isValid(${ref}) && isFinite(+${ref})`;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}