{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { VL_SELECTION_RESOLVE } from '.';\nimport { isScaleChannel } from '../../channel';\nimport * as log from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { isLayerModel } from '../model';\nimport { replacePathInField } from '../../util';\nconst scaleBindings = {\n  defined: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind === 'scales';\n  },\n  parse: (model, selCmpt) => {\n    const bound = selCmpt.scales = [];\n    for (const proj of selCmpt.project.items) {\n      const channel = proj.channel;\n      if (!isScaleChannel(channel)) {\n        continue;\n      }\n      const scale = model.getScaleComponent(channel);\n      const scaleType = scale ? scale.get('type') : undefined;\n      if (scaleType == 'sequential') {\n        log.warn(log.message.SEQUENTIAL_SCALE_DEPRECATED);\n      }\n      if (!scale || !hasContinuousDomain(scaleType)) {\n        log.warn(log.message.SCALE_BINDINGS_CONTINUOUS);\n        continue;\n      }\n      scale.set('selectionExtent', {\n        param: selCmpt.name,\n        field: proj.field\n      }, true);\n      bound.push(proj);\n    }\n  },\n  topLevelSignals: (model, selCmpt, signals) => {\n    const bound = selCmpt.scales.filter(proj => signals.filter(s => s.name === proj.signals.data).length === 0);\n    // Top-level signals are only needed for multiview displays and if this\n    // view's top-level signals haven't already been generated.\n    if (!model.parent || isTopLevelLayer(model) || bound.length === 0) {\n      return signals;\n    }\n    // vlSelectionResolve does not account for the behavior of bound scales in\n    // multiview displays. Each unit view adds a tuple to the store, but the\n    // state of the selection is the unit selection most recently updated. This\n    // state is captured by the top-level signals that we insert and \"push\n    // outer\" to from within the units. We need to reassemble this state into\n    // the top-level named signal, except no single selCmpt has a global view.\n    const namedSg = signals.find(s => s.name === selCmpt.name);\n    let update = namedSg.update;\n    if (update.includes(VL_SELECTION_RESOLVE)) {\n      namedSg.update = `{${bound.map(proj => `${stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`).join(', ')}}`;\n    } else {\n      for (const proj of bound) {\n        const mapping = `${stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`;\n        if (!update.includes(mapping)) {\n          update = `${update.substring(0, update.length - 1)}, ${mapping}}`;\n        }\n      }\n      namedSg.update = update;\n    }\n    return signals.concat(bound.map(proj => ({\n      name: proj.signals.data\n    })));\n  },\n  signals: (model, selCmpt, signals) => {\n    // Nested signals need only push to top-level signals with multiview displays.\n    if (model.parent && !isTopLevelLayer(model)) {\n      for (const proj of selCmpt.scales) {\n        const signal = signals.find(s => s.name === proj.signals.data);\n        signal.push = 'outer';\n        delete signal.value;\n        delete signal.update;\n      }\n    }\n    return signals;\n  }\n};\nexport default scaleBindings;\nexport function domain(model, channel) {\n  const scale = stringValue(model.scaleName(channel));\n  return `domain(${scale})`;\n}\nfunction isTopLevelLayer(model) {\n  return model.parent && isLayerModel(model.parent) && (!model.parent.parent ?? isTopLevelLayer(model.parent.parent));\n}","map":{"version":3,"names":["stringValue","VL_SELECTION_RESOLVE","isScaleChannel","log","hasContinuousDomain","isLayerModel","replacePathInField","scaleBindings","defined","selCmpt","type","resolve","bind","parse","model","bound","scales","proj","project","items","channel","scale","getScaleComponent","scaleType","get","undefined","warn","message","SEQUENTIAL_SCALE_DEPRECATED","SCALE_BINDINGS_CONTINUOUS","set","param","name","field","push","topLevelSignals","signals","filter","s","data","length","parent","isTopLevelLayer","namedSg","find","update","includes","map","join","mapping","substring","concat","signal","value","domain","scaleName"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\selection\\scales.ts"],"sourcesContent":["import {stringValue} from 'vega-util';\nimport {VL_SELECTION_RESOLVE} from '.';\nimport {isScaleChannel, ScaleChannel} from '../../channel';\nimport * as log from '../../log';\nimport {hasContinuousDomain} from '../../scale';\nimport {isLayerModel, Model} from '../model';\nimport {UnitModel} from '../unit';\nimport {SelectionProjection} from './project';\nimport {SelectionCompiler} from '.';\nimport {replacePathInField} from '../../util';\nimport {NewSignal} from 'vega';\n\nconst scaleBindings: SelectionCompiler<'interval'> = {\n  defined: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind === 'scales';\n  },\n\n  parse: (model, selCmpt) => {\n    const bound: SelectionProjection[] = (selCmpt.scales = []);\n\n    for (const proj of selCmpt.project.items) {\n      const channel = proj.channel;\n\n      if (!isScaleChannel(channel)) {\n        continue;\n      }\n\n      const scale = model.getScaleComponent(channel);\n      const scaleType = scale ? scale.get('type') : undefined;\n\n      if (scaleType == 'sequential') {\n        log.warn(log.message.SEQUENTIAL_SCALE_DEPRECATED);\n      }\n\n      if (!scale || !hasContinuousDomain(scaleType)) {\n        log.warn(log.message.SCALE_BINDINGS_CONTINUOUS);\n        continue;\n      }\n\n      scale.set('selectionExtent', {param: selCmpt.name, field: proj.field}, true);\n      bound.push(proj);\n    }\n  },\n\n  topLevelSignals: (model, selCmpt, signals) => {\n    const bound = selCmpt.scales.filter(proj => signals.filter(s => s.name === proj.signals.data).length === 0);\n\n    // Top-level signals are only needed for multiview displays and if this\n    // view's top-level signals haven't already been generated.\n    if (!model.parent || isTopLevelLayer(model) || bound.length === 0) {\n      return signals;\n    }\n\n    // vlSelectionResolve does not account for the behavior of bound scales in\n    // multiview displays. Each unit view adds a tuple to the store, but the\n    // state of the selection is the unit selection most recently updated. This\n    // state is captured by the top-level signals that we insert and \"push\n    // outer\" to from within the units. We need to reassemble this state into\n    // the top-level named signal, except no single selCmpt has a global view.\n    const namedSg: NewSignal = signals.find(s => s.name === selCmpt.name);\n    let update = namedSg.update;\n    if (update.includes(VL_SELECTION_RESOLVE)) {\n      namedSg.update = `{${bound\n        .map(proj => `${stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`)\n        .join(', ')}}`;\n    } else {\n      for (const proj of bound) {\n        const mapping = `${stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`;\n        if (!update.includes(mapping)) {\n          update = `${update.substring(0, update.length - 1)}, ${mapping}}`;\n        }\n      }\n      namedSg.update = update;\n    }\n\n    return signals.concat(bound.map(proj => ({name: proj.signals.data})));\n  },\n\n  signals: (model, selCmpt, signals) => {\n    // Nested signals need only push to top-level signals with multiview displays.\n    if (model.parent && !isTopLevelLayer(model)) {\n      for (const proj of selCmpt.scales) {\n        const signal: any = signals.find(s => s.name === proj.signals.data);\n        signal.push = 'outer';\n        delete signal.value;\n        delete signal.update;\n      }\n    }\n\n    return signals;\n  }\n};\n\nexport default scaleBindings;\n\nexport function domain(model: UnitModel, channel: ScaleChannel) {\n  const scale = stringValue(model.scaleName(channel));\n  return `domain(${scale})`;\n}\n\nfunction isTopLevelLayer(model: Model): boolean {\n  return model.parent && isLayerModel(model.parent) && (!model.parent.parent ?? isTopLevelLayer(model.parent.parent));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}