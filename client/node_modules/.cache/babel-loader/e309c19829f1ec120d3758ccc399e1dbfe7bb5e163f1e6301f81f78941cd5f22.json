{"ast":null,"code":"import { isUrlData } from '../../data';\nimport { AggregateNode } from './aggregate';\nimport { BinNode } from './bin';\nimport { CalculateNode } from './calculate';\nimport { OutputNode } from './dataflow';\nimport { DensityTransformNode } from './density';\nimport { ExtentTransformNode } from './extent';\nimport { FacetNode } from './facet';\nimport { FilterNode } from './filter';\nimport { FilterInvalidNode } from './filterinvalid';\nimport { FlattenTransformNode } from './flatten';\nimport { FoldTransformNode } from './fold';\nimport { ParseNode } from './formatparse';\nimport { GeoJSONNode } from './geojson';\nimport { GeoPointNode } from './geopoint';\nimport { GraticuleNode } from './graticule';\nimport { IdentifierNode } from './identifier';\nimport { ImputeNode } from './impute';\nimport { JoinAggregateTransformNode } from './joinaggregate';\nimport { LoessTransformNode } from './loess';\nimport { LookupNode } from './lookup';\nimport { QuantileTransformNode } from './quantile';\nimport { RegressionTransformNode } from './regression';\nimport { PivotTransformNode } from './pivot';\nimport { SampleTransformNode } from './sample';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\nimport { StackNode } from './stack';\nimport { TimeUnitNode } from './timeunit';\nimport { WindowTransformNode } from './window';\nfunction makeWalkTree(data) {\n  // to name datasources\n  let datasetIndex = 0;\n  /**\n   * Recursively walk down the tree.\n   */\n  function walkTree(node, dataSource) {\n    if (node instanceof SourceNode) {\n      // If the source is a named data source or a data source with values, we need\n      // to put it in a different data source. Otherwise, Vega may override the data.\n      if (!node.isGenerator && !isUrlData(node.data)) {\n        data.push(dataSource);\n        const newData = {\n          name: null,\n          source: dataSource.name,\n          transform: []\n        };\n        dataSource = newData;\n      }\n    }\n    if (node instanceof ParseNode) {\n      if (node.parent instanceof SourceNode && !dataSource.source) {\n        // If node's parent is a root source and the data source does not refer to another data source, use normal format parse\n        dataSource.format = {\n          ...dataSource.format,\n          parse: node.assembleFormatParse()\n        };\n        // add calculates for all nested fields\n        dataSource.transform.push(...node.assembleTransforms(true));\n      } else {\n        // Otherwise use Vega expression to parse\n        dataSource.transform.push(...node.assembleTransforms());\n      }\n    }\n    if (node instanceof FacetNode) {\n      if (!dataSource.name) {\n        dataSource.name = `data_${datasetIndex++}`;\n      }\n      if (!dataSource.source || dataSource.transform.length > 0) {\n        data.push(dataSource);\n        node.data = dataSource.name;\n      } else {\n        node.data = dataSource.source;\n      }\n      data.push(...node.assemble());\n      // break here because the rest of the tree has to be taken care of by the facet.\n      return;\n    }\n    if (node instanceof GraticuleNode || node instanceof SequenceNode || node instanceof FilterInvalidNode || node instanceof FilterNode || node instanceof CalculateNode || node instanceof GeoPointNode || node instanceof AggregateNode || node instanceof LookupNode || node instanceof WindowTransformNode || node instanceof JoinAggregateTransformNode || node instanceof FoldTransformNode || node instanceof FlattenTransformNode || node instanceof DensityTransformNode || node instanceof LoessTransformNode || node instanceof QuantileTransformNode || node instanceof RegressionTransformNode || node instanceof IdentifierNode || node instanceof SampleTransformNode || node instanceof PivotTransformNode || node instanceof ExtentTransformNode) {\n      dataSource.transform.push(node.assemble());\n    }\n    if (node instanceof BinNode || node instanceof TimeUnitNode || node instanceof ImputeNode || node instanceof StackNode || node instanceof GeoJSONNode) {\n      dataSource.transform.push(...node.assemble());\n    }\n    if (node instanceof OutputNode) {\n      if (dataSource.source && dataSource.transform.length === 0) {\n        node.setSource(dataSource.source);\n      } else if (node.parent instanceof OutputNode) {\n        // Note that an output node may be required but we still do not assemble a\n        // separate data source for it.\n        node.setSource(dataSource.name);\n      } else {\n        if (!dataSource.name) {\n          dataSource.name = `data_${datasetIndex++}`;\n        }\n        // Here we set the name of the datasource we generated. From now on\n        // other assemblers can use it.\n        node.setSource(dataSource.name);\n        // if this node has more than one child, we will add a datasource automatically\n        if (node.numChildren() === 1) {\n          data.push(dataSource);\n          const newData = {\n            name: null,\n            source: dataSource.name,\n            transform: []\n          };\n          dataSource = newData;\n        }\n      }\n    }\n    switch (node.numChildren()) {\n      case 0:\n        // done\n        if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {\n          // do not push empty datasources that are simply references\n          data.push(dataSource);\n        }\n        break;\n      case 1:\n        walkTree(node.children[0], dataSource);\n        break;\n      default:\n        {\n          if (!dataSource.name) {\n            dataSource.name = `data_${datasetIndex++}`;\n          }\n          let source = dataSource.name;\n          if (!dataSource.source || dataSource.transform.length > 0) {\n            data.push(dataSource);\n          } else {\n            source = dataSource.source;\n          }\n          for (const child of node.children) {\n            const newData = {\n              name: null,\n              source,\n              transform: []\n            };\n            walkTree(child, newData);\n          }\n          break;\n        }\n    }\n  }\n  return walkTree;\n}\n/**\n * Assemble data sources that are derived from faceted data.\n */\nexport function assembleFacetData(root) {\n  const data = [];\n  const walkTree = makeWalkTree(data);\n  for (const child of root.children) {\n    walkTree(child, {\n      source: root.name,\n      name: null,\n      transform: []\n    });\n  }\n  return data;\n}\n/**\n * Create Vega data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\nexport function assembleRootData(dataComponent, datasets) {\n  const data = [];\n  // dataComponent.sources.forEach(debug);\n  // draw(dataComponent.sources);\n  const walkTree = makeWalkTree(data);\n  let sourceIndex = 0;\n  for (const root of dataComponent.sources) {\n    // assign a name if the source does not have a name yet\n    if (!root.hasName()) {\n      root.dataName = `source_${sourceIndex++}`;\n    }\n    const newData = root.assemble();\n    walkTree(root, newData);\n  }\n  // remove empty transform arrays for cleaner output\n  for (const d of data) {\n    if (d.transform.length === 0) {\n      delete d.transform;\n    }\n  }\n  // move sources without transforms (the ones that are potentially used in lookups) to the beginning\n  let whereTo = 0;\n  for (const [i, d] of data.entries()) {\n    if ((d.transform ?? []).length === 0 && !d.source) {\n      data.splice(whereTo++, 0, data.splice(i, 1)[0]);\n    }\n  }\n  // now fix the from references in lookup transforms\n  for (const d of data) {\n    for (const t of d.transform ?? []) {\n      if (t.type === 'lookup') {\n        t.from = dataComponent.outputNodes[t.from].getSource();\n      }\n    }\n  }\n  // inline values for datasets that are in the datastore\n  for (const d of data) {\n    if (d.name in datasets) {\n      d.values = datasets[d.name];\n    }\n  }\n  return data;\n}","map":{"version":3,"names":["isUrlData","AggregateNode","BinNode","CalculateNode","OutputNode","DensityTransformNode","ExtentTransformNode","FacetNode","FilterNode","FilterInvalidNode","FlattenTransformNode","FoldTransformNode","ParseNode","GeoJSONNode","GeoPointNode","GraticuleNode","IdentifierNode","ImputeNode","JoinAggregateTransformNode","LoessTransformNode","LookupNode","QuantileTransformNode","RegressionTransformNode","PivotTransformNode","SampleTransformNode","SequenceNode","SourceNode","StackNode","TimeUnitNode","WindowTransformNode","makeWalkTree","data","datasetIndex","walkTree","node","dataSource","isGenerator","push","newData","name","source","transform","parent","format","parse","assembleFormatParse","assembleTransforms","length","assemble","setSource","numChildren","children","child","assembleFacetData","root","assembleRootData","dataComponent","datasets","sourceIndex","sources","hasName","dataName","d","whereTo","i","entries","splice","t","type","from","outputNodes","getSource","values"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\data\\assemble.ts"],"sourcesContent":["import {InlineDataset, isUrlData} from '../../data';\nimport {Dict} from '../../util';\nimport {VgData} from '../../vega.schema';\nimport {DataComponent} from './';\nimport {AggregateNode} from './aggregate';\nimport {BinNode} from './bin';\nimport {CalculateNode} from './calculate';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {DensityTransformNode} from './density';\nimport {ExtentTransformNode} from './extent';\nimport {FacetNode} from './facet';\nimport {FilterNode} from './filter';\nimport {FilterInvalidNode} from './filterinvalid';\nimport {FlattenTransformNode} from './flatten';\nimport {FoldTransformNode} from './fold';\nimport {ParseNode} from './formatparse';\nimport {GeoJSONNode} from './geojson';\nimport {GeoPointNode} from './geopoint';\nimport {GraticuleNode} from './graticule';\nimport {IdentifierNode} from './identifier';\nimport {ImputeNode} from './impute';\nimport {JoinAggregateTransformNode} from './joinaggregate';\nimport {LoessTransformNode} from './loess';\nimport {LookupNode} from './lookup';\nimport {QuantileTransformNode} from './quantile';\nimport {RegressionTransformNode} from './regression';\nimport {PivotTransformNode} from './pivot';\nimport {SampleTransformNode} from './sample';\nimport {SequenceNode} from './sequence';\nimport {SourceNode} from './source';\nimport {StackNode} from './stack';\nimport {TimeUnitNode} from './timeunit';\nimport {WindowTransformNode} from './window';\n\nfunction makeWalkTree(data: VgData[]) {\n  // to name datasources\n  let datasetIndex = 0;\n\n  /**\n   * Recursively walk down the tree.\n   */\n  function walkTree(node: DataFlowNode, dataSource: VgData) {\n    if (node instanceof SourceNode) {\n      // If the source is a named data source or a data source with values, we need\n      // to put it in a different data source. Otherwise, Vega may override the data.\n      if (!node.isGenerator && !isUrlData(node.data)) {\n        data.push(dataSource);\n        const newData: VgData = {\n          name: null,\n          source: dataSource.name,\n          transform: []\n        };\n        dataSource = newData;\n      }\n    }\n\n    if (node instanceof ParseNode) {\n      if (node.parent instanceof SourceNode && !dataSource.source) {\n        // If node's parent is a root source and the data source does not refer to another data source, use normal format parse\n        dataSource.format = {\n          ...dataSource.format,\n          parse: node.assembleFormatParse()\n        };\n\n        // add calculates for all nested fields\n        dataSource.transform.push(...node.assembleTransforms(true));\n      } else {\n        // Otherwise use Vega expression to parse\n        dataSource.transform.push(...node.assembleTransforms());\n      }\n    }\n\n    if (node instanceof FacetNode) {\n      if (!dataSource.name) {\n        dataSource.name = `data_${datasetIndex++}`;\n      }\n\n      if (!dataSource.source || dataSource.transform.length > 0) {\n        data.push(dataSource);\n        node.data = dataSource.name;\n      } else {\n        node.data = dataSource.source;\n      }\n\n      data.push(...node.assemble());\n\n      // break here because the rest of the tree has to be taken care of by the facet.\n      return;\n    }\n\n    if (\n      node instanceof GraticuleNode ||\n      node instanceof SequenceNode ||\n      node instanceof FilterInvalidNode ||\n      node instanceof FilterNode ||\n      node instanceof CalculateNode ||\n      node instanceof GeoPointNode ||\n      node instanceof AggregateNode ||\n      node instanceof LookupNode ||\n      node instanceof WindowTransformNode ||\n      node instanceof JoinAggregateTransformNode ||\n      node instanceof FoldTransformNode ||\n      node instanceof FlattenTransformNode ||\n      node instanceof DensityTransformNode ||\n      node instanceof LoessTransformNode ||\n      node instanceof QuantileTransformNode ||\n      node instanceof RegressionTransformNode ||\n      node instanceof IdentifierNode ||\n      node instanceof SampleTransformNode ||\n      node instanceof PivotTransformNode ||\n      node instanceof ExtentTransformNode\n    ) {\n      dataSource.transform.push(node.assemble());\n    }\n\n    if (\n      node instanceof BinNode ||\n      node instanceof TimeUnitNode ||\n      node instanceof ImputeNode ||\n      node instanceof StackNode ||\n      node instanceof GeoJSONNode\n    ) {\n      dataSource.transform.push(...node.assemble());\n    }\n\n    if (node instanceof OutputNode) {\n      if (dataSource.source && dataSource.transform.length === 0) {\n        node.setSource(dataSource.source);\n      } else if (node.parent instanceof OutputNode) {\n        // Note that an output node may be required but we still do not assemble a\n        // separate data source for it.\n        node.setSource(dataSource.name);\n      } else {\n        if (!dataSource.name) {\n          dataSource.name = `data_${datasetIndex++}`;\n        }\n\n        // Here we set the name of the datasource we generated. From now on\n        // other assemblers can use it.\n        node.setSource(dataSource.name);\n\n        // if this node has more than one child, we will add a datasource automatically\n        if (node.numChildren() === 1) {\n          data.push(dataSource);\n          const newData: VgData = {\n            name: null,\n            source: dataSource.name,\n            transform: []\n          };\n          dataSource = newData;\n        }\n      }\n    }\n\n    switch (node.numChildren()) {\n      case 0:\n        // done\n        if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {\n          // do not push empty datasources that are simply references\n          data.push(dataSource);\n        }\n        break;\n      case 1:\n        walkTree(node.children[0], dataSource);\n        break;\n      default: {\n        if (!dataSource.name) {\n          dataSource.name = `data_${datasetIndex++}`;\n        }\n\n        let source = dataSource.name;\n        if (!dataSource.source || dataSource.transform.length > 0) {\n          data.push(dataSource);\n        } else {\n          source = dataSource.source;\n        }\n\n        for (const child of node.children) {\n          const newData: VgData = {\n            name: null,\n            source,\n            transform: []\n          };\n          walkTree(child, newData);\n        }\n        break;\n      }\n    }\n  }\n\n  return walkTree;\n}\n\n/**\n * Assemble data sources that are derived from faceted data.\n */\nexport function assembleFacetData(root: FacetNode): VgData[] {\n  const data: VgData[] = [];\n  const walkTree = makeWalkTree(data);\n\n  for (const child of root.children) {\n    walkTree(child, {\n      source: root.name,\n      name: null,\n      transform: []\n    });\n  }\n\n  return data;\n}\n\n/**\n * Create Vega data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\nexport function assembleRootData(dataComponent: DataComponent, datasets: Dict<InlineDataset>): VgData[] {\n  const data: VgData[] = [];\n\n  // dataComponent.sources.forEach(debug);\n  // draw(dataComponent.sources);\n\n  const walkTree = makeWalkTree(data);\n\n  let sourceIndex = 0;\n\n  for (const root of dataComponent.sources) {\n    // assign a name if the source does not have a name yet\n    if (!root.hasName()) {\n      root.dataName = `source_${sourceIndex++}`;\n    }\n\n    const newData: VgData = root.assemble();\n\n    walkTree(root, newData);\n  }\n\n  // remove empty transform arrays for cleaner output\n  for (const d of data) {\n    if (d.transform.length === 0) {\n      delete d.transform;\n    }\n  }\n\n  // move sources without transforms (the ones that are potentially used in lookups) to the beginning\n  let whereTo = 0;\n  for (const [i, d] of data.entries()) {\n    if ((d.transform ?? []).length === 0 && !d.source) {\n      data.splice(whereTo++, 0, data.splice(i, 1)[0]);\n    }\n  }\n\n  // now fix the from references in lookup transforms\n  for (const d of data) {\n    for (const t of d.transform ?? []) {\n      if (t.type === 'lookup') {\n        t.from = dataComponent.outputNodes[t.from].getSource();\n      }\n    }\n  }\n\n  // inline values for datasets that are in the datastore\n  for (const d of data) {\n    if (d.name in datasets) {\n      d.values = datasets[d.name];\n    }\n  }\n\n  return data;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}