{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { hasConditionalFieldOrDatumDef, isConditionalDef, isFieldDef, isFieldOrDatumDef, isRepeatRef, isSortableFieldDef } from '../channeldef';\nimport * as log from '../log';\nimport { isSortField } from '../sort';\nimport { isFacetMapping } from '../spec/facet';\nimport { hasProperty } from '../util';\nexport function replaceRepeaterInFacet(facet, repeater) {\n  if (!repeater) {\n    return facet;\n  }\n  if (isFacetMapping(facet)) {\n    return replaceRepeaterInMapping(facet, repeater);\n  }\n  return replaceRepeaterInFieldDef(facet, repeater);\n}\nexport function replaceRepeaterInEncoding(encoding, repeater) {\n  if (!repeater) {\n    return encoding;\n  }\n  return replaceRepeaterInMapping(encoding, repeater);\n}\n/**\n * Replaces repeated value and returns if the repeated value is valid.\n */\nfunction replaceRepeatInProp(prop, o, repeater) {\n  const val = o[prop];\n  if (isRepeatRef(val)) {\n    if (val.repeat in repeater) {\n      return {\n        ...o,\n        [prop]: repeater[val.repeat]\n      };\n    } else {\n      log.warn(log.message.noSuchRepeatedValue(val.repeat));\n      return undefined;\n    }\n  }\n  return o;\n}\n/**\n * Replace repeater values in a field def with the concrete field name.\n */\nfunction replaceRepeaterInFieldDef(fieldDef, repeater) {\n  fieldDef = replaceRepeatInProp('field', fieldDef, repeater);\n  if (fieldDef === undefined) {\n    // the field def should be ignored\n    return undefined;\n  } else if (fieldDef === null) {\n    return null;\n  }\n  if (isSortableFieldDef(fieldDef) && isSortField(fieldDef.sort)) {\n    const sort = replaceRepeatInProp('field', fieldDef.sort, repeater);\n    fieldDef = {\n      ...fieldDef,\n      ...(sort ? {\n        sort\n      } : {})\n    };\n  }\n  return fieldDef;\n}\nfunction replaceRepeaterInFieldOrDatumDef(def, repeater) {\n  if (isFieldDef(def)) {\n    return replaceRepeaterInFieldDef(def, repeater);\n  } else {\n    const datumDef = replaceRepeatInProp('datum', def, repeater);\n    if (datumDef !== def && !datumDef.type) {\n      datumDef.type = 'nominal';\n    }\n    return datumDef;\n  }\n}\nfunction replaceRepeaterInChannelDef(channelDef, repeater) {\n  if (isFieldOrDatumDef(channelDef)) {\n    const fd = replaceRepeaterInFieldOrDatumDef(channelDef, repeater);\n    if (fd) {\n      return fd;\n    } else if (isConditionalDef(channelDef)) {\n      return {\n        condition: channelDef.condition\n      };\n    }\n  } else {\n    if (hasConditionalFieldOrDatumDef(channelDef)) {\n      const fd = replaceRepeaterInFieldOrDatumDef(channelDef.condition, repeater);\n      if (fd) {\n        return {\n          ...channelDef,\n          condition: fd\n        };\n      } else {\n        const {\n          condition,\n          ...channelDefWithoutCondition\n        } = channelDef;\n        return channelDefWithoutCondition;\n      }\n    }\n    return channelDef;\n  }\n  return undefined;\n}\nfunction replaceRepeaterInMapping(mapping, repeater) {\n  const out = {};\n  for (const channel in mapping) {\n    if (hasProperty(mapping, channel)) {\n      const channelDef = mapping[channel];\n      if (isArray(channelDef)) {\n        // array cannot have condition\n        out[channel] = channelDef // somehow we need to cast it here\n        .map(cd => replaceRepeaterInChannelDef(cd, repeater)).filter(cd => cd);\n      } else {\n        const cd = replaceRepeaterInChannelDef(channelDef, repeater);\n        if (cd !== undefined) {\n          out[channel] = cd;\n        }\n      }\n    }\n  }\n  return out;\n}","map":{"version":3,"names":["isArray","hasConditionalFieldOrDatumDef","isConditionalDef","isFieldDef","isFieldOrDatumDef","isRepeatRef","isSortableFieldDef","log","isSortField","isFacetMapping","hasProperty","replaceRepeaterInFacet","facet","repeater","replaceRepeaterInMapping","replaceRepeaterInFieldDef","replaceRepeaterInEncoding","encoding","replaceRepeatInProp","prop","o","val","repeat","warn","message","noSuchRepeatedValue","undefined","fieldDef","sort","replaceRepeaterInFieldOrDatumDef","def","datumDef","type","replaceRepeaterInChannelDef","channelDef","fd","condition","channelDefWithoutCondition","mapping","out","channel","map","cd","filter"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\normalize\\repeater.ts"],"sourcesContent":["import {isArray} from 'vega-util';\nimport {\n  ChannelDef,\n  DatumDef,\n  Field,\n  FieldDef,\n  FieldName,\n  hasConditionalFieldOrDatumDef,\n  isConditionalDef,\n  isFieldDef,\n  isFieldOrDatumDef,\n  isRepeatRef,\n  isSortableFieldDef,\n  ScaleFieldDef,\n  ValueDef\n} from '../channeldef';\nimport {Encoding} from '../encoding';\nimport * as log from '../log';\nimport {isSortField} from '../sort';\nimport {FacetFieldDef, FacetMapping, isFacetMapping} from '../spec/facet';\nimport {hasProperty} from '../util';\n\nexport interface RepeaterValue {\n  row?: string;\n  column?: string;\n\n  repeat?: string;\n\n  layer?: string;\n}\n\nexport function replaceRepeaterInFacet(\n  facet: FacetFieldDef<Field> | FacetMapping<Field>,\n  repeater: RepeaterValue\n): FacetFieldDef<FieldName> | FacetMapping<FieldName> {\n  if (!repeater) {\n    return facet as FacetFieldDef<FieldName>;\n  }\n\n  if (isFacetMapping(facet)) {\n    return replaceRepeaterInMapping(facet, repeater) as FacetMapping<FieldName>;\n  }\n  return replaceRepeaterInFieldDef(facet, repeater) as FacetFieldDef<FieldName>;\n}\n\nexport function replaceRepeaterInEncoding<E extends Encoding<Field>>(\n  encoding: E,\n  repeater: RepeaterValue\n): Encoding<FieldName> {\n  if (!repeater) {\n    return encoding as Encoding<FieldName>;\n  }\n\n  return replaceRepeaterInMapping(encoding, repeater) as Encoding<FieldName>;\n}\n\n/**\n * Replaces repeated value and returns if the repeated value is valid.\n */\nfunction replaceRepeatInProp<T>(prop: keyof T, o: T, repeater: RepeaterValue): T {\n  const val = o[prop];\n  if (isRepeatRef(val)) {\n    if (val.repeat in repeater) {\n      return {...o, [prop]: repeater[val.repeat]};\n    } else {\n      log.warn(log.message.noSuchRepeatedValue(val.repeat));\n      return undefined;\n    }\n  }\n  return o;\n}\n\n/**\n * Replace repeater values in a field def with the concrete field name.\n */\n\nfunction replaceRepeaterInFieldDef(fieldDef: FieldDef<Field>, repeater: RepeaterValue) {\n  fieldDef = replaceRepeatInProp('field', fieldDef, repeater);\n\n  if (fieldDef === undefined) {\n    // the field def should be ignored\n    return undefined;\n  } else if (fieldDef === null) {\n    return null;\n  }\n\n  if (isSortableFieldDef(fieldDef) && isSortField(fieldDef.sort)) {\n    const sort = replaceRepeatInProp('field', fieldDef.sort, repeater);\n    fieldDef = {\n      ...fieldDef,\n      ...(sort ? {sort} : {})\n    };\n  }\n\n  return fieldDef as ScaleFieldDef<FieldName>;\n}\n\nfunction replaceRepeaterInFieldOrDatumDef(def: FieldDef<Field> | DatumDef<Field>, repeater: RepeaterValue) {\n  if (isFieldDef(def)) {\n    return replaceRepeaterInFieldDef(def, repeater);\n  } else {\n    const datumDef = replaceRepeatInProp('datum', def, repeater);\n    if (datumDef !== def && !datumDef.type) {\n      datumDef.type = 'nominal';\n    }\n    return datumDef;\n  }\n}\n\nfunction replaceRepeaterInChannelDef(channelDef: ChannelDef<Field>, repeater: RepeaterValue) {\n  if (isFieldOrDatumDef(channelDef)) {\n    const fd = replaceRepeaterInFieldOrDatumDef(channelDef, repeater);\n    if (fd) {\n      return fd;\n    } else if (isConditionalDef<ChannelDef<Field>>(channelDef)) {\n      return {condition: channelDef.condition};\n    }\n  } else {\n    if (hasConditionalFieldOrDatumDef(channelDef)) {\n      const fd = replaceRepeaterInFieldOrDatumDef(channelDef.condition, repeater);\n      if (fd) {\n        return {\n          ...channelDef,\n          condition: fd\n        } as ChannelDef;\n      } else {\n        const {condition, ...channelDefWithoutCondition} = channelDef;\n        return channelDefWithoutCondition as ChannelDef;\n      }\n    }\n    return channelDef as ValueDef;\n  }\n  return undefined;\n}\n\ntype EncodingOrFacet<F extends Field> = Encoding<F> | FacetMapping<F>;\n\nfunction replaceRepeaterInMapping(\n  mapping: EncodingOrFacet<Field>,\n  repeater: RepeaterValue\n): EncodingOrFacet<FieldName> {\n  const out: EncodingOrFacet<FieldName> = {};\n  for (const channel in mapping) {\n    if (hasProperty(mapping, channel)) {\n      const channelDef: ChannelDef<Field> | ChannelDef<Field>[] = mapping[channel];\n\n      if (isArray(channelDef)) {\n        // array cannot have condition\n        (out as any)[channel] = (channelDef as ChannelDef<Field>[]) // somehow we need to cast it here\n          .map(cd => replaceRepeaterInChannelDef(cd, repeater))\n          .filter(cd => cd);\n      } else {\n        const cd = replaceRepeaterInChannelDef(channelDef, repeater);\n        if (cd !== undefined) {\n          (out as any)[channel] = cd;\n        }\n      }\n    }\n  }\n  return out;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}