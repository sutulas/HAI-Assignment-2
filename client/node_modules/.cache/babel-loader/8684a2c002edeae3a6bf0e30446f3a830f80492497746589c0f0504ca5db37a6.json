{"ast":null,"code":"/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\nimport { hasOwnProperty } from 'vega-util';\nimport { keys } from './util';\n// Facet\nexport const ROW = 'row';\nexport const COLUMN = 'column';\nexport const FACET = 'facet';\n// Position\nexport const X = 'x';\nexport const Y = 'y';\nexport const X2 = 'x2';\nexport const Y2 = 'y2';\n// Position Offset\nexport const XOFFSET = 'xOffset';\nexport const YOFFSET = 'yOffset';\n// Arc-Position\nexport const RADIUS = 'radius';\nexport const RADIUS2 = 'radius2';\nexport const THETA = 'theta';\nexport const THETA2 = 'theta2';\n// Geo Position\nexport const LATITUDE = 'latitude';\nexport const LONGITUDE = 'longitude';\nexport const LATITUDE2 = 'latitude2';\nexport const LONGITUDE2 = 'longitude2';\n// Mark property with scale\nexport const COLOR = 'color';\nexport const FILL = 'fill';\nexport const STROKE = 'stroke';\nexport const SHAPE = 'shape';\nexport const SIZE = 'size';\nexport const ANGLE = 'angle';\nexport const OPACITY = 'opacity';\nexport const FILLOPACITY = 'fillOpacity';\nexport const STROKEOPACITY = 'strokeOpacity';\nexport const STROKEWIDTH = 'strokeWidth';\nexport const STROKEDASH = 'strokeDash';\n// Non-scale channel\nexport const TEXT = 'text';\nexport const ORDER = 'order';\nexport const DETAIL = 'detail';\nexport const KEY = 'key';\nexport const TOOLTIP = 'tooltip';\nexport const HREF = 'href';\nexport const URL = 'url';\nexport const DESCRIPTION = 'description';\nconst POSITION_CHANNEL_INDEX = {\n  x: 1,\n  y: 1,\n  x2: 1,\n  y2: 1\n};\nconst POLAR_POSITION_CHANNEL_INDEX = {\n  theta: 1,\n  theta2: 1,\n  radius: 1,\n  radius2: 1\n};\nexport function isPolarPositionChannel(c) {\n  return hasOwnProperty(POLAR_POSITION_CHANNEL_INDEX, c);\n}\nconst GEO_POSIITON_CHANNEL_INDEX = {\n  longitude: 1,\n  longitude2: 1,\n  latitude: 1,\n  latitude2: 1\n};\nexport function getPositionChannelFromLatLong(channel) {\n  switch (channel) {\n    case LATITUDE:\n      return 'y';\n    case LATITUDE2:\n      return 'y2';\n    case LONGITUDE:\n      return 'x';\n    case LONGITUDE2:\n      return 'x2';\n  }\n}\nexport function isGeoPositionChannel(c) {\n  return hasOwnProperty(GEO_POSIITON_CHANNEL_INDEX, c);\n}\nexport const GEOPOSITION_CHANNELS = keys(GEO_POSIITON_CHANNEL_INDEX);\nconst UNIT_CHANNEL_INDEX = {\n  ...POSITION_CHANNEL_INDEX,\n  ...POLAR_POSITION_CHANNEL_INDEX,\n  ...GEO_POSIITON_CHANNEL_INDEX,\n  xOffset: 1,\n  yOffset: 1,\n  // color\n  color: 1,\n  fill: 1,\n  stroke: 1,\n  // other non-position with scale\n  opacity: 1,\n  fillOpacity: 1,\n  strokeOpacity: 1,\n  strokeWidth: 1,\n  strokeDash: 1,\n  size: 1,\n  angle: 1,\n  shape: 1,\n  // channels without scales\n  order: 1,\n  text: 1,\n  detail: 1,\n  key: 1,\n  tooltip: 1,\n  href: 1,\n  url: 1,\n  description: 1\n};\nexport function isColorChannel(channel) {\n  return channel === COLOR || channel === FILL || channel === STROKE;\n}\nconst FACET_CHANNEL_INDEX = {\n  row: 1,\n  column: 1,\n  facet: 1\n};\nexport const FACET_CHANNELS = keys(FACET_CHANNEL_INDEX);\nconst CHANNEL_INDEX = {\n  ...UNIT_CHANNEL_INDEX,\n  ...FACET_CHANNEL_INDEX\n};\nexport const CHANNELS = keys(CHANNEL_INDEX);\nconst {\n  order: _o,\n  detail: _d,\n  tooltip: _tt1,\n  ...SINGLE_DEF_CHANNEL_INDEX\n} = CHANNEL_INDEX;\nconst {\n  row: _r,\n  column: _c,\n  facet: _f,\n  ...SINGLE_DEF_UNIT_CHANNEL_INDEX\n} = SINGLE_DEF_CHANNEL_INDEX;\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them. Similarly, selection projection won't work with \"detail\" and \"order\".)\n */\nexport const SINGLE_DEF_CHANNELS = keys(SINGLE_DEF_CHANNEL_INDEX);\nexport const SINGLE_DEF_UNIT_CHANNELS = keys(SINGLE_DEF_UNIT_CHANNEL_INDEX);\nexport function isSingleDefUnitChannel(str) {\n  return hasOwnProperty(SINGLE_DEF_UNIT_CHANNEL_INDEX, str);\n}\nexport function isChannel(str) {\n  return hasOwnProperty(CHANNEL_INDEX, str);\n}\nexport const SECONDARY_RANGE_CHANNEL = [X2, Y2, LATITUDE2, LONGITUDE2, THETA2, RADIUS2];\nexport function isSecondaryRangeChannel(c) {\n  const main = getMainRangeChannel(c);\n  return main !== c;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getMainRangeChannel(channel) {\n  switch (channel) {\n    case X2:\n      return X;\n    case Y2:\n      return Y;\n    case LATITUDE2:\n      return LATITUDE;\n    case LONGITUDE2:\n      return LONGITUDE;\n    case THETA2:\n      return THETA;\n    case RADIUS2:\n      return RADIUS;\n  }\n  return channel;\n}\nexport function getVgPositionChannel(channel) {\n  if (isPolarPositionChannel(channel)) {\n    switch (channel) {\n      case THETA:\n        return 'startAngle';\n      case THETA2:\n        return 'endAngle';\n      case RADIUS:\n        return 'outerRadius';\n      case RADIUS2:\n        return 'innerRadius';\n    }\n  }\n  return channel;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getSecondaryRangeChannel(channel) {\n  switch (channel) {\n    case X:\n      return X2;\n    case Y:\n      return Y2;\n    case LATITUDE:\n      return LATITUDE2;\n    case LONGITUDE:\n      return LONGITUDE2;\n    case THETA:\n      return THETA2;\n    case RADIUS:\n      return RADIUS2;\n  }\n  return undefined;\n}\nexport function getSizeChannel(channel) {\n  switch (channel) {\n    case X:\n    case X2:\n      return 'width';\n    case Y:\n    case Y2:\n      return 'height';\n  }\n  return undefined;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getOffsetChannel(channel) {\n  switch (channel) {\n    case X:\n      return 'xOffset';\n    case Y:\n      return 'yOffset';\n    case X2:\n      return 'x2Offset';\n    case Y2:\n      return 'y2Offset';\n    case THETA:\n      return 'thetaOffset';\n    case RADIUS:\n      return 'radiusOffset';\n    case THETA2:\n      return 'theta2Offset';\n    case RADIUS2:\n      return 'radius2Offset';\n  }\n  return undefined;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getOffsetScaleChannel(channel) {\n  switch (channel) {\n    case X:\n      return 'xOffset';\n    case Y:\n      return 'yOffset';\n  }\n  return undefined;\n}\nexport function getMainChannelFromOffsetChannel(channel) {\n  switch (channel) {\n    case 'xOffset':\n      return 'x';\n    case 'yOffset':\n      return 'y';\n  }\n}\n// CHANNELS without COLUMN, ROW\nexport const UNIT_CHANNELS = keys(UNIT_CHANNEL_INDEX);\n// NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\nconst {\n  x: _x,\n  y: _y,\n  // x2 and y2 share the same scale as x and y\n  x2: _x2,\n  y2: _y2,\n  //\n  xOffset: _xo,\n  yOffset: _yo,\n  latitude: _latitude,\n  longitude: _longitude,\n  latitude2: _latitude2,\n  longitude2: _longitude2,\n  theta: _theta,\n  theta2: _theta2,\n  radius: _radius,\n  radius2: _radius2,\n  // The rest of unit channels then have scale\n  ...NONPOSITION_CHANNEL_INDEX\n} = UNIT_CHANNEL_INDEX;\nexport const NONPOSITION_CHANNELS = keys(NONPOSITION_CHANNEL_INDEX);\nconst POSITION_SCALE_CHANNEL_INDEX = {\n  x: 1,\n  y: 1\n};\nexport const POSITION_SCALE_CHANNELS = keys(POSITION_SCALE_CHANNEL_INDEX);\nexport function isXorY(channel) {\n  return hasOwnProperty(POSITION_SCALE_CHANNEL_INDEX, channel);\n}\nexport const POLAR_POSITION_SCALE_CHANNEL_INDEX = {\n  theta: 1,\n  radius: 1\n};\nexport const POLAR_POSITION_SCALE_CHANNELS = keys(POLAR_POSITION_SCALE_CHANNEL_INDEX);\nexport function getPositionScaleChannel(sizeType) {\n  return sizeType === 'width' ? X : Y;\n}\nconst OFFSET_SCALE_CHANNEL_INDEX = {\n  xOffset: 1,\n  yOffset: 1\n};\nexport const OFFSET_SCALE_CHANNELS = keys(OFFSET_SCALE_CHANNEL_INDEX);\nexport function isXorYOffset(channel) {\n  return hasOwnProperty(OFFSET_SCALE_CHANNEL_INDEX, channel);\n}\n// NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without position / offset\nconst {\n  // x2 and y2 share the same scale as x and y\n  // text and tooltip have format instead of scale,\n  // href has neither format, nor scale\n  text: _t,\n  tooltip: _tt,\n  href: _hr,\n  url: _u,\n  description: _al,\n  // detail and order have no scale\n  detail: _dd,\n  key: _k,\n  order: _oo,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n} = NONPOSITION_CHANNEL_INDEX;\nexport const NONPOSITION_SCALE_CHANNELS = keys(NONPOSITION_SCALE_CHANNEL_INDEX);\nexport function isNonPositionScaleChannel(channel) {\n  return hasOwnProperty(NONPOSITION_CHANNEL_INDEX, channel);\n}\n/**\n * @returns whether Vega supports legends for a particular channel\n */\nexport function supportLegend(channel) {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case SIZE:\n    case SHAPE:\n    case OPACITY:\n    case STROKEWIDTH:\n    case STROKEDASH:\n      return true;\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case ANGLE:\n      return false;\n  }\n}\n// Declare SCALE_CHANNEL_INDEX\nconst SCALE_CHANNEL_INDEX = {\n  ...POSITION_SCALE_CHANNEL_INDEX,\n  ...POLAR_POSITION_SCALE_CHANNEL_INDEX,\n  ...OFFSET_SCALE_CHANNEL_INDEX,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n};\n/** List of channels with scales */\nexport const SCALE_CHANNELS = keys(SCALE_CHANNEL_INDEX);\nexport function isScaleChannel(channel) {\n  return hasOwnProperty(SCALE_CHANNEL_INDEX, channel);\n}\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nexport function supportMark(channel, mark) {\n  return getSupportedMark(channel)[mark];\n}\nconst ALL_MARKS = {\n  // all marks\n  arc: 'always',\n  area: 'always',\n  bar: 'always',\n  circle: 'always',\n  geoshape: 'always',\n  image: 'always',\n  line: 'always',\n  rule: 'always',\n  point: 'always',\n  rect: 'always',\n  square: 'always',\n  trail: 'always',\n  text: 'always',\n  tick: 'always'\n};\nconst {\n  geoshape: _g,\n  ...ALL_MARKS_EXCEPT_GEOSHAPE\n} = ALL_MARKS;\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to 'always', 'binned', or undefined\n */\nfunction getSupportedMark(channel) {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n    // falls through\n    case DESCRIPTION:\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case STROKEWIDTH:\n    // falls through\n    case FACET:\n    case ROW: // falls through\n    case COLUMN:\n      return ALL_MARKS;\n    case X:\n    case Y:\n    case XOFFSET:\n    case YOFFSET:\n    case LATITUDE:\n    case LONGITUDE:\n      // all marks except geoshape. geoshape does not use X, Y -- it uses a projection\n      return ALL_MARKS_EXCEPT_GEOSHAPE;\n    case X2:\n    case Y2:\n    case LATITUDE2:\n    case LONGITUDE2:\n      return {\n        area: 'always',\n        bar: 'always',\n        image: 'always',\n        rect: 'always',\n        rule: 'always',\n        circle: 'binned',\n        point: 'binned',\n        square: 'binned',\n        tick: 'binned',\n        line: 'binned',\n        trail: 'binned'\n      };\n    case SIZE:\n      return {\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        text: 'always',\n        line: 'always',\n        trail: 'always'\n      };\n    case STROKEDASH:\n      return {\n        line: 'always',\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        geoshape: 'always'\n      };\n    case SHAPE:\n      return {\n        point: 'always',\n        geoshape: 'always'\n      };\n    case TEXT:\n      return {\n        text: 'always'\n      };\n    case ANGLE:\n      return {\n        point: 'always',\n        square: 'always',\n        text: 'always'\n      };\n    case URL:\n      return {\n        image: 'always'\n      };\n    case THETA:\n      return {\n        text: 'always',\n        arc: 'always'\n      };\n    case RADIUS:\n      return {\n        text: 'always',\n        arc: 'always'\n      };\n    case THETA2:\n    case RADIUS2:\n      return {\n        arc: 'always'\n      };\n  }\n}\nexport function rangeType(channel) {\n  switch (channel) {\n    case X:\n    case Y:\n    case THETA:\n    case RADIUS:\n    case XOFFSET:\n    case YOFFSET:\n    case SIZE:\n    case ANGLE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    // X2 and Y2 use X and Y scales, so they similarly have continuous range. [falls through]\n    case X2:\n    case Y2:\n    case THETA2:\n    case RADIUS2:\n      return undefined;\n    case FACET:\n    case ROW:\n    case COLUMN:\n    case SHAPE:\n    case STROKEDASH:\n    // TEXT, TOOLTIP, URL, and HREF have no scale but have discrete output [falls through]\n    case TEXT:\n    case TOOLTIP:\n    case HREF:\n    case URL:\n    case DESCRIPTION:\n      return 'discrete';\n    // Color can be either continuous or discrete, depending on scale type.\n    case COLOR:\n    case FILL:\n    case STROKE:\n      return 'flexible';\n    // No scale, no range type.\n    case LATITUDE:\n    case LONGITUDE:\n    case LATITUDE2:\n    case LONGITUDE2:\n    case DETAIL:\n    case KEY:\n    case ORDER:\n      return undefined;\n  }\n}","map":{"version":3,"names":["hasOwnProperty","keys","ROW","COLUMN","FACET","X","Y","X2","Y2","XOFFSET","YOFFSET","RADIUS","RADIUS2","THETA","THETA2","LATITUDE","LONGITUDE","LATITUDE2","LONGITUDE2","COLOR","FILL","STROKE","SHAPE","SIZE","ANGLE","OPACITY","FILLOPACITY","STROKEOPACITY","STROKEWIDTH","STROKEDASH","TEXT","ORDER","DETAIL","KEY","TOOLTIP","HREF","URL","DESCRIPTION","POSITION_CHANNEL_INDEX","x","y","x2","y2","POLAR_POSITION_CHANNEL_INDEX","theta","theta2","radius","radius2","isPolarPositionChannel","c","GEO_POSIITON_CHANNEL_INDEX","longitude","longitude2","latitude","latitude2","getPositionChannelFromLatLong","channel","isGeoPositionChannel","GEOPOSITION_CHANNELS","UNIT_CHANNEL_INDEX","xOffset","yOffset","color","fill","stroke","opacity","fillOpacity","strokeOpacity","strokeWidth","strokeDash","size","angle","shape","order","text","detail","key","tooltip","href","url","description","isColorChannel","FACET_CHANNEL_INDEX","row","column","facet","FACET_CHANNELS","CHANNEL_INDEX","CHANNELS","_o","_d","_tt1","SINGLE_DEF_CHANNEL_INDEX","_r","_c","_f","SINGLE_DEF_UNIT_CHANNEL_INDEX","SINGLE_DEF_CHANNELS","SINGLE_DEF_UNIT_CHANNELS","isSingleDefUnitChannel","str","isChannel","SECONDARY_RANGE_CHANNEL","isSecondaryRangeChannel","main","getMainRangeChannel","getVgPositionChannel","getSecondaryRangeChannel","undefined","getSizeChannel","getOffsetChannel","getOffsetScaleChannel","getMainChannelFromOffsetChannel","UNIT_CHANNELS","_x","_y","_x2","_y2","_xo","_yo","_latitude","_longitude","_latitude2","_longitude2","_theta","_theta2","_radius","_radius2","NONPOSITION_CHANNEL_INDEX","NONPOSITION_CHANNELS","POSITION_SCALE_CHANNEL_INDEX","POSITION_SCALE_CHANNELS","isXorY","POLAR_POSITION_SCALE_CHANNEL_INDEX","POLAR_POSITION_SCALE_CHANNELS","getPositionScaleChannel","sizeType","OFFSET_SCALE_CHANNEL_INDEX","OFFSET_SCALE_CHANNELS","isXorYOffset","_t","_tt","_hr","_u","_al","_dd","_k","_oo","NONPOSITION_SCALE_CHANNEL_INDEX","NONPOSITION_SCALE_CHANNELS","isNonPositionScaleChannel","supportLegend","SCALE_CHANNEL_INDEX","SCALE_CHANNELS","isScaleChannel","supportMark","mark","getSupportedMark","ALL_MARKS","arc","area","bar","circle","geoshape","image","line","rule","point","rect","square","trail","tick","_g","ALL_MARKS_EXCEPT_GEOSHAPE","rangeType"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\channel.ts"],"sourcesContent":["/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\n\nimport {hasOwnProperty} from 'vega-util';\nimport {RangeType} from './compile/scale/type';\nimport {Encoding} from './encoding';\nimport {Mark} from './mark';\nimport {EncodingFacetMapping} from './spec/facet';\nimport {Flag, keys} from './util';\n\nexport type Channel = keyof Encoding<any>;\nexport type ExtendedChannel = Channel | FacetChannel;\n\n// Facet\nexport const ROW = 'row' as const;\nexport const COLUMN = 'column' as const;\n\nexport const FACET = 'facet' as const;\n\n// Position\nexport const X = 'x' as const;\nexport const Y = 'y' as const;\nexport const X2 = 'x2' as const;\nexport const Y2 = 'y2' as const;\n\n// Position Offset\nexport const XOFFSET = 'xOffset' as const;\nexport const YOFFSET = 'yOffset' as const;\n\n// Arc-Position\nexport const RADIUS = 'radius' as const;\nexport const RADIUS2 = 'radius2' as const;\nexport const THETA = 'theta' as const;\nexport const THETA2 = 'theta2' as const;\n\n// Geo Position\nexport const LATITUDE = 'latitude' as const;\nexport const LONGITUDE = 'longitude' as const;\nexport const LATITUDE2 = 'latitude2' as const;\nexport const LONGITUDE2 = 'longitude2' as const;\n\n// Mark property with scale\nexport const COLOR = 'color' as const;\n\nexport const FILL = 'fill' as const;\n\nexport const STROKE = 'stroke' as const;\n\nexport const SHAPE = 'shape' as const;\nexport const SIZE = 'size' as const;\n\nexport const ANGLE = 'angle' as const;\n\nexport const OPACITY = 'opacity' as const;\nexport const FILLOPACITY = 'fillOpacity' as const;\n\nexport const STROKEOPACITY = 'strokeOpacity' as const;\n\nexport const STROKEWIDTH = 'strokeWidth' as const;\nexport const STROKEDASH = 'strokeDash' as const;\n\n// Non-scale channel\nexport const TEXT = 'text' as const;\nexport const ORDER = 'order' as const;\nexport const DETAIL = 'detail' as const;\nexport const KEY = 'key' as const;\n\nexport const TOOLTIP = 'tooltip' as const;\nexport const HREF = 'href' as const;\n\nexport const URL = 'url' as const;\nexport const DESCRIPTION = 'description' as const;\n\nconst POSITION_CHANNEL_INDEX = {\n  x: 1,\n  y: 1,\n  x2: 1,\n  y2: 1\n} as const;\n\nexport type PositionChannel = keyof typeof POSITION_CHANNEL_INDEX;\n\nconst POLAR_POSITION_CHANNEL_INDEX = {\n  theta: 1,\n  theta2: 1,\n  radius: 1,\n  radius2: 1\n} as const;\n\nexport type PolarPositionChannel = keyof typeof POLAR_POSITION_CHANNEL_INDEX;\n\nexport function isPolarPositionChannel(c: Channel): c is PolarPositionChannel {\n  return hasOwnProperty(POLAR_POSITION_CHANNEL_INDEX, c);\n}\n\nconst GEO_POSIITON_CHANNEL_INDEX = {\n  longitude: 1,\n  longitude2: 1,\n  latitude: 1,\n  latitude2: 1\n} as const;\n\nexport type GeoPositionChannel = keyof typeof GEO_POSIITON_CHANNEL_INDEX;\n\nexport function getPositionChannelFromLatLong(channel: GeoPositionChannel): PositionChannel {\n  switch (channel) {\n    case LATITUDE:\n      return 'y';\n    case LATITUDE2:\n      return 'y2';\n    case LONGITUDE:\n      return 'x';\n    case LONGITUDE2:\n      return 'x2';\n  }\n}\n\nexport function isGeoPositionChannel(c: Channel): c is GeoPositionChannel {\n  return hasOwnProperty(GEO_POSIITON_CHANNEL_INDEX, c);\n}\n\nexport const GEOPOSITION_CHANNELS = keys(GEO_POSIITON_CHANNEL_INDEX);\n\nconst UNIT_CHANNEL_INDEX: Flag<Channel> = {\n  ...POSITION_CHANNEL_INDEX,\n  ...POLAR_POSITION_CHANNEL_INDEX,\n\n  ...GEO_POSIITON_CHANNEL_INDEX,\n  xOffset: 1,\n  yOffset: 1,\n\n  // color\n  color: 1,\n  fill: 1,\n  stroke: 1,\n\n  // other non-position with scale\n  opacity: 1,\n  fillOpacity: 1,\n  strokeOpacity: 1,\n\n  strokeWidth: 1,\n  strokeDash: 1,\n  size: 1,\n  angle: 1,\n  shape: 1,\n\n  // channels without scales\n  order: 1,\n  text: 1,\n  detail: 1,\n  key: 1,\n  tooltip: 1,\n  href: 1,\n  url: 1,\n  description: 1\n};\n\nexport type ColorChannel = 'color' | 'fill' | 'stroke';\n\nexport function isColorChannel(channel: Channel): channel is ColorChannel {\n  return channel === COLOR || channel === FILL || channel === STROKE;\n}\n\nexport type FacetChannel = keyof EncodingFacetMapping<any, any>;\n\nconst FACET_CHANNEL_INDEX: Flag<keyof EncodingFacetMapping<any, any>> = {\n  row: 1,\n  column: 1,\n  facet: 1\n};\n\nexport const FACET_CHANNELS = keys(FACET_CHANNEL_INDEX);\n\nconst CHANNEL_INDEX = {\n  ...UNIT_CHANNEL_INDEX,\n  ...FACET_CHANNEL_INDEX\n};\n\nexport const CHANNELS = keys(CHANNEL_INDEX);\n\nconst {order: _o, detail: _d, tooltip: _tt1, ...SINGLE_DEF_CHANNEL_INDEX} = CHANNEL_INDEX;\nconst {row: _r, column: _c, facet: _f, ...SINGLE_DEF_UNIT_CHANNEL_INDEX} = SINGLE_DEF_CHANNEL_INDEX;\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them. Similarly, selection projection won't work with \"detail\" and \"order\".)\n */\n\nexport const SINGLE_DEF_CHANNELS = keys(SINGLE_DEF_CHANNEL_INDEX);\n\nexport type SingleDefChannel = (typeof SINGLE_DEF_CHANNELS)[number];\n\nexport const SINGLE_DEF_UNIT_CHANNELS = keys(SINGLE_DEF_UNIT_CHANNEL_INDEX);\n\nexport type SingleDefUnitChannel = (typeof SINGLE_DEF_UNIT_CHANNELS)[number];\n\nexport function isSingleDefUnitChannel(str: string): str is SingleDefUnitChannel {\n  return hasOwnProperty(SINGLE_DEF_UNIT_CHANNEL_INDEX, str);\n}\n\nexport function isChannel(str: string): str is Channel {\n  return hasOwnProperty(CHANNEL_INDEX, str);\n}\n\nexport type SecondaryRangeChannel = 'x2' | 'y2' | 'latitude2' | 'longitude2' | 'theta2' | 'radius2';\n\nexport const SECONDARY_RANGE_CHANNEL: SecondaryRangeChannel[] = [X2, Y2, LATITUDE2, LONGITUDE2, THETA2, RADIUS2];\n\nexport function isSecondaryRangeChannel(c: ExtendedChannel): c is SecondaryRangeChannel {\n  const main = getMainRangeChannel(c);\n  return main !== c;\n}\n\nexport type MainChannelOf<C extends ExtendedChannel> = C extends 'x2'\n  ? 'x'\n  : C extends 'y2'\n    ? 'y'\n    : C extends 'latitude2'\n      ? 'latitude'\n      : C extends 'longitude2'\n        ? 'longitude'\n        : C extends 'theta2'\n          ? 'theta'\n          : C extends 'radius2'\n            ? 'radius'\n            : C;\n\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getMainRangeChannel<C extends ExtendedChannel>(channel: C): MainChannelOf<C> {\n  switch (channel) {\n    case X2:\n      return X as MainChannelOf<C>;\n    case Y2:\n      return Y as MainChannelOf<C>;\n    case LATITUDE2:\n      return LATITUDE as MainChannelOf<C>;\n    case LONGITUDE2:\n      return LONGITUDE as MainChannelOf<C>;\n    case THETA2:\n      return THETA as MainChannelOf<C>;\n    case RADIUS2:\n      return RADIUS as MainChannelOf<C>;\n  }\n  return channel as MainChannelOf<C>;\n}\n\nexport type SecondaryChannelOf<C extends Channel> = C extends 'x'\n  ? 'x2'\n  : C extends 'y'\n    ? 'y2'\n    : C extends 'latitude'\n      ? 'latitude2'\n      : C extends 'longitude'\n        ? 'longitude2'\n        : C extends 'theta'\n          ? 'theta2'\n          : C extends 'radius'\n            ? 'radius2'\n            : undefined;\n\nexport function getVgPositionChannel(channel: PolarPositionChannel | PositionChannel) {\n  if (isPolarPositionChannel(channel)) {\n    switch (channel) {\n      case THETA:\n        return 'startAngle';\n      case THETA2:\n        return 'endAngle';\n      case RADIUS:\n        return 'outerRadius';\n      case RADIUS2:\n        return 'innerRadius';\n    }\n  }\n  return channel;\n}\n\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getSecondaryRangeChannel<C extends Channel>(channel: C): SecondaryChannelOf<C> | undefined {\n  switch (channel) {\n    case X:\n      return X2 as SecondaryChannelOf<C>;\n    case Y:\n      return Y2 as SecondaryChannelOf<C>;\n    case LATITUDE:\n      return LATITUDE2 as SecondaryChannelOf<C>;\n    case LONGITUDE:\n      return LONGITUDE2 as SecondaryChannelOf<C>;\n    case THETA:\n      return THETA2 as SecondaryChannelOf<C>;\n    case RADIUS:\n      return RADIUS2 as SecondaryChannelOf<C>;\n  }\n  return undefined;\n}\n\nexport function getSizeChannel(channel: PositionChannel): 'width' | 'height';\nexport function getSizeChannel(channel: Channel): 'width' | 'height' | undefined;\nexport function getSizeChannel(channel: Channel): 'width' | 'height' | undefined {\n  switch (channel) {\n    case X:\n    case X2:\n      return 'width';\n    case Y:\n    case Y2:\n      return 'height';\n  }\n  return undefined;\n}\n\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getOffsetChannel(channel: Channel) {\n  switch (channel) {\n    case X:\n      return 'xOffset';\n    case Y:\n      return 'yOffset';\n    case X2:\n      return 'x2Offset';\n    case Y2:\n      return 'y2Offset';\n    case THETA:\n      return 'thetaOffset';\n    case RADIUS:\n      return 'radiusOffset';\n    case THETA2:\n      return 'theta2Offset';\n    case RADIUS2:\n      return 'radius2Offset';\n  }\n  return undefined;\n}\n\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getOffsetScaleChannel(channel: Channel): OffsetScaleChannel {\n  switch (channel) {\n    case X:\n      return 'xOffset';\n    case Y:\n      return 'yOffset';\n  }\n  return undefined;\n}\n\nexport function getMainChannelFromOffsetChannel(channel: OffsetScaleChannel): PositionScaleChannel {\n  switch (channel) {\n    case 'xOffset':\n      return 'x';\n    case 'yOffset':\n      return 'y';\n  }\n}\n\n// CHANNELS without COLUMN, ROW\nexport const UNIT_CHANNELS = keys(UNIT_CHANNEL_INDEX);\n\n// NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\nconst {\n  x: _x,\n  y: _y,\n  // x2 and y2 share the same scale as x and y\n  x2: _x2,\n  y2: _y2,\n  //\n  xOffset: _xo,\n  yOffset: _yo,\n  latitude: _latitude,\n  longitude: _longitude,\n  latitude2: _latitude2,\n  longitude2: _longitude2,\n  theta: _theta,\n  theta2: _theta2,\n  radius: _radius,\n  radius2: _radius2,\n  // The rest of unit channels then have scale\n  ...NONPOSITION_CHANNEL_INDEX\n} = UNIT_CHANNEL_INDEX;\n\nexport const NONPOSITION_CHANNELS = keys(NONPOSITION_CHANNEL_INDEX);\nexport type NonPositionChannel = (typeof NONPOSITION_CHANNELS)[number];\n\nconst POSITION_SCALE_CHANNEL_INDEX = {\n  x: 1,\n  y: 1\n} as const;\nexport const POSITION_SCALE_CHANNELS = keys(POSITION_SCALE_CHANNEL_INDEX);\nexport type PositionScaleChannel = keyof typeof POSITION_SCALE_CHANNEL_INDEX;\n\nexport function isXorY(channel: ExtendedChannel): channel is PositionScaleChannel {\n  return hasOwnProperty(POSITION_SCALE_CHANNEL_INDEX, channel);\n}\n\nexport const POLAR_POSITION_SCALE_CHANNEL_INDEX = {\n  theta: 1,\n  radius: 1\n} as const;\n\nexport const POLAR_POSITION_SCALE_CHANNELS = keys(POLAR_POSITION_SCALE_CHANNEL_INDEX);\nexport type PolarPositionScaleChannel = keyof typeof POLAR_POSITION_SCALE_CHANNEL_INDEX;\n\nexport function getPositionScaleChannel(sizeType: 'width' | 'height'): PositionScaleChannel {\n  return sizeType === 'width' ? X : Y;\n}\n\nconst OFFSET_SCALE_CHANNEL_INDEX: {xOffset: 1; yOffset: 1} = {xOffset: 1, yOffset: 1};\n\nexport const OFFSET_SCALE_CHANNELS = keys(OFFSET_SCALE_CHANNEL_INDEX);\n\nexport type OffsetScaleChannel = (typeof OFFSET_SCALE_CHANNELS)[0];\n\nexport function isXorYOffset(channel: Channel): channel is OffsetScaleChannel {\n  return hasOwnProperty(OFFSET_SCALE_CHANNEL_INDEX, channel);\n}\n\n// NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without position / offset\nconst {\n  // x2 and y2 share the same scale as x and y\n  // text and tooltip have format instead of scale,\n  // href has neither format, nor scale\n  text: _t,\n  tooltip: _tt,\n  href: _hr,\n  url: _u,\n  description: _al,\n  // detail and order have no scale\n  detail: _dd,\n  key: _k,\n  order: _oo,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n} = NONPOSITION_CHANNEL_INDEX;\nexport const NONPOSITION_SCALE_CHANNELS = keys(NONPOSITION_SCALE_CHANNEL_INDEX);\nexport type NonPositionScaleChannel = (typeof NONPOSITION_SCALE_CHANNELS)[number];\n\nexport function isNonPositionScaleChannel(channel: Channel): channel is NonPositionScaleChannel {\n  return hasOwnProperty(NONPOSITION_CHANNEL_INDEX, channel);\n}\n\n/**\n * @returns whether Vega supports legends for a particular channel\n */\nexport function supportLegend(channel: NonPositionScaleChannel) {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case SIZE:\n    case SHAPE:\n    case OPACITY:\n    case STROKEWIDTH:\n    case STROKEDASH:\n      return true;\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case ANGLE:\n      return false;\n  }\n}\n\n// Declare SCALE_CHANNEL_INDEX\nconst SCALE_CHANNEL_INDEX = {\n  ...POSITION_SCALE_CHANNEL_INDEX,\n  ...POLAR_POSITION_SCALE_CHANNEL_INDEX,\n  ...OFFSET_SCALE_CHANNEL_INDEX,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n};\n\n/** List of channels with scales */\nexport const SCALE_CHANNELS = keys(SCALE_CHANNEL_INDEX);\nexport type ScaleChannel = (typeof SCALE_CHANNELS)[number];\n\nexport function isScaleChannel(channel: ExtendedChannel): channel is ScaleChannel {\n  return hasOwnProperty(SCALE_CHANNEL_INDEX, channel);\n}\n\nexport type SupportedMark = Partial<Record<Mark, 'always' | 'binned'>>;\n\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nexport function supportMark(channel: ExtendedChannel, mark: Mark) {\n  return getSupportedMark(channel)[mark];\n}\n\nconst ALL_MARKS: Record<Mark, 'always'> = {\n  // all marks\n  arc: 'always',\n  area: 'always',\n  bar: 'always',\n  circle: 'always',\n  geoshape: 'always',\n  image: 'always',\n  line: 'always',\n  rule: 'always',\n  point: 'always',\n  rect: 'always',\n  square: 'always',\n  trail: 'always',\n  text: 'always',\n  tick: 'always'\n};\n\nconst {geoshape: _g, ...ALL_MARKS_EXCEPT_GEOSHAPE} = ALL_MARKS;\n\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to 'always', 'binned', or undefined\n */\nfunction getSupportedMark(channel: ExtendedChannel): SupportedMark {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n    // falls through\n\n    case DESCRIPTION:\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case STROKEWIDTH:\n\n    // falls through\n\n    case FACET:\n    case ROW: // falls through\n    case COLUMN:\n      return ALL_MARKS;\n    case X:\n    case Y:\n    case XOFFSET:\n    case YOFFSET:\n    case LATITUDE:\n    case LONGITUDE:\n      // all marks except geoshape. geoshape does not use X, Y -- it uses a projection\n      return ALL_MARKS_EXCEPT_GEOSHAPE;\n    case X2:\n    case Y2:\n    case LATITUDE2:\n    case LONGITUDE2:\n      return {\n        area: 'always',\n        bar: 'always',\n        image: 'always',\n        rect: 'always',\n        rule: 'always',\n        circle: 'binned',\n        point: 'binned',\n        square: 'binned',\n        tick: 'binned',\n        line: 'binned',\n        trail: 'binned'\n      };\n    case SIZE:\n      return {\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        text: 'always',\n        line: 'always',\n        trail: 'always'\n      };\n    case STROKEDASH:\n      return {\n        line: 'always',\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        geoshape: 'always'\n      };\n    case SHAPE:\n      return {point: 'always', geoshape: 'always'};\n    case TEXT:\n      return {text: 'always'};\n    case ANGLE:\n      return {point: 'always', square: 'always', text: 'always'};\n    case URL:\n      return {image: 'always'};\n    case THETA:\n      return {text: 'always', arc: 'always'};\n    case RADIUS:\n      return {text: 'always', arc: 'always'};\n    case THETA2:\n    case RADIUS2:\n      return {arc: 'always'};\n  }\n}\n\nexport function rangeType(channel: ExtendedChannel): RangeType {\n  switch (channel) {\n    case X:\n    case Y:\n    case THETA:\n    case RADIUS:\n    case XOFFSET:\n    case YOFFSET:\n    case SIZE:\n    case ANGLE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n\n    // X2 and Y2 use X and Y scales, so they similarly have continuous range. [falls through]\n    case X2:\n    case Y2:\n    case THETA2:\n    case RADIUS2:\n      return undefined;\n\n    case FACET:\n    case ROW:\n    case COLUMN:\n    case SHAPE:\n    case STROKEDASH:\n    // TEXT, TOOLTIP, URL, and HREF have no scale but have discrete output [falls through]\n    case TEXT:\n    case TOOLTIP:\n    case HREF:\n    case URL:\n    case DESCRIPTION:\n      return 'discrete';\n\n    // Color can be either continuous or discrete, depending on scale type.\n    case COLOR:\n    case FILL:\n    case STROKE:\n      return 'flexible';\n\n    // No scale, no range type.\n\n    case LATITUDE:\n    case LONGITUDE:\n    case LATITUDE2:\n    case LONGITUDE2:\n    case DETAIL:\n    case KEY:\n    case ORDER:\n      return undefined;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}