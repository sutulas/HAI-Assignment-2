{"ast":null,"code":"import { isBoolean, isObject } from 'vega-util';\nimport { COLOR, COLUMN, FILL, FILLOPACITY, OPACITY, ROW, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH } from './channel';\nimport { normalizeBin } from './channeldef';\nimport { entries, hasProperty, keys, varName } from './util';\n/**\n * Create a key for the bin configuration. Not for prebinned bin.\n */\nexport function binToString(bin) {\n  if (isBoolean(bin)) {\n    bin = normalizeBin(bin, undefined);\n  }\n  return 'bin' + keys(bin).map(p => isParameterExtent(bin[p]) ? varName(`_${p}_${entries(bin[p])}`) : varName(`_${p}_${bin[p]}`)).join('');\n}\n/**\n * Vega-Lite should bin the data.\n */\nexport function isBinning(bin) {\n  return bin === true || isBinParams(bin) && !bin.binned;\n}\n/**\n * The data is already binned and so Vega-Lite should not bin it again.\n */\nexport function isBinned(bin) {\n  return bin === 'binned' || isBinParams(bin) && bin.binned === true;\n}\nexport function isBinParams(bin) {\n  return isObject(bin);\n}\nexport function isParameterExtent(extent) {\n  return hasProperty(extent, 'param');\n}\nexport function autoMaxBins(channel) {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case SIZE:\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    // Facets and Size shouldn't have too many bins\n    // We choose 6 like shape to simplify the rule [falls through]\n    case SHAPE:\n      return 6;\n    // Vega's \"shape\" has 6 distinct values\n    case STROKEDASH:\n      return 4;\n    // We only provide 5 different stroke dash values (but 4 is more effective)\n    default:\n      return 10;\n  }\n}","map":{"version":3,"names":["isBoolean","isObject","COLOR","COLUMN","FILL","FILLOPACITY","OPACITY","ROW","SHAPE","SIZE","STROKE","STROKEDASH","STROKEOPACITY","STROKEWIDTH","normalizeBin","entries","hasProperty","keys","varName","binToString","bin","undefined","map","p","isParameterExtent","join","isBinning","isBinParams","binned","isBinned","extent","autoMaxBins","channel"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\bin.ts"],"sourcesContent":["import {isBoolean, isObject} from 'vega-util';\nimport {\n  COLOR,\n  COLUMN,\n  ExtendedChannel,\n  FILL,\n  FILLOPACITY,\n  OPACITY,\n  ROW,\n  SHAPE,\n  SIZE,\n  STROKE,\n  STROKEDASH,\n  STROKEOPACITY,\n  STROKEWIDTH\n} from './channel';\nimport {normalizeBin} from './channeldef';\nimport {ParameterExtent} from './selection';\nimport {entries, hasProperty, keys, varName} from './util';\n\nexport interface BaseBin {\n  /**\n   * The number base to use for automatic bin determination (default is base 10).\n   *\n   * __Default value:__ `10`\n   *\n   */\n  base?: number;\n  /**\n   * An exact step size to use between bins.\n   *\n   * __Note:__ If provided, options such as maxbins will be ignored.\n   */\n  step?: number;\n  /**\n   * An array of allowable step sizes to choose from.\n   * @minItems 1\n   */\n  steps?: number[];\n  /**\n   * A minimum allowable step size (particularly useful for integer values).\n   */\n  minstep?: number;\n  /**\n   * Scale factors indicating allowable subdivisions. The default value is [5, 2], which indicates that for base 10 numbers (the default base), the method may consider dividing bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given constraints.\n   *\n   * __Default value:__ `[5, 2]`\n   *\n   * @minItems 1\n   */\n  divide?: [number, number];\n  /**\n   * Maximum number of bins.\n   *\n   * __Default value:__ `6` for `row`, `column` and `shape` channels; `10` for other channels\n   *\n   * @minimum 2\n   */\n  maxbins?: number;\n  /**\n   * A value in the binned domain at which to anchor the bins, shifting the bin boundaries if necessary to ensure that a boundary aligns with the anchor value.\n   *\n   * __Default value:__ the minimum bin extent value\n   */\n  anchor?: number;\n  /**\n   * If true, attempts to make the bin boundaries use human-friendly boundaries, such as multiples of ten.\n   *\n   * __Default value:__ `true`\n   */\n  nice?: boolean;\n}\n\n/**\n * Binning properties or boolean flag for determining whether to bin data or not.\n */\nexport interface BinParams extends BaseBin {\n  /**\n   * A two-element (`[min, max]`) array indicating the range of desired bin values.\n   */\n  extent?: BinExtent; // VgBinTransform uses a different extent so we need to pull this out.\n\n  /**\n   * When set to `true`, Vega-Lite treats the input data as already binned.\n   */\n  binned?: boolean;\n}\n\nexport type Bin = boolean | BinParams | 'binned' | null;\n\nexport type BinExtent = [number, number] | ParameterExtent;\n\n/**\n * Create a key for the bin configuration. Not for prebinned bin.\n */\nexport function binToString(bin: BinParams | true) {\n  if (isBoolean(bin)) {\n    bin = normalizeBin(bin, undefined);\n  }\n  return (\n    'bin' +\n    keys(bin)\n      .map(p => (isParameterExtent(bin[p]) ? varName(`_${p}_${entries(bin[p])}`) : varName(`_${p}_${bin[p]}`)))\n      .join('')\n  );\n}\n\n/**\n * Vega-Lite should bin the data.\n */\nexport function isBinning(bin: BinParams | boolean | 'binned'): bin is BinParams | true {\n  return bin === true || (isBinParams(bin) && !bin.binned);\n}\n\n/**\n * The data is already binned and so Vega-Lite should not bin it again.\n */\nexport function isBinned(bin: BinParams | boolean | 'binned'): bin is 'binned' | BinParams {\n  return bin === 'binned' || (isBinParams(bin) && bin.binned === true);\n}\n\nexport function isBinParams(bin: BinParams | boolean | 'binned'): bin is BinParams {\n  return isObject(bin);\n}\n\nexport function isParameterExtent(extent: unknown): extent is ParameterExtent {\n  return hasProperty(extent, 'param');\n}\n\nexport function autoMaxBins(channel?: ExtendedChannel): number {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case SIZE:\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    // Facets and Size shouldn't have too many bins\n    // We choose 6 like shape to simplify the rule [falls through]\n    case SHAPE:\n      return 6; // Vega's \"shape\" has 6 distinct values\n    case STROKEDASH:\n      return 4; // We only provide 5 different stroke dash values (but 4 is more effective)\n    default:\n      return 10;\n  }\n}\n"],"mappings":"AAAA,SAAQA,SAAS,EAAEC,QAAQ,QAAO,WAAW;AAC7C,SACEC,KAAK,EACLC,MAAM,EAENC,IAAI,EACJC,WAAW,EACXC,OAAO,EACPC,GAAG,EACHC,KAAK,EACLC,IAAI,EACJC,MAAM,EACNC,UAAU,EACVC,aAAa,EACbC,WAAW,QACN,WAAW;AAClB,SAAQC,YAAY,QAAO,cAAc;AAEzC,SAAQC,OAAO,EAAEC,WAAW,EAAEC,IAAI,EAAEC,OAAO,QAAO,QAAQ;AA0E1D;;;AAGA,OAAM,SAAUC,WAAWA,CAACC,GAAqB;EAC/C,IAAIpB,SAAS,CAACoB,GAAG,CAAC,EAAE;IAClBA,GAAG,GAAGN,YAAY,CAACM,GAAG,EAAEC,SAAS,CAAC;EACpC;EACA,OACE,KAAK,GACLJ,IAAI,CAACG,GAAG,CAAC,CACNE,GAAG,CAACC,CAAC,IAAKC,iBAAiB,CAACJ,GAAG,CAACG,CAAC,CAAC,CAAC,GAAGL,OAAO,CAAC,IAAIK,CAAC,IAAIR,OAAO,CAACK,GAAG,CAACG,CAAC,CAAC,CAAC,EAAE,CAAC,GAAGL,OAAO,CAAC,IAAIK,CAAC,IAAIH,GAAG,CAACG,CAAC,CAAC,EAAE,CAAE,CAAC,CACxGE,IAAI,CAAC,EAAE,CAAC;AAEf;AAEA;;;AAGA,OAAM,SAAUC,SAASA,CAACN,GAAmC;EAC3D,OAAOA,GAAG,KAAK,IAAI,IAAKO,WAAW,CAACP,GAAG,CAAC,IAAI,CAACA,GAAG,CAACQ,MAAO;AAC1D;AAEA;;;AAGA,OAAM,SAAUC,QAAQA,CAACT,GAAmC;EAC1D,OAAOA,GAAG,KAAK,QAAQ,IAAKO,WAAW,CAACP,GAAG,CAAC,IAAIA,GAAG,CAACQ,MAAM,KAAK,IAAK;AACtE;AAEA,OAAM,SAAUD,WAAWA,CAACP,GAAmC;EAC7D,OAAOnB,QAAQ,CAACmB,GAAG,CAAC;AACtB;AAEA,OAAM,SAAUI,iBAAiBA,CAACM,MAAe;EAC/C,OAAOd,WAAW,CAACc,MAAM,EAAE,OAAO,CAAC;AACrC;AAEA,OAAM,SAAUC,WAAWA,CAACC,OAAyB;EACnD,QAAQA,OAAO;IACb,KAAKzB,GAAG;IACR,KAAKJ,MAAM;IACX,KAAKM,IAAI;IACT,KAAKP,KAAK;IACV,KAAKE,IAAI;IACT,KAAKM,MAAM;IACX,KAAKG,WAAW;IAChB,KAAKP,OAAO;IACZ,KAAKD,WAAW;IAChB,KAAKO,aAAa;IAClB;IACA;IACA,KAAKJ,KAAK;MACR,OAAO,CAAC;IAAE;IACZ,KAAKG,UAAU;MACb,OAAO,CAAC;IAAE;IACZ;MACE,OAAO,EAAE;EACb;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}