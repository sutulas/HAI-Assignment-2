{"ast":null,"code":"import { isObject } from 'vega-util';\nimport { isBinned } from '../bin';\nimport { getMainRangeChannel, SECONDARY_RANGE_CHANNEL } from '../channel';\nimport { isDatumDef, isFieldDef } from '../channeldef';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { isUnitSpec } from '../spec/unit';\nexport class RuleForRangedLineNormalizer {\n  constructor() {\n    this.name = 'RuleForRangedLine';\n  }\n  hasMatchingType(spec) {\n    if (isUnitSpec(spec)) {\n      const {\n        encoding,\n        mark\n      } = spec;\n      if (mark === 'line' || isMarkDef(mark) && mark.type === 'line') {\n        for (const channel of SECONDARY_RANGE_CHANNEL) {\n          const mainChannel = getMainRangeChannel(channel);\n          const mainChannelDef = encoding[mainChannel];\n          if (encoding[channel]) {\n            if (isFieldDef(mainChannelDef) && !isBinned(mainChannelDef.bin) || isDatumDef(mainChannelDef)) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n  run(spec, params, normalize) {\n    const {\n      encoding,\n      mark\n    } = spec;\n    log.warn(log.message.lineWithRange(!!encoding.x2, !!encoding.y2));\n    return normalize({\n      ...spec,\n      mark: isObject(mark) ? {\n        ...mark,\n        type: 'rule'\n      } : 'rule'\n    }, params);\n  }\n}","map":{"version":3,"names":["isObject","isBinned","getMainRangeChannel","SECONDARY_RANGE_CHANNEL","isDatumDef","isFieldDef","log","isMarkDef","isUnitSpec","RuleForRangedLineNormalizer","constructor","name","hasMatchingType","spec","encoding","mark","type","channel","mainChannel","mainChannelDef","bin","run","params","normalize","warn","message","lineWithRange","x2","y2"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\normalize\\ruleforrangedline.ts"],"sourcesContent":["import {isObject} from 'vega-util';\nimport {isBinned} from '../bin';\nimport {getMainRangeChannel, SECONDARY_RANGE_CHANNEL} from '../channel';\nimport {Field, isDatumDef, isFieldDef} from '../channeldef';\nimport {Encoding} from '../encoding';\nimport * as log from '../log';\nimport {isMarkDef} from '../mark';\nimport {GenericSpec} from '../spec';\nimport {GenericUnitSpec, isUnitSpec} from '../spec/unit';\nimport {NonFacetUnitNormalizer, NormalizeLayerOrUnit, NormalizerParams} from './base';\n\ninterface EncodingX2Mixins {\n  x2: Encoding<Field>['x2'];\n}\n\ninterface EncodingY2Mixins {\n  y2: Encoding<Field>['y2'];\n}\n\ntype RangedLineSpec = GenericUnitSpec<Encoding<Field> & (EncodingX2Mixins | EncodingY2Mixins), 'line' | {mark: 'line'}>;\n\nexport class RuleForRangedLineNormalizer implements NonFacetUnitNormalizer<RangedLineSpec> {\n  public name = 'RuleForRangedLine';\n\n  public hasMatchingType(spec: GenericSpec<any, any, any, any>): spec is RangedLineSpec {\n    if (isUnitSpec(spec)) {\n      const {encoding, mark} = spec;\n      if (mark === 'line' || (isMarkDef(mark) && mark.type === 'line')) {\n        for (const channel of SECONDARY_RANGE_CHANNEL) {\n          const mainChannel = getMainRangeChannel(channel);\n          const mainChannelDef = encoding[mainChannel];\n\n          if (encoding[channel]) {\n            if ((isFieldDef(mainChannelDef) && !isBinned(mainChannelDef.bin)) || isDatumDef(mainChannelDef)) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  public run(spec: RangedLineSpec, params: NormalizerParams, normalize: NormalizeLayerOrUnit) {\n    const {encoding, mark} = spec;\n    log.warn(log.message.lineWithRange(!!encoding.x2, !!encoding.y2));\n\n    return normalize(\n      {\n        ...spec,\n        mark: isObject(mark) ? {...mark, type: 'rule'} : 'rule'\n      },\n      params\n    );\n  }\n}\n"],"mappings":"AAAA,SAAQA,QAAQ,QAAO,WAAW;AAClC,SAAQC,QAAQ,QAAO,QAAQ;AAC/B,SAAQC,mBAAmB,EAAEC,uBAAuB,QAAO,YAAY;AACvE,SAAeC,UAAU,EAAEC,UAAU,QAAO,eAAe;AAE3D,OAAO,KAAKC,GAAG,MAAM,QAAQ;AAC7B,SAAQC,SAAS,QAAO,SAAS;AAEjC,SAAyBC,UAAU,QAAO,cAAc;AAaxD,OAAM,MAAOC,2BAA2B;EAAxCC,YAAA;IACS,KAAAC,IAAI,GAAG,mBAAmB;EAiCnC;EA/BSC,eAAeA,CAACC,IAAqC;IAC1D,IAAIL,UAAU,CAACK,IAAI,CAAC,EAAE;MACpB,MAAM;QAACC,QAAQ;QAAEC;MAAI,CAAC,GAAGF,IAAI;MAC7B,IAAIE,IAAI,KAAK,MAAM,IAAKR,SAAS,CAACQ,IAAI,CAAC,IAAIA,IAAI,CAACC,IAAI,KAAK,MAAO,EAAE;QAChE,KAAK,MAAMC,OAAO,IAAId,uBAAuB,EAAE;UAC7C,MAAMe,WAAW,GAAGhB,mBAAmB,CAACe,OAAO,CAAC;UAChD,MAAME,cAAc,GAAGL,QAAQ,CAACI,WAAW,CAAC;UAE5C,IAAIJ,QAAQ,CAACG,OAAO,CAAC,EAAE;YACrB,IAAKZ,UAAU,CAACc,cAAc,CAAC,IAAI,CAAClB,QAAQ,CAACkB,cAAc,CAACC,GAAG,CAAC,IAAKhB,UAAU,CAACe,cAAc,CAAC,EAAE;cAC/F,OAAO,IAAI;YACb;UACF;QACF;MACF;IACF;IACA,OAAO,KAAK;EACd;EAEOE,GAAGA,CAACR,IAAoB,EAAES,MAAwB,EAAEC,SAA+B;IACxF,MAAM;MAACT,QAAQ;MAAEC;IAAI,CAAC,GAAGF,IAAI;IAC7BP,GAAG,CAACkB,IAAI,CAAClB,GAAG,CAACmB,OAAO,CAACC,aAAa,CAAC,CAAC,CAACZ,QAAQ,CAACa,EAAE,EAAE,CAAC,CAACb,QAAQ,CAACc,EAAE,CAAC,CAAC;IAEjE,OAAOL,SAAS,CACd;MACE,GAAGV,IAAI;MACPE,IAAI,EAAEf,QAAQ,CAACe,IAAI,CAAC,GAAG;QAAC,GAAGA,IAAI;QAAEC,IAAI,EAAE;MAAM,CAAC,GAAG;KAClD,EACDM,MAAM,CACP;EACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}