{"ast":null,"code":"import { array, isArray, stringValue } from 'vega-util';\nimport { COLOR, OPACITY } from '../../channel';\nimport { hasConditionalValueDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { FILL_STROKE_CONFIG } from '../../mark';\nimport { getFirstDefined, hasProperty, isEmpty, varName } from '../../util';\nimport { applyMarkConfig, signalOrValueRef } from '../common';\nimport { formatCustomType, isCustomFormatType } from '../format';\nimport * as mixins from '../mark/encode';\nimport { STORE } from '../selection';\nexport const legendEncodeRules = {\n  symbols,\n  gradient,\n  labels,\n  entries\n};\nexport function symbols(symbolsSpec, _ref) {\n  let {\n    fieldOrDatumDef,\n    model,\n    channel,\n    legendCmpt,\n    legendType\n  } = _ref;\n  if (legendType !== 'symbol') {\n    return undefined;\n  }\n  const {\n    markDef,\n    encoding,\n    config,\n    mark\n  } = model;\n  const filled = markDef.filled && mark !== 'trail';\n  let out = {\n    ...applyMarkConfig({}, model, FILL_STROKE_CONFIG),\n    ...mixins.color(model, {\n      filled\n    })\n  }; // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n  const symbolOpacity = legendCmpt.get('symbolOpacity') ?? config.legend.symbolOpacity;\n  const symbolFillColor = legendCmpt.get('symbolFillColor') ?? config.legend.symbolFillColor;\n  const symbolStrokeColor = legendCmpt.get('symbolStrokeColor') ?? config.legend.symbolStrokeColor;\n  const opacity = symbolOpacity === undefined ? getMaxValue(encoding.opacity) ?? markDef.opacity : undefined;\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || filled && channel === COLOR) {\n      delete out.fill;\n    } else if (hasProperty(out.fill, 'field')) {\n      // For others, set fill to some opaque value (or nothing if a color is already set)\n      if (symbolFillColor) {\n        delete out.fill;\n      } else {\n        out.fill = signalOrValueRef(config.legend.symbolBaseFillColor ?? 'black');\n        out.fillOpacity = signalOrValueRef(opacity ?? 1);\n      }\n    } else if (isArray(out.fill)) {\n      const fill = getFirstConditionValue(encoding.fill ?? encoding.color) ?? markDef.fill ?? (filled && markDef.color);\n      if (fill) {\n        out.fill = signalOrValueRef(fill);\n      }\n    }\n  }\n  if (out.stroke) {\n    if (channel === 'stroke' || !filled && channel === COLOR) {\n      delete out.stroke;\n    } else if (hasProperty(out.stroke, 'field') || symbolStrokeColor) {\n      // For others, remove stroke field\n      delete out.stroke;\n    } else if (isArray(out.stroke)) {\n      const stroke = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled ? markDef.color : undefined);\n      if (stroke) {\n        out.stroke = {\n          value: stroke\n        };\n      }\n    }\n  }\n  if (channel !== OPACITY) {\n    const condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);\n    if (condition) {\n      out.opacity = [{\n        test: condition,\n        ...signalOrValueRef(opacity ?? 1)\n      }, signalOrValueRef(config.legend.unselectedOpacity)];\n    } else if (opacity) {\n      out.opacity = signalOrValueRef(opacity);\n    }\n  }\n  out = {\n    ...out,\n    ...symbolsSpec\n  };\n  return isEmpty(out) ? undefined : out;\n}\nexport function gradient(gradientSpec, _ref2) {\n  let {\n    model,\n    legendType,\n    legendCmpt\n  } = _ref2;\n  if (legendType !== 'gradient') {\n    return undefined;\n  }\n  const {\n    config,\n    markDef,\n    encoding\n  } = model;\n  let out = {};\n  const gradientOpacity = legendCmpt.get('gradientOpacity') ?? config.legend.gradientOpacity;\n  const opacity = gradientOpacity === undefined ? getMaxValue(encoding.opacity) || markDef.opacity : undefined;\n  if (opacity) {\n    // only apply opacity if it is neither zero or undefined\n    out.opacity = signalOrValueRef(opacity);\n  }\n  out = {\n    ...out,\n    ...gradientSpec\n  };\n  return isEmpty(out) ? undefined : out;\n}\nexport function labels(specifiedlabelsSpec, _ref3) {\n  let {\n    fieldOrDatumDef,\n    model,\n    channel,\n    legendCmpt\n  } = _ref3;\n  const legend = model.legend(channel) || {};\n  const config = model.config;\n  const condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : undefined;\n  const opacity = condition ? [{\n    test: condition,\n    value: 1\n  }, {\n    value: config.legend.unselectedOpacity\n  }] : undefined;\n  const {\n    format,\n    formatType\n  } = legend;\n  let text = undefined;\n  if (isCustomFormatType(formatType)) {\n    text = formatCustomType({\n      fieldOrDatumDef,\n      field: 'datum.value',\n      format,\n      formatType,\n      config\n    });\n  } else if (format === undefined && formatType === undefined && config.customFormatTypes) {\n    if (fieldOrDatumDef.type === 'quantitative' && config.numberFormatType) {\n      text = formatCustomType({\n        fieldOrDatumDef,\n        field: 'datum.value',\n        format: config.numberFormat,\n        formatType: config.numberFormatType,\n        config\n      });\n    } else if (fieldOrDatumDef.type === 'temporal' && config.timeFormatType && isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit === undefined) {\n      text = formatCustomType({\n        fieldOrDatumDef,\n        field: 'datum.value',\n        format: config.timeFormat,\n        formatType: config.timeFormatType,\n        config\n      });\n    }\n  }\n  const labelsSpec = {\n    ...(opacity ? {\n      opacity\n    } : {}),\n    ...(text ? {\n      text\n    } : {}),\n    ...specifiedlabelsSpec\n  };\n  return isEmpty(labelsSpec) ? undefined : labelsSpec;\n}\nexport function entries(entriesSpec, _ref4) {\n  let {\n    legendCmpt\n  } = _ref4;\n  const selections = legendCmpt.get('selections');\n  return selections?.length ? {\n    ...entriesSpec,\n    fill: {\n      value: 'transparent'\n    }\n  } : entriesSpec;\n}\nfunction getMaxValue(channelDef) {\n  return getConditionValue(channelDef, (v, conditionalDef) => Math.max(v, conditionalDef.value));\n}\nexport function getFirstConditionValue(channelDef) {\n  return getConditionValue(channelDef, (v, conditionalDef) => {\n    return getFirstDefined(v, conditionalDef.value);\n  });\n}\nfunction getConditionValue(channelDef, reducer) {\n  if (hasConditionalValueDef(channelDef)) {\n    return array(channelDef.condition).reduce(reducer, channelDef.value);\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value;\n  }\n  return undefined;\n}\nfunction selectedCondition(model, legendCmpt, fieldDef) {\n  const selections = legendCmpt.get('selections');\n  if (!selections?.length) return undefined;\n  const field = stringValue(fieldDef.field);\n  return selections.map(name => {\n    const store = stringValue(varName(name) + STORE);\n    return `(!length(data(${store})) || (${name}[${field}] && indexof(${name}[${field}], datum.value) >= 0))`;\n  }).join(' || ');\n}","map":{"version":3,"names":["array","isArray","stringValue","COLOR","OPACITY","hasConditionalValueDef","isFieldDef","isValueDef","FILL_STROKE_CONFIG","getFirstDefined","hasProperty","isEmpty","varName","applyMarkConfig","signalOrValueRef","formatCustomType","isCustomFormatType","mixins","STORE","legendEncodeRules","symbols","gradient","labels","entries","symbolsSpec","_ref","fieldOrDatumDef","model","channel","legendCmpt","legendType","undefined","markDef","encoding","config","mark","filled","out","color","symbolOpacity","get","legend","symbolFillColor","symbolStrokeColor","opacity","getMaxValue","fill","symbolBaseFillColor","fillOpacity","getFirstConditionValue","stroke","value","condition","selectedCondition","test","unselectedOpacity","gradientSpec","_ref2","gradientOpacity","specifiedlabelsSpec","_ref3","format","formatType","text","field","customFormatTypes","type","numberFormatType","numberFormat","timeFormatType","timeUnit","timeFormat","labelsSpec","entriesSpec","_ref4","selections","length","channelDef","getConditionValue","v","conditionalDef","Math","max","reducer","reduce","fieldDef","map","name","store","join"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\legend\\encode.ts"],"sourcesContent":["import {ColorValueRef, EncodeEntry, Gradient, LegendEncode, LegendType, SignalRef, SymbolEncodeEntry} from 'vega';\nimport {array, isArray, stringValue} from 'vega-util';\nimport {COLOR, NonPositionScaleChannel, OPACITY} from '../../channel';\nimport {\n  Conditional,\n  DatumDef,\n  hasConditionalValueDef,\n  isFieldDef,\n  isValueDef,\n  TypedFieldDef,\n  Value,\n  ValueDef\n} from '../../channeldef';\nimport {Encoding} from '../../encoding';\nimport {FILL_STROKE_CONFIG} from '../../mark';\nimport {getFirstDefined, hasProperty, isEmpty, varName} from '../../util';\nimport {applyMarkConfig, signalOrValueRef} from '../common';\nimport {formatCustomType, isCustomFormatType} from '../format';\nimport * as mixins from '../mark/encode';\nimport {STORE} from '../selection';\nimport {UnitModel} from '../unit';\nimport {LegendComponent} from './component';\n\nexport interface LegendEncodeParams {\n  fieldOrDatumDef: TypedFieldDef<string> | DatumDef;\n  model: UnitModel;\n  channel: NonPositionScaleChannel;\n  legendCmpt: LegendComponent;\n  legendType: LegendType;\n}\n\nexport const legendEncodeRules: {\n  [part in keyof LegendEncode]?: (spec: EncodeEntry, params: LegendEncodeParams) => EncodeEntry;\n} = {\n  symbols,\n  gradient,\n  labels,\n  entries\n};\n\nexport function symbols(\n  symbolsSpec: any,\n  {fieldOrDatumDef, model, channel, legendCmpt, legendType}: LegendEncodeParams\n): SymbolEncodeEntry {\n  if (legendType !== 'symbol') {\n    return undefined;\n  }\n\n  const {markDef, encoding, config, mark} = model;\n  const filled = markDef.filled && mark !== 'trail';\n\n  let out = {\n    ...applyMarkConfig({}, model, FILL_STROKE_CONFIG),\n    ...mixins.color(model, {filled})\n  } as SymbolEncodeEntry; // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n\n  const symbolOpacity = legendCmpt.get('symbolOpacity') ?? config.legend.symbolOpacity;\n  const symbolFillColor = legendCmpt.get('symbolFillColor') ?? config.legend.symbolFillColor;\n  const symbolStrokeColor = legendCmpt.get('symbolStrokeColor') ?? config.legend.symbolStrokeColor;\n\n  const opacity = symbolOpacity === undefined ? (getMaxValue(encoding.opacity) ?? markDef.opacity) : undefined;\n\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || (filled && channel === COLOR)) {\n      delete out.fill;\n    } else if (hasProperty(out.fill, 'field')) {\n      // For others, set fill to some opaque value (or nothing if a color is already set)\n      if (symbolFillColor) {\n        delete out.fill;\n      } else {\n        out.fill = signalOrValueRef(config.legend.symbolBaseFillColor ?? 'black');\n        out.fillOpacity = signalOrValueRef(opacity ?? 1);\n      }\n    } else if (isArray(out.fill)) {\n      const fill = getFirstConditionValue(encoding.fill ?? encoding.color) ?? markDef.fill ?? (filled && markDef.color);\n      if (fill) {\n        out.fill = signalOrValueRef(fill) as ColorValueRef;\n      }\n    }\n  }\n\n  if (out.stroke) {\n    if (channel === 'stroke' || (!filled && channel === COLOR)) {\n      delete out.stroke;\n    } else if (hasProperty(out.stroke, 'field') || symbolStrokeColor) {\n      // For others, remove stroke field\n      delete out.stroke;\n    } else if (isArray(out.stroke)) {\n      const stroke = getFirstDefined<string | Gradient | SignalRef>(\n        getFirstConditionValue<string | Gradient>(encoding.stroke || encoding.color),\n        markDef.stroke,\n        filled ? markDef.color : undefined\n      );\n      if (stroke) {\n        out.stroke = {value: stroke} as ColorValueRef;\n      }\n    }\n  }\n\n  if (channel !== OPACITY) {\n    const condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);\n\n    if (condition) {\n      out.opacity = [\n        {test: condition, ...signalOrValueRef(opacity ?? 1)},\n        signalOrValueRef(config.legend.unselectedOpacity)\n      ];\n    } else if (opacity) {\n      out.opacity = signalOrValueRef(opacity);\n    }\n  }\n\n  out = {...out, ...symbolsSpec};\n\n  return isEmpty(out) ? undefined : out;\n}\n\nexport function gradient(gradientSpec: any, {model, legendType, legendCmpt}: LegendEncodeParams) {\n  if (legendType !== 'gradient') {\n    return undefined;\n  }\n\n  const {config, markDef, encoding} = model;\n\n  let out: SymbolEncodeEntry = {};\n\n  const gradientOpacity = legendCmpt.get('gradientOpacity') ?? config.legend.gradientOpacity;\n  const opacity = gradientOpacity === undefined ? getMaxValue(encoding.opacity) || markDef.opacity : undefined;\n  if (opacity) {\n    // only apply opacity if it is neither zero or undefined\n    out.opacity = signalOrValueRef(opacity);\n  }\n\n  out = {...out, ...gradientSpec};\n  return isEmpty(out) ? undefined : out;\n}\n\nexport function labels(specifiedlabelsSpec: any, {fieldOrDatumDef, model, channel, legendCmpt}: LegendEncodeParams) {\n  const legend = model.legend(channel) || {};\n  const config = model.config;\n\n  const condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : undefined;\n  const opacity = condition ? [{test: condition, value: 1}, {value: config.legend.unselectedOpacity}] : undefined;\n\n  const {format, formatType} = legend;\n\n  let text = undefined;\n\n  if (isCustomFormatType(formatType)) {\n    text = formatCustomType({\n      fieldOrDatumDef,\n      field: 'datum.value',\n      format,\n      formatType,\n      config\n    });\n  } else if (format === undefined && formatType === undefined && config.customFormatTypes) {\n    if (fieldOrDatumDef.type === 'quantitative' && config.numberFormatType) {\n      text = formatCustomType({\n        fieldOrDatumDef,\n        field: 'datum.value',\n        format: config.numberFormat,\n        formatType: config.numberFormatType,\n        config\n      });\n    } else if (\n      fieldOrDatumDef.type === 'temporal' &&\n      config.timeFormatType &&\n      isFieldDef(fieldOrDatumDef) &&\n      fieldOrDatumDef.timeUnit === undefined\n    ) {\n      text = formatCustomType({\n        fieldOrDatumDef,\n        field: 'datum.value',\n        format: config.timeFormat,\n        formatType: config.timeFormatType,\n        config\n      });\n    }\n  }\n\n  const labelsSpec = {\n    ...(opacity ? {opacity} : {}),\n    ...(text ? {text} : {}),\n    ...specifiedlabelsSpec\n  };\n\n  return isEmpty(labelsSpec) ? undefined : labelsSpec;\n}\n\nexport function entries(entriesSpec: any, {legendCmpt}: LegendEncodeParams) {\n  const selections = legendCmpt.get('selections');\n  return selections?.length ? {...entriesSpec, fill: {value: 'transparent'}} : entriesSpec;\n}\n\nfunction getMaxValue(channelDef: Encoding<string>['opacity']) {\n  return getConditionValue<number>(channelDef, (v: number, conditionalDef) => Math.max(v, conditionalDef.value as any));\n}\n\nexport function getFirstConditionValue<V extends Value | Gradient>(\n  channelDef: Encoding<string>['fill' | 'stroke' | 'shape']\n): V {\n  return getConditionValue<V>(channelDef, (v: V, conditionalDef: Conditional<ValueDef<V>>) => {\n    return getFirstDefined<V>(v, conditionalDef.value);\n  });\n}\n\nfunction getConditionValue<V extends Value | Gradient>(\n  channelDef: Encoding<string>['fill' | 'stroke' | 'shape' | 'opacity'],\n  reducer: (val: V, conditionalDef: Conditional<ValueDef<V>>) => V\n): V {\n  if (hasConditionalValueDef(channelDef)) {\n    return array(channelDef.condition).reduce(reducer, channelDef.value as any);\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value as any;\n  }\n  return undefined;\n}\n\nfunction selectedCondition(model: UnitModel, legendCmpt: LegendComponent, fieldDef: TypedFieldDef<string>) {\n  const selections = legendCmpt.get('selections');\n  if (!selections?.length) return undefined;\n\n  const field = stringValue(fieldDef.field);\n  return selections\n    .map(name => {\n      const store = stringValue(varName(name) + STORE);\n      return `(!length(data(${store})) || (${name}[${field}] && indexof(${name}[${field}], datum.value) >= 0))`;\n    })\n    .join(' || ');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}