{"ast":null,"code":"import { isArray, isString } from 'vega-util';\nimport { isSelectionParameter } from '../selection';\nimport { isUnitSpec } from '../spec';\nimport { SpecMapper } from '../spec/map';\nexport class TopLevelSelectionsNormalizer extends SpecMapper {\n  map(spec, normParams) {\n    const selections = normParams.selections ?? [];\n    if (spec.params && !isUnitSpec(spec)) {\n      const params = [];\n      for (const param of spec.params) {\n        if (isSelectionParameter(param)) {\n          selections.push(param);\n        } else {\n          params.push(param);\n        }\n      }\n      spec.params = params;\n    }\n    normParams.selections = selections;\n    return super.map(spec, normParams);\n  }\n  mapUnit(spec, normParams) {\n    const selections = normParams.selections;\n    if (!selections || !selections.length) return spec;\n    const path = (normParams.path ?? []).concat(spec.name);\n    const params = [];\n    for (const selection of selections) {\n      // By default, apply selections to all unit views.\n      if (!selection.views || !selection.views.length) {\n        params.push(selection);\n      } else {\n        for (const view of selection.views) {\n          // view is either a specific unit name, or a partial path through the spec tree.\n          if (isString(view) && (view === spec.name || path.includes(view)) || isArray(view) &&\n          // logic for backwards compatibility with view paths before we had unique names\n          // @ts-ignore\n          view.map(v => path.indexOf(v)).every((v, i, arr) => v !== -1 && (i === 0 || v > arr[i - 1]))) {\n            params.push(selection);\n          }\n        }\n      }\n    }\n    if (params.length) spec.params = params;\n    return spec;\n  }\n}\nfor (const method of ['mapFacet', 'mapRepeat', 'mapHConcat', 'mapVConcat', 'mapLayer']) {\n  const proto = TopLevelSelectionsNormalizer.prototype[method];\n  TopLevelSelectionsNormalizer.prototype[method] = function (spec, params) {\n    return proto.call(this, spec, addSpecNameToParams(spec, params));\n  };\n}\nfunction addSpecNameToParams(spec, params) {\n  return spec.name ? {\n    ...params,\n    path: (params.path ?? []).concat(spec.name)\n  } : params;\n}","map":{"version":3,"names":["isArray","isString","isSelectionParameter","isUnitSpec","SpecMapper","TopLevelSelectionsNormalizer","map","spec","normParams","selections","params","param","push","mapUnit","length","path","concat","name","selection","views","view","includes","v","indexOf","every","i","arr","method","proto","prototype","call","addSpecNameToParams"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\normalize\\toplevelselection.ts"],"sourcesContent":["import {isArray, isString} from 'vega-util';\nimport {Field} from '../channeldef';\nimport {VariableParameter} from '../parameter';\nimport {isSelectionParameter, SelectionParameter} from '../selection';\nimport {\n  BaseSpec,\n  isUnitSpec,\n  NormalizedLayerSpec,\n  NormalizedSpec,\n  NormalizedUnitSpec,\n  TopLevel,\n  UnitSpec\n} from '../spec';\nimport {SpecMapper} from '../spec/map';\nimport {NormalizerParams} from './base';\n\nexport class TopLevelSelectionsNormalizer extends SpecMapper<NormalizerParams, NormalizedUnitSpec> {\n  public map(spec: TopLevel<NormalizedSpec>, normParams: NormalizerParams): TopLevel<NormalizedSpec> {\n    const selections = normParams.selections ?? [];\n    if (spec.params && !isUnitSpec(spec)) {\n      const params: VariableParameter[] = [];\n      for (const param of spec.params) {\n        if (isSelectionParameter(param)) {\n          selections.push(param);\n        } else {\n          params.push(param);\n        }\n      }\n\n      spec.params = params;\n    }\n\n    normParams.selections = selections;\n    return super.map(spec, normParams);\n  }\n\n  public mapUnit(spec: UnitSpec<Field>, normParams: NormalizerParams): NormalizedUnitSpec | NormalizedLayerSpec {\n    const selections = normParams.selections;\n    if (!selections || !selections.length) return spec as NormalizedUnitSpec;\n\n    const path = (normParams.path ?? []).concat(spec.name);\n    const params: SelectionParameter[] = [];\n\n    for (const selection of selections) {\n      // By default, apply selections to all unit views.\n      if (!selection.views || !selection.views.length) {\n        params.push(selection);\n      } else {\n        for (const view of selection.views) {\n          // view is either a specific unit name, or a partial path through the spec tree.\n          if (\n            (isString(view) && (view === spec.name || path.includes(view))) ||\n            (isArray(view) &&\n              // logic for backwards compatibility with view paths before we had unique names\n              // @ts-ignore\n              view.map(v => path.indexOf(v)).every((v, i, arr) => v !== -1 && (i === 0 || v > arr[i - 1])))\n          ) {\n            params.push(selection);\n          }\n        }\n      }\n    }\n\n    if (params.length) spec.params = params;\n    return spec as NormalizedUnitSpec;\n  }\n}\n\nfor (const method of ['mapFacet', 'mapRepeat', 'mapHConcat', 'mapVConcat', 'mapLayer'] as const) {\n  const proto = TopLevelSelectionsNormalizer.prototype[method];\n  TopLevelSelectionsNormalizer.prototype[method] = function (spec: BaseSpec, params: NormalizerParams) {\n    return proto.call(this, spec, addSpecNameToParams(spec, params));\n  };\n}\n\nfunction addSpecNameToParams(spec: BaseSpec, params: NormalizerParams) {\n  return spec.name\n    ? {\n        ...params,\n        path: (params.path ?? []).concat(spec.name)\n      }\n    : params;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}