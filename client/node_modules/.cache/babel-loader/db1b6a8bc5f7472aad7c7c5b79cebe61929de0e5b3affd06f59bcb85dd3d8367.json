{"ast":null,"code":"import { isArray, isObject } from 'vega-util';\nimport { isBinned, isBinning } from '../../bin';\nimport { X } from '../../channel';\nimport { isDiscrete, isFieldDef, toFieldDefBase, valueArray } from '../../channeldef';\nimport { hasDiscreteDomain } from '../../scale';\nimport { durationExpr, normalizeTimeUnit } from '../../timeunit';\nimport { NOMINAL, ORDINAL } from '../../type';\nimport { contains, normalizeAngle } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeTitle, mergeTitleFieldDefs } from '../common';\nimport { getAxisConfig } from './config';\nexport const axisRules = {\n  scale: _ref => {\n    let {\n      model,\n      channel\n    } = _ref;\n    return model.scaleName(channel);\n  },\n  format: _ref2 => {\n    let {\n      format\n    } = _ref2;\n    return format;\n  },\n  // we already calculate this in parse\n  formatType: _ref3 => {\n    let {\n      formatType\n    } = _ref3;\n    return formatType;\n  },\n  // we already calculate this in parse\n  grid: _ref4 => {\n    let {\n      fieldOrDatumDef,\n      axis,\n      scaleType\n    } = _ref4;\n    return axis.grid ?? defaultGrid(scaleType, fieldOrDatumDef);\n  },\n  gridScale: _ref5 => {\n    let {\n      model,\n      channel\n    } = _ref5;\n    return gridScale(model, channel);\n  },\n  labelAlign: _ref6 => {\n    let {\n      axis,\n      labelAngle,\n      orient,\n      channel\n    } = _ref6;\n    return axis.labelAlign || defaultLabelAlign(labelAngle, orient, channel);\n  },\n  labelAngle: _ref7 => {\n    let {\n      labelAngle\n    } = _ref7;\n    return labelAngle;\n  },\n  // we already calculate this in parse\n  labelBaseline: _ref8 => {\n    let {\n      axis,\n      labelAngle,\n      orient,\n      channel\n    } = _ref8;\n    return axis.labelBaseline || defaultLabelBaseline(labelAngle, orient, channel);\n  },\n  labelFlush: _ref9 => {\n    let {\n      axis,\n      fieldOrDatumDef,\n      channel\n    } = _ref9;\n    return axis.labelFlush ?? defaultLabelFlush(fieldOrDatumDef.type, channel);\n  },\n  labelOverlap: _ref10 => {\n    let {\n      axis,\n      fieldOrDatumDef,\n      scaleType\n    } = _ref10;\n    return axis.labelOverlap ?? defaultLabelOverlap(fieldOrDatumDef.type, scaleType, isFieldDef(fieldOrDatumDef) && !!fieldOrDatumDef.timeUnit, isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined);\n  },\n  // we already calculate orient in parse\n  orient: _ref11 => {\n    let {\n      orient\n    } = _ref11;\n    return orient;\n  },\n  // Need to cast until Vega supports signal\n  tickCount: _ref12 => {\n    let {\n      channel,\n      model,\n      axis,\n      fieldOrDatumDef,\n      scaleType\n    } = _ref12;\n    const sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n    const size = sizeType ? model.getSizeSignalRef(sizeType) : undefined;\n    return axis.tickCount ?? defaultTickCount({\n      fieldOrDatumDef,\n      scaleType,\n      size,\n      values: axis.values\n    });\n  },\n  tickMinStep: defaultTickMinStep,\n  title: _ref13 => {\n    let {\n      axis,\n      model,\n      channel\n    } = _ref13;\n    if (axis.title !== undefined) {\n      return axis.title;\n    }\n    const fieldDefTitle = getFieldDefTitle(model, channel);\n    if (fieldDefTitle !== undefined) {\n      return fieldDefTitle;\n    }\n    const fieldDef = model.typedFieldDef(channel);\n    const channel2 = channel === 'x' ? 'x2' : 'y2';\n    const fieldDef2 = model.fieldDef(channel2);\n    // If title not specified, store base parts of fieldDef (and fieldDef2 if exists)\n    return mergeTitleFieldDefs(fieldDef ? [toFieldDefBase(fieldDef)] : [], isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []);\n  },\n  values: _ref14 => {\n    let {\n      axis,\n      fieldOrDatumDef\n    } = _ref14;\n    return values(axis, fieldOrDatumDef);\n  },\n  zindex: _ref15 => {\n    let {\n      axis,\n      fieldOrDatumDef,\n      mark\n    } = _ref15;\n    return axis.zindex ?? defaultZindex(mark, fieldOrDatumDef);\n  }\n};\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\nexport function defaultGrid(scaleType, fieldDef) {\n  return !hasDiscreteDomain(scaleType) && isFieldDef(fieldDef) && !isBinning(fieldDef?.bin) && !isBinned(fieldDef?.bin);\n}\nexport function gridScale(model, channel) {\n  const gridChannel = channel === 'x' ? 'y' : 'x';\n  if (model.getScaleComponent(gridChannel)) {\n    return model.scaleName(gridChannel);\n  }\n  return undefined;\n}\nexport function getLabelAngle(fieldOrDatumDef, axis, channel, styleConfig, axisConfigs) {\n  const labelAngle = axis?.labelAngle;\n  // try axis value\n  if (labelAngle !== undefined) {\n    return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);\n  } else {\n    // try axis config value\n    const {\n      configValue: angle\n    } = getAxisConfig('labelAngle', styleConfig, axis?.style, axisConfigs);\n    if (angle !== undefined) {\n      return normalizeAngle(angle);\n    } else {\n      // get default value\n      if (channel === X && contains([NOMINAL, ORDINAL], fieldOrDatumDef.type) && !(isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit)) {\n        return 270;\n      }\n      // no default\n      return undefined;\n    }\n  }\n}\nexport function normalizeAngleExpr(angle) {\n  return `(((${angle.signal} % 360) + 360) % 360)`;\n}\nexport function defaultLabelBaseline(angle, orient, channel, alwaysIncludeMiddle) {\n  if (angle !== undefined) {\n    if (channel === 'x') {\n      if (isSignalRef(angle)) {\n        const a = normalizeAngleExpr(angle);\n        const orientIsTop = isSignalRef(orient) ? `(${orient.signal} === \"top\")` : orient === 'top';\n        return {\n          signal: `(45 < ${a} && ${a} < 135) || (225 < ${a} && ${a} < 315) ? \"middle\" :` + `(${a} <= 45 || 315 <= ${a}) === ${orientIsTop} ? \"bottom\" : \"top\"`\n        };\n      }\n      if (45 < angle && angle < 135 || 225 < angle && angle < 315) {\n        return 'middle';\n      }\n      if (isSignalRef(orient)) {\n        const op = angle <= 45 || 315 <= angle ? '===' : '!==';\n        return {\n          signal: `${orient.signal} ${op} \"top\" ? \"bottom\" : \"top\"`\n        };\n      }\n      return (angle <= 45 || 315 <= angle) === (orient === 'top') ? 'bottom' : 'top';\n    } else {\n      if (isSignalRef(angle)) {\n        const a = normalizeAngleExpr(angle);\n        const orientIsLeft = isSignalRef(orient) ? `(${orient.signal} === \"left\")` : orient === 'left';\n        const middle = alwaysIncludeMiddle ? '\"middle\"' : 'null';\n        return {\n          signal: `${a} <= 45 || 315 <= ${a} || (135 <= ${a} && ${a} <= 225) ? ${middle} : (45 <= ${a} && ${a} <= 135) === ${orientIsLeft} ? \"top\" : \"bottom\"`\n        };\n      }\n      if (angle <= 45 || 315 <= angle || 135 <= angle && angle <= 225) {\n        return alwaysIncludeMiddle ? 'middle' : null;\n      }\n      if (isSignalRef(orient)) {\n        const op = 45 <= angle && angle <= 135 ? '===' : '!==';\n        return {\n          signal: `${orient.signal} ${op} \"left\" ? \"top\" : \"bottom\"`\n        };\n      }\n      return (45 <= angle && angle <= 135) === (orient === 'left') ? 'top' : 'bottom';\n    }\n  }\n  return undefined;\n}\nexport function defaultLabelAlign(angle, orient, channel) {\n  if (angle === undefined) {\n    return undefined;\n  }\n  const isX = channel === 'x';\n  const startAngle = isX ? 0 : 90;\n  const mainOrient = isX ? 'bottom' : 'left';\n  if (isSignalRef(angle)) {\n    const a = normalizeAngleExpr(angle);\n    const orientIsMain = isSignalRef(orient) ? `(${orient.signal} === \"${mainOrient}\")` : orient === mainOrient;\n    return {\n      signal: `(${startAngle ? `(${a} + 90)` : a} % 180 === 0) ? ${isX ? null : '\"center\"'} :` + `(${startAngle} < ${a} && ${a} < ${180 + startAngle}) === ${orientIsMain} ? \"left\" : \"right\"`\n    };\n  }\n  if ((angle + startAngle) % 180 === 0) {\n    // For bottom, use default label align so label flush still works\n    return isX ? null : 'center';\n  }\n  if (isSignalRef(orient)) {\n    const op = startAngle < angle && angle < 180 + startAngle ? '===' : '!==';\n    const orientIsMain = `${orient.signal} ${op} \"${mainOrient}\"`;\n    return {\n      signal: `${orientIsMain} ? \"left\" : \"right\"`\n    };\n  }\n  if ((startAngle < angle && angle < 180 + startAngle) === (orient === mainOrient)) {\n    return 'left';\n  }\n  return 'right';\n}\nexport function defaultLabelFlush(type, channel) {\n  if (channel === 'x' && contains(['quantitative', 'temporal'], type)) {\n    return true;\n  }\n  return undefined;\n}\nexport function defaultLabelOverlap(type, scaleType, hasTimeUnit, sort) {\n  // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n  if (hasTimeUnit && !isObject(sort) || type !== 'nominal' && type !== 'ordinal') {\n    if (scaleType === 'log' || scaleType === 'symlog') {\n      return 'greedy';\n    }\n    return true;\n  }\n  return undefined;\n}\nexport function defaultOrient(channel) {\n  return channel === 'x' ? 'bottom' : 'left';\n}\nexport function defaultTickCount(_ref16) {\n  let {\n    fieldOrDatumDef,\n    scaleType,\n    size,\n    values: vals\n  } = _ref16;\n  if (!vals && !hasDiscreteDomain(scaleType) && scaleType !== 'log') {\n    if (isFieldDef(fieldOrDatumDef)) {\n      if (isBinning(fieldOrDatumDef.bin)) {\n        // for binned data, we don't want more ticks than maxbins\n        return {\n          signal: `ceil(${size.signal}/10)`\n        };\n      }\n      if (fieldOrDatumDef.timeUnit && contains(['month', 'hours', 'day', 'quarter'], normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit)) {\n        return undefined;\n      }\n    }\n    return {\n      signal: `ceil(${size.signal}/40)`\n    };\n  }\n  return undefined;\n}\nexport function defaultTickMinStep(_ref17) {\n  let {\n    format,\n    fieldOrDatumDef\n  } = _ref17;\n  if (format === 'd') {\n    return 1;\n  }\n  if (isFieldDef(fieldOrDatumDef)) {\n    const {\n      timeUnit\n    } = fieldOrDatumDef;\n    if (timeUnit) {\n      const signal = durationExpr(timeUnit);\n      if (signal) {\n        return {\n          signal\n        };\n      }\n    }\n  }\n  return undefined;\n}\nexport function getFieldDefTitle(model, channel) {\n  const channel2 = channel === 'x' ? 'x2' : 'y2';\n  const fieldDef = model.fieldDef(channel);\n  const fieldDef2 = model.fieldDef(channel2);\n  const title1 = fieldDef ? fieldDef.title : undefined;\n  const title2 = fieldDef2 ? fieldDef2.title : undefined;\n  if (title1 && title2) {\n    return mergeTitle(title1, title2);\n  } else if (title1) {\n    return title1;\n  } else if (title2) {\n    return title2;\n  } else if (title1 !== undefined) {\n    // falsy value to disable config\n    return title1;\n  } else if (title2 !== undefined) {\n    // falsy value to disable config\n    return title2;\n  }\n  return undefined;\n}\nexport function values(axis, fieldOrDatumDef) {\n  const vals = axis.values;\n  if (isArray(vals)) {\n    return valueArray(fieldOrDatumDef, vals);\n  } else if (isSignalRef(vals)) {\n    return vals;\n  }\n  return undefined;\n}\nexport function defaultZindex(mark, fieldDef) {\n  if (mark === 'rect' && isDiscrete(fieldDef)) {\n    return 1;\n  }\n  return 0;\n}","map":{"version":3,"names":["isArray","isObject","isBinned","isBinning","X","isDiscrete","isFieldDef","toFieldDefBase","valueArray","hasDiscreteDomain","durationExpr","normalizeTimeUnit","NOMINAL","ORDINAL","contains","normalizeAngle","isSignalRef","mergeTitle","mergeTitleFieldDefs","getAxisConfig","axisRules","scale","_ref","model","channel","scaleName","format","_ref2","formatType","_ref3","grid","_ref4","fieldOrDatumDef","axis","scaleType","defaultGrid","gridScale","_ref5","labelAlign","_ref6","labelAngle","orient","defaultLabelAlign","_ref7","labelBaseline","_ref8","defaultLabelBaseline","labelFlush","_ref9","defaultLabelFlush","type","labelOverlap","_ref10","defaultLabelOverlap","timeUnit","sort","undefined","_ref11","tickCount","_ref12","sizeType","size","getSizeSignalRef","defaultTickCount","values","tickMinStep","defaultTickMinStep","title","_ref13","fieldDefTitle","getFieldDefTitle","fieldDef","typedFieldDef","channel2","fieldDef2","_ref14","zindex","_ref15","mark","defaultZindex","bin","gridChannel","getScaleComponent","getLabelAngle","styleConfig","axisConfigs","configValue","angle","style","normalizeAngleExpr","signal","alwaysIncludeMiddle","a","orientIsTop","op","orientIsLeft","middle","isX","startAngle","mainOrient","orientIsMain","hasTimeUnit","defaultOrient","_ref16","vals","unit","_ref17","title1","title2"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\axis\\properties.ts"],"sourcesContent":["import {Align, AxisOrient, Orient, SignalRef} from 'vega';\nimport {isArray, isObject} from 'vega-util';\nimport {AxisInternal} from '../../axis';\nimport {isBinned, isBinning} from '../../bin';\nimport {PositionScaleChannel, X} from '../../channel';\nimport {\n  DatumDef,\n  isDiscrete,\n  isFieldDef,\n  PositionDatumDef,\n  PositionFieldDef,\n  toFieldDefBase,\n  TypedFieldDef,\n  valueArray\n} from '../../channeldef';\nimport {Config, StyleConfigIndex} from '../../config';\nimport {Mark} from '../../mark';\nimport {hasDiscreteDomain} from '../../scale';\nimport {Sort} from '../../sort';\nimport {durationExpr, normalizeTimeUnit} from '../../timeunit';\nimport {NOMINAL, ORDINAL, Type} from '../../type';\nimport {contains, normalizeAngle} from '../../util';\nimport {isSignalRef} from '../../vega.schema';\nimport {mergeTitle, mergeTitleFieldDefs} from '../common';\nimport {guideFormatType} from '../format';\nimport {UnitModel} from '../unit';\nimport {ScaleType} from './../../scale';\nimport {AxisComponentProps} from './component';\nimport {AxisConfigs, getAxisConfig} from './config';\n\nexport interface AxisRuleParams {\n  fieldOrDatumDef: PositionFieldDef<string> | PositionDatumDef<string>;\n  axis: AxisInternal;\n  channel: PositionScaleChannel;\n  model: UnitModel;\n\n  mark: Mark;\n  scaleType: ScaleType;\n  orient: Orient | SignalRef;\n  labelAngle: number | SignalRef;\n  format: string | SignalRef;\n  formatType: ReturnType<typeof guideFormatType>;\n  config: Config;\n}\n\nexport const axisRules: {\n  [k in keyof AxisComponentProps]?: (params: AxisRuleParams) => AxisComponentProps[k];\n} = {\n  scale: ({model, channel}) => model.scaleName(channel),\n\n  format: ({format}) => format, // we already calculate this in parse\n\n  formatType: ({formatType}) => formatType, // we already calculate this in parse\n\n  grid: ({fieldOrDatumDef, axis, scaleType}) => axis.grid ?? defaultGrid(scaleType, fieldOrDatumDef),\n\n  gridScale: ({model, channel}) => gridScale(model, channel),\n\n  labelAlign: ({axis, labelAngle, orient, channel}) =>\n    axis.labelAlign || defaultLabelAlign(labelAngle, orient, channel),\n\n  labelAngle: ({labelAngle}) => labelAngle, // we already calculate this in parse\n\n  labelBaseline: ({axis, labelAngle, orient, channel}) =>\n    axis.labelBaseline || defaultLabelBaseline(labelAngle, orient, channel),\n\n  labelFlush: ({axis, fieldOrDatumDef, channel}) => axis.labelFlush ?? defaultLabelFlush(fieldOrDatumDef.type, channel),\n\n  labelOverlap: ({axis, fieldOrDatumDef, scaleType}) =>\n    axis.labelOverlap ??\n    defaultLabelOverlap(\n      fieldOrDatumDef.type,\n      scaleType,\n      isFieldDef(fieldOrDatumDef) && !!fieldOrDatumDef.timeUnit,\n      isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined\n    ),\n\n  // we already calculate orient in parse\n  orient: ({orient}) => orient as AxisOrient, // Need to cast until Vega supports signal\n\n  tickCount: ({channel, model, axis, fieldOrDatumDef, scaleType}) => {\n    const sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n    const size = sizeType ? model.getSizeSignalRef(sizeType) : undefined;\n    return axis.tickCount ?? defaultTickCount({fieldOrDatumDef, scaleType, size, values: axis.values});\n  },\n\n  tickMinStep: defaultTickMinStep,\n\n  title: ({axis, model, channel}) => {\n    if (axis.title !== undefined) {\n      return axis.title;\n    }\n    const fieldDefTitle = getFieldDefTitle(model, channel);\n    if (fieldDefTitle !== undefined) {\n      return fieldDefTitle;\n    }\n    const fieldDef = model.typedFieldDef(channel);\n    const channel2 = channel === 'x' ? 'x2' : 'y2';\n    const fieldDef2 = model.fieldDef(channel2);\n\n    // If title not specified, store base parts of fieldDef (and fieldDef2 if exists)\n    return mergeTitleFieldDefs(\n      fieldDef ? [toFieldDefBase(fieldDef)] : [],\n      isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []\n    );\n  },\n\n  values: ({axis, fieldOrDatumDef}) => values(axis, fieldOrDatumDef),\n\n  zindex: ({axis, fieldOrDatumDef, mark}) => axis.zindex ?? defaultZindex(mark, fieldOrDatumDef)\n};\n\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\n\nexport function defaultGrid(scaleType: ScaleType, fieldDef: TypedFieldDef<string> | DatumDef) {\n  return !hasDiscreteDomain(scaleType) && isFieldDef(fieldDef) && !isBinning(fieldDef?.bin) && !isBinned(fieldDef?.bin);\n}\n\nexport function gridScale(model: UnitModel, channel: PositionScaleChannel) {\n  const gridChannel: PositionScaleChannel = channel === 'x' ? 'y' : 'x';\n  if (model.getScaleComponent(gridChannel)) {\n    return model.scaleName(gridChannel);\n  }\n  return undefined;\n}\n\nexport function getLabelAngle(\n  fieldOrDatumDef: PositionFieldDef<string> | PositionDatumDef<string>,\n  axis: AxisInternal,\n  channel: PositionScaleChannel,\n  styleConfig: StyleConfigIndex<SignalRef>,\n  axisConfigs?: AxisConfigs\n) {\n  const labelAngle = axis?.labelAngle;\n  // try axis value\n  if (labelAngle !== undefined) {\n    return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);\n  } else {\n    // try axis config value\n    const {configValue: angle} = getAxisConfig('labelAngle', styleConfig, axis?.style, axisConfigs);\n    if (angle !== undefined) {\n      return normalizeAngle(angle);\n    } else {\n      // get default value\n      if (\n        channel === X &&\n        contains([NOMINAL, ORDINAL], fieldOrDatumDef.type) &&\n        !(isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit)\n      ) {\n        return 270;\n      }\n      // no default\n      return undefined;\n    }\n  }\n}\n\nexport function normalizeAngleExpr(angle: SignalRef) {\n  return `(((${angle.signal} % 360) + 360) % 360)`;\n}\n\nexport function defaultLabelBaseline(\n  angle: number | SignalRef,\n  orient: AxisOrient | SignalRef,\n  channel: 'x' | 'y',\n  alwaysIncludeMiddle?: boolean\n) {\n  if (angle !== undefined) {\n    if (channel === 'x') {\n      if (isSignalRef(angle)) {\n        const a = normalizeAngleExpr(angle);\n        const orientIsTop = isSignalRef(orient) ? `(${orient.signal} === \"top\")` : orient === 'top';\n        return {\n          signal:\n            `(45 < ${a} && ${a} < 135) || (225 < ${a} && ${a} < 315) ? \"middle\" :` +\n            `(${a} <= 45 || 315 <= ${a}) === ${orientIsTop} ? \"bottom\" : \"top\"`\n        };\n      }\n\n      if ((45 < angle && angle < 135) || (225 < angle && angle < 315)) {\n        return 'middle';\n      }\n\n      if (isSignalRef(orient)) {\n        const op = angle <= 45 || 315 <= angle ? '===' : '!==';\n        return {signal: `${orient.signal} ${op} \"top\" ? \"bottom\" : \"top\"`};\n      }\n\n      return (angle <= 45 || 315 <= angle) === (orient === 'top') ? 'bottom' : 'top';\n    } else {\n      if (isSignalRef(angle)) {\n        const a = normalizeAngleExpr(angle);\n        const orientIsLeft = isSignalRef(orient) ? `(${orient.signal} === \"left\")` : orient === 'left';\n        const middle = alwaysIncludeMiddle ? '\"middle\"' : 'null';\n        return {\n          signal: `${a} <= 45 || 315 <= ${a} || (135 <= ${a} && ${a} <= 225) ? ${middle} : (45 <= ${a} && ${a} <= 135) === ${orientIsLeft} ? \"top\" : \"bottom\"`\n        };\n      }\n\n      if (angle <= 45 || 315 <= angle || (135 <= angle && angle <= 225)) {\n        return alwaysIncludeMiddle ? 'middle' : null;\n      }\n\n      if (isSignalRef(orient)) {\n        const op = 45 <= angle && angle <= 135 ? '===' : '!==';\n        return {signal: `${orient.signal} ${op} \"left\" ? \"top\" : \"bottom\"`};\n      }\n\n      return (45 <= angle && angle <= 135) === (orient === 'left') ? 'top' : 'bottom';\n    }\n  }\n  return undefined;\n}\n\nexport function defaultLabelAlign(\n  angle: number | SignalRef,\n  orient: AxisOrient | SignalRef,\n  channel: 'x' | 'y'\n): Align | SignalRef {\n  if (angle === undefined) {\n    return undefined;\n  }\n\n  const isX = channel === 'x';\n  const startAngle = isX ? 0 : 90;\n  const mainOrient = isX ? 'bottom' : 'left';\n\n  if (isSignalRef(angle)) {\n    const a = normalizeAngleExpr(angle);\n    const orientIsMain = isSignalRef(orient) ? `(${orient.signal} === \"${mainOrient}\")` : orient === mainOrient;\n    return {\n      signal:\n        `(${startAngle ? `(${a} + 90)` : a} % 180 === 0) ? ${isX ? null : '\"center\"'} :` +\n        `(${startAngle} < ${a} && ${a} < ${180 + startAngle}) === ${orientIsMain} ? \"left\" : \"right\"`\n    };\n  }\n\n  if ((angle + startAngle) % 180 === 0) {\n    // For bottom, use default label align so label flush still works\n    return isX ? null : 'center';\n  }\n\n  if (isSignalRef(orient)) {\n    const op = startAngle < angle && angle < 180 + startAngle ? '===' : '!==';\n    const orientIsMain = `${orient.signal} ${op} \"${mainOrient}\"`;\n    return {\n      signal: `${orientIsMain} ? \"left\" : \"right\"`\n    };\n  }\n\n  if ((startAngle < angle && angle < 180 + startAngle) === (orient === mainOrient)) {\n    return 'left';\n  }\n\n  return 'right';\n}\n\nexport function defaultLabelFlush(type: Type, channel: PositionScaleChannel) {\n  if (channel === 'x' && contains(['quantitative', 'temporal'], type)) {\n    return true;\n  }\n  return undefined;\n}\n\nexport function defaultLabelOverlap(type: Type, scaleType: ScaleType, hasTimeUnit: boolean, sort?: Sort<string>) {\n  // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n  if ((hasTimeUnit && !isObject(sort)) || (type !== 'nominal' && type !== 'ordinal')) {\n    if (scaleType === 'log' || scaleType === 'symlog') {\n      return 'greedy';\n    }\n    return true;\n  }\n  return undefined;\n}\n\nexport function defaultOrient(channel: PositionScaleChannel) {\n  return channel === 'x' ? 'bottom' : 'left';\n}\n\nexport function defaultTickCount({\n  fieldOrDatumDef,\n  scaleType,\n  size,\n  values: vals\n}: {\n  fieldOrDatumDef: TypedFieldDef<string> | DatumDef;\n  scaleType: ScaleType;\n  size?: SignalRef;\n  values?: AxisInternal['values'];\n}) {\n  if (!vals && !hasDiscreteDomain(scaleType) && scaleType !== 'log') {\n    if (isFieldDef(fieldOrDatumDef)) {\n      if (isBinning(fieldOrDatumDef.bin)) {\n        // for binned data, we don't want more ticks than maxbins\n        return {signal: `ceil(${size.signal}/10)`};\n      }\n\n      if (\n        fieldOrDatumDef.timeUnit &&\n        contains(['month', 'hours', 'day', 'quarter'], normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit)\n      ) {\n        return undefined;\n      }\n    }\n\n    return {signal: `ceil(${size.signal}/40)`};\n  }\n\n  return undefined;\n}\n\nexport function defaultTickMinStep({format, fieldOrDatumDef}: Pick<AxisRuleParams, 'format' | 'fieldOrDatumDef'>) {\n  if (format === 'd') {\n    return 1;\n  }\n\n  if (isFieldDef(fieldOrDatumDef)) {\n    const {timeUnit} = fieldOrDatumDef;\n    if (timeUnit) {\n      const signal = durationExpr(timeUnit);\n      if (signal) {\n        return {signal};\n      }\n    }\n  }\n  return undefined;\n}\n\nexport function getFieldDefTitle(model: UnitModel, channel: 'x' | 'y') {\n  const channel2 = channel === 'x' ? 'x2' : 'y2';\n  const fieldDef = model.fieldDef(channel);\n  const fieldDef2 = model.fieldDef(channel2);\n\n  const title1 = fieldDef ? fieldDef.title : undefined;\n  const title2 = fieldDef2 ? fieldDef2.title : undefined;\n\n  if (title1 && title2) {\n    return mergeTitle(title1, title2);\n  } else if (title1) {\n    return title1;\n  } else if (title2) {\n    return title2;\n  } else if (title1 !== undefined) {\n    // falsy value to disable config\n    return title1;\n  } else if (title2 !== undefined) {\n    // falsy value to disable config\n    return title2;\n  }\n\n  return undefined;\n}\n\nexport function values(axis: AxisInternal, fieldOrDatumDef: TypedFieldDef<string> | DatumDef) {\n  const vals = axis.values;\n\n  if (isArray(vals)) {\n    return valueArray(fieldOrDatumDef, vals);\n  } else if (isSignalRef(vals)) {\n    return vals;\n  }\n\n  return undefined;\n}\n\nexport function defaultZindex(mark: Mark, fieldDef: TypedFieldDef<string> | DatumDef) {\n  if (mark === 'rect' && isDiscrete(fieldDef)) {\n    return 1;\n  }\n  return 0;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}