{"ast":null,"code":"import { Split } from '../split';\n/**\n * Class to track interesting properties (see https://15721.courses.cs.cmu.edu/spring2016/papers/graefe-ieee1995.pdf)\n * about how fields have been parsed or whether they have been derived in a transform. We use this to not parse the\n * same field again (or differently).\n */\nexport class AncestorParse extends Split {\n  constructor() {\n    let explicit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let implicit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let parseNothing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    super(explicit, implicit);\n    this.explicit = explicit;\n    this.implicit = implicit;\n    this.parseNothing = parseNothing;\n  }\n  clone() {\n    const clone = super.clone();\n    clone.parseNothing = this.parseNothing;\n    return clone;\n  }\n}","map":{"version":3,"names":["Split","AncestorParse","constructor","explicit","arguments","length","undefined","implicit","parseNothing","clone"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\data\\index.ts"],"sourcesContent":["import {Parse} from '../../data';\nimport {Dict} from '../../util';\nimport {Split} from '../split';\nimport {OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {SourceNode} from './source';\n\nexport interface DataComponent {\n  /**\n   * A list of unique sources.\n   */\n  sources: SourceNode[];\n\n  /**\n   * Registry of output nodes.\n   */\n  outputNodes: Dict<OutputNode | FacetNode>;\n\n  /**\n   * How often is an output node used. If it is not used, we don't need to\n   * instantiate it in the assemble step.\n   */\n  outputNodeRefCounts: Dict<number>;\n\n  /**\n   * The output node before aggregation.\n   */\n  raw?: OutputNode;\n\n  /**\n   * The output node for scale domain before filter invalid.\n   */\n  preFilterInvalid?: OutputNode;\n\n  /**\n   * The output node for scale domain after filter invalid.\n   */\n  postFilterInvalid?: OutputNode;\n\n  /**\n   * The main output node.\n   */\n  main?: OutputNode;\n\n  /**\n   * For facets, we store the reference to the root node.\n   */\n  facetRoot?: FacetNode;\n\n  /**\n   * True if the data for this model is faceted.\n   * A dataset is faceted if a parent model is a facet and no new dataset is\n   * defined (which would make the data unfaceted again).\n   */\n  isFaceted: boolean;\n\n  /**\n   * Parse properties passed down from ancestors. Helps us to keep track of what has been parsed or is derived.\n   */\n  ancestorParse?: AncestorParse;\n}\n\n/**\n * Class to track interesting properties (see https://15721.courses.cs.cmu.edu/spring2016/papers/graefe-ieee1995.pdf)\n * about how fields have been parsed or whether they have been derived in a transform. We use this to not parse the\n * same field again (or differently).\n */\nexport class AncestorParse extends Split<Parse> {\n  constructor(\n    public readonly explicit: Partial<Parse> = {},\n    public readonly implicit: Partial<Parse> = {},\n    public parseNothing = false\n  ) {\n    super(explicit, implicit);\n  }\n\n  public clone(): AncestorParse {\n    const clone = super.clone() as AncestorParse;\n    clone.parseNothing = this.parseNothing;\n    return clone;\n  }\n}\n"],"mappings":"AAEA,SAAQA,KAAK,QAAO,UAAU;AA4D9B;;;;;AAKA,OAAM,MAAOC,aAAc,SAAQD,KAAY;EAC7CE,YAAA,EAG6B;IAAA,IAFXC,QAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA2B,EAAE;IAAA,IAC7BG,QAAA,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA2B,EAAE;IAAA,IACtCI,YAAA,GAAAJ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAe,KAAK;IAE3B,KAAK,CAACD,QAAQ,EAAEI,QAAQ,CAAC;IAJT,KAAAJ,QAAQ,GAARA,QAAQ;IACR,KAAAI,QAAQ,GAARA,QAAQ;IACjB,KAAAC,YAAY,GAAZA,YAAY;EAGrB;EAEOC,KAAKA,CAAA;IACV,MAAMA,KAAK,GAAG,KAAK,CAACA,KAAK,EAAmB;IAC5CA,KAAK,CAACD,YAAY,GAAG,IAAI,CAACA,YAAY;IACtC,OAAOC,KAAK;EACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}