{"ast":null,"code":"import { isObject } from 'vega';\nimport { array, stringValue } from 'vega-util';\nimport { STORE, TUPLE, unitName } from '.';\nimport { LATITUDE, LONGITUDE, X, Y } from '../../channel';\nimport { warn } from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { SELECTION_ID } from '../../selection';\nimport { keys, vals } from '../../util';\nimport { isUnitModel } from '../model';\nimport { assembleInit } from './assemble';\nimport { TUPLE_FIELDS } from './project';\nimport scales from './scales';\nexport const BRUSH = '_brush';\nexport const SCALE_TRIGGER = '_scale_trigger';\nexport const GEO_INIT_TICK = 'geo_interval_init_tick'; // Workaround for https://github.com/vega/vega/issues/3481\nconst INIT = '_init';\nconst CENTER = '_center';\nconst interval = {\n  defined: selCmpt => selCmpt.type === 'interval',\n  parse: (model, selCmpt, selDef) => {\n    var _a;\n    if (model.hasProjection) {\n      const def = {\n        ...(isObject(selDef.select) ? selDef.select : {})\n      };\n      def.fields = [SELECTION_ID];\n      if (!def.encodings) {\n        // Remap default x/y projection\n        def.encodings = selDef.value ? keys(selDef.value) : [LONGITUDE, LATITUDE];\n      }\n      selDef.select = {\n        type: 'interval',\n        ...def\n      };\n    }\n    if (selCmpt.translate && !scales.defined(selCmpt)) {\n      const filterExpr = `!event.item || event.item.mark.name !== ${stringValue(selCmpt.name + BRUSH)}`;\n      for (const evt of selCmpt.events) {\n        if (!evt.between) {\n          warn(`${evt} is not an ordered event stream for interval selections.`);\n          continue;\n        }\n        const filters = array((_a = evt.between[0]).filter ?? (_a.filter = []));\n        if (!filters.includes(filterExpr)) {\n          filters.push(filterExpr);\n        }\n      }\n    }\n  },\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const tupleSg = name + TUPLE;\n    const channels = vals(selCmpt.project.hasChannel).filter(p => p.channel === X || p.channel === Y);\n    const init = selCmpt.init ? selCmpt.init[0] : null;\n    signals.push(...channels.reduce((arr, proj) => arr.concat(channelSignals(model, selCmpt, proj, init && init[proj.index])), []));\n    if (!model.hasProjection) {\n      // Proxy scale reactions to ensure that an infinite loop doesn't occur\n      // when an interval selection filter touches the scale.\n      if (!scales.defined(selCmpt)) {\n        const triggerSg = name + SCALE_TRIGGER;\n        const scaleTriggers = channels.map(proj => {\n          const channel = proj.channel;\n          const {\n            data: dname,\n            visual: vname\n          } = proj.signals;\n          const scaleName = stringValue(model.scaleName(channel));\n          const scaleType = model.getScaleComponent(channel).get('type');\n          const toNum = hasContinuousDomain(scaleType) ? '+' : '';\n          return `(!isArray(${dname}) || ` + `(${toNum}invert(${scaleName}, ${vname})[0] === ${toNum}${dname}[0] && ` + `${toNum}invert(${scaleName}, ${vname})[1] === ${toNum}${dname}[1]))`;\n        });\n        if (scaleTriggers.length) {\n          signals.push({\n            name: triggerSg,\n            value: {},\n            on: [{\n              events: channels.map(proj => ({\n                scale: model.scaleName(proj.channel)\n              })),\n              update: scaleTriggers.join(' && ') + ` ? ${triggerSg} : {}`\n            }]\n          });\n        }\n      }\n      // Only add an interval to the store if it has valid data extents. Data extents\n      // are set to null if pixel extents are equal to account for intervals over\n      // ordinal/nominal domains which, when inverted, will still produce a valid datum.\n      const dataSignals = channels.map(proj => proj.signals.data);\n      const update = `unit: ${unitName(model)}, fields: ${name + TUPLE_FIELDS}, values`;\n      return signals.concat({\n        name: tupleSg,\n        ...(init ? {\n          init: `{${update}: ${assembleInit(init)}}`\n        } : {}),\n        ...(dataSignals.length ? {\n          on: [{\n            events: [{\n              signal: dataSignals.join(' || ')\n            }],\n            // Prevents double invocation, see https://github.com/vega/vega/issues/1672.\n            update: `${dataSignals.join(' && ')} ? {${update}: [${dataSignals}]} : null`\n          }]\n        } : {})\n      });\n    } else {\n      const projection = stringValue(model.projectionName());\n      const centerSg = model.projectionName() + CENTER;\n      const {\n        x,\n        y\n      } = selCmpt.project.hasChannel;\n      const xvname = x && x.signals.visual;\n      const yvname = y && y.signals.visual;\n      const xinit = x ? init && init[x.index] : `${centerSg}[0]`;\n      const yinit = y ? init && init[y.index] : `${centerSg}[1]`;\n      const sizeSg = layout => model.getSizeSignalRef(layout).signal;\n      const bbox = `[` + `[${xvname ? xvname + '[0]' : '0'}, ${yvname ? yvname + '[0]' : '0'}],` + `[${xvname ? xvname + '[1]' : sizeSg('width')}, ` + `${yvname ? yvname + '[1]' : sizeSg('height')}]` + `]`;\n      if (init) {\n        signals.unshift({\n          name: name + INIT,\n          init: `[scale(${projection}, [${x ? xinit[0] : xinit}, ${y ? yinit[0] : yinit}]), ` + `scale(${projection}, [${x ? xinit[1] : xinit}, ${y ? yinit[1] : yinit}])]`\n        });\n        if (!x || !y) {\n          // If initializing a uni-dimensional brush, use the center of the view to determine the other coord\n          const hasCenterSg = signals.find(s => s.name === centerSg);\n          if (!hasCenterSg) {\n            signals.unshift({\n              name: centerSg,\n              update: `invert(${projection}, [${sizeSg('width')}/2, ${sizeSg('height')}/2])`\n            });\n          }\n        }\n      }\n      const intersect = `intersect(${bbox}, {markname: ${stringValue(model.getName('marks'))}}, unit.mark)`;\n      const base = `{unit: ${unitName(model)}}`;\n      const update = `vlSelectionTuples(${intersect}, ${base})`;\n      const visualSignals = channels.map(proj => proj.signals.visual);\n      return signals.concat({\n        name: tupleSg,\n        on: [{\n          events: [...(visualSignals.length ? [{\n            signal: visualSignals.join(' || ')\n          }] : []), ...(init ? [{\n            signal: GEO_INIT_TICK\n          }] : [])],\n          update\n        }]\n      });\n    }\n  },\n  topLevelSignals: (model, selCmpt, signals) => {\n    if (isUnitModel(model) && model.hasProjection && selCmpt.init) {\n      // Workaround for https://github.com/vega/vega/issues/3481\n      // The scenegraph isn't populated on the first pulse. So we use a timer signal\n      // to re-pulse the dataflow as soon as possible. We return an object to ensure\n      // this only occurs once.\n      const hasTick = signals.filter(s => s.name === GEO_INIT_TICK);\n      if (!hasTick.length) {\n        signals.unshift({\n          name: GEO_INIT_TICK,\n          value: null,\n          on: [{\n            events: 'timer{1}',\n            update: `${GEO_INIT_TICK} === null ? {} : ${GEO_INIT_TICK}`\n          }]\n        });\n      }\n    }\n    return signals;\n  },\n  marks: (model, selCmpt, marks) => {\n    const name = selCmpt.name;\n    const {\n      x,\n      y\n    } = selCmpt.project.hasChannel;\n    const xvname = x?.signals.visual;\n    const yvname = y?.signals.visual;\n    const store = `data(${stringValue(selCmpt.name + STORE)})`;\n    // Do not add a brush if we're binding to scales\n    // or we don't have a valid interval projection\n    if (scales.defined(selCmpt) || !x && !y) {\n      return marks;\n    }\n    const update = {\n      x: x !== undefined ? {\n        signal: `${xvname}[0]`\n      } : {\n        value: 0\n      },\n      y: y !== undefined ? {\n        signal: `${yvname}[0]`\n      } : {\n        value: 0\n      },\n      x2: x !== undefined ? {\n        signal: `${xvname}[1]`\n      } : {\n        field: {\n          group: 'width'\n        }\n      },\n      y2: y !== undefined ? {\n        signal: `${yvname}[1]`\n      } : {\n        field: {\n          group: 'height'\n        }\n      }\n    };\n    // If the selection is resolved to global, only a single interval is in\n    // the store. Wrap brush mark's encodings with a production rule to test\n    // this based on the `unit` property. Hide the brush mark if it corresponds\n    // to a unit different from the one in the store.\n    if (selCmpt.resolve === 'global') {\n      for (const key of keys(update)) {\n        update[key] = [{\n          test: `${store}.length && ${store}[0].unit === ${unitName(model)}`,\n          ...update[key]\n        }, {\n          value: 0\n        }];\n      }\n    }\n    // Two brush marks ensure that fill colors and other aesthetic choices do\n    // not interefere with the core marks, but that the brushed region can still\n    // be interacted with (e.g., dragging it around).\n    const {\n      fill,\n      fillOpacity,\n      cursor,\n      ...stroke\n    } = selCmpt.mark;\n    const vgStroke = keys(stroke).reduce((def, k) => {\n      def[k] = [{\n        test: [x !== undefined && `${xvname}[0] !== ${xvname}[1]`, y !== undefined && `${yvname}[0] !== ${yvname}[1]`].filter(t => t).join(' && '),\n        value: stroke[k]\n      }, {\n        value: null\n      }];\n      return def;\n    }, {});\n    // Set cursor to move unless the brush cannot be translated\n    const vgCursor = cursor ?? (selCmpt.translate ? 'move' : null);\n    return [{\n      name: `${name + BRUSH}_bg`,\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: {\n          fill: {\n            value: fill\n          },\n          fillOpacity: {\n            value: fillOpacity\n          }\n        },\n        update\n      }\n    }, ...marks, {\n      name: name + BRUSH,\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: {\n          ...(vgCursor ? {\n            cursor: {\n              value: vgCursor\n            }\n          } : {}),\n          fill: {\n            value: 'transparent'\n          }\n        },\n        update: {\n          ...update,\n          ...vgStroke\n        }\n      }\n    }];\n  }\n};\nexport default interval;\n/**\n * Returns the visual and data signals for an interval selection.\n */\nfunction channelSignals(model, selCmpt, proj, init) {\n  const scaledInterval = !model.hasProjection;\n  const channel = proj.channel;\n  const vname = proj.signals.visual;\n  const scaleName = stringValue(scaledInterval ? model.scaleName(channel) : model.projectionName());\n  const scaled = str => `scale(${scaleName}, ${str})`;\n  const size = model.getSizeSignalRef(channel === X ? 'width' : 'height').signal;\n  const coord = `${channel}(unit)`;\n  const von = selCmpt.events.reduce((def, evt) => {\n    return [...def, {\n      events: evt.between[0],\n      update: `[${coord}, ${coord}]`\n    },\n    // Brush Start\n    {\n      events: evt,\n      update: `[${vname}[0], clamp(${coord}, 0, ${size})]`\n    } // Brush End\n    ];\n  }, []);\n  if (scaledInterval) {\n    const dname = proj.signals.data;\n    const hasScales = scales.defined(selCmpt);\n    const scale = model.getScaleComponent(channel);\n    const scaleType = scale ? scale.get('type') : undefined;\n    const vinit = init ? {\n      init: assembleInit(init, true, scaled)\n    } : {\n      value: []\n    };\n    // React to pan/zooms of continuous scales. Non-continuous scales\n    // (band, point) cannot be pan/zoomed and any other changes\n    // to their domains (e.g., filtering) should clear the brushes.\n    von.push({\n      events: {\n        signal: selCmpt.name + SCALE_TRIGGER\n      },\n      update: hasContinuousDomain(scaleType) ? `[${scaled(`${dname}[0]`)}, ${scaled(`${dname}[1]`)}]` : `[0, 0]`\n    });\n    return hasScales ? [{\n      name: dname,\n      on: []\n    }] : [{\n      name: vname,\n      ...vinit,\n      on: von\n    }, {\n      name: dname,\n      ...(init ? {\n        init: assembleInit(init)\n      } : {}),\n      // Cannot be `value` as `init` may require datetime exprs.\n      on: [{\n        events: {\n          signal: vname\n        },\n        update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`\n      }]\n    }];\n  } else {\n    const initIdx = channel === X ? 0 : 1;\n    const initSg = selCmpt.name + INIT;\n    const vinit = init ? {\n      init: `[${initSg}[0][${initIdx}], ${initSg}[1][${initIdx}]]`\n    } : {\n      value: []\n    };\n    return [{\n      name: vname,\n      ...vinit,\n      on: von\n    }];\n  }\n}","map":{"version":3,"names":["isObject","array","stringValue","STORE","TUPLE","unitName","LATITUDE","LONGITUDE","X","Y","warn","hasContinuousDomain","SELECTION_ID","keys","vals","isUnitModel","assembleInit","TUPLE_FIELDS","scales","BRUSH","SCALE_TRIGGER","GEO_INIT_TICK","INIT","CENTER","interval","defined","selCmpt","type","parse","model","selDef","hasProjection","def","select","fields","encodings","value","translate","filterExpr","name","evt","events","between","filters","_a","filter","includes","push","signals","tupleSg","channels","project","hasChannel","p","channel","init","reduce","arr","proj","concat","channelSignals","index","triggerSg","scaleTriggers","map","data","dname","visual","vname","scaleName","scaleType","getScaleComponent","get","toNum","length","on","scale","update","join","dataSignals","signal","projection","projectionName","centerSg","x","y","xvname","yvname","xinit","yinit","sizeSg","layout","getSizeSignalRef","bbox","unshift","hasCenterSg","find","s","intersect","getName","base","visualSignals","topLevelSignals","hasTick","marks","store","undefined","x2","field","group","y2","resolve","key","test","fill","fillOpacity","cursor","stroke","mark","vgStroke","k","t","vgCursor","clip","encode","enter","scaledInterval","scaled","str","size","coord","von","hasScales","vinit","initIdx","initSg"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\selection\\interval.ts"],"sourcesContent":["import {isObject, NewSignal, OnEvent, SignalValue, Stream} from 'vega';\nimport {array, stringValue} from 'vega-util';\nimport {SelectionCompiler, SelectionComponent, STORE, TUPLE, unitName} from '.';\nimport {GeoPositionChannel, LATITUDE, LONGITUDE, ScaleChannel, X, Y} from '../../channel';\nimport {FieldName} from '../../channeldef';\nimport {warn} from '../../log';\nimport {hasContinuousDomain} from '../../scale';\nimport {IntervalSelectionConfigWithoutType, SelectionInitInterval, SELECTION_ID} from '../../selection';\nimport {keys, vals} from '../../util';\nimport {LayoutSizeIndex} from '../layoutsize/component';\nimport {isUnitModel} from '../model';\nimport {UnitModel} from '../unit';\nimport {assembleInit} from './assemble';\nimport {SelectionProjection, TUPLE_FIELDS} from './project';\nimport scales from './scales';\n\nexport const BRUSH = '_brush';\nexport const SCALE_TRIGGER = '_scale_trigger';\nexport const GEO_INIT_TICK = 'geo_interval_init_tick'; // Workaround for https://github.com/vega/vega/issues/3481\nconst INIT = '_init';\nconst CENTER = '_center';\n\n// Separate type because the \"fields\" property is only used internally and we don't want to leak it to the schema.\nexport type IntervalSelectionConfigWithField = IntervalSelectionConfigWithoutType & {fields?: FieldName[]};\n\nconst interval: SelectionCompiler<'interval'> = {\n  defined: selCmpt => selCmpt.type === 'interval',\n\n  parse: (model, selCmpt, selDef) => {\n    if (model.hasProjection) {\n      const def: IntervalSelectionConfigWithField = {...(isObject(selDef.select) ? selDef.select : {})};\n      def.fields = [SELECTION_ID];\n      if (!def.encodings) {\n        // Remap default x/y projection\n        def.encodings = selDef.value ? (keys(selDef.value) as GeoPositionChannel[]) : [LONGITUDE, LATITUDE];\n      }\n\n      selDef.select = {type: 'interval', ...def};\n    }\n\n    if (selCmpt.translate && !scales.defined(selCmpt)) {\n      const filterExpr = `!event.item || event.item.mark.name !== ${stringValue(selCmpt.name + BRUSH)}`;\n      for (const evt of selCmpt.events) {\n        if (!evt.between) {\n          warn(`${evt} is not an ordered event stream for interval selections.`);\n          continue;\n        }\n\n        const filters = array((evt.between[0].filter ??= []));\n        if (!filters.includes(filterExpr)) {\n          filters.push(filterExpr);\n        }\n      }\n    }\n  },\n\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const tupleSg = name + TUPLE;\n    const channels = vals(selCmpt.project.hasChannel).filter(p => p.channel === X || p.channel === Y);\n    const init = selCmpt.init ? selCmpt.init[0] : null;\n\n    signals.push(\n      ...channels.reduce((arr, proj) => arr.concat(channelSignals(model, selCmpt, proj, init && init[proj.index])), [])\n    );\n\n    if (!model.hasProjection) {\n      // Proxy scale reactions to ensure that an infinite loop doesn't occur\n      // when an interval selection filter touches the scale.\n      if (!scales.defined(selCmpt)) {\n        const triggerSg = name + SCALE_TRIGGER;\n        const scaleTriggers = channels.map(proj => {\n          const channel = proj.channel as 'x' | 'y';\n          const {data: dname, visual: vname} = proj.signals;\n          const scaleName = stringValue(model.scaleName(channel));\n          const scaleType = model.getScaleComponent(channel).get('type');\n          const toNum = hasContinuousDomain(scaleType) ? '+' : '';\n          return (\n            `(!isArray(${dname}) || ` +\n            `(${toNum}invert(${scaleName}, ${vname})[0] === ${toNum}${dname}[0] && ` +\n            `${toNum}invert(${scaleName}, ${vname})[1] === ${toNum}${dname}[1]))`\n          );\n        });\n\n        if (scaleTriggers.length) {\n          signals.push({\n            name: triggerSg,\n            value: {},\n            on: [\n              {\n                events: channels.map(proj => ({scale: model.scaleName(proj.channel)})),\n                update: scaleTriggers.join(' && ') + ` ? ${triggerSg} : {}`\n              }\n            ]\n          });\n        }\n      }\n\n      // Only add an interval to the store if it has valid data extents. Data extents\n      // are set to null if pixel extents are equal to account for intervals over\n      // ordinal/nominal domains which, when inverted, will still produce a valid datum.\n      const dataSignals = channels.map(proj => proj.signals.data);\n      const update = `unit: ${unitName(model)}, fields: ${name + TUPLE_FIELDS}, values`;\n      return signals.concat({\n        name: tupleSg,\n        ...(init ? {init: `{${update}: ${assembleInit(init)}}`} : {}),\n        ...(dataSignals.length\n          ? {\n              on: [\n                {\n                  events: [{signal: dataSignals.join(' || ')}], // Prevents double invocation, see https://github.com/vega/vega/issues/1672.\n                  update: `${dataSignals.join(' && ')} ? {${update}: [${dataSignals}]} : null`\n                }\n              ]\n            }\n          : {})\n      });\n    } else {\n      const projection = stringValue(model.projectionName());\n      const centerSg = model.projectionName() + CENTER;\n      const {x, y} = selCmpt.project.hasChannel;\n      const xvname = x && x.signals.visual;\n      const yvname = y && y.signals.visual;\n      const xinit = x ? init && init[x.index] : `${centerSg}[0]`;\n      const yinit = y ? init && init[y.index] : `${centerSg}[1]`;\n      const sizeSg = (layout: keyof LayoutSizeIndex) => model.getSizeSignalRef(layout).signal;\n      const bbox =\n        `[` +\n        `[${xvname ? xvname + '[0]' : '0'}, ${yvname ? yvname + '[0]' : '0'}],` +\n        `[${xvname ? xvname + '[1]' : sizeSg('width')}, ` +\n        `${yvname ? yvname + '[1]' : sizeSg('height')}]` +\n        `]`;\n\n      if (init) {\n        signals.unshift({\n          name: name + INIT,\n          init:\n            `[scale(${projection}, [${x ? xinit[0] : xinit}, ${y ? yinit[0] : yinit}]), ` +\n            `scale(${projection}, [${x ? xinit[1] : xinit}, ${y ? yinit[1] : yinit}])]`\n        });\n\n        if (!x || !y) {\n          // If initializing a uni-dimensional brush, use the center of the view to determine the other coord\n          const hasCenterSg = signals.find(s => s.name === centerSg);\n          if (!hasCenterSg) {\n            signals.unshift({\n              name: centerSg,\n              update: `invert(${projection}, [${sizeSg('width')}/2, ${sizeSg('height')}/2])`\n            });\n          }\n        }\n      }\n\n      const intersect = `intersect(${bbox}, {markname: ${stringValue(model.getName('marks'))}}, unit.mark)`;\n      const base = `{unit: ${unitName(model)}}`;\n      const update = `vlSelectionTuples(${intersect}, ${base})`;\n      const visualSignals = channels.map(proj => proj.signals.visual);\n\n      return signals.concat({\n        name: tupleSg,\n        on: [\n          {\n            events: [\n              ...(visualSignals.length ? [{signal: visualSignals.join(' || ')}] : []),\n              ...(init ? [{signal: GEO_INIT_TICK}] : [])\n            ],\n            update\n          }\n        ]\n      });\n    }\n  },\n\n  topLevelSignals: (model, selCmpt, signals) => {\n    if (isUnitModel(model) && model.hasProjection && selCmpt.init) {\n      // Workaround for https://github.com/vega/vega/issues/3481\n      // The scenegraph isn't populated on the first pulse. So we use a timer signal\n      // to re-pulse the dataflow as soon as possible. We return an object to ensure\n      // this only occurs once.\n      const hasTick = signals.filter(s => s.name === GEO_INIT_TICK);\n      if (!hasTick.length) {\n        signals.unshift({\n          name: GEO_INIT_TICK,\n          value: null,\n          on: [\n            {\n              events: 'timer{1}',\n              update: `${GEO_INIT_TICK} === null ? {} : ${GEO_INIT_TICK}`\n            }\n          ]\n        });\n      }\n    }\n\n    return signals;\n  },\n\n  marks: (model, selCmpt, marks) => {\n    const name = selCmpt.name;\n    const {x, y} = selCmpt.project.hasChannel;\n    const xvname = x?.signals.visual;\n    const yvname = y?.signals.visual;\n    const store = `data(${stringValue(selCmpt.name + STORE)})`;\n\n    // Do not add a brush if we're binding to scales\n    // or we don't have a valid interval projection\n    if (scales.defined(selCmpt) || (!x && !y)) {\n      return marks;\n    }\n\n    const update: any = {\n      x: x !== undefined ? {signal: `${xvname}[0]`} : {value: 0},\n      y: y !== undefined ? {signal: `${yvname}[0]`} : {value: 0},\n      x2: x !== undefined ? {signal: `${xvname}[1]`} : {field: {group: 'width'}},\n      y2: y !== undefined ? {signal: `${yvname}[1]`} : {field: {group: 'height'}}\n    };\n\n    // If the selection is resolved to global, only a single interval is in\n    // the store. Wrap brush mark's encodings with a production rule to test\n    // this based on the `unit` property. Hide the brush mark if it corresponds\n    // to a unit different from the one in the store.\n    if (selCmpt.resolve === 'global') {\n      for (const key of keys(update)) {\n        update[key] = [\n          {\n            test: `${store}.length && ${store}[0].unit === ${unitName(model)}`,\n            ...update[key]\n          },\n          {value: 0}\n        ];\n      }\n    }\n\n    // Two brush marks ensure that fill colors and other aesthetic choices do\n    // not interefere with the core marks, but that the brushed region can still\n    // be interacted with (e.g., dragging it around).\n    const {fill, fillOpacity, cursor, ...stroke} = selCmpt.mark;\n    const vgStroke = keys(stroke).reduce(\n      (def, k) => {\n        def[k] = [\n          {\n            test: [\n              x !== undefined && `${xvname}[0] !== ${xvname}[1]`,\n              y !== undefined && `${yvname}[0] !== ${yvname}[1]`\n            ]\n              .filter(t => t)\n              .join(' && '),\n            value: stroke[k]\n          },\n          {value: null}\n        ];\n        return def;\n      },\n      {} as Record<keyof typeof stroke, any>\n    );\n\n    // Set cursor to move unless the brush cannot be translated\n    const vgCursor = cursor ?? (selCmpt.translate ? 'move' : null);\n\n    return [\n      {\n        name: `${name + BRUSH}_bg`,\n        type: 'rect',\n        clip: true,\n        encode: {\n          enter: {\n            fill: {value: fill},\n            fillOpacity: {value: fillOpacity}\n          },\n          update\n        }\n      },\n      ...marks,\n      {\n        name: name + BRUSH,\n        type: 'rect',\n        clip: true,\n        encode: {\n          enter: {\n            ...(vgCursor ? {cursor: {value: vgCursor}} : {}),\n            fill: {value: 'transparent'}\n          },\n          update: {...update, ...vgStroke}\n        }\n      }\n    ];\n  }\n};\nexport default interval;\n\n/**\n * Returns the visual and data signals for an interval selection.\n */\nfunction channelSignals(\n  model: UnitModel,\n  selCmpt: SelectionComponent<'interval'>,\n  proj: SelectionProjection,\n  init: SelectionInitInterval\n): NewSignal[] {\n  const scaledInterval = !model.hasProjection;\n  const channel = proj.channel;\n  const vname = proj.signals.visual;\n\n  const scaleName = stringValue(scaledInterval ? model.scaleName(channel) : model.projectionName());\n  const scaled = (str: string) => `scale(${scaleName}, ${str})`;\n\n  const size = model.getSizeSignalRef(channel === X ? 'width' : 'height').signal;\n  const coord = `${channel}(unit)`;\n  const von = selCmpt.events.reduce((def: OnEvent[], evt: Stream) => {\n    return [\n      ...def,\n      {events: evt.between[0], update: `[${coord}, ${coord}]`}, // Brush Start\n      {events: evt, update: `[${vname}[0], clamp(${coord}, 0, ${size})]`} // Brush End\n    ];\n  }, []);\n\n  if (scaledInterval) {\n    const dname = proj.signals.data;\n    const hasScales = scales.defined(selCmpt);\n    const scale = model.getScaleComponent(channel as ScaleChannel);\n    const scaleType = scale ? scale.get('type') : undefined;\n    const vinit: SignalValue = init ? {init: assembleInit(init, true, scaled)} : {value: []};\n\n    // React to pan/zooms of continuous scales. Non-continuous scales\n    // (band, point) cannot be pan/zoomed and any other changes\n    // to their domains (e.g., filtering) should clear the brushes.\n    von.push({\n      events: {signal: selCmpt.name + SCALE_TRIGGER},\n      update: hasContinuousDomain(scaleType) ? `[${scaled(`${dname}[0]`)}, ${scaled(`${dname}[1]`)}]` : `[0, 0]`\n    });\n\n    return hasScales\n      ? [{name: dname, on: []}]\n      : [\n          {name: vname, ...vinit, on: von},\n          {\n            name: dname,\n            ...(init ? {init: assembleInit(init)} : {}), // Cannot be `value` as `init` may require datetime exprs.\n            on: [\n              {\n                events: {signal: vname},\n                update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`\n              }\n            ]\n          }\n        ];\n  } else {\n    const initIdx = channel === X ? 0 : 1;\n    const initSg = selCmpt.name + INIT;\n    const vinit: SignalValue = init ? {init: `[${initSg}[0][${initIdx}], ${initSg}[1][${initIdx}]]`} : {value: []};\n    return [{name: vname, ...vinit, on: von}];\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}