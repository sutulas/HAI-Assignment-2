{"ast":null,"code":"import { array } from 'vega-util';\nimport { isConditionalDef, isConditionalParameter } from '../../../channeldef';\nimport { expression } from '../../predicate';\nimport { parseSelectionPredicate } from '../../selection/parse';\n/**\n * Return a VgEncodeEntry that includes a Vega production rule for a scale channel's encoding or guide encoding, which includes:\n * (1) the conditional rules (if provided as part of channelDef)\n * (2) invalidValueRef for handling invalid values (if provided as a parameter of this method)\n * (3) main reference for the encoded data.\n */\nexport function wrapCondition(_ref) {\n  let {\n    model,\n    channelDef,\n    vgChannel,\n    invalidValueRef,\n    mainRefFn\n  } = _ref;\n  const condition = isConditionalDef(channelDef) && channelDef.condition;\n  let valueRefs = [];\n  if (condition) {\n    const conditions = array(condition);\n    valueRefs = conditions.map(c => {\n      const conditionValueRef = mainRefFn(c);\n      if (isConditionalParameter(c)) {\n        const {\n          param,\n          empty\n        } = c;\n        const test = parseSelectionPredicate(model, {\n          param,\n          empty\n        });\n        return {\n          test,\n          ...conditionValueRef\n        };\n      } else {\n        const test = expression(model, c.test); // FIXME: remove casting once TS is no longer dumb about it\n        return {\n          test,\n          ...conditionValueRef\n        };\n      }\n    });\n  }\n  if (invalidValueRef !== undefined) {\n    valueRefs.push(invalidValueRef);\n  }\n  const mainValueRef = mainRefFn(channelDef);\n  if (mainValueRef !== undefined) {\n    valueRefs.push(mainValueRef);\n  }\n  if (valueRefs.length > 1 || valueRefs.length === 1 && Boolean(valueRefs[0].test) // We must use array form valueRefs if test exists, otherwise Vega won't execute the test.\n  ) {\n    return {\n      [vgChannel]: valueRefs\n    };\n  } else if (valueRefs.length === 1) {\n    return {\n      [vgChannel]: valueRefs[0]\n    };\n  }\n  return {};\n}","map":{"version":3,"names":["array","isConditionalDef","isConditionalParameter","expression","parseSelectionPredicate","wrapCondition","_ref","model","channelDef","vgChannel","invalidValueRef","mainRefFn","condition","valueRefs","conditions","map","c","conditionValueRef","param","empty","test","undefined","push","mainValueRef","length","Boolean"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\mark\\encode\\conditional.ts"],"sourcesContent":["import {array} from 'vega-util';\nimport {ChannelDef, ConditionalPredicate, isConditionalDef, isConditionalParameter} from '../../../channeldef';\nimport {GuideEncodingConditionalValueDef} from '../../../guide';\nimport {VgEncodeEntry, VgValueRef} from '../../../vega.schema';\nimport {expression} from '../../predicate';\nimport {parseSelectionPredicate} from '../../selection/parse';\nimport {UnitModel} from '../../unit';\n\n/**\n * Return a VgEncodeEntry that includes a Vega production rule for a scale channel's encoding or guide encoding, which includes:\n * (1) the conditional rules (if provided as part of channelDef)\n * (2) invalidValueRef for handling invalid values (if provided as a parameter of this method)\n * (3) main reference for the encoded data.\n */\nexport function wrapCondition<CD extends ChannelDef | GuideEncodingConditionalValueDef>({\n  model,\n  channelDef,\n  vgChannel,\n  invalidValueRef,\n  mainRefFn\n}: {\n  model: UnitModel;\n  channelDef: CD;\n  vgChannel: string;\n\n  /**\n   * invalidValue for a scale channel if the invalidDataMode is include for the channel.\n   * For scale channel with other invalidDataMode or non-scale channel, this value should be undefined.\n   */\n  invalidValueRef: VgValueRef | undefined;\n  mainRefFn: (cDef: CD) => VgValueRef;\n}): VgEncodeEntry {\n  const condition = isConditionalDef<CD>(channelDef) && channelDef.condition;\n\n  let valueRefs: VgValueRef[] = [];\n\n  if (condition) {\n    const conditions = array(condition);\n    valueRefs = conditions.map(c => {\n      const conditionValueRef = mainRefFn(c);\n      if (isConditionalParameter<any>(c)) {\n        const {param, empty} = c;\n        const test = parseSelectionPredicate(model, {param, empty});\n        return {test, ...conditionValueRef};\n      } else {\n        const test = expression(model, (c as ConditionalPredicate<any>).test); // FIXME: remove casting once TS is no longer dumb about it\n        return {test, ...conditionValueRef};\n      }\n    });\n  }\n\n  if (invalidValueRef !== undefined) {\n    valueRefs.push(invalidValueRef);\n  }\n\n  const mainValueRef = mainRefFn(channelDef);\n  if (mainValueRef !== undefined) {\n    valueRefs.push(mainValueRef);\n  }\n\n  if (\n    valueRefs.length > 1 ||\n    (valueRefs.length === 1 && Boolean(valueRefs[0].test)) // We must use array form valueRefs if test exists, otherwise Vega won't execute the test.\n  ) {\n    return {[vgChannel]: valueRefs};\n  } else if (valueRefs.length === 1) {\n    return {[vgChannel]: valueRefs[0]};\n  }\n  return {};\n}\n"],"mappings":"AAAA,SAAQA,KAAK,QAAO,WAAW;AAC/B,SAA0CC,gBAAgB,EAAEC,sBAAsB,QAAO,qBAAqB;AAG9G,SAAQC,UAAU,QAAO,iBAAiB;AAC1C,SAAQC,uBAAuB,QAAO,uBAAuB;AAG7D;;;;;;AAMA,OAAM,SAAUC,aAAaA,CAAAC,IAAA,EAiB5B;EAAA,IAjBuF;IACtFC,KAAK;IACLC,UAAU;IACVC,SAAS;IACTC,eAAe;IACfC;EAAS,CAYV,GAAAL,IAAA;EACC,MAAMM,SAAS,GAAGX,gBAAgB,CAAKO,UAAU,CAAC,IAAIA,UAAU,CAACI,SAAS;EAE1E,IAAIC,SAAS,GAAiB,EAAE;EAEhC,IAAID,SAAS,EAAE;IACb,MAAME,UAAU,GAAGd,KAAK,CAACY,SAAS,CAAC;IACnCC,SAAS,GAAGC,UAAU,CAACC,GAAG,CAACC,CAAC,IAAG;MAC7B,MAAMC,iBAAiB,GAAGN,SAAS,CAACK,CAAC,CAAC;MACtC,IAAId,sBAAsB,CAAMc,CAAC,CAAC,EAAE;QAClC,MAAM;UAACE,KAAK;UAAEC;QAAK,CAAC,GAAGH,CAAC;QACxB,MAAMI,IAAI,GAAGhB,uBAAuB,CAACG,KAAK,EAAE;UAACW,KAAK;UAAEC;QAAK,CAAC,CAAC;QAC3D,OAAO;UAACC,IAAI;UAAE,GAAGH;QAAiB,CAAC;MACrC,CAAC,MAAM;QACL,MAAMG,IAAI,GAAGjB,UAAU,CAACI,KAAK,EAAGS,CAA+B,CAACI,IAAI,CAAC,CAAC,CAAC;QACvE,OAAO;UAACA,IAAI;UAAE,GAAGH;QAAiB,CAAC;MACrC;IACF,CAAC,CAAC;EACJ;EAEA,IAAIP,eAAe,KAAKW,SAAS,EAAE;IACjCR,SAAS,CAACS,IAAI,CAACZ,eAAe,CAAC;EACjC;EAEA,MAAMa,YAAY,GAAGZ,SAAS,CAACH,UAAU,CAAC;EAC1C,IAAIe,YAAY,KAAKF,SAAS,EAAE;IAC9BR,SAAS,CAACS,IAAI,CAACC,YAAY,CAAC;EAC9B;EAEA,IACEV,SAAS,CAACW,MAAM,GAAG,CAAC,IACnBX,SAAS,CAACW,MAAM,KAAK,CAAC,IAAIC,OAAO,CAACZ,SAAS,CAAC,CAAC,CAAC,CAACO,IAAI,CAAE,CAAC;EAAA,EACvD;IACA,OAAO;MAAC,CAACX,SAAS,GAAGI;IAAS,CAAC;EACjC,CAAC,MAAM,IAAIA,SAAS,CAACW,MAAM,KAAK,CAAC,EAAE;IACjC,OAAO;MAAC,CAACf,SAAS,GAAGI,SAAS,CAAC,CAAC;IAAC,CAAC;EACpC;EACA,OAAO,EAAE;AACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}