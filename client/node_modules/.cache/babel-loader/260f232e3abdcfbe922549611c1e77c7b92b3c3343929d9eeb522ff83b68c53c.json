{"ast":null,"code":"import { isXorY } from '../channel';\nimport * as log from '../log';\nimport { isConcatModel, isFacetModel, isLayerModel } from './model';\nexport function defaultScaleResolve(channel, model) {\n  if (isFacetModel(model)) {\n    return channel === 'theta' ? 'independent' : 'shared';\n  } else if (isLayerModel(model)) {\n    return 'shared';\n  } else if (isConcatModel(model)) {\n    return isXorY(channel) || channel === 'theta' || channel === 'radius' ? 'independent' : 'shared';\n  }\n  /* istanbul ignore next: should never reach here. */\n  throw new Error('invalid model type for resolve');\n}\nexport function parseGuideResolve(resolve, channel) {\n  const channelScaleResolve = resolve.scale[channel];\n  const guide = isXorY(channel) ? 'axis' : 'legend';\n  if (channelScaleResolve === 'independent') {\n    if (resolve[guide][channel] === 'shared') {\n      log.warn(log.message.independentScaleMeansIndependentGuide(channel));\n    }\n    return 'independent';\n  }\n  return resolve[guide][channel] || 'shared';\n}","map":{"version":3,"names":["isXorY","log","isConcatModel","isFacetModel","isLayerModel","defaultScaleResolve","channel","model","Error","parseGuideResolve","resolve","channelScaleResolve","scale","guide","warn","message","independentScaleMeansIndependentGuide"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\resolve.ts"],"sourcesContent":["import {isXorY, ScaleChannel} from '../channel';\nimport * as log from '../log';\nimport {Resolve, ResolveMode} from '../resolve';\nimport {isConcatModel, isFacetModel, isLayerModel, Model} from './model';\n\nexport function defaultScaleResolve(channel: ScaleChannel, model: Model): ResolveMode {\n  if (isFacetModel(model)) {\n    return channel === 'theta' ? 'independent' : 'shared';\n  } else if (isLayerModel(model)) {\n    return 'shared';\n  } else if (isConcatModel(model)) {\n    return isXorY(channel) || channel === 'theta' || channel === 'radius' ? 'independent' : 'shared';\n  }\n  /* istanbul ignore next: should never reach here. */\n  throw new Error('invalid model type for resolve');\n}\n\nexport function parseGuideResolve(resolve: Resolve, channel: ScaleChannel): ResolveMode {\n  const channelScaleResolve = resolve.scale[channel];\n  const guide = isXorY(channel) ? 'axis' : 'legend';\n\n  if (channelScaleResolve === 'independent') {\n    if ((resolve[guide] as any)[channel] === 'shared') {\n      log.warn(log.message.independentScaleMeansIndependentGuide(channel));\n    }\n    return 'independent';\n  }\n\n  return (resolve[guide] as any)[channel] || 'shared';\n}\n"],"mappings":"AAAA,SAAQA,MAAM,QAAqB,YAAY;AAC/C,OAAO,KAAKC,GAAG,MAAM,QAAQ;AAE7B,SAAQC,aAAa,EAAEC,YAAY,EAAEC,YAAY,QAAc,SAAS;AAExE,OAAM,SAAUC,mBAAmBA,CAACC,OAAqB,EAAEC,KAAY;EACrE,IAAIJ,YAAY,CAACI,KAAK,CAAC,EAAE;IACvB,OAAOD,OAAO,KAAK,OAAO,GAAG,aAAa,GAAG,QAAQ;EACvD,CAAC,MAAM,IAAIF,YAAY,CAACG,KAAK,CAAC,EAAE;IAC9B,OAAO,QAAQ;EACjB,CAAC,MAAM,IAAIL,aAAa,CAACK,KAAK,CAAC,EAAE;IAC/B,OAAOP,MAAM,CAACM,OAAO,CAAC,IAAIA,OAAO,KAAK,OAAO,IAAIA,OAAO,KAAK,QAAQ,GAAG,aAAa,GAAG,QAAQ;EAClG;EACA;EACA,MAAM,IAAIE,KAAK,CAAC,gCAAgC,CAAC;AACnD;AAEA,OAAM,SAAUC,iBAAiBA,CAACC,OAAgB,EAAEJ,OAAqB;EACvE,MAAMK,mBAAmB,GAAGD,OAAO,CAACE,KAAK,CAACN,OAAO,CAAC;EAClD,MAAMO,KAAK,GAAGb,MAAM,CAACM,OAAO,CAAC,GAAG,MAAM,GAAG,QAAQ;EAEjD,IAAIK,mBAAmB,KAAK,aAAa,EAAE;IACzC,IAAKD,OAAO,CAACG,KAAK,CAAS,CAACP,OAAO,CAAC,KAAK,QAAQ,EAAE;MACjDL,GAAG,CAACa,IAAI,CAACb,GAAG,CAACc,OAAO,CAACC,qCAAqC,CAACV,OAAO,CAAC,CAAC;IACtE;IACA,OAAO,aAAa;EACtB;EAEA,OAAQI,OAAO,CAACG,KAAK,CAAS,CAACP,OAAO,CAAC,IAAI,QAAQ;AACrD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}