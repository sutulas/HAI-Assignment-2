{"ast":null,"code":"import { isBinned, isBinning } from '../../bin';\nimport { isFieldDef, isNumericDataDef, isUnbinnedQuantitativeFieldOrDatumDef, isTypedFieldDef } from '../../channeldef';\nimport { isAggregate } from '../../encoding';\nimport { replaceExprRef } from '../../expr';\nimport * as log from '../../log';\nimport { AREA, BAR, BAR_CORNER_RADIUS_INDEX as BAR_CORNER_RADIUS_END_INDEX, CIRCLE, IMAGE, LINE, POINT, RECT, RULE, SQUARE, TEXT, TICK } from '../../mark';\nimport { QUANTITATIVE, TEMPORAL } from '../../type';\nimport { contains, getFirstDefined } from '../../util';\nimport { getMarkConfig, getMarkPropOrConfig } from '../common';\nexport function initMarkdef(originalMarkDef, encoding, config) {\n  // FIXME: markDef expects that exprRefs are replaced recursively but replaceExprRef only replaces the top level\n  const markDef = replaceExprRef(originalMarkDef);\n  // set orient, which can be overridden by rules as sometimes the specified orient is invalid.\n  const specifiedOrient = getMarkPropOrConfig('orient', markDef, config);\n  markDef.orient = orient(markDef.type, encoding, specifiedOrient);\n  if (specifiedOrient !== undefined && specifiedOrient !== markDef.orient) {\n    log.warn(log.message.orientOverridden(markDef.orient, specifiedOrient));\n  }\n  if (markDef.type === 'bar' && markDef.orient) {\n    const cornerRadiusEnd = getMarkPropOrConfig('cornerRadiusEnd', markDef, config);\n    if (cornerRadiusEnd !== undefined) {\n      const newProps = markDef.orient === 'horizontal' && encoding.x2 || markDef.orient === 'vertical' && encoding.y2 ? ['cornerRadius'] : BAR_CORNER_RADIUS_END_INDEX[markDef.orient];\n      for (const newProp of newProps) {\n        markDef[newProp] = cornerRadiusEnd;\n      }\n      if (markDef.cornerRadiusEnd !== undefined) {\n        delete markDef.cornerRadiusEnd; // no need to keep the original cap cornerRadius\n      }\n    }\n  }\n  // set opacity and filled if not specified in mark config\n  const specifiedOpacity = getMarkPropOrConfig('opacity', markDef, config);\n  const specifiedfillOpacity = getMarkPropOrConfig('fillOpacity', markDef, config);\n  if (specifiedOpacity === undefined && specifiedfillOpacity === undefined) {\n    markDef.opacity = opacity(markDef.type, encoding);\n  }\n  // set cursor, which should be pointer if href channel is present unless otherwise specified\n  const specifiedCursor = getMarkPropOrConfig('cursor', markDef, config);\n  if (specifiedCursor === undefined) {\n    markDef.cursor = cursor(markDef, encoding, config);\n  }\n  return markDef;\n}\nfunction cursor(markDef, encoding, config) {\n  if (encoding.href || markDef.href || getMarkPropOrConfig('href', markDef, config)) {\n    return 'pointer';\n  }\n  return markDef.cursor;\n}\nfunction opacity(mark, encoding) {\n  if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n    // point-based marks\n    if (!isAggregate(encoding)) {\n      return 0.7;\n    }\n  }\n  return undefined;\n}\nexport function defaultFilled(markDef, config, _ref) {\n  let {\n    graticule\n  } = _ref;\n  if (graticule) {\n    return false;\n  }\n  const filledConfig = getMarkConfig('filled', markDef, config);\n  const mark = markDef.type;\n  return getFirstDefined(filledConfig, mark !== POINT && mark !== LINE && mark !== RULE);\n}\nfunction orient(mark, encoding, specifiedOrient) {\n  switch (mark) {\n    case POINT:\n    case CIRCLE:\n    case SQUARE:\n    case TEXT:\n    case RECT:\n    case IMAGE:\n      // orient is meaningless for these marks.\n      return undefined;\n  }\n  const {\n    x,\n    y,\n    x2,\n    y2\n  } = encoding;\n  switch (mark) {\n    case BAR:\n      if (isFieldDef(x) && (isBinned(x.bin) || isFieldDef(y) && y.aggregate && !x.aggregate)) {\n        return 'vertical';\n      }\n      if (isFieldDef(y) && (isBinned(y.bin) || isFieldDef(x) && x.aggregate && !y.aggregate)) {\n        return 'horizontal';\n      }\n      if (y2 || x2) {\n        // Ranged bar does not always have clear orientation, so we allow overriding\n        if (specifiedOrient) {\n          return specifiedOrient;\n        }\n        // If y is range and x is non-range, non-bin Q\n        if (!x2) {\n          if (isFieldDef(x) && x.type === QUANTITATIVE && !isBinning(x.bin) || isNumericDataDef(x)) {\n            if (isFieldDef(y) && isBinned(y.bin)) {\n              return 'horizontal';\n            }\n          }\n          return 'vertical';\n        }\n        // If x is range and y is non-range, non-bin Q\n        if (!y2) {\n          if (isFieldDef(y) && y.type === QUANTITATIVE && !isBinning(y.bin) || isNumericDataDef(y)) {\n            if (isFieldDef(x) && isBinned(x.bin)) {\n              return 'vertical';\n            }\n          }\n          return 'horizontal';\n        }\n      }\n    // falls through\n    case RULE:\n      // return undefined for line segment rule and bar with both axis ranged\n      // we have to ignore the case that the data are already binned\n      if (x2 && !(isFieldDef(x) && isBinned(x.bin)) && y2 && !(isFieldDef(y) && isBinned(y.bin))) {\n        return undefined;\n      }\n    // falls through\n    case AREA:\n      // If there are range for both x and y, y (vertical) has higher precedence.\n      if (y2) {\n        if (isFieldDef(y) && isBinned(y.bin)) {\n          return 'horizontal';\n        } else {\n          return 'vertical';\n        }\n      } else if (x2) {\n        if (isFieldDef(x) && isBinned(x.bin)) {\n          return 'vertical';\n        } else {\n          return 'horizontal';\n        }\n      } else if (mark === RULE) {\n        if (x && !y) {\n          return 'vertical';\n        } else if (y && !x) {\n          return 'horizontal';\n        }\n      }\n    // falls through\n    case LINE:\n    case TICK:\n      {\n        const xIsMeasure = isUnbinnedQuantitativeFieldOrDatumDef(x);\n        const yIsMeasure = isUnbinnedQuantitativeFieldOrDatumDef(y);\n        if (specifiedOrient) {\n          return specifiedOrient;\n        } else if (xIsMeasure && !yIsMeasure) {\n          // Tick is opposite to bar, line, area\n          return mark !== 'tick' ? 'horizontal' : 'vertical';\n        } else if (!xIsMeasure && yIsMeasure) {\n          // Tick is opposite to bar, line, area\n          return mark !== 'tick' ? 'vertical' : 'horizontal';\n        } else if (xIsMeasure && yIsMeasure) {\n          return 'vertical';\n        } else {\n          const xIsTemporal = isTypedFieldDef(x) && x.type === TEMPORAL;\n          const yIsTemporal = isTypedFieldDef(y) && y.type === TEMPORAL;\n          // x: T, y: N --> vertical tick\n          if (xIsTemporal && !yIsTemporal) {\n            return 'vertical';\n          } else if (!xIsTemporal && yIsTemporal) {\n            return 'horizontal';\n          }\n        }\n        return undefined;\n      }\n  }\n  return 'vertical';\n}","map":{"version":3,"names":["isBinned","isBinning","isFieldDef","isNumericDataDef","isUnbinnedQuantitativeFieldOrDatumDef","isTypedFieldDef","isAggregate","replaceExprRef","log","AREA","BAR","BAR_CORNER_RADIUS_INDEX","BAR_CORNER_RADIUS_END_INDEX","CIRCLE","IMAGE","LINE","POINT","RECT","RULE","SQUARE","TEXT","TICK","QUANTITATIVE","TEMPORAL","contains","getFirstDefined","getMarkConfig","getMarkPropOrConfig","initMarkdef","originalMarkDef","encoding","config","markDef","specifiedOrient","orient","type","undefined","warn","message","orientOverridden","cornerRadiusEnd","newProps","x2","y2","newProp","specifiedOpacity","specifiedfillOpacity","opacity","specifiedCursor","cursor","href","mark","defaultFilled","_ref","graticule","filledConfig","x","y","bin","aggregate","xIsMeasure","yIsMeasure","xIsTemporal","yIsTemporal"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\mark\\init.ts"],"sourcesContent":["import {Orientation, SignalRef} from 'vega';\nimport {isBinned, isBinning} from '../../bin';\nimport {isFieldDef, isNumericDataDef, isUnbinnedQuantitativeFieldOrDatumDef, isTypedFieldDef} from '../../channeldef';\nimport {Config} from '../../config';\nimport {Encoding, isAggregate} from '../../encoding';\nimport {replaceExprRef} from '../../expr';\nimport * as log from '../../log';\nimport {\n  AREA,\n  BAR,\n  BAR_CORNER_RADIUS_INDEX as BAR_CORNER_RADIUS_END_INDEX,\n  CIRCLE,\n  IMAGE,\n  LINE,\n  Mark,\n  MarkDef,\n  POINT,\n  RECT,\n  RULE,\n  SQUARE,\n  TEXT,\n  TICK\n} from '../../mark';\nimport {QUANTITATIVE, TEMPORAL} from '../../type';\nimport {contains, getFirstDefined} from '../../util';\nimport {getMarkConfig, getMarkPropOrConfig} from '../common';\n\nexport function initMarkdef(originalMarkDef: MarkDef, encoding: Encoding<string>, config: Config<SignalRef>) {\n  // FIXME: markDef expects that exprRefs are replaced recursively but replaceExprRef only replaces the top level\n  const markDef: MarkDef<Mark, SignalRef> = replaceExprRef(originalMarkDef) as any;\n\n  // set orient, which can be overridden by rules as sometimes the specified orient is invalid.\n  const specifiedOrient = getMarkPropOrConfig('orient', markDef, config);\n  markDef.orient = orient(markDef.type, encoding, specifiedOrient);\n  if (specifiedOrient !== undefined && specifiedOrient !== markDef.orient) {\n    log.warn(log.message.orientOverridden(markDef.orient, specifiedOrient));\n  }\n\n  if (markDef.type === 'bar' && markDef.orient) {\n    const cornerRadiusEnd = getMarkPropOrConfig('cornerRadiusEnd', markDef, config);\n    if (cornerRadiusEnd !== undefined) {\n      const newProps =\n        (markDef.orient === 'horizontal' && encoding.x2) || (markDef.orient === 'vertical' && encoding.y2)\n          ? (['cornerRadius'] as const)\n          : BAR_CORNER_RADIUS_END_INDEX[markDef.orient];\n\n      for (const newProp of newProps) {\n        markDef[newProp] = cornerRadiusEnd;\n      }\n\n      if (markDef.cornerRadiusEnd !== undefined) {\n        delete markDef.cornerRadiusEnd; // no need to keep the original cap cornerRadius\n      }\n    }\n  }\n\n  // set opacity and filled if not specified in mark config\n  const specifiedOpacity = getMarkPropOrConfig('opacity', markDef, config);\n  const specifiedfillOpacity = getMarkPropOrConfig('fillOpacity', markDef, config);\n  if (specifiedOpacity === undefined && specifiedfillOpacity === undefined) {\n    markDef.opacity = opacity(markDef.type, encoding);\n  }\n\n  // set cursor, which should be pointer if href channel is present unless otherwise specified\n  const specifiedCursor = getMarkPropOrConfig('cursor', markDef, config);\n  if (specifiedCursor === undefined) {\n    markDef.cursor = cursor(markDef, encoding, config);\n  }\n\n  return markDef;\n}\n\nfunction cursor(markDef: MarkDef<Mark, SignalRef>, encoding: Encoding<string>, config: Config<SignalRef>) {\n  if (encoding.href || markDef.href || getMarkPropOrConfig('href', markDef, config)) {\n    return 'pointer';\n  }\n  return markDef.cursor;\n}\n\nfunction opacity(mark: Mark, encoding: Encoding<string>) {\n  if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n    // point-based marks\n    if (!isAggregate(encoding)) {\n      return 0.7;\n    }\n  }\n  return undefined;\n}\n\nexport function defaultFilled(markDef: MarkDef, config: Config<SignalRef>, {graticule}: {graticule: boolean}) {\n  if (graticule) {\n    return false;\n  }\n  const filledConfig = getMarkConfig('filled', markDef, config);\n  const mark = markDef.type;\n  return getFirstDefined(filledConfig, mark !== POINT && mark !== LINE && mark !== RULE);\n}\n\nfunction orient(mark: Mark, encoding: Encoding<string>, specifiedOrient: Orientation): Orientation {\n  switch (mark) {\n    case POINT:\n    case CIRCLE:\n    case SQUARE:\n    case TEXT:\n    case RECT:\n    case IMAGE:\n      // orient is meaningless for these marks.\n      return undefined;\n  }\n\n  const {x, y, x2, y2} = encoding;\n\n  switch (mark) {\n    case BAR:\n      if (isFieldDef(x) && (isBinned(x.bin) || (isFieldDef(y) && y.aggregate && !x.aggregate))) {\n        return 'vertical';\n      }\n      if (isFieldDef(y) && (isBinned(y.bin) || (isFieldDef(x) && x.aggregate && !y.aggregate))) {\n        return 'horizontal';\n      }\n      if (y2 || x2) {\n        // Ranged bar does not always have clear orientation, so we allow overriding\n        if (specifiedOrient) {\n          return specifiedOrient;\n        }\n\n        // If y is range and x is non-range, non-bin Q\n        if (!x2) {\n          if ((isFieldDef(x) && x.type === QUANTITATIVE && !isBinning(x.bin)) || isNumericDataDef(x)) {\n            if (isFieldDef(y) && isBinned(y.bin)) {\n              return 'horizontal';\n            }\n          }\n          return 'vertical';\n        }\n\n        // If x is range and y is non-range, non-bin Q\n        if (!y2) {\n          if ((isFieldDef(y) && y.type === QUANTITATIVE && !isBinning(y.bin)) || isNumericDataDef(y)) {\n            if (isFieldDef(x) && isBinned(x.bin)) {\n              return 'vertical';\n            }\n          }\n          return 'horizontal';\n        }\n      }\n\n    // falls through\n    case RULE:\n      // return undefined for line segment rule and bar with both axis ranged\n      // we have to ignore the case that the data are already binned\n      if (x2 && !(isFieldDef(x) && isBinned(x.bin)) && y2 && !(isFieldDef(y) && isBinned(y.bin))) {\n        return undefined;\n      }\n\n    // falls through\n    case AREA:\n      // If there are range for both x and y, y (vertical) has higher precedence.\n      if (y2) {\n        if (isFieldDef(y) && isBinned(y.bin)) {\n          return 'horizontal';\n        } else {\n          return 'vertical';\n        }\n      } else if (x2) {\n        if (isFieldDef(x) && isBinned(x.bin)) {\n          return 'vertical';\n        } else {\n          return 'horizontal';\n        }\n      } else if (mark === RULE) {\n        if (x && !y) {\n          return 'vertical';\n        } else if (y && !x) {\n          return 'horizontal';\n        }\n      }\n\n    // falls through\n    case LINE:\n    case TICK: {\n      const xIsMeasure = isUnbinnedQuantitativeFieldOrDatumDef(x);\n      const yIsMeasure = isUnbinnedQuantitativeFieldOrDatumDef(y);\n\n      if (specifiedOrient) {\n        return specifiedOrient;\n      } else if (xIsMeasure && !yIsMeasure) {\n        // Tick is opposite to bar, line, area\n        return mark !== 'tick' ? 'horizontal' : 'vertical';\n      } else if (!xIsMeasure && yIsMeasure) {\n        // Tick is opposite to bar, line, area\n        return mark !== 'tick' ? 'vertical' : 'horizontal';\n      } else if (xIsMeasure && yIsMeasure) {\n        return 'vertical';\n      } else {\n        const xIsTemporal = isTypedFieldDef(x) && x.type === TEMPORAL;\n        const yIsTemporal = isTypedFieldDef(y) && y.type === TEMPORAL;\n\n        // x: T, y: N --> vertical tick\n        if (xIsTemporal && !yIsTemporal) {\n          return 'vertical';\n        } else if (!xIsTemporal && yIsTemporal) {\n          return 'horizontal';\n        }\n      }\n      return undefined;\n    }\n  }\n  return 'vertical';\n}\n"],"mappings":"AACA,SAAQA,QAAQ,EAAEC,SAAS,QAAO,WAAW;AAC7C,SAAQC,UAAU,EAAEC,gBAAgB,EAAEC,qCAAqC,EAAEC,eAAe,QAAO,kBAAkB;AAErH,SAAkBC,WAAW,QAAO,gBAAgB;AACpD,SAAQC,cAAc,QAAO,YAAY;AACzC,OAAO,KAAKC,GAAG,MAAM,WAAW;AAChC,SACEC,IAAI,EACJC,GAAG,EACHC,uBAAuB,IAAIC,2BAA2B,EACtDC,MAAM,EACNC,KAAK,EACLC,IAAI,EAGJC,KAAK,EACLC,IAAI,EACJC,IAAI,EACJC,MAAM,EACNC,IAAI,EACJC,IAAI,QACC,YAAY;AACnB,SAAQC,YAAY,EAAEC,QAAQ,QAAO,YAAY;AACjD,SAAQC,QAAQ,EAAEC,eAAe,QAAO,YAAY;AACpD,SAAQC,aAAa,EAAEC,mBAAmB,QAAO,WAAW;AAE5D,OAAM,SAAUC,WAAWA,CAACC,eAAwB,EAAEC,QAA0B,EAAEC,MAAyB;EACzG;EACA,MAAMC,OAAO,GAA6BzB,cAAc,CAACsB,eAAe,CAAQ;EAEhF;EACA,MAAMI,eAAe,GAAGN,mBAAmB,CAAC,QAAQ,EAAEK,OAAO,EAAED,MAAM,CAAC;EACtEC,OAAO,CAACE,MAAM,GAAGA,MAAM,CAACF,OAAO,CAACG,IAAI,EAAEL,QAAQ,EAAEG,eAAe,CAAC;EAChE,IAAIA,eAAe,KAAKG,SAAS,IAAIH,eAAe,KAAKD,OAAO,CAACE,MAAM,EAAE;IACvE1B,GAAG,CAAC6B,IAAI,CAAC7B,GAAG,CAAC8B,OAAO,CAACC,gBAAgB,CAACP,OAAO,CAACE,MAAM,EAAED,eAAe,CAAC,CAAC;EACzE;EAEA,IAAID,OAAO,CAACG,IAAI,KAAK,KAAK,IAAIH,OAAO,CAACE,MAAM,EAAE;IAC5C,MAAMM,eAAe,GAAGb,mBAAmB,CAAC,iBAAiB,EAAEK,OAAO,EAAED,MAAM,CAAC;IAC/E,IAAIS,eAAe,KAAKJ,SAAS,EAAE;MACjC,MAAMK,QAAQ,GACXT,OAAO,CAACE,MAAM,KAAK,YAAY,IAAIJ,QAAQ,CAACY,EAAE,IAAMV,OAAO,CAACE,MAAM,KAAK,UAAU,IAAIJ,QAAQ,CAACa,EAAG,GAC7F,CAAC,cAAc,CAAW,GAC3B/B,2BAA2B,CAACoB,OAAO,CAACE,MAAM,CAAC;MAEjD,KAAK,MAAMU,OAAO,IAAIH,QAAQ,EAAE;QAC9BT,OAAO,CAACY,OAAO,CAAC,GAAGJ,eAAe;MACpC;MAEA,IAAIR,OAAO,CAACQ,eAAe,KAAKJ,SAAS,EAAE;QACzC,OAAOJ,OAAO,CAACQ,eAAe,CAAC,CAAC;MAClC;IACF;EACF;EAEA;EACA,MAAMK,gBAAgB,GAAGlB,mBAAmB,CAAC,SAAS,EAAEK,OAAO,EAAED,MAAM,CAAC;EACxE,MAAMe,oBAAoB,GAAGnB,mBAAmB,CAAC,aAAa,EAAEK,OAAO,EAAED,MAAM,CAAC;EAChF,IAAIc,gBAAgB,KAAKT,SAAS,IAAIU,oBAAoB,KAAKV,SAAS,EAAE;IACxEJ,OAAO,CAACe,OAAO,GAAGA,OAAO,CAACf,OAAO,CAACG,IAAI,EAAEL,QAAQ,CAAC;EACnD;EAEA;EACA,MAAMkB,eAAe,GAAGrB,mBAAmB,CAAC,QAAQ,EAAEK,OAAO,EAAED,MAAM,CAAC;EACtE,IAAIiB,eAAe,KAAKZ,SAAS,EAAE;IACjCJ,OAAO,CAACiB,MAAM,GAAGA,MAAM,CAACjB,OAAO,EAAEF,QAAQ,EAAEC,MAAM,CAAC;EACpD;EAEA,OAAOC,OAAO;AAChB;AAEA,SAASiB,MAAMA,CAACjB,OAAiC,EAAEF,QAA0B,EAAEC,MAAyB;EACtG,IAAID,QAAQ,CAACoB,IAAI,IAAIlB,OAAO,CAACkB,IAAI,IAAIvB,mBAAmB,CAAC,MAAM,EAAEK,OAAO,EAAED,MAAM,CAAC,EAAE;IACjF,OAAO,SAAS;EAClB;EACA,OAAOC,OAAO,CAACiB,MAAM;AACvB;AAEA,SAASF,OAAOA,CAACI,IAAU,EAAErB,QAA0B;EACrD,IAAIN,QAAQ,CAAC,CAACR,KAAK,EAAEK,IAAI,EAAER,MAAM,EAAEM,MAAM,CAAC,EAAEgC,IAAI,CAAC,EAAE;IACjD;IACA,IAAI,CAAC7C,WAAW,CAACwB,QAAQ,CAAC,EAAE;MAC1B,OAAO,GAAG;IACZ;EACF;EACA,OAAOM,SAAS;AAClB;AAEA,OAAM,SAAUgB,aAAaA,CAACpB,OAAgB,EAAED,MAAyB,EAAAsB,IAAA,EAAmC;EAAA,IAAjC;IAACC;EAAS,CAAuB,GAAAD,IAAA;EAC1G,IAAIC,SAAS,EAAE;IACb,OAAO,KAAK;EACd;EACA,MAAMC,YAAY,GAAG7B,aAAa,CAAC,QAAQ,EAAEM,OAAO,EAAED,MAAM,CAAC;EAC7D,MAAMoB,IAAI,GAAGnB,OAAO,CAACG,IAAI;EACzB,OAAOV,eAAe,CAAC8B,YAAY,EAAEJ,IAAI,KAAKnC,KAAK,IAAImC,IAAI,KAAKpC,IAAI,IAAIoC,IAAI,KAAKjC,IAAI,CAAC;AACxF;AAEA,SAASgB,MAAMA,CAACiB,IAAU,EAAErB,QAA0B,EAAEG,eAA4B;EAClF,QAAQkB,IAAI;IACV,KAAKnC,KAAK;IACV,KAAKH,MAAM;IACX,KAAKM,MAAM;IACX,KAAKC,IAAI;IACT,KAAKH,IAAI;IACT,KAAKH,KAAK;MACR;MACA,OAAOsB,SAAS;EACpB;EAEA,MAAM;IAACoB,CAAC;IAAEC,CAAC;IAAEf,EAAE;IAAEC;EAAE,CAAC,GAAGb,QAAQ;EAE/B,QAAQqB,IAAI;IACV,KAAKzC,GAAG;MACN,IAAIR,UAAU,CAACsD,CAAC,CAAC,KAAKxD,QAAQ,CAACwD,CAAC,CAACE,GAAG,CAAC,IAAKxD,UAAU,CAACuD,CAAC,CAAC,IAAIA,CAAC,CAACE,SAAS,IAAI,CAACH,CAAC,CAACG,SAAU,CAAC,EAAE;QACxF,OAAO,UAAU;MACnB;MACA,IAAIzD,UAAU,CAACuD,CAAC,CAAC,KAAKzD,QAAQ,CAACyD,CAAC,CAACC,GAAG,CAAC,IAAKxD,UAAU,CAACsD,CAAC,CAAC,IAAIA,CAAC,CAACG,SAAS,IAAI,CAACF,CAAC,CAACE,SAAU,CAAC,EAAE;QACxF,OAAO,YAAY;MACrB;MACA,IAAIhB,EAAE,IAAID,EAAE,EAAE;QACZ;QACA,IAAIT,eAAe,EAAE;UACnB,OAAOA,eAAe;QACxB;QAEA;QACA,IAAI,CAACS,EAAE,EAAE;UACP,IAAKxC,UAAU,CAACsD,CAAC,CAAC,IAAIA,CAAC,CAACrB,IAAI,KAAKb,YAAY,IAAI,CAACrB,SAAS,CAACuD,CAAC,CAACE,GAAG,CAAC,IAAKvD,gBAAgB,CAACqD,CAAC,CAAC,EAAE;YAC1F,IAAItD,UAAU,CAACuD,CAAC,CAAC,IAAIzD,QAAQ,CAACyD,CAAC,CAACC,GAAG,CAAC,EAAE;cACpC,OAAO,YAAY;YACrB;UACF;UACA,OAAO,UAAU;QACnB;QAEA;QACA,IAAI,CAACf,EAAE,EAAE;UACP,IAAKzC,UAAU,CAACuD,CAAC,CAAC,IAAIA,CAAC,CAACtB,IAAI,KAAKb,YAAY,IAAI,CAACrB,SAAS,CAACwD,CAAC,CAACC,GAAG,CAAC,IAAKvD,gBAAgB,CAACsD,CAAC,CAAC,EAAE;YAC1F,IAAIvD,UAAU,CAACsD,CAAC,CAAC,IAAIxD,QAAQ,CAACwD,CAAC,CAACE,GAAG,CAAC,EAAE;cACpC,OAAO,UAAU;YACnB;UACF;UACA,OAAO,YAAY;QACrB;MACF;IAEF;IACA,KAAKxC,IAAI;MACP;MACA;MACA,IAAIwB,EAAE,IAAI,EAAExC,UAAU,CAACsD,CAAC,CAAC,IAAIxD,QAAQ,CAACwD,CAAC,CAACE,GAAG,CAAC,CAAC,IAAIf,EAAE,IAAI,EAAEzC,UAAU,CAACuD,CAAC,CAAC,IAAIzD,QAAQ,CAACyD,CAAC,CAACC,GAAG,CAAC,CAAC,EAAE;QAC1F,OAAOtB,SAAS;MAClB;IAEF;IACA,KAAK3B,IAAI;MACP;MACA,IAAIkC,EAAE,EAAE;QACN,IAAIzC,UAAU,CAACuD,CAAC,CAAC,IAAIzD,QAAQ,CAACyD,CAAC,CAACC,GAAG,CAAC,EAAE;UACpC,OAAO,YAAY;QACrB,CAAC,MAAM;UACL,OAAO,UAAU;QACnB;MACF,CAAC,MAAM,IAAIhB,EAAE,EAAE;QACb,IAAIxC,UAAU,CAACsD,CAAC,CAAC,IAAIxD,QAAQ,CAACwD,CAAC,CAACE,GAAG,CAAC,EAAE;UACpC,OAAO,UAAU;QACnB,CAAC,MAAM;UACL,OAAO,YAAY;QACrB;MACF,CAAC,MAAM,IAAIP,IAAI,KAAKjC,IAAI,EAAE;QACxB,IAAIsC,CAAC,IAAI,CAACC,CAAC,EAAE;UACX,OAAO,UAAU;QACnB,CAAC,MAAM,IAAIA,CAAC,IAAI,CAACD,CAAC,EAAE;UAClB,OAAO,YAAY;QACrB;MACF;IAEF;IACA,KAAKzC,IAAI;IACT,KAAKM,IAAI;MAAE;QACT,MAAMuC,UAAU,GAAGxD,qCAAqC,CAACoD,CAAC,CAAC;QAC3D,MAAMK,UAAU,GAAGzD,qCAAqC,CAACqD,CAAC,CAAC;QAE3D,IAAIxB,eAAe,EAAE;UACnB,OAAOA,eAAe;QACxB,CAAC,MAAM,IAAI2B,UAAU,IAAI,CAACC,UAAU,EAAE;UACpC;UACA,OAAOV,IAAI,KAAK,MAAM,GAAG,YAAY,GAAG,UAAU;QACpD,CAAC,MAAM,IAAI,CAACS,UAAU,IAAIC,UAAU,EAAE;UACpC;UACA,OAAOV,IAAI,KAAK,MAAM,GAAG,UAAU,GAAG,YAAY;QACpD,CAAC,MAAM,IAAIS,UAAU,IAAIC,UAAU,EAAE;UACnC,OAAO,UAAU;QACnB,CAAC,MAAM;UACL,MAAMC,WAAW,GAAGzD,eAAe,CAACmD,CAAC,CAAC,IAAIA,CAAC,CAACrB,IAAI,KAAKZ,QAAQ;UAC7D,MAAMwC,WAAW,GAAG1D,eAAe,CAACoD,CAAC,CAAC,IAAIA,CAAC,CAACtB,IAAI,KAAKZ,QAAQ;UAE7D;UACA,IAAIuC,WAAW,IAAI,CAACC,WAAW,EAAE;YAC/B,OAAO,UAAU;UACnB,CAAC,MAAM,IAAI,CAACD,WAAW,IAAIC,WAAW,EAAE;YACtC,OAAO,YAAY;UACrB;QACF;QACA,OAAO3B,SAAS;MAClB;EACF;EACA,OAAO,UAAU;AACnB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}