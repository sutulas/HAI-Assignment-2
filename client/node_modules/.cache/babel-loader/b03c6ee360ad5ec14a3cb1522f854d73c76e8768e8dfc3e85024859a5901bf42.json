{"ast":null,"code":"import { isCountingAggregateOp } from '../../../aggregate';\nimport { isScaleChannel } from '../../../channel';\nimport { fieldValidPredicate } from '../../../predicate';\nimport { signalOrValueRef } from '../../common';\nimport { getScaleInvalidDataMode, shouldBreakPath } from '../../invalid/ScaleInvalidDataMode';\n/**\n * Create Vega's \"defined\" encoding to break paths in a path mark for invalid values.\n */\nexport function defined(model) {\n  const {\n    config,\n    markDef\n  } = model;\n  // For each channel (x/y), add fields to break path to a set first.\n  const fieldsToBreakPath = new Set();\n  model.forEachFieldDef((fieldDef, channel) => {\n    let scaleType;\n    if (!isScaleChannel(channel) || !(scaleType = model.getScaleType(channel))) {\n      // Skip if the channel is not a scale channel or does not have a scale\n      return;\n    }\n    const isCountAggregate = isCountingAggregateOp(fieldDef.aggregate);\n    const invalidDataMode = getScaleInvalidDataMode({\n      scaleChannel: channel,\n      markDef,\n      config,\n      scaleType,\n      isCountAggregate\n    });\n    if (shouldBreakPath(invalidDataMode)) {\n      const field = model.vgField(channel, {\n        expr: 'datum',\n        binSuffix: model.stack?.impute ? 'mid' : undefined\n      });\n      if (field) {\n        fieldsToBreakPath.add(field);\n      }\n    }\n  });\n  // If the set is not empty, return a defined signal.\n  if (fieldsToBreakPath.size > 0) {\n    const signal = [...fieldsToBreakPath].map(field => fieldValidPredicate(field, true)).join(' && ');\n    return {\n      defined: {\n        signal\n      }\n    };\n  }\n  return undefined;\n}\nexport function valueIfDefined(prop, value) {\n  if (value !== undefined) {\n    return {\n      [prop]: signalOrValueRef(value)\n    };\n  }\n  return undefined;\n}","map":{"version":3,"names":["isCountingAggregateOp","isScaleChannel","fieldValidPredicate","signalOrValueRef","getScaleInvalidDataMode","shouldBreakPath","defined","model","config","markDef","fieldsToBreakPath","Set","forEachFieldDef","fieldDef","channel","scaleType","getScaleType","isCountAggregate","aggregate","invalidDataMode","scaleChannel","field","vgField","expr","binSuffix","stack","impute","undefined","add","size","signal","map","join","valueIfDefined","prop","value"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\mark\\encode\\defined.ts"],"sourcesContent":["import {isCountingAggregateOp} from '../../../aggregate';\nimport {isScaleChannel} from '../../../channel';\nimport {Value} from '../../../channeldef';\nimport {fieldValidPredicate} from '../../../predicate';\nimport {VgEncodeEntry} from '../../../vega.schema';\nimport {signalOrValueRef} from '../../common';\nimport {getScaleInvalidDataMode, shouldBreakPath} from '../../invalid/ScaleInvalidDataMode';\nimport {UnitModel} from '../../unit';\n\n/**\n * Create Vega's \"defined\" encoding to break paths in a path mark for invalid values.\n */\nexport function defined(model: UnitModel): VgEncodeEntry {\n  const {config, markDef} = model;\n\n  // For each channel (x/y), add fields to break path to a set first.\n  const fieldsToBreakPath = new Set<string>();\n\n  model.forEachFieldDef((fieldDef, channel) => {\n    let scaleType;\n    if (!isScaleChannel(channel) || !(scaleType = model.getScaleType(channel))) {\n      // Skip if the channel is not a scale channel or does not have a scale\n      return;\n    }\n\n    const isCountAggregate = isCountingAggregateOp(fieldDef.aggregate);\n    const invalidDataMode = getScaleInvalidDataMode({\n      scaleChannel: channel,\n      markDef,\n      config,\n      scaleType,\n      isCountAggregate\n    });\n    if (shouldBreakPath(invalidDataMode)) {\n      const field = model.vgField(channel, {expr: 'datum', binSuffix: model.stack?.impute ? 'mid' : undefined});\n      if (field) {\n        fieldsToBreakPath.add(field);\n      }\n    }\n  });\n\n  // If the set is not empty, return a defined signal.\n  if (fieldsToBreakPath.size > 0) {\n    const signal = [...fieldsToBreakPath].map(field => fieldValidPredicate(field, true)).join(' && ');\n    return {defined: {signal}};\n  }\n  return undefined;\n}\n\nexport function valueIfDefined(prop: string, value: Value): VgEncodeEntry {\n  if (value !== undefined) {\n    return {[prop]: signalOrValueRef(value)};\n  }\n  return undefined;\n}\n"],"mappings":"AAAA,SAAQA,qBAAqB,QAAO,oBAAoB;AACxD,SAAQC,cAAc,QAAO,kBAAkB;AAE/C,SAAQC,mBAAmB,QAAO,oBAAoB;AAEtD,SAAQC,gBAAgB,QAAO,cAAc;AAC7C,SAAQC,uBAAuB,EAAEC,eAAe,QAAO,oCAAoC;AAG3F;;;AAGA,OAAM,SAAUC,OAAOA,CAACC,KAAgB;EACtC,MAAM;IAACC,MAAM;IAAEC;EAAO,CAAC,GAAGF,KAAK;EAE/B;EACA,MAAMG,iBAAiB,GAAG,IAAIC,GAAG,EAAU;EAE3CJ,KAAK,CAACK,eAAe,CAAC,CAACC,QAAQ,EAAEC,OAAO,KAAI;IAC1C,IAAIC,SAAS;IACb,IAAI,CAACd,cAAc,CAACa,OAAO,CAAC,IAAI,EAAEC,SAAS,GAAGR,KAAK,CAACS,YAAY,CAACF,OAAO,CAAC,CAAC,EAAE;MAC1E;MACA;IACF;IAEA,MAAMG,gBAAgB,GAAGjB,qBAAqB,CAACa,QAAQ,CAACK,SAAS,CAAC;IAClE,MAAMC,eAAe,GAAGf,uBAAuB,CAAC;MAC9CgB,YAAY,EAAEN,OAAO;MACrBL,OAAO;MACPD,MAAM;MACNO,SAAS;MACTE;KACD,CAAC;IACF,IAAIZ,eAAe,CAACc,eAAe,CAAC,EAAE;MACpC,MAAME,KAAK,GAAGd,KAAK,CAACe,OAAO,CAACR,OAAO,EAAE;QAACS,IAAI,EAAE,OAAO;QAAEC,SAAS,EAAEjB,KAAK,CAACkB,KAAK,EAAEC,MAAM,GAAG,KAAK,GAAGC;MAAS,CAAC,CAAC;MACzG,IAAIN,KAAK,EAAE;QACTX,iBAAiB,CAACkB,GAAG,CAACP,KAAK,CAAC;MAC9B;IACF;EACF,CAAC,CAAC;EAEF;EACA,IAAIX,iBAAiB,CAACmB,IAAI,GAAG,CAAC,EAAE;IAC9B,MAAMC,MAAM,GAAG,CAAC,GAAGpB,iBAAiB,CAAC,CAACqB,GAAG,CAACV,KAAK,IAAInB,mBAAmB,CAACmB,KAAK,EAAE,IAAI,CAAC,CAAC,CAACW,IAAI,CAAC,MAAM,CAAC;IACjG,OAAO;MAAC1B,OAAO,EAAE;QAACwB;MAAM;IAAC,CAAC;EAC5B;EACA,OAAOH,SAAS;AAClB;AAEA,OAAM,SAAUM,cAAcA,CAACC,IAAY,EAAEC,KAAY;EACvD,IAAIA,KAAK,KAAKR,SAAS,EAAE;IACvB,OAAO;MAAC,CAACO,IAAI,GAAG/B,gBAAgB,CAACgC,KAAK;IAAC,CAAC;EAC1C;EACA,OAAOR,SAAS;AAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}