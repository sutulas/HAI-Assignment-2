{"ast":null,"code":"import { isCountingAggregateOp } from '../../../aggregate';\nimport { getFieldDef, vgField } from '../../../channeldef';\nimport { isScaleInvalidDataIncludeAsValue } from '../../../invalid';\nimport { fieldValidPredicate } from '../../../predicate';\nimport { isSignalRef } from '../../../vega.schema';\nimport { getScaleInvalidDataMode } from '../../invalid/ScaleInvalidDataMode';\nimport { scaledZeroOrMinOrMax } from './scaledZeroOrMinOrMax';\nexport function getConditionalValueRefForIncludingInvalidValue(_ref) {\n  let {\n    scaleChannel,\n    channelDef,\n    scale,\n    scaleName,\n    markDef,\n    config\n  } = _ref;\n  const scaleType = scale?.get('type');\n  const fieldDef = getFieldDef(channelDef);\n  const isCountAggregate = isCountingAggregateOp(fieldDef?.aggregate);\n  const invalidDataMode = getScaleInvalidDataMode({\n    scaleChannel,\n    markDef,\n    config,\n    scaleType,\n    isCountAggregate\n  });\n  if (fieldDef && invalidDataMode === 'show') {\n    const includeAs = config.scale.invalid?.[scaleChannel] ?? 'zero-or-min';\n    return {\n      test: fieldValidPredicate(vgField(fieldDef, {\n        expr: 'datum'\n      }), false),\n      ...refForInvalidValues(includeAs, scale, scaleName)\n    };\n  }\n  return undefined;\n}\nfunction refForInvalidValues(includeAs, scale, scaleName) {\n  if (isScaleInvalidDataIncludeAsValue(includeAs)) {\n    const {\n      value\n    } = includeAs;\n    return isSignalRef(value) ? {\n      signal: value.signal\n    } : {\n      value\n    };\n  }\n  return scaledZeroOrMinOrMax({\n    scale,\n    scaleName,\n    mode: 'zeroOrMin'\n  });\n}","map":{"version":3,"names":["isCountingAggregateOp","getFieldDef","vgField","isScaleInvalidDataIncludeAsValue","fieldValidPredicate","isSignalRef","getScaleInvalidDataMode","scaledZeroOrMinOrMax","getConditionalValueRefForIncludingInvalidValue","_ref","scaleChannel","channelDef","scale","scaleName","markDef","config","scaleType","get","fieldDef","isCountAggregate","aggregate","invalidDataMode","includeAs","invalid","test","expr","refForInvalidValues","undefined","value","signal","mode"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\mark\\encode\\invalid.ts"],"sourcesContent":["import {isCountingAggregateOp} from '../../../aggregate';\nimport {NonPositionScaleChannel, PolarPositionScaleChannel, PositionScaleChannel} from '../../../channel';\nimport {getFieldDef, vgField} from '../../../channeldef';\nimport {ScaleInvalidDataShowAs, isScaleInvalidDataIncludeAsValue} from '../../../invalid';\nimport {fieldValidPredicate} from '../../../predicate';\nimport {VgValueRef, isSignalRef} from '../../../vega.schema';\nimport {getScaleInvalidDataMode} from '../../invalid/ScaleInvalidDataMode';\nimport {ScaleComponent} from '../../scale/component';\nimport {scaledZeroOrMinOrMax} from './scaledZeroOrMinOrMax';\nimport {MidPointParams} from './valueref';\n\nexport function getConditionalValueRefForIncludingInvalidValue<\n  C extends PositionScaleChannel | PolarPositionScaleChannel | NonPositionScaleChannel\n>({\n  scaleChannel,\n  channelDef,\n  scale,\n  scaleName,\n  markDef,\n  config\n}: {\n  scaleChannel: C;\n} & Pick<MidPointParams, 'scale' | 'scaleName' | 'channelDef' | 'markDef' | 'config'>): VgValueRef | undefined {\n  const scaleType = scale?.get('type');\n\n  const fieldDef = getFieldDef<string>(channelDef);\n  const isCountAggregate = isCountingAggregateOp(fieldDef?.aggregate);\n\n  const invalidDataMode = getScaleInvalidDataMode<C>({\n    scaleChannel,\n    markDef,\n    config,\n    scaleType,\n    isCountAggregate\n  });\n\n  if (fieldDef && invalidDataMode === 'show') {\n    const includeAs: ScaleInvalidDataShowAs<C> = config.scale.invalid?.[scaleChannel] ?? 'zero-or-min';\n    return {\n      test: fieldValidPredicate(vgField(fieldDef, {expr: 'datum'}), false),\n      ...refForInvalidValues(includeAs, scale, scaleName)\n    };\n  }\n  return undefined;\n}\n\nfunction refForInvalidValues<C extends PositionScaleChannel | PolarPositionScaleChannel | NonPositionScaleChannel>(\n  includeAs: ScaleInvalidDataShowAs<C>,\n  scale: ScaleComponent,\n  scaleName: string\n): VgValueRef {\n  if (isScaleInvalidDataIncludeAsValue(includeAs)) {\n    const {value} = includeAs;\n    return isSignalRef(value) ? {signal: value.signal} : {value};\n  }\n\n  return scaledZeroOrMinOrMax({\n    scale,\n    scaleName,\n    mode: 'zeroOrMin'\n  });\n}\n"],"mappings":"AAAA,SAAQA,qBAAqB,QAAO,oBAAoB;AAExD,SAAQC,WAAW,EAAEC,OAAO,QAAO,qBAAqB;AACxD,SAAgCC,gCAAgC,QAAO,kBAAkB;AACzF,SAAQC,mBAAmB,QAAO,oBAAoB;AACtD,SAAoBC,WAAW,QAAO,sBAAsB;AAC5D,SAAQC,uBAAuB,QAAO,oCAAoC;AAE1E,SAAQC,oBAAoB,QAAO,wBAAwB;AAG3D,OAAM,SAAUC,8CAA8CA,CAAAC,IAAA,EAWuB;EAAA,IATnF;IACAC,YAAY;IACZC,UAAU;IACVC,KAAK;IACLC,SAAS;IACTC,OAAO;IACPC;EAAM,CAG6E,GAAAN,IAAA;EACnF,MAAMO,SAAS,GAAGJ,KAAK,EAAEK,GAAG,CAAC,MAAM,CAAC;EAEpC,MAAMC,QAAQ,GAAGjB,WAAW,CAASU,UAAU,CAAC;EAChD,MAAMQ,gBAAgB,GAAGnB,qBAAqB,CAACkB,QAAQ,EAAEE,SAAS,CAAC;EAEnE,MAAMC,eAAe,GAAGf,uBAAuB,CAAI;IACjDI,YAAY;IACZI,OAAO;IACPC,MAAM;IACNC,SAAS;IACTG;GACD,CAAC;EAEF,IAAID,QAAQ,IAAIG,eAAe,KAAK,MAAM,EAAE;IAC1C,MAAMC,SAAS,GAA8BP,MAAM,CAACH,KAAK,CAACW,OAAO,GAAGb,YAAY,CAAC,IAAI,aAAa;IAClG,OAAO;MACLc,IAAI,EAAEpB,mBAAmB,CAACF,OAAO,CAACgB,QAAQ,EAAE;QAACO,IAAI,EAAE;MAAO,CAAC,CAAC,EAAE,KAAK,CAAC;MACpE,GAAGC,mBAAmB,CAACJ,SAAS,EAAEV,KAAK,EAAEC,SAAS;KACnD;EACH;EACA,OAAOc,SAAS;AAClB;AAEA,SAASD,mBAAmBA,CAC1BJ,SAAoC,EACpCV,KAAqB,EACrBC,SAAiB;EAEjB,IAAIV,gCAAgC,CAACmB,SAAS,CAAC,EAAE;IAC/C,MAAM;MAACM;IAAK,CAAC,GAAGN,SAAS;IACzB,OAAOjB,WAAW,CAACuB,KAAK,CAAC,GAAG;MAACC,MAAM,EAAED,KAAK,CAACC;IAAM,CAAC,GAAG;MAACD;IAAK,CAAC;EAC9D;EAEA,OAAOrB,oBAAoB,CAAC;IAC1BK,KAAK;IACLC,SAAS;IACTiB,IAAI,EAAE;GACP,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}