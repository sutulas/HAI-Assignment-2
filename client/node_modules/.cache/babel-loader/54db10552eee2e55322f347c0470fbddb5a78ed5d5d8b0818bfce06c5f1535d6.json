{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isColorChannel } from '../../channel';\nimport { title as fieldDefTitle, valueArray } from '../../channeldef';\nimport { isContinuousToContinuous } from '../../scale';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { guideFormat, guideFormatType } from '../format';\nimport { getFirstConditionValue } from './encode';\nexport const legendRules = {\n  direction: _ref => {\n    let {\n      direction\n    } = _ref;\n    return direction;\n  },\n  format: _ref2 => {\n    let {\n      fieldOrDatumDef,\n      legend,\n      config\n    } = _ref2;\n    const {\n      format,\n      formatType\n    } = legend;\n    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, false);\n  },\n  formatType: _ref3 => {\n    let {\n      legend,\n      fieldOrDatumDef,\n      scaleType\n    } = _ref3;\n    const {\n      formatType\n    } = legend;\n    return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n  },\n  gradientLength: params => {\n    const {\n      legend,\n      legendConfig\n    } = params;\n    return legend.gradientLength ?? legendConfig.gradientLength ?? defaultGradientLength(params);\n  },\n  labelOverlap: _ref4 => {\n    let {\n      legend,\n      legendConfig,\n      scaleType\n    } = _ref4;\n    return legend.labelOverlap ?? legendConfig.labelOverlap ?? defaultLabelOverlap(scaleType);\n  },\n  symbolType: _ref5 => {\n    let {\n      legend,\n      markDef,\n      channel,\n      encoding\n    } = _ref5;\n    return legend.symbolType ?? defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape);\n  },\n  title: _ref6 => {\n    let {\n      fieldOrDatumDef,\n      config\n    } = _ref6;\n    return fieldDefTitle(fieldOrDatumDef, config, {\n      allowDisabling: true\n    });\n  },\n  type: _ref7 => {\n    let {\n      legendType,\n      scaleType,\n      channel\n    } = _ref7;\n    if (isColorChannel(channel) && isContinuousToContinuous(scaleType)) {\n      if (legendType === 'gradient') {\n        return undefined;\n      }\n    } else if (legendType === 'symbol') {\n      return undefined;\n    }\n    return legendType;\n  },\n  // depended by other property, let's define upfront\n  values: _ref8 => {\n    let {\n      fieldOrDatumDef,\n      legend\n    } = _ref8;\n    return values(legend, fieldOrDatumDef);\n  }\n};\nexport function values(legend, fieldOrDatumDef) {\n  const vals = legend.values;\n  if (isArray(vals)) {\n    return valueArray(fieldOrDatumDef, vals);\n  } else if (isSignalRef(vals)) {\n    return vals;\n  }\n  return undefined;\n}\nexport function defaultSymbolType(mark, channel, shapeChannelDef, markShape) {\n  if (channel !== 'shape') {\n    // use the value from the shape encoding or the mark config if they exist\n    const shape = getFirstConditionValue(shapeChannelDef) ?? markShape;\n    if (shape) {\n      return shape;\n    }\n  }\n  switch (mark) {\n    case 'bar':\n    case 'rect':\n    case 'image':\n    case 'square':\n      return 'square';\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return 'stroke';\n    case 'arc':\n    case 'point':\n    case 'circle':\n    case 'tick':\n    case 'geoshape':\n    case 'area':\n    case 'text':\n      return 'circle';\n  }\n}\nexport function clipHeight(legendType) {\n  if (legendType === 'gradient') {\n    return 20;\n  }\n  return undefined;\n}\nexport function getLegendType(params) {\n  const {\n    legend\n  } = params;\n  return getFirstDefined(legend.type, defaultType(params));\n}\nexport function defaultType(_ref9) {\n  let {\n    channel,\n    timeUnit,\n    scaleType\n  } = _ref9;\n  // Following the logic in https://github.com/vega/vega-parser/blob/master/src/parsers/legend.js\n  if (isColorChannel(channel)) {\n    if (contains(['quarter', 'month', 'day'], timeUnit)) {\n      return 'symbol';\n    }\n    if (isContinuousToContinuous(scaleType)) {\n      return 'gradient';\n    }\n  }\n  return 'symbol';\n}\nexport function getDirection(_ref10) {\n  let {\n    legendConfig,\n    legendType,\n    orient,\n    legend\n  } = _ref10;\n  return legend.direction ?? legendConfig[legendType ? 'gradientDirection' : 'symbolDirection'] ?? defaultDirection(orient, legendType);\n}\nexport function defaultDirection(orient, legendType) {\n  switch (orient) {\n    case 'top':\n    case 'bottom':\n      return 'horizontal';\n    case 'left':\n    case 'right':\n    case 'none':\n    case undefined:\n      // undefined = \"right\" in Vega\n      return undefined;\n    // vertical is Vega's default\n    default:\n      // top-left / ...\n      // For inner legend, uses compact layout like Tableau\n      return legendType === 'gradient' ? 'horizontal' : undefined;\n  }\n}\nexport function defaultGradientLength(_ref11) {\n  let {\n    legendConfig,\n    model,\n    direction,\n    orient,\n    scaleType\n  } = _ref11;\n  const {\n    gradientHorizontalMaxLength,\n    gradientHorizontalMinLength,\n    gradientVerticalMaxLength,\n    gradientVerticalMinLength\n  } = legendConfig;\n  if (isContinuousToContinuous(scaleType)) {\n    if (direction === 'horizontal') {\n      if (orient === 'top' || orient === 'bottom') {\n        return gradientLengthSignal(model, 'width', gradientHorizontalMinLength, gradientHorizontalMaxLength);\n      } else {\n        return gradientHorizontalMinLength;\n      }\n    } else {\n      // vertical / undefined (Vega uses vertical by default)\n      return gradientLengthSignal(model, 'height', gradientVerticalMinLength, gradientVerticalMaxLength);\n    }\n  }\n  return undefined;\n}\nfunction gradientLengthSignal(model, sizeType, min, max) {\n  const sizeSignal = model.getSizeSignalRef(sizeType).signal;\n  return {\n    signal: `clamp(${sizeSignal}, ${min}, ${max})`\n  };\n}\nexport function defaultLabelOverlap(scaleType) {\n  if (contains(['quantile', 'threshold', 'log', 'symlog'], scaleType)) {\n    return 'greedy';\n  }\n  return undefined;\n}","map":{"version":3,"names":["isArray","isColorChannel","title","fieldDefTitle","valueArray","isContinuousToContinuous","contains","getFirstDefined","isSignalRef","guideFormat","guideFormatType","getFirstConditionValue","legendRules","direction","_ref","format","_ref2","fieldOrDatumDef","legend","config","formatType","type","_ref3","scaleType","gradientLength","params","legendConfig","defaultGradientLength","labelOverlap","_ref4","defaultLabelOverlap","symbolType","_ref5","markDef","channel","encoding","defaultSymbolType","shape","_ref6","allowDisabling","_ref7","legendType","undefined","values","_ref8","vals","mark","shapeChannelDef","markShape","clipHeight","getLegendType","defaultType","_ref9","timeUnit","getDirection","_ref10","orient","defaultDirection","_ref11","model","gradientHorizontalMaxLength","gradientHorizontalMinLength","gradientVerticalMaxLength","gradientVerticalMinLength","gradientLengthSignal","sizeType","min","max","sizeSignal","getSizeSignalRef","signal"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\legend\\properties.ts"],"sourcesContent":["import {LabelOverlap, LegendOrient, LegendType, Orientation, SignalRef, SymbolShape} from 'vega';\nimport {isArray} from 'vega-util';\nimport {isColorChannel} from '../../channel';\nimport {DatumDef, MarkPropFieldOrDatumDef, title as fieldDefTitle, TypedFieldDef, valueArray} from '../../channeldef';\nimport {Config} from '../../config';\nimport {Encoding} from '../../encoding';\nimport {Legend, LegendConfig, LegendInternal} from '../../legend';\nimport {Mark, MarkDef} from '../../mark';\nimport {isContinuousToContinuous, ScaleType} from '../../scale';\nimport {TimeUnit} from '../../timeunit';\nimport {contains, getFirstDefined} from '../../util';\nimport {isSignalRef} from '../../vega.schema';\nimport {guideFormat, guideFormatType} from '../format';\nimport {Model} from '../model';\nimport {UnitModel} from '../unit';\nimport {NonPositionScaleChannel} from './../../channel';\nimport {LegendComponentProps} from './component';\nimport {getFirstConditionValue} from './encode';\n\nexport interface LegendRuleParams {\n  legend: LegendInternal;\n  channel: NonPositionScaleChannel;\n  model: UnitModel;\n  markDef: MarkDef<Mark, SignalRef>;\n  encoding: Encoding<string>;\n  fieldOrDatumDef: MarkPropFieldOrDatumDef<string>;\n  legendConfig: LegendConfig<SignalRef>;\n  config: Config<SignalRef>;\n  scaleType: ScaleType;\n  orient: LegendOrient;\n  legendType: LegendType;\n  direction: Orientation;\n}\n\nexport const legendRules: {\n  [k in keyof LegendComponentProps]?: (params: LegendRuleParams) => LegendComponentProps[k];\n} = {\n  direction: ({direction}) => direction,\n\n  format: ({fieldOrDatumDef, legend, config}) => {\n    const {format, formatType} = legend;\n    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, false);\n  },\n\n  formatType: ({legend, fieldOrDatumDef, scaleType}) => {\n    const {formatType} = legend;\n    return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n  },\n\n  gradientLength: params => {\n    const {legend, legendConfig} = params;\n    return legend.gradientLength ?? legendConfig.gradientLength ?? defaultGradientLength(params);\n  },\n\n  labelOverlap: ({legend, legendConfig, scaleType}) =>\n    legend.labelOverlap ?? legendConfig.labelOverlap ?? defaultLabelOverlap(scaleType),\n\n  symbolType: ({legend, markDef, channel, encoding}) =>\n    legend.symbolType ?? defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape),\n\n  title: ({fieldOrDatumDef, config}) => fieldDefTitle(fieldOrDatumDef, config, {allowDisabling: true}),\n\n  type: ({legendType, scaleType, channel}) => {\n    if (isColorChannel(channel) && isContinuousToContinuous(scaleType)) {\n      if (legendType === 'gradient') {\n        return undefined;\n      }\n    } else if (legendType === 'symbol') {\n      return undefined;\n    }\n    return legendType;\n  }, // depended by other property, let's define upfront\n\n  values: ({fieldOrDatumDef, legend}) => values(legend, fieldOrDatumDef)\n};\n\nexport function values(legend: LegendInternal, fieldOrDatumDef: TypedFieldDef<string> | DatumDef) {\n  const vals = legend.values;\n\n  if (isArray(vals)) {\n    return valueArray(fieldOrDatumDef, vals);\n  } else if (isSignalRef(vals)) {\n    return vals;\n  }\n  return undefined;\n}\n\nexport function defaultSymbolType(\n  mark: Mark,\n  channel: NonPositionScaleChannel,\n  shapeChannelDef: Encoding<string>['shape'],\n  markShape: SymbolShape | SignalRef\n): SymbolShape | SignalRef {\n  if (channel !== 'shape') {\n    // use the value from the shape encoding or the mark config if they exist\n    const shape = getFirstConditionValue<string>(shapeChannelDef) ?? markShape;\n    if (shape) {\n      return shape;\n    }\n  }\n\n  switch (mark) {\n    case 'bar':\n    case 'rect':\n    case 'image':\n    case 'square':\n      return 'square';\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return 'stroke';\n    case 'arc':\n    case 'point':\n    case 'circle':\n    case 'tick':\n    case 'geoshape':\n    case 'area':\n    case 'text':\n      return 'circle';\n  }\n}\n\nexport function clipHeight(legendType: LegendType) {\n  if (legendType === 'gradient') {\n    return 20;\n  }\n  return undefined;\n}\n\nexport function getLegendType(params: {\n  legend: LegendInternal;\n  channel: NonPositionScaleChannel;\n  timeUnit?: TimeUnit;\n  scaleType: ScaleType;\n}): LegendType {\n  const {legend} = params;\n\n  return getFirstDefined(legend.type, defaultType(params));\n}\n\nexport function defaultType({\n  channel,\n  timeUnit,\n  scaleType\n}: {\n  channel: NonPositionScaleChannel;\n  timeUnit?: TimeUnit;\n  scaleType: ScaleType;\n}): LegendType {\n  // Following the logic in https://github.com/vega/vega-parser/blob/master/src/parsers/legend.js\n\n  if (isColorChannel(channel)) {\n    if (contains(['quarter', 'month', 'day'], timeUnit)) {\n      return 'symbol';\n    }\n\n    if (isContinuousToContinuous(scaleType)) {\n      return 'gradient';\n    }\n  }\n  return 'symbol';\n}\n\nexport function getDirection({\n  legendConfig,\n  legendType,\n  orient,\n  legend\n}: {\n  orient: LegendOrient;\n  legendConfig: LegendConfig<SignalRef>;\n  legendType: LegendType;\n  legend: Legend<SignalRef>;\n}): Orientation {\n  return (\n    legend.direction ??\n    legendConfig[legendType ? 'gradientDirection' : 'symbolDirection'] ??\n    defaultDirection(orient, legendType)\n  );\n}\n\nexport function defaultDirection(orient: LegendOrient, legendType: LegendType): 'horizontal' | undefined {\n  switch (orient) {\n    case 'top':\n    case 'bottom':\n      return 'horizontal';\n\n    case 'left':\n    case 'right':\n    case 'none':\n    case undefined: // undefined = \"right\" in Vega\n      return undefined; // vertical is Vega's default\n    default:\n      // top-left / ...\n      // For inner legend, uses compact layout like Tableau\n      return legendType === 'gradient' ? 'horizontal' : undefined;\n  }\n}\n\nexport function defaultGradientLength({\n  legendConfig,\n  model,\n  direction,\n  orient,\n  scaleType\n}: {\n  scaleType: ScaleType;\n  direction: Orientation;\n  orient: LegendOrient;\n  model: Model;\n  legendConfig: LegendConfig<SignalRef>;\n}) {\n  const {\n    gradientHorizontalMaxLength,\n    gradientHorizontalMinLength,\n    gradientVerticalMaxLength,\n    gradientVerticalMinLength\n  } = legendConfig;\n  if (isContinuousToContinuous(scaleType)) {\n    if (direction === 'horizontal') {\n      if (orient === 'top' || orient === 'bottom') {\n        return gradientLengthSignal(model, 'width', gradientHorizontalMinLength, gradientHorizontalMaxLength);\n      } else {\n        return gradientHorizontalMinLength;\n      }\n    } else {\n      // vertical / undefined (Vega uses vertical by default)\n      return gradientLengthSignal(model, 'height', gradientVerticalMinLength, gradientVerticalMaxLength);\n    }\n  }\n  return undefined;\n}\n\nfunction gradientLengthSignal(model: Model, sizeType: 'width' | 'height', min: number, max: number) {\n  const sizeSignal = model.getSizeSignalRef(sizeType).signal;\n  return {signal: `clamp(${sizeSignal}, ${min}, ${max})`};\n}\n\nexport function defaultLabelOverlap(scaleType: ScaleType): LabelOverlap {\n  if (contains(['quantile', 'threshold', 'log', 'symlog'], scaleType)) {\n    return 'greedy';\n  }\n  return undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}