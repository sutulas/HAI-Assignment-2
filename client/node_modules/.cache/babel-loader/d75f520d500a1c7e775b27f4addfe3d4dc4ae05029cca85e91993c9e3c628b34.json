{"ast":null,"code":"import { COLOR, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef, isFieldDef } from '../../channeldef';\nimport { LEGEND_SCALE_CHANNELS } from '../../legend';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport { GEOJSON } from '../../type';\nimport { deleteNestedProperty, isEmpty, keys, varName } from '../../util';\nimport { mergeTitleComponent } from '../common';\nimport { guideEncodeEntry } from '../guide';\nimport { isUnitModel } from '../model';\nimport { parseGuideResolve } from '../resolve';\nimport { parseInteractiveLegend } from '../selection/legends';\nimport { defaultTieBreaker, makeImplicit, mergeValuesWithExplicit } from '../split';\nimport { LegendComponent, LEGEND_COMPONENT_PROPERTIES } from './component';\nimport { legendEncodeRules } from './encode';\nimport { getDirection, getLegendType, legendRules } from './properties';\nexport function parseLegend(model) {\n  const legendComponent = isUnitModel(model) ? parseUnitLegend(model) : parseNonUnitLegend(model);\n  model.component.legends = legendComponent;\n  return legendComponent;\n}\nfunction parseUnitLegend(model) {\n  const {\n    encoding\n  } = model;\n  const legendComponent = {};\n  for (const channel of [COLOR, ...LEGEND_SCALE_CHANNELS]) {\n    const def = getFieldOrDatumDef(encoding[channel]);\n    if (!def || !model.getScaleComponent(channel)) {\n      continue;\n    }\n    if (channel === SHAPE && isFieldDef(def) && def.type === GEOJSON) {\n      continue;\n    }\n    legendComponent[channel] = parseLegendForChannel(model, channel);\n  }\n  return legendComponent;\n}\nfunction getLegendDefWithScale(model, channel) {\n  const scale = model.scaleName(channel);\n  if (model.mark === 'trail') {\n    if (channel === 'color') {\n      // trail is a filled mark, but its default symbolType (\"stroke\") should use \"stroke\"\n      return {\n        stroke: scale\n      };\n    } else if (channel === 'size') {\n      return {\n        strokeWidth: scale\n      };\n    }\n  }\n  if (channel === 'color') {\n    return model.markDef.filled ? {\n      fill: scale\n    } : {\n      stroke: scale\n    };\n  }\n  return {\n    [channel]: scale\n  };\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isExplicit(value, property, legend, fieldDef) {\n  switch (property) {\n    case 'disable':\n      return legend !== undefined;\n    // if axis is specified or null/false, then its enable/disable state is explicit\n    case 'values':\n      // specified legend.values is already respected, but may get transformed.\n      return !!legend?.values;\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (property === 'title' && value === fieldDef?.title) {\n        return true;\n      }\n  }\n  // Otherwise, things are explicit if the returned value matches the specified property\n  return value === (legend || {})[property];\n}\nexport function parseLegendForChannel(model, channel) {\n  let legend = model.legend(channel);\n  const {\n    markDef,\n    encoding,\n    config\n  } = model;\n  const legendConfig = config.legend;\n  const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));\n  parseInteractiveLegend(model, channel, legendCmpt);\n  const disable = legend !== undefined ? !legend : legendConfig.disable;\n  legendCmpt.set('disable', disable, legend !== undefined);\n  if (disable) {\n    return legendCmpt;\n  }\n  legend = legend || {};\n  const scaleType = model.getScaleComponent(channel).get('type');\n  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n  const timeUnit = isFieldDef(fieldOrDatumDef) ? normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit : undefined;\n  const orient = legend.orient || config.legend.orient || 'right';\n  const legendType = getLegendType({\n    legend,\n    channel,\n    timeUnit,\n    scaleType\n  });\n  const direction = getDirection({\n    legend,\n    legendType,\n    orient,\n    legendConfig\n  });\n  const ruleParams = {\n    legend,\n    channel,\n    model,\n    markDef,\n    encoding,\n    fieldOrDatumDef,\n    legendConfig,\n    config,\n    scaleType,\n    orient,\n    legendType,\n    direction\n  };\n  for (const property of LEGEND_COMPONENT_PROPERTIES) {\n    if (legendType === 'gradient' && property.startsWith('symbol') || legendType === 'symbol' && property.startsWith('gradient')) {\n      continue;\n    }\n    const value = property in legendRules ? legendRules[property](ruleParams) : legend[property];\n    if (value !== undefined) {\n      const explicit = isExplicit(value, property, legend, model.fieldDef(channel));\n      if (explicit || config.legend[property] === undefined) {\n        legendCmpt.set(property, value, explicit);\n      }\n    }\n  }\n  const legendEncoding = legend?.encoding ?? {};\n  const selections = legendCmpt.get('selections');\n  const legendEncode = {};\n  const legendEncodeParams = {\n    fieldOrDatumDef,\n    model,\n    channel,\n    legendCmpt,\n    legendType\n  };\n  for (const part of ['labels', 'legend', 'title', 'symbols', 'gradient', 'entries']) {\n    // FIXME: remove as any (figure out what legendEncoding.entries is)\n    const legendEncodingPart = guideEncodeEntry(legendEncoding[part] ?? {}, model);\n    const value = part in legendEncodeRules ? legendEncodeRules[part](legendEncodingPart, legendEncodeParams) // apply rule\n    : legendEncodingPart; // no rule -- just default values\n    if (value !== undefined && !isEmpty(value)) {\n      legendEncode[part] = {\n        ...(selections?.length && isFieldDef(fieldOrDatumDef) ? {\n          name: `${varName(fieldOrDatumDef.field)}_legend_${part}`\n        } : {}),\n        ...(selections?.length ? {\n          interactive: !!selections\n        } : {}),\n        update: value\n      };\n    }\n  }\n  if (!isEmpty(legendEncode)) {\n    legendCmpt.set('encode', legendEncode, !!legend?.encoding);\n  }\n  return legendCmpt;\n}\nfunction parseNonUnitLegend(model) {\n  const {\n    legends,\n    resolve\n  } = model.component;\n  for (const child of model.children) {\n    parseLegend(child);\n    for (const channel of keys(child.component.legends)) {\n      resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);\n      if (resolve.legend[channel] === 'shared') {\n        // If the resolve says shared (and has not been overridden)\n        // We will try to merge and see if there is a conflict\n        legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);\n        if (!legends[channel]) {\n          // If merge returns nothing, there is a conflict so we cannot make the legend shared.\n          // Thus, mark legend as independent and remove the legend component.\n          resolve.legend[channel] = 'independent';\n          delete legends[channel];\n        }\n      }\n    }\n  }\n  for (const channel of keys(legends)) {\n    for (const child of model.children) {\n      if (!child.component.legends[channel]) {\n        // skip if the child does not have a particular legend\n        continue;\n      }\n      if (resolve.legend[channel] === 'shared') {\n        // After merging shared legend, make sure to remove legend from child\n        delete child.component.legends[channel];\n      }\n    }\n  }\n  return legends;\n}\nexport function mergeLegendComponent(mergedLegend, childLegend) {\n  if (!mergedLegend) {\n    return childLegend.clone();\n  }\n  const mergedOrient = mergedLegend.getWithExplicit('orient');\n  const childOrient = childLegend.getWithExplicit('orient');\n  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n    // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n    // Cannot merge due to inconsistent orient\n    return undefined;\n  }\n  let typeMerged = false;\n  // Otherwise, let's merge\n  for (const prop of LEGEND_COMPONENT_PROPERTIES) {\n    const mergedValueWithExplicit = mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop), childLegend.getWithExplicit(prop), prop, 'legend',\n    // Tie breaker function\n    (v1, v2) => {\n      switch (prop) {\n        case 'symbolType':\n          return mergeSymbolType(v1, v2);\n        case 'title':\n          return mergeTitleComponent(v1, v2);\n        case 'type':\n          // There are only two types. If we have different types, then prefer symbol over gradient.\n          typeMerged = true;\n          return makeImplicit('symbol');\n      }\n      return defaultTieBreaker(v1, v2, prop, 'legend');\n    });\n    mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);\n  }\n  if (typeMerged) {\n    if (mergedLegend.implicit?.encode?.gradient) {\n      deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);\n    }\n    if (mergedLegend.explicit?.encode?.gradient) {\n      deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);\n    }\n  }\n  return mergedLegend;\n}\nfunction mergeSymbolType(st1, st2) {\n  if (st2.value === 'circle') {\n    // prefer \"circle\" over \"stroke\"\n    return st2;\n  }\n  return st1;\n}","map":{"version":3,"names":["COLOR","SHAPE","getFieldOrDatumDef","isFieldDef","LEGEND_SCALE_CHANNELS","normalizeTimeUnit","GEOJSON","deleteNestedProperty","isEmpty","keys","varName","mergeTitleComponent","guideEncodeEntry","isUnitModel","parseGuideResolve","parseInteractiveLegend","defaultTieBreaker","makeImplicit","mergeValuesWithExplicit","LegendComponent","LEGEND_COMPONENT_PROPERTIES","legendEncodeRules","getDirection","getLegendType","legendRules","parseLegend","model","legendComponent","parseUnitLegend","parseNonUnitLegend","component","legends","encoding","channel","def","getScaleComponent","type","parseLegendForChannel","getLegendDefWithScale","scale","scaleName","mark","stroke","strokeWidth","markDef","filled","fill","isExplicit","value","property","legend","fieldDef","undefined","values","title","config","legendConfig","legendCmpt","disable","set","scaleType","get","fieldOrDatumDef","timeUnit","unit","orient","legendType","direction","ruleParams","startsWith","explicit","legendEncoding","selections","legendEncode","legendEncodeParams","part","legendEncodingPart","length","name","field","interactive","update","resolve","child","children","mergeLegendComponent","mergedLegend","childLegend","clone","mergedOrient","getWithExplicit","childOrient","typeMerged","prop","mergedValueWithExplicit","v1","v2","mergeSymbolType","setWithExplicit","implicit","encode","gradient","st1","st2"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\legend\\parse.ts"],"sourcesContent":["import {Legend as VgLegend, LegendEncode} from 'vega';\nimport {COLOR, NonPositionScaleChannel, SHAPE} from '../../channel';\nimport {DatumDef, FieldDef, getFieldOrDatumDef, isFieldDef, MarkPropDatumDef, MarkPropFieldDef} from '../../channeldef';\nimport {LegendInternal, LEGEND_SCALE_CHANNELS} from '../../legend';\nimport {normalizeTimeUnit} from '../../timeunit';\nimport {GEOJSON} from '../../type';\nimport {deleteNestedProperty, isEmpty, keys, varName} from '../../util';\nimport {mergeTitleComponent} from '../common';\nimport {guideEncodeEntry} from '../guide';\nimport {isUnitModel, Model} from '../model';\nimport {parseGuideResolve} from '../resolve';\nimport {parseInteractiveLegend} from '../selection/legends';\nimport {defaultTieBreaker, Explicit, makeImplicit, mergeValuesWithExplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {LegendComponent, LegendComponentIndex, LegendComponentProps, LEGEND_COMPONENT_PROPERTIES} from './component';\nimport {LegendEncodeParams, legendEncodeRules} from './encode';\nimport {getDirection, getLegendType, LegendRuleParams, legendRules} from './properties';\n\nexport function parseLegend(model: Model) {\n  const legendComponent = isUnitModel(model) ? parseUnitLegend(model) : parseNonUnitLegend(model);\n  model.component.legends = legendComponent;\n  return legendComponent;\n}\n\nfunction parseUnitLegend(model: UnitModel): LegendComponentIndex {\n  const {encoding} = model;\n\n  const legendComponent: LegendComponentIndex = {};\n\n  for (const channel of [COLOR, ...LEGEND_SCALE_CHANNELS]) {\n    const def = getFieldOrDatumDef(encoding[channel]) as MarkPropFieldDef<string> | MarkPropDatumDef<string>;\n\n    if (!def || !model.getScaleComponent(channel)) {\n      continue;\n    }\n\n    if (channel === SHAPE && isFieldDef(def) && def.type === GEOJSON) {\n      continue;\n    }\n\n    legendComponent[channel] = parseLegendForChannel(model, channel);\n  }\n\n  return legendComponent;\n}\n\nfunction getLegendDefWithScale(model: UnitModel, channel: NonPositionScaleChannel): VgLegend {\n  const scale = model.scaleName(channel);\n  if (model.mark === 'trail') {\n    if (channel === 'color') {\n      // trail is a filled mark, but its default symbolType (\"stroke\") should use \"stroke\"\n      return {stroke: scale};\n    } else if (channel === 'size') {\n      return {strokeWidth: scale};\n    }\n  }\n\n  if (channel === 'color') {\n    return model.markDef.filled ? {fill: scale} : {stroke: scale};\n  }\n  return {[channel]: scale};\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isExplicit<T extends string | number | object | boolean>(\n  value: T,\n  property: keyof LegendComponentProps,\n  legend: LegendInternal,\n  fieldDef: FieldDef<string>\n) {\n  switch (property) {\n    case 'disable':\n      return legend !== undefined; // if axis is specified or null/false, then its enable/disable state is explicit\n    case 'values':\n      // specified legend.values is already respected, but may get transformed.\n      return !!legend?.values;\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (property === 'title' && value === fieldDef?.title) {\n        return true;\n      }\n  }\n  // Otherwise, things are explicit if the returned value matches the specified property\n  return value === (legend || ({} as any))[property];\n}\n\nexport function parseLegendForChannel(model: UnitModel, channel: NonPositionScaleChannel): LegendComponent {\n  let legend = model.legend(channel);\n\n  const {markDef, encoding, config} = model;\n  const legendConfig = config.legend;\n  const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));\n  parseInteractiveLegend(model, channel, legendCmpt);\n\n  const disable = legend !== undefined ? !legend : legendConfig.disable;\n  legendCmpt.set('disable', disable, legend !== undefined);\n  if (disable) {\n    return legendCmpt;\n  }\n\n  legend = legend || {};\n\n  const scaleType = model.getScaleComponent(channel).get('type');\n  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) as MarkPropFieldDef<string> | DatumDef;\n  const timeUnit = isFieldDef(fieldOrDatumDef) ? normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit : undefined;\n\n  const orient = legend.orient || config.legend.orient || 'right';\n  const legendType = getLegendType({legend, channel, timeUnit, scaleType});\n\n  const direction = getDirection({legend, legendType, orient, legendConfig});\n\n  const ruleParams: LegendRuleParams = {\n    legend,\n    channel,\n    model,\n    markDef,\n    encoding,\n    fieldOrDatumDef,\n    legendConfig,\n    config,\n    scaleType,\n    orient,\n    legendType,\n    direction\n  };\n\n  for (const property of LEGEND_COMPONENT_PROPERTIES) {\n    if (\n      (legendType === 'gradient' && property.startsWith('symbol')) ||\n      (legendType === 'symbol' && property.startsWith('gradient'))\n    ) {\n      continue;\n    }\n\n    const value = property in legendRules ? legendRules[property](ruleParams) : (legend as any)[property];\n    if (value !== undefined) {\n      const explicit = isExplicit(value, property, legend, model.fieldDef(channel));\n      if (explicit || (config.legend as any)[property] === undefined) {\n        legendCmpt.set(property, value, explicit);\n      }\n    }\n  }\n\n  const legendEncoding = legend?.encoding ?? {};\n  const selections = legendCmpt.get('selections');\n  const legendEncode: LegendEncode = {};\n\n  const legendEncodeParams: LegendEncodeParams = {fieldOrDatumDef, model, channel, legendCmpt, legendType};\n\n  for (const part of ['labels', 'legend', 'title', 'symbols', 'gradient', 'entries'] as const) {\n    // FIXME: remove as any (figure out what legendEncoding.entries is)\n    const legendEncodingPart = guideEncodeEntry((legendEncoding as any)[part] ?? {}, model);\n\n    const value =\n      part in legendEncodeRules\n        ? legendEncodeRules[part](legendEncodingPart, legendEncodeParams) // apply rule\n        : legendEncodingPart; // no rule -- just default values\n\n    if (value !== undefined && !isEmpty(value)) {\n      legendEncode[part] = {\n        ...(selections?.length && isFieldDef(fieldOrDatumDef)\n          ? {name: `${varName(fieldOrDatumDef.field)}_legend_${part}`}\n          : {}),\n        ...(selections?.length ? {interactive: !!selections} : {}),\n        update: value\n      };\n    }\n  }\n\n  if (!isEmpty(legendEncode)) {\n    legendCmpt.set('encode', legendEncode, !!legend?.encoding);\n  }\n\n  return legendCmpt;\n}\n\nfunction parseNonUnitLegend(model: Model) {\n  const {legends, resolve} = model.component;\n\n  for (const child of model.children) {\n    parseLegend(child);\n\n    for (const channel of keys(child.component.legends)) {\n      resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);\n\n      if (resolve.legend[channel] === 'shared') {\n        // If the resolve says shared (and has not been overridden)\n        // We will try to merge and see if there is a conflict\n\n        legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);\n\n        if (!legends[channel]) {\n          // If merge returns nothing, there is a conflict so we cannot make the legend shared.\n          // Thus, mark legend as independent and remove the legend component.\n          resolve.legend[channel] = 'independent';\n          delete legends[channel];\n        }\n      }\n    }\n  }\n\n  for (const channel of keys(legends)) {\n    for (const child of model.children) {\n      if (!child.component.legends[channel]) {\n        // skip if the child does not have a particular legend\n        continue;\n      }\n\n      if (resolve.legend[channel] === 'shared') {\n        // After merging shared legend, make sure to remove legend from child\n        delete child.component.legends[channel];\n      }\n    }\n  }\n\n  return legends;\n}\n\nexport function mergeLegendComponent(mergedLegend: LegendComponent, childLegend: LegendComponent): LegendComponent {\n  if (!mergedLegend) {\n    return childLegend.clone();\n  }\n  const mergedOrient = mergedLegend.getWithExplicit('orient');\n  const childOrient = childLegend.getWithExplicit('orient');\n\n  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n    // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n    // Cannot merge due to inconsistent orient\n    return undefined;\n  }\n\n  let typeMerged = false;\n  // Otherwise, let's merge\n  for (const prop of LEGEND_COMPONENT_PROPERTIES) {\n    const mergedValueWithExplicit = mergeValuesWithExplicit<LegendComponentProps, any>(\n      mergedLegend.getWithExplicit(prop),\n      childLegend.getWithExplicit(prop),\n      prop,\n      'legend',\n\n      // Tie breaker function\n      (v1: Explicit<any>, v2: Explicit<any>): any => {\n        switch (prop) {\n          case 'symbolType':\n            return mergeSymbolType(v1, v2);\n          case 'title':\n            return mergeTitleComponent(v1, v2);\n          case 'type':\n            // There are only two types. If we have different types, then prefer symbol over gradient.\n            typeMerged = true;\n            return makeImplicit('symbol');\n        }\n        return defaultTieBreaker<LegendComponentProps, any>(v1, v2, prop, 'legend');\n      }\n    );\n    mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);\n  }\n  if (typeMerged) {\n    if (mergedLegend.implicit?.encode?.gradient) {\n      deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);\n    }\n    if (mergedLegend.explicit?.encode?.gradient) {\n      deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);\n    }\n  }\n\n  return mergedLegend;\n}\n\nfunction mergeSymbolType(st1: Explicit<string>, st2: Explicit<string>) {\n  if (st2.value === 'circle') {\n    // prefer \"circle\" over \"stroke\"\n    return st2;\n  }\n  return st1;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}