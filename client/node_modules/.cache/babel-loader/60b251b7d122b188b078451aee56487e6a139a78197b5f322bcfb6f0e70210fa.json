{"ast":null,"code":"import { DataSourceType } from '../../data';\nimport { normalizeInvalidDataMode } from './normalizeInvalidDataMode';\nexport function getDataSourcesForHandlingInvalidValues(_ref) {\n  let {\n    invalid,\n    isPath\n  } = _ref;\n  const normalizedInvalid = normalizeInvalidDataMode(invalid, {\n    isPath\n  });\n  switch (normalizedInvalid) {\n    case 'filter':\n      // Both marks and scales use post-filter data\n      return {\n        marks: 'exclude-invalid-values',\n        scales: 'exclude-invalid-values'\n      };\n    case 'break-paths-show-domains':\n      return {\n        // Path-based marks use pre-filter data so we know to skip these invalid points in the path.\n        // For non-path based marks, we skip by not showing them at all.\n        marks: isPath ? 'include-invalid-values' : 'exclude-invalid-values',\n        scales: 'include-invalid-values'\n      };\n    case 'break-paths-filter-domains':\n      // For path marks, the marks will use unfiltered data (and skip points). But we need a separate data sources to feed the domain.\n      // For non-path marks, we can use the filtered data for both marks and scales.\n      return {\n        marks: isPath ? 'include-invalid-values' : 'exclude-invalid-values',\n        // Unlike 'break-paths-show-domains', 'break-paths-filter-domains' uses post-filter data to feed scale.\n        scales: 'exclude-invalid-values'\n      };\n    case 'show':\n      return {\n        marks: 'include-invalid-values',\n        scales: 'include-invalid-values'\n      };\n  }\n}\nexport function getScaleDataSourceForHandlingInvalidValues(props) {\n  const {\n    marks,\n    scales\n  } = getDataSourcesForHandlingInvalidValues(props);\n  if (marks === scales) {\n    // If both marks and scales use the same data, there is only the main data source.\n    return DataSourceType.Main;\n  }\n  // If marks and scales use differetnt data, return the pre/post-filter data source accordingly.\n  return scales === 'include-invalid-values' ? DataSourceType.PreFilterInvalid : DataSourceType.PostFilterInvalid;\n}","map":{"version":3,"names":["DataSourceType","normalizeInvalidDataMode","getDataSourcesForHandlingInvalidValues","_ref","invalid","isPath","normalizedInvalid","marks","scales","getScaleDataSourceForHandlingInvalidValues","props","Main","PreFilterInvalid","PostFilterInvalid"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\invalid\\datasources.ts"],"sourcesContent":["import {MarkInvalidDataMode} from '../../invalid';\n\nimport {DataSourceType} from '../../data';\nimport {normalizeInvalidDataMode} from './normalizeInvalidDataMode';\n\ntype PreOrPostFilteringInvalidValues = 'include-invalid-values' | 'exclude-invalid-values';\n\nexport interface DataSourcesForHandlingInvalidValues {\n  marks: PreOrPostFilteringInvalidValues;\n  scales: PreOrPostFilteringInvalidValues;\n}\ninterface GetDataSourcesForHandlingInvalidValuesProps {\n  invalid: MarkInvalidDataMode | null | undefined;\n  isPath: boolean;\n}\n\nexport function getDataSourcesForHandlingInvalidValues({\n  invalid,\n  isPath\n}: GetDataSourcesForHandlingInvalidValuesProps): DataSourcesForHandlingInvalidValues {\n  const normalizedInvalid = normalizeInvalidDataMode(invalid, {isPath});\n\n  switch (normalizedInvalid) {\n    case 'filter':\n      // Both marks and scales use post-filter data\n      return {\n        marks: 'exclude-invalid-values',\n        scales: 'exclude-invalid-values'\n      };\n    case 'break-paths-show-domains':\n      return {\n        // Path-based marks use pre-filter data so we know to skip these invalid points in the path.\n        // For non-path based marks, we skip by not showing them at all.\n        marks: isPath ? 'include-invalid-values' : 'exclude-invalid-values',\n        scales: 'include-invalid-values'\n      };\n    case 'break-paths-filter-domains':\n      // For path marks, the marks will use unfiltered data (and skip points). But we need a separate data sources to feed the domain.\n      // For non-path marks, we can use the filtered data for both marks and scales.\n      return {\n        marks: isPath ? 'include-invalid-values' : 'exclude-invalid-values',\n        // Unlike 'break-paths-show-domains', 'break-paths-filter-domains' uses post-filter data to feed scale.\n        scales: 'exclude-invalid-values'\n      };\n    case 'show':\n      return {\n        marks: 'include-invalid-values',\n        scales: 'include-invalid-values'\n      };\n  }\n}\n\nexport function getScaleDataSourceForHandlingInvalidValues(\n  props: GetDataSourcesForHandlingInvalidValuesProps\n): DataSourceType {\n  const {marks, scales} = getDataSourcesForHandlingInvalidValues(props);\n  if (marks === scales) {\n    // If both marks and scales use the same data, there is only the main data source.\n    return DataSourceType.Main;\n  }\n  // If marks and scales use differetnt data, return the pre/post-filter data source accordingly.\n  return scales === 'include-invalid-values' ? DataSourceType.PreFilterInvalid : DataSourceType.PostFilterInvalid;\n}\n"],"mappings":"AAEA,SAAQA,cAAc,QAAO,YAAY;AACzC,SAAQC,wBAAwB,QAAO,4BAA4B;AAanE,OAAM,SAAUC,sCAAsCA,CAAAC,IAAA,EAGR;EAAA,IAHS;IACrDC,OAAO;IACPC;EAAM,CACsC,GAAAF,IAAA;EAC5C,MAAMG,iBAAiB,GAAGL,wBAAwB,CAACG,OAAO,EAAE;IAACC;EAAM,CAAC,CAAC;EAErE,QAAQC,iBAAiB;IACvB,KAAK,QAAQ;MACX;MACA,OAAO;QACLC,KAAK,EAAE,wBAAwB;QAC/BC,MAAM,EAAE;OACT;IACH,KAAK,0BAA0B;MAC7B,OAAO;QACL;QACA;QACAD,KAAK,EAAEF,MAAM,GAAG,wBAAwB,GAAG,wBAAwB;QACnEG,MAAM,EAAE;OACT;IACH,KAAK,4BAA4B;MAC/B;MACA;MACA,OAAO;QACLD,KAAK,EAAEF,MAAM,GAAG,wBAAwB,GAAG,wBAAwB;QACnE;QACAG,MAAM,EAAE;OACT;IACH,KAAK,MAAM;MACT,OAAO;QACLD,KAAK,EAAE,wBAAwB;QAC/BC,MAAM,EAAE;OACT;EACL;AACF;AAEA,OAAM,SAAUC,0CAA0CA,CACxDC,KAAkD;EAElD,MAAM;IAACH,KAAK;IAAEC;EAAM,CAAC,GAAGN,sCAAsC,CAACQ,KAAK,CAAC;EACrE,IAAIH,KAAK,KAAKC,MAAM,EAAE;IACpB;IACA,OAAOR,cAAc,CAACW,IAAI;EAC5B;EACA;EACA,OAAOH,MAAM,KAAK,wBAAwB,GAAGR,cAAc,CAACY,gBAAgB,GAAGZ,cAAc,CAACa,iBAAiB;AACjH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}