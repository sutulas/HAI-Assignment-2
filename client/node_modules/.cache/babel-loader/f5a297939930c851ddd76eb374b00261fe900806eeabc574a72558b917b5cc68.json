{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW } from '../../channel';\nimport { vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { hasDiscreteDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../../sort';\nimport { hash } from '../../util';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { HEADER_CHANNELS, HEADER_TYPES } from '../header/component';\nimport { assembleDomain, getFieldFromDomain } from '../scale/domain';\nimport { sortArrayIndexField } from './calculate';\nimport { DataFlowNode } from './dataflow';\n/**\n * A node that helps us track what fields we are faceting by.\n */\nexport class FacetNode extends DataFlowNode {\n  /**\n   * @param model The facet model.\n   * @param name The name that this facet source will have.\n   * @param data The source data for this facet data.\n   */\n  constructor(parent, model, name, data) {\n    super(parent);\n    this.model = model;\n    this.name = name;\n    this.data = data;\n    for (const channel of FACET_CHANNELS) {\n      const fieldDef = model.facet[channel];\n      if (fieldDef) {\n        const {\n          bin,\n          sort\n        } = fieldDef;\n        this[channel] = {\n          name: model.getName(`${channel}_domain`),\n          fields: [vgField(fieldDef), ...(isBinning(bin) ? [vgField(fieldDef, {\n            binSuffix: 'end'\n          })] : [])],\n          ...(isSortField(sort) ? {\n            sortField: sort\n          } : isArray(sort) ? {\n            sortIndexField: sortArrayIndexField(fieldDef, channel)\n          } : {})\n        };\n      }\n    }\n    this.childModel = model.child;\n  }\n  hash() {\n    let out = `Facet`;\n    for (const channel of FACET_CHANNELS) {\n      if (this[channel]) {\n        out += ` ${channel.charAt(0)}:${hash(this[channel])}`;\n      }\n    }\n    return out;\n  }\n  get fields() {\n    const f = [];\n    for (const channel of FACET_CHANNELS) {\n      if (this[channel]?.fields) {\n        f.push(...this[channel].fields);\n      }\n    }\n    return f;\n  }\n  dependentFields() {\n    const depFields = new Set(this.fields);\n    for (const channel of FACET_CHANNELS) {\n      if (this[channel]) {\n        if (this[channel].sortField) {\n          depFields.add(this[channel].sortField.field);\n        }\n        if (this[channel].sortIndexField) {\n          depFields.add(this[channel].sortIndexField);\n        }\n      }\n    }\n    return depFields;\n  }\n  producedFields() {\n    return new Set(); // facet does not produce any new fields\n  }\n  /**\n   * The name to reference this source is its name.\n   */\n  getSource() {\n    return this.name;\n  }\n  getChildIndependentFieldsWithStep() {\n    const childIndependentFieldsWithStep = {};\n    for (const channel of POSITION_SCALE_CHANNELS) {\n      const childScaleComponent = this.childModel.component.scales[channel];\n      if (childScaleComponent && !childScaleComponent.merged) {\n        // independent scale\n        const type = childScaleComponent.get('type');\n        const range = childScaleComponent.get('range');\n        if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n          const domain = assembleDomain(this.childModel, channel);\n          const field = getFieldFromDomain(domain);\n          if (field) {\n            childIndependentFieldsWithStep[channel] = field;\n          } else {\n            log.warn(log.message.unknownField(channel));\n          }\n        }\n      }\n    }\n    return childIndependentFieldsWithStep;\n  }\n  assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {\n    const childChannel = {\n      row: 'y',\n      column: 'x',\n      facet: undefined\n    }[channel];\n    const fields = [];\n    const ops = [];\n    const as = [];\n    if (childChannel && childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {\n      if (crossedDataName) {\n        // If there is a crossed data, calculate max\n        fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n        ops.push('max');\n      } else {\n        // If there is no crossed data, just calculate distinct\n        fields.push(childIndependentFieldsWithStep[childChannel]);\n        ops.push('distinct');\n      }\n      // Although it is technically a max, just name it distinct so it's easier to refer to it\n      as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n    }\n    const {\n      sortField,\n      sortIndexField\n    } = this[channel];\n    if (sortField) {\n      const {\n        op = DEFAULT_SORT_OP,\n        field\n      } = sortField;\n      fields.push(field);\n      ops.push(op);\n      as.push(vgField(sortField, {\n        forAs: true\n      }));\n    } else if (sortIndexField) {\n      fields.push(sortIndexField);\n      ops.push('max');\n      as.push(sortIndexField);\n    }\n    return {\n      name: this[channel].name,\n      // Use data from the crossed one if it exist\n      source: crossedDataName ?? this.data,\n      transform: [{\n        type: 'aggregate',\n        groupby: this[channel].fields,\n        ...(fields.length ? {\n          fields,\n          ops,\n          as\n        } : {})\n      }]\n    };\n  }\n  assembleFacetHeaderData(childIndependentFieldsWithStep) {\n    const {\n      columns\n    } = this.model.layout;\n    const {\n      layoutHeaders\n    } = this.model.component;\n    const data = [];\n    const hasSharedAxis = {};\n    for (const headerChannel of HEADER_CHANNELS) {\n      for (const headerType of HEADER_TYPES) {\n        const headers = (layoutHeaders[headerChannel] && layoutHeaders[headerChannel][headerType]) ?? [];\n        for (const header of headers) {\n          if (header.axes?.length > 0) {\n            hasSharedAxis[headerChannel] = true;\n            break;\n          }\n        }\n      }\n      if (hasSharedAxis[headerChannel]) {\n        const cardinality = `length(data(\"${this.facet.name}\"))`;\n        const stop = headerChannel === 'row' ? columns ? {\n          signal: `ceil(${cardinality} / ${columns})`\n        } : 1 : columns ? {\n          signal: `min(${cardinality}, ${columns})`\n        } : {\n          signal: cardinality\n        };\n        data.push({\n          name: `${this.facet.name}_${headerChannel}`,\n          transform: [{\n            type: 'sequence',\n            start: 0,\n            stop\n          }]\n        });\n      }\n    }\n    const {\n      row,\n      column\n    } = hasSharedAxis;\n    if (row || column) {\n      data.unshift(this.assembleRowColumnHeaderData('facet', null, childIndependentFieldsWithStep));\n    }\n    return data;\n  }\n  assemble() {\n    const data = [];\n    let crossedDataName = null;\n    const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();\n    const {\n      column,\n      row,\n      facet\n    } = this;\n    if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {\n      // Need to create a cross dataset to correctly calculate cardinality\n      crossedDataName = `cross_${this.column.name}_${this.row.name}`;\n      const fields = [].concat(childIndependentFieldsWithStep.x ?? [], childIndependentFieldsWithStep.y ?? []);\n      const ops = fields.map(() => 'distinct');\n      data.push({\n        name: crossedDataName,\n        source: this.data,\n        transform: [{\n          type: 'aggregate',\n          groupby: this.fields,\n          fields,\n          ops\n        }]\n      });\n    }\n    for (const channel of [COLUMN, ROW]) {\n      if (this[channel]) {\n        data.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));\n      }\n    }\n    if (facet) {\n      const facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);\n      if (facetData) {\n        data.push(...facetData);\n      }\n    }\n    return data;\n  }\n}","map":{"version":3,"names":["isArray","isBinning","COLUMN","FACET_CHANNELS","POSITION_SCALE_CHANNELS","ROW","vgField","log","hasDiscreteDomain","DEFAULT_SORT_OP","isSortField","hash","isVgRangeStep","HEADER_CHANNELS","HEADER_TYPES","assembleDomain","getFieldFromDomain","sortArrayIndexField","DataFlowNode","FacetNode","constructor","parent","model","name","data","channel","fieldDef","facet","bin","sort","getName","fields","binSuffix","sortField","sortIndexField","childModel","child","out","charAt","f","push","dependentFields","depFields","Set","add","field","producedFields","getSource","getChildIndependentFieldsWithStep","childIndependentFieldsWithStep","childScaleComponent","component","scales","merged","type","get","range","domain","warn","message","unknownField","assembleRowColumnHeaderData","crossedDataName","childChannel","row","column","undefined","ops","as","op","forAs","source","transform","groupby","length","assembleFacetHeaderData","columns","layout","layoutHeaders","hasSharedAxis","headerChannel","headerType","headers","header","axes","cardinality","stop","signal","start","unshift","assemble","x","y","concat","map","facetData"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\data\\facet.ts"],"sourcesContent":["import type {AggregateOp} from 'vega';\nimport {isArray} from 'vega-util';\nimport {isBinning} from '../../bin';\nimport {COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW} from '../../channel';\nimport {vgField} from '../../channeldef';\nimport * as log from '../../log';\nimport {hasDiscreteDomain} from '../../scale';\nimport {DEFAULT_SORT_OP, EncodingSortField, isSortField} from '../../sort';\nimport {hash} from '../../util';\nimport {isVgRangeStep, VgData} from '../../vega.schema';\nimport {FacetModel} from '../facet';\nimport {HEADER_CHANNELS, HEADER_TYPES} from '../header/component';\nimport {Model} from '../model';\nimport {assembleDomain, getFieldFromDomain} from '../scale/domain';\nimport {sortArrayIndexField} from './calculate';\nimport {DataFlowNode} from './dataflow';\n\ninterface ChildIndependentFieldsWithStep {\n  x?: string;\n  y?: string;\n}\n\ninterface FacetChannelInfo {\n  name: string;\n  fields: string[];\n  sortField?: EncodingSortField<string>;\n\n  sortIndexField?: string;\n}\n\n/**\n * A node that helps us track what fields we are faceting by.\n */\nexport class FacetNode extends DataFlowNode {\n  private readonly column: FacetChannelInfo;\n\n  private readonly row: FacetChannelInfo;\n\n  private readonly facet: FacetChannelInfo;\n\n  private readonly childModel: Model;\n\n  /**\n   * @param model The facet model.\n   * @param name The name that this facet source will have.\n   * @param data The source data for this facet data.\n   */\n  public constructor(\n    parent: DataFlowNode,\n    public readonly model: FacetModel,\n    public readonly name: string,\n    public data: string\n  ) {\n    super(parent);\n\n    for (const channel of FACET_CHANNELS) {\n      const fieldDef = model.facet[channel];\n      if (fieldDef) {\n        const {bin, sort} = fieldDef;\n        this[channel] = {\n          name: model.getName(`${channel}_domain`),\n          fields: [vgField(fieldDef), ...(isBinning(bin) ? [vgField(fieldDef, {binSuffix: 'end'})] : [])],\n          ...(isSortField(sort)\n            ? {sortField: sort}\n            : isArray(sort)\n              ? {sortIndexField: sortArrayIndexField(fieldDef, channel)}\n              : {})\n        };\n      }\n    }\n    this.childModel = model.child;\n  }\n\n  public hash() {\n    let out = `Facet`;\n\n    for (const channel of FACET_CHANNELS) {\n      if (this[channel]) {\n        out += ` ${channel.charAt(0)}:${hash(this[channel])}`;\n      }\n    }\n\n    return out;\n  }\n\n  get fields() {\n    const f: string[] = [];\n\n    for (const channel of FACET_CHANNELS) {\n      if (this[channel]?.fields) {\n        f.push(...this[channel].fields);\n      }\n    }\n    return f;\n  }\n\n  public dependentFields() {\n    const depFields = new Set<string>(this.fields);\n\n    for (const channel of FACET_CHANNELS) {\n      if (this[channel]) {\n        if (this[channel].sortField) {\n          depFields.add(this[channel].sortField.field);\n        }\n        if (this[channel].sortIndexField) {\n          depFields.add(this[channel].sortIndexField);\n        }\n      }\n    }\n\n    return depFields;\n  }\n\n  public producedFields() {\n    return new Set<string>(); // facet does not produce any new fields\n  }\n\n  /**\n   * The name to reference this source is its name.\n   */\n  public getSource() {\n    return this.name;\n  }\n\n  private getChildIndependentFieldsWithStep() {\n    const childIndependentFieldsWithStep: ChildIndependentFieldsWithStep = {};\n\n    for (const channel of POSITION_SCALE_CHANNELS) {\n      const childScaleComponent = this.childModel.component.scales[channel];\n      if (childScaleComponent && !childScaleComponent.merged) {\n        // independent scale\n        const type = childScaleComponent.get('type');\n        const range = childScaleComponent.get('range');\n\n        if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n          const domain = assembleDomain(this.childModel, channel);\n          const field = getFieldFromDomain(domain);\n          if (field) {\n            childIndependentFieldsWithStep[channel] = field;\n          } else {\n            log.warn(log.message.unknownField(channel));\n          }\n        }\n      }\n    }\n\n    return childIndependentFieldsWithStep;\n  }\n\n  private assembleRowColumnHeaderData(\n    channel: 'row' | 'column' | 'facet',\n    crossedDataName: string,\n    childIndependentFieldsWithStep: ChildIndependentFieldsWithStep\n  ): VgData {\n    const childChannel = ({row: 'y', column: 'x', facet: undefined} as const)[channel];\n\n    const fields: string[] = [];\n    const ops: AggregateOp[] = [];\n    const as: string[] = [];\n\n    if (childChannel && childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {\n      if (crossedDataName) {\n        // If there is a crossed data, calculate max\n        fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n\n        ops.push('max');\n      } else {\n        // If there is no crossed data, just calculate distinct\n        fields.push(childIndependentFieldsWithStep[childChannel]);\n        ops.push('distinct');\n      }\n      // Although it is technically a max, just name it distinct so it's easier to refer to it\n      as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n    }\n\n    const {sortField, sortIndexField} = this[channel];\n    if (sortField) {\n      const {op = DEFAULT_SORT_OP, field} = sortField;\n      fields.push(field);\n      ops.push(op);\n      as.push(vgField(sortField, {forAs: true}));\n    } else if (sortIndexField) {\n      fields.push(sortIndexField);\n      ops.push('max');\n      as.push(sortIndexField);\n    }\n\n    return {\n      name: this[channel].name,\n      // Use data from the crossed one if it exist\n      source: crossedDataName ?? this.data,\n      transform: [\n        {\n          type: 'aggregate',\n          groupby: this[channel].fields,\n          ...(fields.length\n            ? {\n                fields,\n                ops,\n                as\n              }\n            : {})\n        }\n      ]\n    };\n  }\n\n  private assembleFacetHeaderData(childIndependentFieldsWithStep: ChildIndependentFieldsWithStep) {\n    const {columns} = this.model.layout;\n    const {layoutHeaders} = this.model.component;\n    const data: VgData[] = [];\n\n    const hasSharedAxis: {row?: true; column?: true} = {};\n    for (const headerChannel of HEADER_CHANNELS) {\n      for (const headerType of HEADER_TYPES) {\n        const headers = (layoutHeaders[headerChannel] && layoutHeaders[headerChannel][headerType]) ?? [];\n        for (const header of headers) {\n          if (header.axes?.length > 0) {\n            hasSharedAxis[headerChannel] = true;\n            break;\n          }\n        }\n      }\n\n      if (hasSharedAxis[headerChannel]) {\n        const cardinality = `length(data(\"${this.facet.name}\"))`;\n\n        const stop =\n          headerChannel === 'row'\n            ? columns\n              ? {signal: `ceil(${cardinality} / ${columns})`}\n              : 1\n            : columns\n              ? {signal: `min(${cardinality}, ${columns})`}\n              : {signal: cardinality};\n\n        data.push({\n          name: `${this.facet.name}_${headerChannel}`,\n          transform: [\n            {\n              type: 'sequence',\n              start: 0,\n              stop\n            }\n          ]\n        });\n      }\n    }\n\n    const {row, column} = hasSharedAxis;\n\n    if (row || column) {\n      data.unshift(this.assembleRowColumnHeaderData('facet', null, childIndependentFieldsWithStep));\n    }\n\n    return data;\n  }\n\n  public assemble() {\n    const data: VgData[] = [];\n    let crossedDataName = null;\n    const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();\n\n    const {column, row, facet} = this;\n\n    if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {\n      // Need to create a cross dataset to correctly calculate cardinality\n      crossedDataName = `cross_${this.column.name}_${this.row.name}`;\n\n      const fields: string[] = [].concat(\n        childIndependentFieldsWithStep.x ?? [],\n        childIndependentFieldsWithStep.y ?? []\n      );\n      const ops = fields.map((): AggregateOp => 'distinct');\n\n      data.push({\n        name: crossedDataName,\n        source: this.data,\n        transform: [\n          {\n            type: 'aggregate',\n            groupby: this.fields,\n            fields,\n            ops\n          }\n        ]\n      });\n    }\n\n    for (const channel of [COLUMN, ROW]) {\n      if (this[channel]) {\n        data.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));\n      }\n    }\n\n    if (facet) {\n      const facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);\n      if (facetData) {\n        data.push(...facetData);\n      }\n    }\n\n    return data;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}