{"ast":null,"code":"import { isString } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { channelDefType, isFieldDef, isFieldOrDatumDefForTimeFormat, isPositionFieldOrDatumDef, isScaleFieldDef, vgField } from '../channeldef';\nimport { fieldValidPredicate } from '../predicate';\nimport { ScaleType } from '../scale';\nimport { formatExpression, normalizeTimeUnit, timeUnitSpecifierExpression } from '../timeunit';\nimport { QUANTITATIVE } from '../type';\nimport { stringify } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { datumDefToExpr } from './mark/encode/valueref';\nexport function isCustomFormatType(formatType) {\n  return formatType && formatType !== 'number' && formatType !== 'time';\n}\nfunction customFormatExpr(formatType, field, format) {\n  return `${formatType}(${field}${format ? `, ${stringify(format)}` : ''})`;\n}\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\nexport function formatSignalRef(_ref) {\n  let {\n    fieldOrDatumDef,\n    format,\n    formatType,\n    expr,\n    normalizeStack,\n    config\n  } = _ref;\n  if (isCustomFormatType(formatType)) {\n    return formatCustomType({\n      fieldOrDatumDef,\n      format,\n      formatType,\n      expr,\n      config\n    });\n  }\n  const field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n  const type = channelDefType(fieldOrDatumDef);\n  if (format === undefined && formatType === undefined && config.customFormatTypes) {\n    if (type === 'quantitative') {\n      if (normalizeStack && config.normalizedNumberFormatType) return formatCustomType({\n        fieldOrDatumDef,\n        format: config.normalizedNumberFormat,\n        formatType: config.normalizedNumberFormatType,\n        expr,\n        config\n      });\n      if (config.numberFormatType) {\n        return formatCustomType({\n          fieldOrDatumDef,\n          format: config.numberFormat,\n          formatType: config.numberFormatType,\n          expr,\n          config\n        });\n      }\n    }\n    if (type === 'temporal' && config.timeFormatType && isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit === undefined) {\n      return formatCustomType({\n        fieldOrDatumDef,\n        format: config.timeFormat,\n        formatType: config.timeFormatType,\n        expr,\n        config\n      });\n    }\n  }\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    const signal = timeFormatExpression({\n      field,\n      timeUnit: isFieldDef(fieldOrDatumDef) ? normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit : undefined,\n      format,\n      formatType: config.timeFormatType,\n      rawTimeFormat: config.timeFormat,\n      isUTCScale: isScaleFieldDef(fieldOrDatumDef) && fieldOrDatumDef.scale?.type === ScaleType.UTC\n    });\n    return signal ? {\n      signal\n    } : undefined;\n  }\n  format = numberFormat({\n    type,\n    specifiedFormat: format,\n    config,\n    normalizeStack\n  });\n  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n    const endField = vgField(fieldOrDatumDef, {\n      expr,\n      binSuffix: 'end'\n    });\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  } else if (format || channelDefType(fieldOrDatumDef) === 'quantitative') {\n    return {\n      signal: `${formatExpr(field, format)}`\n    };\n  } else {\n    return {\n      signal: `isValid(${field}) ? ${field} : \"\"+${field}`\n    };\n  }\n}\nfunction fieldToFormat(fieldOrDatumDef, expr, normalizeStack) {\n  if (isFieldDef(fieldOrDatumDef)) {\n    if (normalizeStack) {\n      return `${vgField(fieldOrDatumDef, {\n        expr,\n        suffix: 'end'\n      })}-${vgField(fieldOrDatumDef, {\n        expr,\n        suffix: 'start'\n      })}`;\n    } else {\n      return vgField(fieldOrDatumDef, {\n        expr\n      });\n    }\n  } else {\n    return datumDefToExpr(fieldOrDatumDef);\n  }\n}\nexport function formatCustomType(_ref2) {\n  let {\n    fieldOrDatumDef,\n    format,\n    formatType,\n    expr,\n    normalizeStack,\n    config,\n    field\n  } = _ref2;\n  field ?? (field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack));\n  if (field !== 'datum.value' &&\n  // For axis/legend, we can't correctly know the end of the bin from `datum`\n  isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n    const endField = vgField(fieldOrDatumDef, {\n      expr,\n      binSuffix: 'end'\n    });\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  }\n  return {\n    signal: customFormatExpr(formatType, field, format)\n  };\n}\nexport function guideFormat(fieldOrDatumDef, type, format, formatType, config, omitTimeFormatConfig // axis doesn't use config.timeFormat\n) {\n  if (isString(formatType) && isCustomFormatType(formatType)) {\n    return undefined; // handled in encode block\n  } else if (format === undefined && formatType === undefined && config.customFormatTypes) {\n    if (channelDefType(fieldOrDatumDef) === 'quantitative') {\n      if (config.normalizedNumberFormatType && isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === 'normalize') {\n        return undefined; // handled in encode block\n      }\n      if (config.numberFormatType) {\n        return undefined; // handled in encode block\n      }\n    }\n  }\n  if (isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === 'normalize' && config.normalizedNumberFormat) {\n    return numberFormat({\n      type: 'quantitative',\n      config,\n      normalizeStack: true\n    });\n  }\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    const timeUnit = isFieldDef(fieldOrDatumDef) ? normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit : undefined;\n    if (timeUnit === undefined && config.customFormatTypes && config.timeFormatType) {\n      return undefined; // hanlded in encode block\n    }\n    return timeFormat({\n      specifiedFormat: format,\n      timeUnit,\n      config,\n      omitTimeFormatConfig\n    });\n  }\n  return numberFormat({\n    type,\n    specifiedFormat: format,\n    config\n  });\n}\nexport function guideFormatType(formatType, fieldOrDatumDef, scaleType) {\n  if (formatType && (isSignalRef(formatType) || formatType === 'number' || formatType === 'time')) {\n    return formatType;\n  }\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType !== 'time' && scaleType !== 'utc') {\n    return isFieldDef(fieldOrDatumDef) && normalizeTimeUnit(fieldOrDatumDef?.timeUnit)?.utc ? 'utc' : 'time';\n  }\n  return undefined;\n}\n/**\n * Returns number format for a fieldDef.\n */\nexport function numberFormat(_ref3) {\n  let {\n    type,\n    specifiedFormat,\n    config,\n    normalizeStack\n  } = _ref3;\n  // Specified format in axis/legend has higher precedence than fieldDef.format\n  if (isString(specifiedFormat)) {\n    return specifiedFormat;\n  }\n  if (type === QUANTITATIVE) {\n    // we only apply the default if the field is quantitative\n    return normalizeStack ? config.normalizedNumberFormat : config.numberFormat;\n  }\n  return undefined;\n}\n/**\n * Returns time format for a fieldDef for use in guides.\n */\nexport function timeFormat(_ref4) {\n  let {\n    specifiedFormat,\n    timeUnit,\n    config,\n    omitTimeFormatConfig\n  } = _ref4;\n  if (specifiedFormat) {\n    return specifiedFormat;\n  }\n  if (timeUnit) {\n    return {\n      signal: timeUnitSpecifierExpression(timeUnit)\n    };\n  }\n  return omitTimeFormatConfig ? undefined : config.timeFormat;\n}\nfunction formatExpr(field, format) {\n  return `format(${field}, \"${format || ''}\")`;\n}\nfunction binNumberFormatExpr(field, format, formatType, config) {\n  if (isCustomFormatType(formatType)) {\n    return customFormatExpr(formatType, field, format);\n  }\n  return formatExpr(field, (isString(format) ? format : undefined) ?? config.numberFormat);\n}\nexport function binFormatExpression(startField, endField, format, formatType, config) {\n  if (format === undefined && formatType === undefined && config.customFormatTypes && config.numberFormatType) {\n    return binFormatExpression(startField, endField, config.numberFormat, config.numberFormatType, config);\n  }\n  const start = binNumberFormatExpr(startField, format, formatType, config);\n  const end = binNumberFormatExpr(endField, format, formatType, config);\n  return `${fieldValidPredicate(startField, false)} ? \"null\" : ${start} + \"${BIN_RANGE_DELIMITER}\" + ${end}`;\n}\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression(_ref5) {\n  let {\n    field,\n    timeUnit,\n    format,\n    formatType,\n    rawTimeFormat,\n    isUTCScale\n  } = _ref5;\n  if (!timeUnit || format) {\n    // If there is no time unit, or if user explicitly specifies format for axis/legend/text.\n    if (!timeUnit && formatType) {\n      return `${formatType}(${field}, '${format}')`;\n    }\n    format = isString(format) ? format : rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n    return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;\n  } else {\n    return formatExpression(timeUnit, field, isUTCScale);\n  }\n}","map":{"version":3,"names":["isString","isBinning","channelDefType","isFieldDef","isFieldOrDatumDefForTimeFormat","isPositionFieldOrDatumDef","isScaleFieldDef","vgField","fieldValidPredicate","ScaleType","formatExpression","normalizeTimeUnit","timeUnitSpecifierExpression","QUANTITATIVE","stringify","isSignalRef","datumDefToExpr","isCustomFormatType","formatType","customFormatExpr","field","format","BIN_RANGE_DELIMITER","formatSignalRef","_ref","fieldOrDatumDef","expr","normalizeStack","config","formatCustomType","fieldToFormat","type","undefined","customFormatTypes","normalizedNumberFormatType","normalizedNumberFormat","numberFormatType","numberFormat","timeFormatType","timeUnit","timeFormat","signal","timeFormatExpression","unit","rawTimeFormat","isUTCScale","scale","UTC","specifiedFormat","bin","endField","binSuffix","binFormatExpression","formatExpr","suffix","_ref2","guideFormat","omitTimeFormatConfig","stack","guideFormatType","scaleType","utc","_ref3","_ref4","binNumberFormatExpr","startField","start","end","_ref5"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\format.ts"],"sourcesContent":["import type {SignalRef} from 'vega';\nimport {isString} from 'vega-util';\nimport {isBinning} from '../bin';\nimport {\n  channelDefType,\n  DatumDef,\n  FieldDef,\n  isFieldDef,\n  isFieldOrDatumDefForTimeFormat,\n  isPositionFieldOrDatumDef,\n  isScaleFieldDef,\n  vgField\n} from '../channeldef';\nimport {Config} from '../config';\nimport {fieldValidPredicate} from '../predicate';\nimport {ScaleType} from '../scale';\nimport {formatExpression, normalizeTimeUnit, timeUnitSpecifierExpression} from '../timeunit';\nimport {QUANTITATIVE, Type} from '../type';\nimport {Dict, stringify} from '../util';\nimport {isSignalRef} from '../vega.schema';\nimport {TimeUnit} from './../timeunit';\nimport {datumDefToExpr} from './mark/encode/valueref';\n\nexport function isCustomFormatType(formatType: string) {\n  return formatType && formatType !== 'number' && formatType !== 'time';\n}\n\nfunction customFormatExpr(formatType: string, field: string, format: string | Dict<unknown>) {\n  return `${formatType}(${field}${format ? `, ${stringify(format)}` : ''})`;\n}\n\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\n\nexport function formatSignalRef({\n  fieldOrDatumDef,\n  format,\n  formatType,\n  expr,\n  normalizeStack,\n  config\n}: {\n  fieldOrDatumDef: FieldDef<string> | DatumDef<string>;\n  format: string | Dict<unknown>;\n  formatType: string;\n  expr?: 'datum' | 'parent' | 'datum.datum';\n  normalizeStack?: boolean;\n  config: Config;\n}) {\n  if (isCustomFormatType(formatType)) {\n    return formatCustomType({\n      fieldOrDatumDef,\n      format,\n      formatType,\n      expr,\n      config\n    });\n  }\n\n  const field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n  const type = channelDefType(fieldOrDatumDef);\n\n  if (format === undefined && formatType === undefined && config.customFormatTypes) {\n    if (type === 'quantitative') {\n      if (normalizeStack && config.normalizedNumberFormatType)\n        return formatCustomType({\n          fieldOrDatumDef,\n          format: config.normalizedNumberFormat,\n          formatType: config.normalizedNumberFormatType,\n          expr,\n          config\n        });\n      if (config.numberFormatType) {\n        return formatCustomType({\n          fieldOrDatumDef,\n          format: config.numberFormat,\n          formatType: config.numberFormatType,\n          expr,\n          config\n        });\n      }\n    }\n    if (\n      type === 'temporal' &&\n      config.timeFormatType &&\n      isFieldDef(fieldOrDatumDef) &&\n      fieldOrDatumDef.timeUnit === undefined\n    ) {\n      return formatCustomType({\n        fieldOrDatumDef,\n        format: config.timeFormat,\n        formatType: config.timeFormatType,\n        expr,\n        config\n      });\n    }\n  }\n\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    const signal = timeFormatExpression({\n      field,\n      timeUnit: isFieldDef(fieldOrDatumDef) ? normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit : undefined,\n      format,\n      formatType: config.timeFormatType,\n      rawTimeFormat: config.timeFormat,\n      isUTCScale: isScaleFieldDef(fieldOrDatumDef) && fieldOrDatumDef.scale?.type === ScaleType.UTC\n    });\n    return signal ? {signal} : undefined;\n  }\n\n  format = numberFormat({type, specifiedFormat: format, config, normalizeStack});\n  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n    const endField = vgField(fieldOrDatumDef, {expr, binSuffix: 'end'});\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  } else if (format || channelDefType(fieldOrDatumDef) === 'quantitative') {\n    return {\n      signal: `${formatExpr(field, format)}`\n    };\n  } else {\n    return {signal: `isValid(${field}) ? ${field} : \"\"+${field}`};\n  }\n}\n\nfunction fieldToFormat(\n  fieldOrDatumDef: FieldDef<string> | DatumDef<string>,\n  expr: 'datum' | 'parent' | 'datum.datum',\n  normalizeStack: boolean\n) {\n  if (isFieldDef(fieldOrDatumDef)) {\n    if (normalizeStack) {\n      return `${vgField(fieldOrDatumDef, {expr, suffix: 'end'})}-${vgField(fieldOrDatumDef, {\n        expr,\n        suffix: 'start'\n      })}`;\n    } else {\n      return vgField(fieldOrDatumDef, {expr});\n    }\n  } else {\n    return datumDefToExpr(fieldOrDatumDef);\n  }\n}\n\nexport function formatCustomType({\n  fieldOrDatumDef,\n  format,\n  formatType,\n  expr,\n  normalizeStack,\n  config,\n  field\n}: {\n  fieldOrDatumDef: FieldDef<string> | DatumDef<string>;\n  format: string | Dict<unknown>;\n  formatType: string;\n  expr?: 'datum' | 'parent' | 'datum.datum';\n  normalizeStack?: boolean;\n  config: Config;\n  field?: string; // axis/legend \"use datum.value\"\n}) {\n  field ??= fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n\n  if (\n    field !== 'datum.value' && // For axis/legend, we can't correctly know the end of the bin from `datum`\n    isFieldDef(fieldOrDatumDef) &&\n    isBinning(fieldOrDatumDef.bin)\n  ) {\n    const endField = vgField(fieldOrDatumDef, {expr, binSuffix: 'end'});\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  }\n  return {signal: customFormatExpr(formatType, field, format)};\n}\n\nexport function guideFormat(\n  fieldOrDatumDef: FieldDef<string> | DatumDef<string>,\n  type: Type,\n  format: string | Dict<unknown>,\n  formatType: string | SignalRef,\n  config: Config,\n  omitTimeFormatConfig: boolean // axis doesn't use config.timeFormat\n) {\n  if (isString(formatType) && isCustomFormatType(formatType)) {\n    return undefined; // handled in encode block\n  } else if (format === undefined && formatType === undefined && config.customFormatTypes) {\n    if (channelDefType(fieldOrDatumDef) === 'quantitative') {\n      if (\n        config.normalizedNumberFormatType &&\n        isPositionFieldOrDatumDef(fieldOrDatumDef) &&\n        fieldOrDatumDef.stack === 'normalize'\n      ) {\n        return undefined; // handled in encode block\n      }\n      if (config.numberFormatType) {\n        return undefined; // handled in encode block\n      }\n    }\n  }\n\n  if (\n    isPositionFieldOrDatumDef(fieldOrDatumDef) &&\n    fieldOrDatumDef.stack === 'normalize' &&\n    config.normalizedNumberFormat\n  ) {\n    return numberFormat({\n      type: 'quantitative',\n      config,\n      normalizeStack: true\n    });\n  }\n\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    const timeUnit = isFieldDef(fieldOrDatumDef) ? normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit : undefined;\n    if (timeUnit === undefined && config.customFormatTypes && config.timeFormatType) {\n      return undefined; // hanlded in encode block\n    }\n\n    return timeFormat({specifiedFormat: format as string, timeUnit, config, omitTimeFormatConfig});\n  }\n\n  return numberFormat({type, specifiedFormat: format, config});\n}\n\nexport function guideFormatType(\n  formatType: string | SignalRef,\n  fieldOrDatumDef: FieldDef<string> | DatumDef<string>,\n  scaleType: ScaleType\n) {\n  if (formatType && (isSignalRef(formatType) || formatType === 'number' || formatType === 'time')) {\n    return formatType;\n  }\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType !== 'time' && scaleType !== 'utc') {\n    return isFieldDef(fieldOrDatumDef) && normalizeTimeUnit(fieldOrDatumDef?.timeUnit)?.utc ? 'utc' : 'time';\n  }\n  return undefined;\n}\n\n/**\n * Returns number format for a fieldDef.\n */\nexport function numberFormat({\n  type,\n  specifiedFormat,\n  config,\n  normalizeStack\n}: {\n  type: Type;\n  specifiedFormat?: string | Dict<unknown>;\n  config: Config;\n  normalizeStack?: boolean;\n}) {\n  // Specified format in axis/legend has higher precedence than fieldDef.format\n  if (isString(specifiedFormat)) {\n    return specifiedFormat;\n  }\n\n  if (type === QUANTITATIVE) {\n    // we only apply the default if the field is quantitative\n    return normalizeStack ? config.normalizedNumberFormat : config.numberFormat;\n  }\n  return undefined;\n}\n\n/**\n * Returns time format for a fieldDef for use in guides.\n */\nexport function timeFormat({\n  specifiedFormat,\n  timeUnit,\n  config,\n  omitTimeFormatConfig\n}: {\n  specifiedFormat?: string;\n  timeUnit?: TimeUnit;\n  config: Config;\n  omitTimeFormatConfig?: boolean;\n}) {\n  if (specifiedFormat) {\n    return specifiedFormat;\n  }\n\n  if (timeUnit) {\n    return {\n      signal: timeUnitSpecifierExpression(timeUnit)\n    };\n  }\n\n  return omitTimeFormatConfig ? undefined : config.timeFormat;\n}\n\nfunction formatExpr(field: string, format: string) {\n  return `format(${field}, \"${format || ''}\")`;\n}\n\nfunction binNumberFormatExpr(field: string, format: string | Dict<unknown>, formatType: string, config: Config) {\n  if (isCustomFormatType(formatType)) {\n    return customFormatExpr(formatType, field, format);\n  }\n\n  return formatExpr(field, (isString(format) ? format : undefined) ?? config.numberFormat);\n}\n\nexport function binFormatExpression(\n  startField: string,\n  endField: string,\n  format: string | Dict<unknown>,\n  formatType: string,\n  config: Config\n): string {\n  if (format === undefined && formatType === undefined && config.customFormatTypes && config.numberFormatType) {\n    return binFormatExpression(startField, endField, config.numberFormat, config.numberFormatType, config);\n  }\n  const start = binNumberFormatExpr(startField, format, formatType, config);\n  const end = binNumberFormatExpr(endField, format, formatType, config);\n  return `${fieldValidPredicate(startField, false)} ? \"null\" : ${start} + \"${BIN_RANGE_DELIMITER}\" + ${end}`;\n}\n\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression({\n  field,\n  timeUnit,\n  format,\n  formatType,\n  rawTimeFormat,\n  isUTCScale\n}: {\n  field: string;\n  timeUnit?: TimeUnit;\n  format?: string | Dict<unknown>;\n  formatType?: string;\n  rawTimeFormat?: string; // should be provided only for actual text and headers, not axis/legend labels\n  isUTCScale?: boolean;\n}): string {\n  if (!timeUnit || format) {\n    // If there is no time unit, or if user explicitly specifies format for axis/legend/text.\n    if (!timeUnit && formatType) {\n      return `${formatType}(${field}, '${format}')`;\n    }\n    format = isString(format) ? format : rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n    return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;\n  } else {\n    return formatExpression(timeUnit, field, isUTCScale);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}