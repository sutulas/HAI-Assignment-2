{"ast":null,"code":"import { isFieldDef } from '../../channeldef';\nimport { pathGroupingFields } from '../../encoding';\nimport { isImputeSequence } from '../../transform';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class ImputeNode extends DataFlowNode {\n  clone() {\n    return new ImputeNode(null, duplicate(this.transform));\n  }\n  constructor(parent, transform) {\n    super(parent);\n    this.transform = transform;\n  }\n  dependentFields() {\n    return new Set([this.transform.impute, this.transform.key, ...(this.transform.groupby ?? [])]);\n  }\n  producedFields() {\n    return new Set([this.transform.impute]);\n  }\n  processSequence(keyvals) {\n    const {\n      start = 0,\n      stop,\n      step\n    } = keyvals;\n    const result = [start, stop, ...(step ? [step] : [])].join(',');\n    return {\n      signal: `sequence(${result})`\n    };\n  }\n  static makeFromTransform(parent, imputeTransform) {\n    return new ImputeNode(parent, imputeTransform);\n  }\n  static makeFromEncoding(parent, model) {\n    const encoding = model.encoding;\n    const xDef = encoding.x;\n    const yDef = encoding.y;\n    if (isFieldDef(xDef) && isFieldDef(yDef)) {\n      const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : undefined;\n      if (imputedChannel === undefined) {\n        return undefined;\n      }\n      const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : undefined;\n      const {\n        method,\n        value,\n        frame,\n        keyvals\n      } = imputedChannel.impute;\n      const groupbyFields = pathGroupingFields(model.mark, encoding);\n      return new ImputeNode(parent, {\n        impute: imputedChannel.field,\n        key: keyChannel.field,\n        ...(method ? {\n          method\n        } : {}),\n        ...(value !== undefined ? {\n          value\n        } : {}),\n        ...(frame ? {\n          frame\n        } : {}),\n        ...(keyvals !== undefined ? {\n          keyvals\n        } : {}),\n        ...(groupbyFields.length ? {\n          groupby: groupbyFields\n        } : {})\n      });\n    }\n    return null;\n  }\n  hash() {\n    return `Impute ${hash(this.transform)}`;\n  }\n  assemble() {\n    const {\n      impute,\n      key,\n      keyvals,\n      method,\n      groupby,\n      value,\n      frame = [null, null]\n    } = this.transform;\n    const imputeTransform = {\n      type: 'impute',\n      field: impute,\n      key,\n      ...(keyvals ? {\n        keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals\n      } : {}),\n      method: 'value',\n      ...(groupby ? {\n        groupby\n      } : {}),\n      value: !method || method === 'value' ? value : null\n    };\n    if (method && method !== 'value') {\n      const deriveNewField = {\n        type: 'window',\n        as: [`imputed_${impute}_value`],\n        ops: [method],\n        fields: [impute],\n        frame,\n        ignorePeers: false,\n        ...(groupby ? {\n          groupby\n        } : {})\n      };\n      const replaceOriginal = {\n        type: 'formula',\n        expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,\n        as: impute\n      };\n      return [imputeTransform, deriveNewField, replaceOriginal];\n    } else {\n      return [imputeTransform];\n    }\n  }\n}","map":{"version":3,"names":["isFieldDef","pathGroupingFields","isImputeSequence","duplicate","hash","DataFlowNode","ImputeNode","clone","transform","constructor","parent","dependentFields","Set","impute","key","groupby","producedFields","processSequence","keyvals","start","stop","step","result","join","signal","makeFromTransform","imputeTransform","makeFromEncoding","model","encoding","xDef","x","yDef","y","imputedChannel","undefined","keyChannel","method","value","frame","groupbyFields","mark","field","length","assemble","type","deriveNewField","as","ops","fields","ignorePeers","replaceOriginal","expr"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\data\\impute.ts"],"sourcesContent":["import {\n  FormulaTransform as VgFormulaTransform,\n  ImputeTransform as VgImputeTransform,\n  SignalRef,\n  WindowTransform as VgWindowTransform\n} from 'vega';\nimport {isFieldDef} from '../../channeldef';\nimport {pathGroupingFields} from '../../encoding';\nimport {ImputeSequence, ImputeTransform, isImputeSequence} from '../../transform';\nimport {duplicate, hash} from '../../util';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\nexport class ImputeNode extends DataFlowNode {\n  public clone() {\n    return new ImputeNode(null, duplicate(this.transform));\n  }\n\n  constructor(\n    parent: DataFlowNode,\n    private readonly transform: ImputeTransform\n  ) {\n    super(parent);\n  }\n\n  public dependentFields() {\n    return new Set([this.transform.impute, this.transform.key, ...(this.transform.groupby ?? [])]);\n  }\n\n  public producedFields() {\n    return new Set([this.transform.impute]);\n  }\n\n  private processSequence(keyvals: ImputeSequence): SignalRef {\n    const {start = 0, stop, step} = keyvals;\n    const result = [start, stop, ...(step ? [step] : [])].join(',');\n\n    return {signal: `sequence(${result})`};\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, imputeTransform: ImputeTransform): ImputeNode {\n    return new ImputeNode(parent, imputeTransform);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: UnitModel) {\n    const encoding = model.encoding;\n    const xDef = encoding.x;\n    const yDef = encoding.y;\n\n    if (isFieldDef(xDef) && isFieldDef(yDef)) {\n      const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : undefined;\n      if (imputedChannel === undefined) {\n        return undefined;\n      }\n      const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : undefined;\n      const {method, value, frame, keyvals} = imputedChannel.impute;\n      const groupbyFields = pathGroupingFields(model.mark, encoding);\n\n      return new ImputeNode(parent, {\n        impute: imputedChannel.field,\n        key: keyChannel.field,\n        ...(method ? {method} : {}),\n        ...(value !== undefined ? {value} : {}),\n        ...(frame ? {frame} : {}),\n        ...(keyvals !== undefined ? {keyvals} : {}),\n        ...(groupbyFields.length ? {groupby: groupbyFields} : {})\n      });\n    }\n    return null;\n  }\n\n  public hash() {\n    return `Impute ${hash(this.transform)}`;\n  }\n\n  public assemble() {\n    const {impute, key, keyvals, method, groupby, value, frame = [null, null] as [null, null]} = this.transform;\n\n    const imputeTransform: VgImputeTransform = {\n      type: 'impute',\n      field: impute,\n      key,\n      ...(keyvals ? {keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals} : {}),\n      method: 'value',\n      ...(groupby ? {groupby} : {}),\n      value: !method || method === 'value' ? value : null\n    };\n\n    if (method && method !== 'value') {\n      const deriveNewField: VgWindowTransform = {\n        type: 'window',\n        as: [`imputed_${impute}_value`],\n        ops: [method],\n        fields: [impute],\n        frame,\n        ignorePeers: false,\n        ...(groupby ? {groupby} : {})\n      };\n      const replaceOriginal: VgFormulaTransform = {\n        type: 'formula',\n        expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,\n        as: impute\n      };\n      return [imputeTransform, deriveNewField, replaceOriginal];\n    } else {\n      return [imputeTransform];\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}