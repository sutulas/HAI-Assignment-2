{"ast":null,"code":"import { isArray, isNumber } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../bin';\nimport { COLOR, FILL, getSecondaryRangeChannel, isXorY, isXorYOffset, POLAR_POSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, STROKE } from '../../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldDef, valueExpr } from '../../channeldef';\nimport { isDateTime } from '../../datetime';\nimport { channelHasNestedOffsetScale } from '../../encoding';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, isContinuousToContinuous, isContinuousToDiscrete, ScaleType, scaleTypeSupportProperty } from '../../scale';\nimport * as util from '../../util';\nimport { contains, getFirstDefined, keys } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { parseUnitScaleRange } from './range';\nexport function parseScaleProperty(model, property) {\n  if (isUnitModel(model)) {\n    parseUnitScaleProperty(model, property);\n  } else {\n    parseNonUnitScaleProperty(model, property);\n  }\n}\nfunction parseUnitScaleProperty(model, property) {\n  const localScaleComponents = model.component.scales;\n  const {\n    config,\n    encoding,\n    markDef,\n    specifiedScales\n  } = model;\n  for (const channel of keys(localScaleComponents)) {\n    const specifiedScale = specifiedScales[channel];\n    const localScaleCmpt = localScaleComponents[channel];\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n    const specifiedValue = specifiedScale[property];\n    const scaleType = mergedScaleCmpt.get('type');\n    const scalePadding = mergedScaleCmpt.get('padding');\n    const scalePaddingInner = mergedScaleCmpt.get('paddingInner');\n    const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n    const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n    if (specifiedValue !== undefined) {\n      // If there is a specified value, check if it is compatible with scale type and channel\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      }\n    }\n    if (supportedByScaleType && channelIncompatability === undefined) {\n      if (specifiedValue !== undefined) {\n        const timeUnit = fieldOrDatumDef.timeUnit;\n        const type = fieldOrDatumDef.type;\n        switch (property) {\n          // domainMax/Min to signal if the value is a datetime object\n          case 'domainMax':\n          case 'domainMin':\n            if (isDateTime(specifiedScale[property]) || type === 'temporal' || timeUnit) {\n              localScaleCmpt.set(property, {\n                signal: valueExpr(specifiedScale[property], {\n                  type,\n                  timeUnit\n                })\n              }, true);\n            } else {\n              localScaleCmpt.set(property, specifiedScale[property], true);\n            }\n            break;\n          default:\n            localScaleCmpt.copyKeyFromObject(property, specifiedScale);\n        }\n      } else {\n        const value = util.hasProperty(scaleRules, property) ? scaleRules[property]({\n          model,\n          channel,\n          fieldOrDatumDef,\n          scaleType,\n          scalePadding,\n          scalePaddingInner,\n          domain: specifiedScale.domain,\n          domainMin: specifiedScale.domainMin,\n          domainMax: specifiedScale.domainMax,\n          markDef,\n          config,\n          hasNestedOffsetScale: channelHasNestedOffsetScale(encoding, channel),\n          hasSecondaryRangeChannel: !!encoding[getSecondaryRangeChannel(channel)]\n        }) : config.scale[property];\n        if (value !== undefined) {\n          localScaleCmpt.set(property, value, false);\n        }\n      }\n    }\n  }\n}\nexport const scaleRules = {\n  bins: _ref => {\n    let {\n      model,\n      fieldOrDatumDef\n    } = _ref;\n    return isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : undefined;\n  },\n  interpolate: _ref2 => {\n    let {\n      channel,\n      fieldOrDatumDef\n    } = _ref2;\n    return interpolate(channel, fieldOrDatumDef.type);\n  },\n  nice: _ref3 => {\n    let {\n      scaleType,\n      channel,\n      domain,\n      domainMin,\n      domainMax,\n      fieldOrDatumDef\n    } = _ref3;\n    return nice(scaleType, channel, domain, domainMin, domainMax, fieldOrDatumDef);\n  },\n  padding: _ref4 => {\n    let {\n      channel,\n      scaleType,\n      fieldOrDatumDef,\n      markDef,\n      config\n    } = _ref4;\n    return padding(channel, scaleType, config.scale, fieldOrDatumDef, markDef, config.bar);\n  },\n  paddingInner: _ref5 => {\n    let {\n      scalePadding,\n      channel,\n      markDef,\n      scaleType,\n      config,\n      hasNestedOffsetScale\n    } = _ref5;\n    return paddingInner(scalePadding, channel, markDef.type, scaleType, config.scale, hasNestedOffsetScale);\n  },\n  paddingOuter: _ref6 => {\n    let {\n      scalePadding,\n      channel,\n      scaleType,\n      scalePaddingInner,\n      config,\n      hasNestedOffsetScale\n    } = _ref6;\n    return paddingOuter(scalePadding, channel, scaleType, scalePaddingInner, config.scale, hasNestedOffsetScale);\n  },\n  reverse: _ref7 => {\n    let {\n      fieldOrDatumDef,\n      scaleType,\n      channel,\n      config\n    } = _ref7;\n    const sort = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined;\n    return reverse(scaleType, sort, channel, config.scale);\n  },\n  zero: _ref8 => {\n    let {\n      channel,\n      fieldOrDatumDef,\n      domain,\n      markDef,\n      scaleType,\n      config,\n      hasSecondaryRangeChannel\n    } = _ref8;\n    return zero(channel, fieldOrDatumDef, domain, markDef, scaleType, config.scale, hasSecondaryRangeChannel);\n  }\n};\n// This method is here rather than in range.ts to avoid circular dependency.\nexport function parseScaleRange(model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleRange(model);\n  } else {\n    parseNonUnitScaleProperty(model, 'range');\n  }\n}\nexport function parseNonUnitScaleProperty(model, property) {\n  const localScaleComponents = model.component.scales;\n  for (const child of model.children) {\n    if (property === 'range') {\n      parseScaleRange(child);\n    } else {\n      parseScaleProperty(child, property);\n    }\n  }\n  for (const channel of keys(localScaleComponents)) {\n    let valueWithExplicit;\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        const childValueWithExplicit = childComponent.getWithExplicit(property);\n        valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property, 'scale', tieBreakByComparing((v1, v2) => {\n          switch (property) {\n            case 'range':\n              // For step, prefer larger step\n              if (v1.step && v2.step) {\n                return v1.step - v2.step;\n              }\n              return 0;\n            // TODO: precedence rule for other properties\n          }\n          return 0;\n        }));\n      }\n    }\n    localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n  }\n}\nexport function bins(model, fieldDef) {\n  const bin = fieldDef.bin;\n  if (isBinning(bin)) {\n    const binSignal = getBinSignalName(model, fieldDef.field, bin);\n    return new SignalRefWrapper(() => {\n      return model.getSignalName(binSignal);\n    });\n  } else if (isBinned(bin) && isBinParams(bin) && bin.step !== undefined) {\n    // start and stop will be determined from the scale domain\n    return {\n      step: bin.step\n    };\n  }\n  return undefined;\n}\nexport function interpolate(channel, type) {\n  if (contains([COLOR, FILL, STROKE], channel) && type !== 'nominal') {\n    return 'hcl';\n  }\n  return undefined;\n}\nexport function nice(scaleType, channel, specifiedDomain, domainMin, domainMax, fieldOrDatumDef) {\n  if (getFieldDef(fieldOrDatumDef)?.bin || isArray(specifiedDomain) || domainMax != null || domainMin != null || util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n    return undefined;\n  }\n  return isXorY(channel) ? true : undefined;\n}\nexport function padding(channel, scaleType, scaleConfig, fieldOrDatumDef, markDef, barConfig) {\n  if (isXorY(channel)) {\n    if (isContinuousToContinuous(scaleType)) {\n      if (scaleConfig.continuousPadding !== undefined) {\n        return scaleConfig.continuousPadding;\n      }\n      const {\n        type,\n        orient\n      } = markDef;\n      if (type === 'bar' && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {\n        if (orient === 'vertical' && channel === 'x' || orient === 'horizontal' && channel === 'y') {\n          return barConfig.continuousBandSize;\n        }\n      }\n    }\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n  return undefined;\n}\nexport function paddingInner(paddingValue, channel, mark, scaleType, scaleConfig) {\n  let hasNestedOffsetScale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n  if (isXorY(channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n    const {\n      bandPaddingInner,\n      barBandPaddingInner,\n      rectBandPaddingInner,\n      tickBandPaddingInner,\n      bandWithNestedOffsetPaddingInner\n    } = scaleConfig;\n    if (hasNestedOffsetScale) {\n      return bandWithNestedOffsetPaddingInner;\n    }\n    return getFirstDefined(bandPaddingInner, mark === 'bar' ? barBandPaddingInner : mark === 'tick' ? tickBandPaddingInner : rectBandPaddingInner);\n  } else if (isXorYOffset(channel)) {\n    if (scaleType === ScaleType.BAND) {\n      return scaleConfig.offsetBandPaddingInner;\n    }\n  }\n  return undefined;\n}\nexport function paddingOuter(paddingValue, channel, scaleType, paddingInnerValue, scaleConfig) {\n  let hasNestedOffsetScale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n  if (isXorY(channel)) {\n    const {\n      bandPaddingOuter,\n      bandWithNestedOffsetPaddingOuter\n    } = scaleConfig;\n    if (hasNestedOffsetScale) {\n      return bandWithNestedOffsetPaddingOuter;\n    }\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    if (scaleType === ScaleType.BAND) {\n      return getFirstDefined(bandPaddingOuter,\n      /* By default, paddingOuter is paddingInner / 2. The reason is that\n        size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n        and we want the width/height to be integer by default.\n        Note that step (by default) and cardinality are integers.) */\n      isSignalRef(paddingInnerValue) ? {\n        signal: `${paddingInnerValue.signal}/2`\n      } : paddingInnerValue / 2);\n    }\n  } else if (isXorYOffset(channel)) {\n    if (scaleType === ScaleType.POINT) {\n      return 0.5; // so the point positions align with centers of band scales.\n    } else if (scaleType === ScaleType.BAND) {\n      return scaleConfig.offsetBandPaddingOuter;\n    }\n  }\n  return undefined;\n}\nexport function reverse(scaleType, sort, channel, scaleConfig) {\n  if (channel === 'x' && scaleConfig.xReverse !== undefined) {\n    if (hasContinuousDomain(scaleType) && sort === 'descending') {\n      if (isSignalRef(scaleConfig.xReverse)) {\n        return {\n          signal: `!${scaleConfig.xReverse.signal}`\n        };\n      } else {\n        return !scaleConfig.xReverse;\n      }\n    }\n    return scaleConfig.xReverse;\n  }\n  if (hasContinuousDomain(scaleType) && sort === 'descending') {\n    // For continuous domain scales, Vega does not support domain sort.\n    // Thus, we reverse range instead if sort is descending\n    return true;\n  }\n  return undefined;\n}\nexport function zero(channel, fieldDef, specifiedDomain, markDef, scaleType, scaleConfig, hasSecondaryRangeChannel) {\n  // If users explicitly provide a domain, we should not augment zero as that will be unexpected.\n  const hasCustomDomain = !!specifiedDomain && specifiedDomain !== 'unaggregated';\n  if (hasCustomDomain) {\n    if (hasContinuousDomain(scaleType)) {\n      if (isArray(specifiedDomain)) {\n        const first = specifiedDomain[0];\n        const last = specifiedDomain[specifiedDomain.length - 1];\n        if (isNumber(first) && first <= 0 && isNumber(last) && last >= 0) {\n          // if the domain includes zero, make zero remain true\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n  // If there is no custom domain, return configZero value (=`true` as default) only for the following cases:\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common. However, if the scaleType is discretizing scale, we want to return\n  // false so that range doesn't start at zero\n  if (channel === 'size' && fieldDef.type === 'quantitative' && !isContinuousToDiscrete(scaleType)) {\n    return true;\n  }\n  // 2) non-binned, quantitative x-scale or y-scale\n  // (For binning, we should not include zero by default because binning are calculated without zero.)\n  // (For area/bar charts with ratio scale chart, we should always include zero.)\n  if (!(isFieldDef(fieldDef) && fieldDef.bin) && util.contains([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)) {\n    const {\n      orient,\n      type\n    } = markDef;\n    if (contains(['bar', 'area', 'line', 'trail'], type)) {\n      if (orient === 'horizontal' && channel === 'y' || orient === 'vertical' && channel === 'x') {\n        return false;\n      }\n    }\n    if (contains(['bar', 'area'], type) && !hasSecondaryRangeChannel) {\n      return true;\n    }\n    return scaleConfig?.zero;\n  }\n  return false;\n}","map":{"version":3,"names":["isArray","isNumber","isBinned","isBinning","isBinParams","COLOR","FILL","getSecondaryRangeChannel","isXorY","isXorYOffset","POLAR_POSITION_SCALE_CHANNELS","POSITION_SCALE_CHANNELS","STROKE","getFieldDef","getFieldOrDatumDef","isFieldDef","valueExpr","isDateTime","channelHasNestedOffsetScale","log","channelScalePropertyIncompatability","hasContinuousDomain","isContinuousToContinuous","isContinuousToDiscrete","ScaleType","scaleTypeSupportProperty","util","contains","getFirstDefined","keys","isSignalRef","getBinSignalName","isUnitModel","SignalRefWrapper","mergeValuesWithExplicit","tieBreakByComparing","parseUnitScaleRange","parseScaleProperty","model","property","parseUnitScaleProperty","parseNonUnitScaleProperty","localScaleComponents","component","scales","config","encoding","markDef","specifiedScales","channel","specifiedScale","localScaleCmpt","mergedScaleCmpt","getScaleComponent","fieldOrDatumDef","specifiedValue","scaleType","get","scalePadding","scalePaddingInner","supportedByScaleType","channelIncompatability","undefined","warn","message","scalePropertyNotWorkWithScaleType","timeUnit","type","set","signal","copyKeyFromObject","value","hasProperty","scaleRules","domain","domainMin","domainMax","hasNestedOffsetScale","hasSecondaryRangeChannel","scale","bins","_ref","interpolate","_ref2","nice","_ref3","padding","_ref4","bar","paddingInner","_ref5","paddingOuter","_ref6","reverse","_ref7","sort","zero","_ref8","parseScaleRange","child","children","valueWithExplicit","childComponent","childValueWithExplicit","getWithExplicit","v1","v2","step","setWithExplicit","fieldDef","bin","binSignal","field","getSignalName","specifiedDomain","TIME","UTC","scaleConfig","barConfig","continuousPadding","orient","continuousBandSize","POINT","pointPadding","paddingValue","mark","arguments","length","bandPaddingInner","barBandPaddingInner","rectBandPaddingInner","tickBandPaddingInner","bandWithNestedOffsetPaddingInner","BAND","offsetBandPaddingInner","paddingInnerValue","bandPaddingOuter","bandWithNestedOffsetPaddingOuter","offsetBandPaddingOuter","xReverse","hasCustomDomain","first","last"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\scale\\properties.ts"],"sourcesContent":["import {SignalRef, TimeInterval} from 'vega';\nimport {isArray, isNumber} from 'vega-util';\nimport {isBinned, isBinning, isBinParams} from '../../bin';\nimport {\n  COLOR,\n  FILL,\n  getSecondaryRangeChannel,\n  isXorY,\n  isXorYOffset,\n  POLAR_POSITION_SCALE_CHANNELS,\n  POSITION_SCALE_CHANNELS,\n  ScaleChannel,\n  STROKE\n} from '../../channel';\nimport {\n  getFieldDef,\n  getFieldOrDatumDef,\n  isFieldDef,\n  ScaleDatumDef,\n  ScaleFieldDef,\n  TypedFieldDef,\n  valueExpr\n} from '../../channeldef';\nimport {Config} from '../../config';\nimport {isDateTime} from '../../datetime';\nimport {channelHasNestedOffsetScale} from '../../encoding';\nimport * as log from '../../log';\nimport {Mark, MarkDef, RectConfig} from '../../mark';\nimport {\n  channelScalePropertyIncompatability,\n  Domain,\n  hasContinuousDomain,\n  isContinuousToContinuous,\n  isContinuousToDiscrete,\n  Scale,\n  ScaleConfig,\n  ScaleType,\n  scaleTypeSupportProperty\n} from '../../scale';\nimport {Sort} from '../../sort';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {contains, getFirstDefined, keys} from '../../util';\nimport {isSignalRef, VgScale} from '../../vega.schema';\nimport {getBinSignalName} from '../data/bin';\nimport {isUnitModel, Model} from '../model';\nimport {SignalRefWrapper} from '../signal';\nimport {Explicit, mergeValuesWithExplicit, tieBreakByComparing} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex, ScaleComponentProps} from './component';\nimport {parseUnitScaleRange} from './range';\n\nexport function parseScaleProperty(model: Model, property: Exclude<keyof (Scale | ScaleComponentProps), 'range'>) {\n  if (isUnitModel(model)) {\n    parseUnitScaleProperty(model, property);\n  } else {\n    parseNonUnitScaleProperty(model, property);\n  }\n}\n\nfunction parseUnitScaleProperty(model: UnitModel, property: Exclude<keyof (Scale | ScaleComponentProps), 'range'>) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n  const {config, encoding, markDef, specifiedScales} = model;\n\n  for (const channel of keys(localScaleComponents)) {\n    const specifiedScale = specifiedScales[channel];\n    const localScaleCmpt = localScaleComponents[channel];\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) as ScaleFieldDef<string, Type> | ScaleDatumDef;\n\n    const specifiedValue = specifiedScale[property];\n    const scaleType = mergedScaleCmpt.get('type');\n    const scalePadding = mergedScaleCmpt.get('padding');\n    const scalePaddingInner = mergedScaleCmpt.get('paddingInner');\n\n    const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n    const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n    if (specifiedValue !== undefined) {\n      // If there is a specified value, check if it is compatible with scale type and channel\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      }\n    }\n    if (supportedByScaleType && channelIncompatability === undefined) {\n      if (specifiedValue !== undefined) {\n        const timeUnit = (fieldOrDatumDef as any).timeUnit;\n        const type = fieldOrDatumDef.type;\n\n        switch (property) {\n          // domainMax/Min to signal if the value is a datetime object\n          case 'domainMax':\n          case 'domainMin':\n            if (isDateTime(specifiedScale[property]) || type === 'temporal' || timeUnit) {\n              localScaleCmpt.set(property, {signal: valueExpr(specifiedScale[property], {type, timeUnit})}, true);\n            } else {\n              localScaleCmpt.set(property, specifiedScale[property] as any, true);\n            }\n            break;\n          default:\n            localScaleCmpt.copyKeyFromObject<Omit<ScaleComponentProps, 'range' | 'domainMin' | 'domainMax'>>(\n              property,\n              specifiedScale\n            );\n        }\n      } else {\n        const value = util.hasProperty(scaleRules, property)\n          ? scaleRules[property]({\n              model,\n              channel,\n              fieldOrDatumDef,\n              scaleType,\n              scalePadding,\n              scalePaddingInner,\n              domain: specifiedScale.domain,\n              domainMin: specifiedScale.domainMin,\n              domainMax: specifiedScale.domainMax,\n              markDef,\n              config,\n              hasNestedOffsetScale: channelHasNestedOffsetScale(encoding, channel),\n              hasSecondaryRangeChannel: !!encoding[getSecondaryRangeChannel(channel)]\n            })\n          : config.scale[property];\n        if (value !== undefined) {\n          localScaleCmpt.set(property, value as any, false);\n        }\n      }\n    }\n  }\n}\n\nexport interface ScaleRuleParams {\n  model: Model;\n  channel: ScaleChannel;\n  fieldOrDatumDef: ScaleFieldDef<string, Type> | ScaleDatumDef;\n  hasNestedOffsetScale: boolean;\n  scaleType: ScaleType;\n  scalePadding: number | SignalRef;\n  scalePaddingInner: number | SignalRef;\n  domain: Domain;\n  domainMin: Scale['domainMin'];\n  domainMax: Scale['domainMax'];\n  markDef: MarkDef<Mark, SignalRef>;\n  config: Config<SignalRef>;\n  hasSecondaryRangeChannel: boolean;\n}\n\nexport const scaleRules: {\n  [k in keyof Scale]?: (params: ScaleRuleParams) => Scale[k];\n} = {\n  bins: ({model, fieldOrDatumDef}) => (isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : undefined),\n\n  interpolate: ({channel, fieldOrDatumDef}) => interpolate(channel, fieldOrDatumDef.type),\n\n  nice: ({scaleType, channel, domain, domainMin, domainMax, fieldOrDatumDef}) =>\n    nice(scaleType, channel, domain, domainMin, domainMax, fieldOrDatumDef),\n\n  padding: ({channel, scaleType, fieldOrDatumDef, markDef, config}) =>\n    padding(channel, scaleType, config.scale, fieldOrDatumDef, markDef, config.bar),\n\n  paddingInner: ({scalePadding, channel, markDef, scaleType, config, hasNestedOffsetScale}) =>\n    paddingInner(scalePadding, channel, markDef.type, scaleType, config.scale, hasNestedOffsetScale),\n\n  paddingOuter: ({scalePadding, channel, scaleType, scalePaddingInner, config, hasNestedOffsetScale}) =>\n    paddingOuter(scalePadding, channel, scaleType, scalePaddingInner, config.scale, hasNestedOffsetScale),\n\n  reverse: ({fieldOrDatumDef, scaleType, channel, config}) => {\n    const sort = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined;\n    return reverse(scaleType, sort, channel, config.scale);\n  },\n  zero: ({channel, fieldOrDatumDef, domain, markDef, scaleType, config, hasSecondaryRangeChannel}) =>\n    zero(channel, fieldOrDatumDef, domain, markDef, scaleType, config.scale, hasSecondaryRangeChannel)\n};\n\n// This method is here rather than in range.ts to avoid circular dependency.\nexport function parseScaleRange(model: Model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleRange(model);\n  } else {\n    parseNonUnitScaleProperty(model, 'range');\n  }\n}\n\nexport function parseNonUnitScaleProperty(model: Model, property: keyof (Scale | ScaleComponentProps)) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  for (const child of model.children) {\n    if (property === 'range') {\n      parseScaleRange(child);\n    } else {\n      parseScaleProperty(child, property);\n    }\n  }\n\n  for (const channel of keys(localScaleComponents)) {\n    let valueWithExplicit: Explicit<any>;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        const childValueWithExplicit = childComponent.getWithExplicit(property);\n        valueWithExplicit = mergeValuesWithExplicit<VgScale, any>(\n          valueWithExplicit,\n          childValueWithExplicit,\n          property,\n          'scale',\n          tieBreakByComparing<VgScale, any>((v1, v2) => {\n            switch (property) {\n              case 'range':\n                // For step, prefer larger step\n                if (v1.step && v2.step) {\n                  return v1.step - v2.step;\n                }\n                return 0;\n              // TODO: precedence rule for other properties\n            }\n            return 0;\n          })\n        );\n      }\n    }\n    localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n  }\n}\n\nexport function bins(model: Model, fieldDef: TypedFieldDef<string>) {\n  const bin = fieldDef.bin;\n  if (isBinning(bin)) {\n    const binSignal = getBinSignalName(model, fieldDef.field, bin);\n    return new SignalRefWrapper(() => {\n      return model.getSignalName(binSignal);\n    });\n  } else if (isBinned(bin) && isBinParams(bin) && bin.step !== undefined) {\n    // start and stop will be determined from the scale domain\n    return {\n      step: bin.step\n    };\n  }\n  return undefined;\n}\n\nexport function interpolate(channel: ScaleChannel, type: Type): Scale['interpolate'] {\n  if (contains([COLOR, FILL, STROKE], channel) && type !== 'nominal') {\n    return 'hcl';\n  }\n  return undefined;\n}\n\nexport function nice(\n  scaleType: ScaleType,\n  channel: ScaleChannel,\n  specifiedDomain: Domain,\n  domainMin: Scale['domainMin'],\n  domainMax: Scale['domainMax'],\n  fieldOrDatumDef: TypedFieldDef<string> | ScaleDatumDef\n): boolean | TimeInterval {\n  if (\n    getFieldDef(fieldOrDatumDef)?.bin ||\n    isArray(specifiedDomain) ||\n    domainMax != null ||\n    domainMin != null ||\n    util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)\n  ) {\n    return undefined;\n  }\n  return isXorY(channel) ? true : undefined;\n}\n\nexport function padding(\n  channel: ScaleChannel,\n  scaleType: ScaleType,\n  scaleConfig: ScaleConfig<SignalRef>,\n  fieldOrDatumDef: TypedFieldDef<string> | ScaleDatumDef,\n  markDef: MarkDef<Mark, SignalRef>,\n  barConfig: RectConfig<SignalRef>\n) {\n  if (isXorY(channel)) {\n    if (isContinuousToContinuous(scaleType)) {\n      if (scaleConfig.continuousPadding !== undefined) {\n        return scaleConfig.continuousPadding;\n      }\n\n      const {type, orient} = markDef;\n      if (type === 'bar' && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {\n        if ((orient === 'vertical' && channel === 'x') || (orient === 'horizontal' && channel === 'y')) {\n          return barConfig.continuousBandSize;\n        }\n      }\n    }\n\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n  return undefined;\n}\n\nexport function paddingInner(\n  paddingValue: number | SignalRef,\n  channel: ScaleChannel,\n  mark: Mark,\n  scaleType: ScaleType,\n  scaleConfig: ScaleConfig<SignalRef>,\n  hasNestedOffsetScale = false\n) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n\n  if (isXorY(channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n    const {\n      bandPaddingInner,\n      barBandPaddingInner,\n      rectBandPaddingInner,\n      tickBandPaddingInner,\n      bandWithNestedOffsetPaddingInner\n    } = scaleConfig;\n\n    if (hasNestedOffsetScale) {\n      return bandWithNestedOffsetPaddingInner;\n    }\n\n    return getFirstDefined(\n      bandPaddingInner,\n      mark === 'bar' ? barBandPaddingInner : mark === 'tick' ? tickBandPaddingInner : rectBandPaddingInner\n    );\n  } else if (isXorYOffset(channel)) {\n    if (scaleType === ScaleType.BAND) {\n      return scaleConfig.offsetBandPaddingInner;\n    }\n  }\n  return undefined;\n}\n\nexport function paddingOuter(\n  paddingValue: number | SignalRef,\n  channel: ScaleChannel,\n  scaleType: ScaleType,\n  paddingInnerValue: number | SignalRef,\n  scaleConfig: ScaleConfig<SignalRef>,\n  hasNestedOffsetScale = false\n) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n\n  if (isXorY(channel)) {\n    const {bandPaddingOuter, bandWithNestedOffsetPaddingOuter} = scaleConfig;\n    if (hasNestedOffsetScale) {\n      return bandWithNestedOffsetPaddingOuter;\n    }\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    if (scaleType === ScaleType.BAND) {\n      return getFirstDefined(\n        bandPaddingOuter,\n        /* By default, paddingOuter is paddingInner / 2. The reason is that\n          size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n          and we want the width/height to be integer by default.\n          Note that step (by default) and cardinality are integers.) */\n        isSignalRef(paddingInnerValue) ? {signal: `${paddingInnerValue.signal}/2`} : paddingInnerValue / 2\n      );\n    }\n  } else if (isXorYOffset(channel)) {\n    if (scaleType === ScaleType.POINT) {\n      return 0.5; // so the point positions align with centers of band scales.\n    } else if (scaleType === ScaleType.BAND) {\n      return scaleConfig.offsetBandPaddingOuter;\n    }\n  }\n  return undefined;\n}\n\nexport function reverse(\n  scaleType: ScaleType,\n  sort: Sort<string>,\n  channel: ScaleChannel,\n  scaleConfig: ScaleConfig<SignalRef>\n) {\n  if (channel === 'x' && scaleConfig.xReverse !== undefined) {\n    if (hasContinuousDomain(scaleType) && sort === 'descending') {\n      if (isSignalRef(scaleConfig.xReverse)) {\n        return {signal: `!${scaleConfig.xReverse.signal}`};\n      } else {\n        return !scaleConfig.xReverse;\n      }\n    }\n    return scaleConfig.xReverse;\n  }\n\n  if (hasContinuousDomain(scaleType) && sort === 'descending') {\n    // For continuous domain scales, Vega does not support domain sort.\n    // Thus, we reverse range instead if sort is descending\n    return true;\n  }\n  return undefined;\n}\n\nexport function zero(\n  channel: ScaleChannel,\n  fieldDef: TypedFieldDef<string> | ScaleDatumDef,\n  specifiedDomain: Domain,\n  markDef: MarkDef,\n  scaleType: ScaleType,\n  scaleConfig: ScaleConfig<SignalRef>,\n  hasSecondaryRangeChannel: boolean\n) {\n  // If users explicitly provide a domain, we should not augment zero as that will be unexpected.\n  const hasCustomDomain = !!specifiedDomain && specifiedDomain !== 'unaggregated';\n  if (hasCustomDomain) {\n    if (hasContinuousDomain(scaleType)) {\n      if (isArray(specifiedDomain)) {\n        const first = specifiedDomain[0];\n        const last = specifiedDomain[specifiedDomain.length - 1];\n\n        if (isNumber(first) && first <= 0 && isNumber(last) && last >= 0) {\n          // if the domain includes zero, make zero remain true\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  // If there is no custom domain, return configZero value (=`true` as default) only for the following cases:\n\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common. However, if the scaleType is discretizing scale, we want to return\n  // false so that range doesn't start at zero\n  if (channel === 'size' && fieldDef.type === 'quantitative' && !isContinuousToDiscrete(scaleType)) {\n    return true;\n  }\n\n  // 2) non-binned, quantitative x-scale or y-scale\n  // (For binning, we should not include zero by default because binning are calculated without zero.)\n  // (For area/bar charts with ratio scale chart, we should always include zero.)\n  if (\n    !(isFieldDef(fieldDef) && fieldDef.bin) &&\n    util.contains([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)\n  ) {\n    const {orient, type} = markDef;\n    if (contains(['bar', 'area', 'line', 'trail'], type)) {\n      if ((orient === 'horizontal' && channel === 'y') || (orient === 'vertical' && channel === 'x')) {\n        return false;\n      }\n    }\n\n    if (contains(['bar', 'area'], type) && !hasSecondaryRangeChannel) {\n      return true;\n    }\n\n    return scaleConfig?.zero;\n  }\n\n  return false;\n}\n"],"mappings":"AACA,SAAQA,OAAO,EAAEC,QAAQ,QAAO,WAAW;AAC3C,SAAQC,QAAQ,EAAEC,SAAS,EAAEC,WAAW,QAAO,WAAW;AAC1D,SACEC,KAAK,EACLC,IAAI,EACJC,wBAAwB,EACxBC,MAAM,EACNC,YAAY,EACZC,6BAA6B,EAC7BC,uBAAuB,EAEvBC,MAAM,QACD,eAAe;AACtB,SACEC,WAAW,EACXC,kBAAkB,EAClBC,UAAU,EAIVC,SAAS,QACJ,kBAAkB;AAEzB,SAAQC,UAAU,QAAO,gBAAgB;AACzC,SAAQC,2BAA2B,QAAO,gBAAgB;AAC1D,OAAO,KAAKC,GAAG,MAAM,WAAW;AAEhC,SACEC,mCAAmC,EAEnCC,mBAAmB,EACnBC,wBAAwB,EACxBC,sBAAsB,EAGtBC,SAAS,EACTC,wBAAwB,QACnB,aAAa;AAGpB,OAAO,KAAKC,IAAI,MAAM,YAAY;AAClC,SAAQC,QAAQ,EAAEC,eAAe,EAAEC,IAAI,QAAO,YAAY;AAC1D,SAAQC,WAAW,QAAgB,mBAAmB;AACtD,SAAQC,gBAAgB,QAAO,aAAa;AAC5C,SAAQC,WAAW,QAAc,UAAU;AAC3C,SAAQC,gBAAgB,QAAO,WAAW;AAC1C,SAAkBC,uBAAuB,EAAEC,mBAAmB,QAAO,UAAU;AAG/E,SAAQC,mBAAmB,QAAO,SAAS;AAE3C,OAAM,SAAUC,kBAAkBA,CAACC,KAAY,EAAEC,QAA+D;EAC9G,IAAIP,WAAW,CAACM,KAAK,CAAC,EAAE;IACtBE,sBAAsB,CAACF,KAAK,EAAEC,QAAQ,CAAC;EACzC,CAAC,MAAM;IACLE,yBAAyB,CAACH,KAAK,EAAEC,QAAQ,CAAC;EAC5C;AACF;AAEA,SAASC,sBAAsBA,CAACF,KAAgB,EAAEC,QAA+D;EAC/G,MAAMG,oBAAoB,GAAwBJ,KAAK,CAACK,SAAS,CAACC,MAAM;EACxE,MAAM;IAACC,MAAM;IAAEC,QAAQ;IAAEC,OAAO;IAAEC;EAAe,CAAC,GAAGV,KAAK;EAE1D,KAAK,MAAMW,OAAO,IAAIpB,IAAI,CAACa,oBAAoB,CAAC,EAAE;IAChD,MAAMQ,cAAc,GAAGF,eAAe,CAACC,OAAO,CAAC;IAC/C,MAAME,cAAc,GAAGT,oBAAoB,CAACO,OAAO,CAAC;IACpD,MAAMG,eAAe,GAAGd,KAAK,CAACe,iBAAiB,CAACJ,OAAO,CAAC;IACxD,MAAMK,eAAe,GAAGxC,kBAAkB,CAACgC,QAAQ,CAACG,OAAO,CAAC,CAAgD;IAE5G,MAAMM,cAAc,GAAGL,cAAc,CAACX,QAAQ,CAAC;IAC/C,MAAMiB,SAAS,GAAGJ,eAAe,CAACK,GAAG,CAAC,MAAM,CAAC;IAC7C,MAAMC,YAAY,GAAGN,eAAe,CAACK,GAAG,CAAC,SAAS,CAAC;IACnD,MAAME,iBAAiB,GAAGP,eAAe,CAACK,GAAG,CAAC,cAAc,CAAC;IAE7D,MAAMG,oBAAoB,GAAGnC,wBAAwB,CAAC+B,SAAS,EAAEjB,QAAQ,CAAC;IAC1E,MAAMsB,sBAAsB,GAAGzC,mCAAmC,CAAC6B,OAAO,EAAEV,QAAQ,CAAC;IAErF,IAAIgB,cAAc,KAAKO,SAAS,EAAE;MAChC;MACA,IAAI,CAACF,oBAAoB,EAAE;QACzBzC,GAAG,CAAC4C,IAAI,CAAC5C,GAAG,CAAC6C,OAAO,CAACC,iCAAiC,CAACT,SAAS,EAAEjB,QAAQ,EAAEU,OAAO,CAAC,CAAC;MACvF,CAAC,MAAM,IAAIY,sBAAsB,EAAE;QACjC;QACA1C,GAAG,CAAC4C,IAAI,CAACF,sBAAsB,CAAC;MAClC;IACF;IACA,IAAID,oBAAoB,IAAIC,sBAAsB,KAAKC,SAAS,EAAE;MAChE,IAAIP,cAAc,KAAKO,SAAS,EAAE;QAChC,MAAMI,QAAQ,GAAIZ,eAAuB,CAACY,QAAQ;QAClD,MAAMC,IAAI,GAAGb,eAAe,CAACa,IAAI;QAEjC,QAAQ5B,QAAQ;UACd;UACA,KAAK,WAAW;UAChB,KAAK,WAAW;YACd,IAAItB,UAAU,CAACiC,cAAc,CAACX,QAAQ,CAAC,CAAC,IAAI4B,IAAI,KAAK,UAAU,IAAID,QAAQ,EAAE;cAC3Ef,cAAc,CAACiB,GAAG,CAAC7B,QAAQ,EAAE;gBAAC8B,MAAM,EAAErD,SAAS,CAACkC,cAAc,CAACX,QAAQ,CAAC,EAAE;kBAAC4B,IAAI;kBAAED;gBAAQ,CAAC;cAAC,CAAC,EAAE,IAAI,CAAC;YACrG,CAAC,MAAM;cACLf,cAAc,CAACiB,GAAG,CAAC7B,QAAQ,EAAEW,cAAc,CAACX,QAAQ,CAAQ,EAAE,IAAI,CAAC;YACrE;YACA;UACF;YACEY,cAAc,CAACmB,iBAAiB,CAC9B/B,QAAQ,EACRW,cAAc,CACf;QACL;MACF,CAAC,MAAM;QACL,MAAMqB,KAAK,GAAG7C,IAAI,CAAC8C,WAAW,CAACC,UAAU,EAAElC,QAAQ,CAAC,GAChDkC,UAAU,CAAClC,QAAQ,CAAC,CAAC;UACnBD,KAAK;UACLW,OAAO;UACPK,eAAe;UACfE,SAAS;UACTE,YAAY;UACZC,iBAAiB;UACjBe,MAAM,EAAExB,cAAc,CAACwB,MAAM;UAC7BC,SAAS,EAAEzB,cAAc,CAACyB,SAAS;UACnCC,SAAS,EAAE1B,cAAc,CAAC0B,SAAS;UACnC7B,OAAO;UACPF,MAAM;UACNgC,oBAAoB,EAAE3D,2BAA2B,CAAC4B,QAAQ,EAAEG,OAAO,CAAC;UACpE6B,wBAAwB,EAAE,CAAC,CAAChC,QAAQ,CAACvC,wBAAwB,CAAC0C,OAAO,CAAC;SACvE,CAAC,GACFJ,MAAM,CAACkC,KAAK,CAACxC,QAAQ,CAAC;QAC1B,IAAIgC,KAAK,KAAKT,SAAS,EAAE;UACvBX,cAAc,CAACiB,GAAG,CAAC7B,QAAQ,EAAEgC,KAAY,EAAE,KAAK,CAAC;QACnD;MACF;IACF;EACF;AACF;AAkBA,OAAO,MAAME,UAAU,GAEnB;EACFO,IAAI,EAAEC,IAAA;IAAA,IAAC;MAAC3C,KAAK;MAAEgB;IAAe,CAAC,GAAA2B,IAAA;IAAA,OAAMlE,UAAU,CAACuC,eAAe,CAAC,GAAG0B,IAAI,CAAC1C,KAAK,EAAEgB,eAAe,CAAC,GAAGQ,SAAS;EAAA,CAAC;EAE5GoB,WAAW,EAAEC,KAAA;IAAA,IAAC;MAAClC,OAAO;MAAEK;IAAe,CAAC,GAAA6B,KAAA;IAAA,OAAKD,WAAW,CAACjC,OAAO,EAAEK,eAAe,CAACa,IAAI,CAAC;EAAA;EAEvFiB,IAAI,EAAEC,KAAA;IAAA,IAAC;MAAC7B,SAAS;MAAEP,OAAO;MAAEyB,MAAM;MAAEC,SAAS;MAAEC,SAAS;MAAEtB;IAAe,CAAC,GAAA+B,KAAA;IAAA,OACxED,IAAI,CAAC5B,SAAS,EAAEP,OAAO,EAAEyB,MAAM,EAAEC,SAAS,EAAEC,SAAS,EAAEtB,eAAe,CAAC;EAAA;EAEzEgC,OAAO,EAAEC,KAAA;IAAA,IAAC;MAACtC,OAAO;MAAEO,SAAS;MAAEF,eAAe;MAAEP,OAAO;MAAEF;IAAM,CAAC,GAAA0C,KAAA;IAAA,OAC9DD,OAAO,CAACrC,OAAO,EAAEO,SAAS,EAAEX,MAAM,CAACkC,KAAK,EAAEzB,eAAe,EAAEP,OAAO,EAAEF,MAAM,CAAC2C,GAAG,CAAC;EAAA;EAEjFC,YAAY,EAAEC,KAAA;IAAA,IAAC;MAAChC,YAAY;MAAET,OAAO;MAAEF,OAAO;MAAES,SAAS;MAAEX,MAAM;MAAEgC;IAAoB,CAAC,GAAAa,KAAA;IAAA,OACtFD,YAAY,CAAC/B,YAAY,EAAET,OAAO,EAAEF,OAAO,CAACoB,IAAI,EAAEX,SAAS,EAAEX,MAAM,CAACkC,KAAK,EAAEF,oBAAoB,CAAC;EAAA;EAElGc,YAAY,EAAEC,KAAA;IAAA,IAAC;MAAClC,YAAY;MAAET,OAAO;MAAEO,SAAS;MAAEG,iBAAiB;MAAEd,MAAM;MAAEgC;IAAoB,CAAC,GAAAe,KAAA;IAAA,OAChGD,YAAY,CAACjC,YAAY,EAAET,OAAO,EAAEO,SAAS,EAAEG,iBAAiB,EAAEd,MAAM,CAACkC,KAAK,EAAEF,oBAAoB,CAAC;EAAA;EAEvGgB,OAAO,EAAEC,KAAA,IAAkD;IAAA,IAAjD;MAACxC,eAAe;MAAEE,SAAS;MAAEP,OAAO;MAAEJ;IAAM,CAAC,GAAAiD,KAAA;IACrD,MAAMC,IAAI,GAAGhF,UAAU,CAACuC,eAAe,CAAC,GAAGA,eAAe,CAACyC,IAAI,GAAGjC,SAAS;IAC3E,OAAO+B,OAAO,CAACrC,SAAS,EAAEuC,IAAI,EAAE9C,OAAO,EAAEJ,MAAM,CAACkC,KAAK,CAAC;EACxD,CAAC;EACDiB,IAAI,EAAEC,KAAA;IAAA,IAAC;MAAChD,OAAO;MAAEK,eAAe;MAAEoB,MAAM;MAAE3B,OAAO;MAAES,SAAS;MAAEX,MAAM;MAAEiC;IAAwB,CAAC,GAAAmB,KAAA;IAAA,OAC7FD,IAAI,CAAC/C,OAAO,EAAEK,eAAe,EAAEoB,MAAM,EAAE3B,OAAO,EAAES,SAAS,EAAEX,MAAM,CAACkC,KAAK,EAAED,wBAAwB,CAAC;EAAA;CACrG;AAED;AACA,OAAM,SAAUoB,eAAeA,CAAC5D,KAAY;EAC1C,IAAIN,WAAW,CAACM,KAAK,CAAC,EAAE;IACtBF,mBAAmB,CAACE,KAAK,CAAC;EAC5B,CAAC,MAAM;IACLG,yBAAyB,CAACH,KAAK,EAAE,OAAO,CAAC;EAC3C;AACF;AAEA,OAAM,SAAUG,yBAAyBA,CAACH,KAAY,EAAEC,QAA6C;EACnG,MAAMG,oBAAoB,GAAwBJ,KAAK,CAACK,SAAS,CAACC,MAAM;EAExE,KAAK,MAAMuD,KAAK,IAAI7D,KAAK,CAAC8D,QAAQ,EAAE;IAClC,IAAI7D,QAAQ,KAAK,OAAO,EAAE;MACxB2D,eAAe,CAACC,KAAK,CAAC;IACxB,CAAC,MAAM;MACL9D,kBAAkB,CAAC8D,KAAK,EAAE5D,QAAQ,CAAC;IACrC;EACF;EAEA,KAAK,MAAMU,OAAO,IAAIpB,IAAI,CAACa,oBAAoB,CAAC,EAAE;IAChD,IAAI2D,iBAAgC;IAEpC,KAAK,MAAMF,KAAK,IAAI7D,KAAK,CAAC8D,QAAQ,EAAE;MAClC,MAAME,cAAc,GAAGH,KAAK,CAACxD,SAAS,CAACC,MAAM,CAACK,OAAO,CAAC;MACtD,IAAIqD,cAAc,EAAE;QAClB,MAAMC,sBAAsB,GAAGD,cAAc,CAACE,eAAe,CAACjE,QAAQ,CAAC;QACvE8D,iBAAiB,GAAGnE,uBAAuB,CACzCmE,iBAAiB,EACjBE,sBAAsB,EACtBhE,QAAQ,EACR,OAAO,EACPJ,mBAAmB,CAAe,CAACsE,EAAE,EAAEC,EAAE,KAAI;UAC3C,QAAQnE,QAAQ;YACd,KAAK,OAAO;cACV;cACA,IAAIkE,EAAE,CAACE,IAAI,IAAID,EAAE,CAACC,IAAI,EAAE;gBACtB,OAAOF,EAAE,CAACE,IAAI,GAAGD,EAAE,CAACC,IAAI;cAC1B;cACA,OAAO,CAAC;YACV;UACF;UACA,OAAO,CAAC;QACV,CAAC,CAAC,CACH;MACH;IACF;IACAjE,oBAAoB,CAACO,OAAO,CAAC,CAAC2D,eAAe,CAACrE,QAAQ,EAAE8D,iBAAiB,CAAC;EAC5E;AACF;AAEA,OAAM,SAAUrB,IAAIA,CAAC1C,KAAY,EAAEuE,QAA+B;EAChE,MAAMC,GAAG,GAAGD,QAAQ,CAACC,GAAG;EACxB,IAAI3G,SAAS,CAAC2G,GAAG,CAAC,EAAE;IAClB,MAAMC,SAAS,GAAGhF,gBAAgB,CAACO,KAAK,EAAEuE,QAAQ,CAACG,KAAK,EAAEF,GAAG,CAAC;IAC9D,OAAO,IAAI7E,gBAAgB,CAAC,MAAK;MAC/B,OAAOK,KAAK,CAAC2E,aAAa,CAACF,SAAS,CAAC;IACvC,CAAC,CAAC;EACJ,CAAC,MAAM,IAAI7G,QAAQ,CAAC4G,GAAG,CAAC,IAAI1G,WAAW,CAAC0G,GAAG,CAAC,IAAIA,GAAG,CAACH,IAAI,KAAK7C,SAAS,EAAE;IACtE;IACA,OAAO;MACL6C,IAAI,EAAEG,GAAG,CAACH;KACX;EACH;EACA,OAAO7C,SAAS;AAClB;AAEA,OAAM,SAAUoB,WAAWA,CAACjC,OAAqB,EAAEkB,IAAU;EAC3D,IAAIxC,QAAQ,CAAC,CAACtB,KAAK,EAAEC,IAAI,EAAEM,MAAM,CAAC,EAAEqC,OAAO,CAAC,IAAIkB,IAAI,KAAK,SAAS,EAAE;IAClE,OAAO,KAAK;EACd;EACA,OAAOL,SAAS;AAClB;AAEA,OAAM,SAAUsB,IAAIA,CAClB5B,SAAoB,EACpBP,OAAqB,EACrBiE,eAAuB,EACvBvC,SAA6B,EAC7BC,SAA6B,EAC7BtB,eAAsD;EAEtD,IACEzC,WAAW,CAACyC,eAAe,CAAC,EAAEwD,GAAG,IACjC9G,OAAO,CAACkH,eAAe,CAAC,IACxBtC,SAAS,IAAI,IAAI,IACjBD,SAAS,IAAI,IAAI,IACjBjD,IAAI,CAACC,QAAQ,CAAC,CAACH,SAAS,CAAC2F,IAAI,EAAE3F,SAAS,CAAC4F,GAAG,CAAC,EAAE5D,SAAS,CAAC,EACzD;IACA,OAAOM,SAAS;EAClB;EACA,OAAOtD,MAAM,CAACyC,OAAO,CAAC,GAAG,IAAI,GAAGa,SAAS;AAC3C;AAEA,OAAM,SAAUwB,OAAOA,CACrBrC,OAAqB,EACrBO,SAAoB,EACpB6D,WAAmC,EACnC/D,eAAsD,EACtDP,OAAiC,EACjCuE,SAAgC;EAEhC,IAAI9G,MAAM,CAACyC,OAAO,CAAC,EAAE;IACnB,IAAI3B,wBAAwB,CAACkC,SAAS,CAAC,EAAE;MACvC,IAAI6D,WAAW,CAACE,iBAAiB,KAAKzD,SAAS,EAAE;QAC/C,OAAOuD,WAAW,CAACE,iBAAiB;MACtC;MAEA,MAAM;QAACpD,IAAI;QAAEqD;MAAM,CAAC,GAAGzE,OAAO;MAC9B,IAAIoB,IAAI,KAAK,KAAK,IAAI,EAAEpD,UAAU,CAACuC,eAAe,CAAC,KAAKA,eAAe,CAACwD,GAAG,IAAIxD,eAAe,CAACY,QAAQ,CAAC,CAAC,EAAE;QACzG,IAAKsD,MAAM,KAAK,UAAU,IAAIvE,OAAO,KAAK,GAAG,IAAMuE,MAAM,KAAK,YAAY,IAAIvE,OAAO,KAAK,GAAI,EAAE;UAC9F,OAAOqE,SAAS,CAACG,kBAAkB;QACrC;MACF;IACF;IAEA,IAAIjE,SAAS,KAAKhC,SAAS,CAACkG,KAAK,EAAE;MACjC,OAAOL,WAAW,CAACM,YAAY;IACjC;EACF;EACA,OAAO7D,SAAS;AAClB;AAEA,OAAM,SAAU2B,YAAYA,CAC1BmC,YAAgC,EAChC3E,OAAqB,EACrB4E,IAAU,EACVrE,SAAoB,EACpB6D,WAAmC,EACP;EAAA,IAA5BxC,oBAAoB,GAAAiD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAhE,SAAA,GAAAgE,SAAA,MAAG,KAAK;EAE5B,IAAIF,YAAY,KAAK9D,SAAS,EAAE;IAC9B;IACA,OAAOA,SAAS;EAClB;EAEA,IAAItD,MAAM,CAACyC,OAAO,CAAC,EAAE;IACnB;IACA;IAEA;IACA,MAAM;MACJ+E,gBAAgB;MAChBC,mBAAmB;MACnBC,oBAAoB;MACpBC,oBAAoB;MACpBC;IAAgC,CACjC,GAAGf,WAAW;IAEf,IAAIxC,oBAAoB,EAAE;MACxB,OAAOuD,gCAAgC;IACzC;IAEA,OAAOxG,eAAe,CACpBoG,gBAAgB,EAChBH,IAAI,KAAK,KAAK,GAAGI,mBAAmB,GAAGJ,IAAI,KAAK,MAAM,GAAGM,oBAAoB,GAAGD,oBAAoB,CACrG;EACH,CAAC,MAAM,IAAIzH,YAAY,CAACwC,OAAO,CAAC,EAAE;IAChC,IAAIO,SAAS,KAAKhC,SAAS,CAAC6G,IAAI,EAAE;MAChC,OAAOhB,WAAW,CAACiB,sBAAsB;IAC3C;EACF;EACA,OAAOxE,SAAS;AAClB;AAEA,OAAM,SAAU6B,YAAYA,CAC1BiC,YAAgC,EAChC3E,OAAqB,EACrBO,SAAoB,EACpB+E,iBAAqC,EACrClB,WAAmC,EACP;EAAA,IAA5BxC,oBAAoB,GAAAiD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAhE,SAAA,GAAAgE,SAAA,MAAG,KAAK;EAE5B,IAAIF,YAAY,KAAK9D,SAAS,EAAE;IAC9B;IACA,OAAOA,SAAS;EAClB;EAEA,IAAItD,MAAM,CAACyC,OAAO,CAAC,EAAE;IACnB,MAAM;MAACuF,gBAAgB;MAAEC;IAAgC,CAAC,GAAGpB,WAAW;IACxE,IAAIxC,oBAAoB,EAAE;MACxB,OAAO4D,gCAAgC;IACzC;IACA;IACA;IACA,IAAIjF,SAAS,KAAKhC,SAAS,CAAC6G,IAAI,EAAE;MAChC,OAAOzG,eAAe,CACpB4G,gBAAgB;MAChB;;;;MAIA1G,WAAW,CAACyG,iBAAiB,CAAC,GAAG;QAAClE,MAAM,EAAE,GAAGkE,iBAAiB,CAAClE,MAAM;MAAI,CAAC,GAAGkE,iBAAiB,GAAG,CAAC,CACnG;IACH;EACF,CAAC,MAAM,IAAI9H,YAAY,CAACwC,OAAO,CAAC,EAAE;IAChC,IAAIO,SAAS,KAAKhC,SAAS,CAACkG,KAAK,EAAE;MACjC,OAAO,GAAG,CAAC,CAAC;IACd,CAAC,MAAM,IAAIlE,SAAS,KAAKhC,SAAS,CAAC6G,IAAI,EAAE;MACvC,OAAOhB,WAAW,CAACqB,sBAAsB;IAC3C;EACF;EACA,OAAO5E,SAAS;AAClB;AAEA,OAAM,SAAU+B,OAAOA,CACrBrC,SAAoB,EACpBuC,IAAkB,EAClB9C,OAAqB,EACrBoE,WAAmC;EAEnC,IAAIpE,OAAO,KAAK,GAAG,IAAIoE,WAAW,CAACsB,QAAQ,KAAK7E,SAAS,EAAE;IACzD,IAAIzC,mBAAmB,CAACmC,SAAS,CAAC,IAAIuC,IAAI,KAAK,YAAY,EAAE;MAC3D,IAAIjE,WAAW,CAACuF,WAAW,CAACsB,QAAQ,CAAC,EAAE;QACrC,OAAO;UAACtE,MAAM,EAAE,IAAIgD,WAAW,CAACsB,QAAQ,CAACtE,MAAM;QAAE,CAAC;MACpD,CAAC,MAAM;QACL,OAAO,CAACgD,WAAW,CAACsB,QAAQ;MAC9B;IACF;IACA,OAAOtB,WAAW,CAACsB,QAAQ;EAC7B;EAEA,IAAItH,mBAAmB,CAACmC,SAAS,CAAC,IAAIuC,IAAI,KAAK,YAAY,EAAE;IAC3D;IACA;IACA,OAAO,IAAI;EACb;EACA,OAAOjC,SAAS;AAClB;AAEA,OAAM,SAAUkC,IAAIA,CAClB/C,OAAqB,EACrB4D,QAA+C,EAC/CK,eAAuB,EACvBnE,OAAgB,EAChBS,SAAoB,EACpB6D,WAAmC,EACnCvC,wBAAiC;EAEjC;EACA,MAAM8D,eAAe,GAAG,CAAC,CAAC1B,eAAe,IAAIA,eAAe,KAAK,cAAc;EAC/E,IAAI0B,eAAe,EAAE;IACnB,IAAIvH,mBAAmB,CAACmC,SAAS,CAAC,EAAE;MAClC,IAAIxD,OAAO,CAACkH,eAAe,CAAC,EAAE;QAC5B,MAAM2B,KAAK,GAAG3B,eAAe,CAAC,CAAC,CAAC;QAChC,MAAM4B,IAAI,GAAG5B,eAAe,CAACA,eAAe,CAACa,MAAM,GAAG,CAAC,CAAC;QAExD,IAAI9H,QAAQ,CAAC4I,KAAK,CAAC,IAAIA,KAAK,IAAI,CAAC,IAAI5I,QAAQ,CAAC6I,IAAI,CAAC,IAAIA,IAAI,IAAI,CAAC,EAAE;UAChE;UACA,OAAO,IAAI;QACb;MACF;MACA,OAAO,KAAK;IACd;EACF;EAEA;EAEA;EACA;EACA;EACA;EACA,IAAI7F,OAAO,KAAK,MAAM,IAAI4D,QAAQ,CAAC1C,IAAI,KAAK,cAAc,IAAI,CAAC5C,sBAAsB,CAACiC,SAAS,CAAC,EAAE;IAChG,OAAO,IAAI;EACb;EAEA;EACA;EACA;EACA,IACE,EAAEzC,UAAU,CAAC8F,QAAQ,CAAC,IAAIA,QAAQ,CAACC,GAAG,CAAC,IACvCpF,IAAI,CAACC,QAAQ,CAAC,CAAC,GAAGhB,uBAAuB,EAAE,GAAGD,6BAA6B,CAAC,EAAEuC,OAAO,CAAC,EACtF;IACA,MAAM;MAACuE,MAAM;MAAErD;IAAI,CAAC,GAAGpB,OAAO;IAC9B,IAAIpB,QAAQ,CAAC,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,EAAEwC,IAAI,CAAC,EAAE;MACpD,IAAKqD,MAAM,KAAK,YAAY,IAAIvE,OAAO,KAAK,GAAG,IAAMuE,MAAM,KAAK,UAAU,IAAIvE,OAAO,KAAK,GAAI,EAAE;QAC9F,OAAO,KAAK;MACd;IACF;IAEA,IAAItB,QAAQ,CAAC,CAAC,KAAK,EAAE,MAAM,CAAC,EAAEwC,IAAI,CAAC,IAAI,CAACW,wBAAwB,EAAE;MAChE,OAAO,IAAI;IACb;IAEA,OAAOuC,WAAW,EAAErB,IAAI;EAC1B;EAEA,OAAO,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}