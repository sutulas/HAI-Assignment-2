{"ast":null,"code":"import { isString } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2 } from '../../channel';\nimport { getFieldOrDatumDef, isDatumDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class GeoPointNode extends DataFlowNode {\n  clone() {\n    return new GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));\n  }\n  constructor(parent, projection, fields, as) {\n    super(parent);\n    this.projection = projection;\n    this.fields = fields;\n    this.as = as;\n  }\n  static parseAll(parent, model) {\n    if (!model.projectionName()) {\n      return parent;\n    }\n    for (const coordinates of [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]]) {\n      const pair = coordinates.map(channel => {\n        const def = getFieldOrDatumDef(model.encoding[channel]);\n        return isFieldDef(def) ? def.field : isDatumDef(def) ? {\n          expr: `${def.datum}`\n        } : isValueDef(def) ? {\n          expr: `${def['value']}`\n        } : undefined;\n      });\n      const suffix = coordinates[0] === LONGITUDE2 ? '2' : '';\n      if (pair[0] || pair[1]) {\n        parent = new GeoPointNode(parent, model.projectionName(), pair, [model.getName(`x${suffix}`), model.getName(`y${suffix}`)]);\n      }\n    }\n    return parent;\n  }\n  dependentFields() {\n    return new Set(this.fields.filter(isString));\n  }\n  producedFields() {\n    return new Set(this.as);\n  }\n  hash() {\n    return `Geopoint ${this.projection} ${hash(this.fields)} ${hash(this.as)}`;\n  }\n  assemble() {\n    return {\n      type: 'geopoint',\n      projection: this.projection,\n      fields: this.fields,\n      as: this.as\n    };\n  }\n}","map":{"version":3,"names":["isString","LATITUDE","LATITUDE2","LONGITUDE","LONGITUDE2","getFieldOrDatumDef","isDatumDef","isFieldDef","isValueDef","duplicate","hash","DataFlowNode","GeoPointNode","clone","projection","fields","as","constructor","parent","parseAll","model","projectionName","coordinates","pair","map","channel","def","encoding","field","expr","datum","undefined","suffix","getName","dependentFields","Set","filter","producedFields","assemble","type"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\data\\geopoint.ts"],"sourcesContent":["import {GeoPointTransform as VgGeoPointTransform, Vector2} from 'vega';\nimport {isString} from 'vega-util';\nimport {GeoPositionChannel, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2} from '../../channel';\nimport {getFieldOrDatumDef, isDatumDef, isFieldDef, isValueDef} from '../../channeldef';\nimport {duplicate, hash} from '../../util';\nimport {VgExprRef} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\nexport class GeoPointNode extends DataFlowNode {\n  public clone() {\n    return new GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));\n  }\n\n  constructor(\n    parent: DataFlowNode,\n    private projection: string,\n    private fields: [string | VgExprRef, string | VgExprRef],\n    private as: [string, string]\n  ) {\n    super(parent);\n  }\n\n  public static parseAll(parent: DataFlowNode, model: UnitModel): DataFlowNode {\n    if (!model.projectionName()) {\n      return parent;\n    }\n\n    for (const coordinates of [\n      [LONGITUDE, LATITUDE],\n      [LONGITUDE2, LATITUDE2]\n    ] as Vector2<GeoPositionChannel>[]) {\n      const pair = coordinates.map(channel => {\n        const def = getFieldOrDatumDef(model.encoding[channel]);\n        return isFieldDef(def)\n          ? def.field\n          : isDatumDef(def)\n            ? {expr: `${def.datum}`}\n            : isValueDef(def)\n              ? {expr: `${def['value']}`}\n              : undefined;\n      }) as [GeoPositionChannel, GeoPositionChannel];\n\n      const suffix = coordinates[0] === LONGITUDE2 ? '2' : '';\n\n      if (pair[0] || pair[1]) {\n        parent = new GeoPointNode(parent, model.projectionName(), pair, [\n          model.getName(`x${suffix}`),\n          model.getName(`y${suffix}`)\n        ]);\n      }\n    }\n\n    return parent;\n  }\n\n  public dependentFields() {\n    return new Set(this.fields.filter(isString));\n  }\n\n  public producedFields() {\n    return new Set(this.as);\n  }\n\n  public hash() {\n    return `Geopoint ${this.projection} ${hash(this.fields)} ${hash(this.as)}`;\n  }\n\n  public assemble(): VgGeoPointTransform {\n    return {\n      type: 'geopoint',\n      projection: this.projection,\n      fields: this.fields,\n      as: this.as\n    };\n  }\n}\n"],"mappings":"AACA,SAAQA,QAAQ,QAAO,WAAW;AAClC,SAA4BC,QAAQ,EAAEC,SAAS,EAAEC,SAAS,EAAEC,UAAU,QAAO,eAAe;AAC5F,SAAQC,kBAAkB,EAAEC,UAAU,EAAEC,UAAU,EAAEC,UAAU,QAAO,kBAAkB;AACvF,SAAQC,SAAS,EAAEC,IAAI,QAAO,YAAY;AAG1C,SAAQC,YAAY,QAAO,YAAY;AAEvC,OAAM,MAAOC,YAAa,SAAQD,YAAY;EACrCE,KAAKA,CAAA;IACV,OAAO,IAAID,YAAY,CAAC,IAAI,EAAE,IAAI,CAACE,UAAU,EAAEL,SAAS,CAAC,IAAI,CAACM,MAAM,CAAC,EAAEN,SAAS,CAAC,IAAI,CAACO,EAAE,CAAC,CAAC;EAC5F;EAEAC,YACEC,MAAoB,EACZJ,UAAkB,EAClBC,MAAgD,EAChDC,EAAoB;IAE5B,KAAK,CAACE,MAAM,CAAC;IAJL,KAAAJ,UAAU,GAAVA,UAAU;IACV,KAAAC,MAAM,GAANA,MAAM;IACN,KAAAC,EAAE,GAAFA,EAAE;EAGZ;EAEO,OAAOG,QAAQA,CAACD,MAAoB,EAAEE,KAAgB;IAC3D,IAAI,CAACA,KAAK,CAACC,cAAc,EAAE,EAAE;MAC3B,OAAOH,MAAM;IACf;IAEA,KAAK,MAAMI,WAAW,IAAI,CACxB,CAACnB,SAAS,EAAEF,QAAQ,CAAC,EACrB,CAACG,UAAU,EAAEF,SAAS,CAAC,CACS,EAAE;MAClC,MAAMqB,IAAI,GAAGD,WAAW,CAACE,GAAG,CAACC,OAAO,IAAG;QACrC,MAAMC,GAAG,GAAGrB,kBAAkB,CAACe,KAAK,CAACO,QAAQ,CAACF,OAAO,CAAC,CAAC;QACvD,OAAOlB,UAAU,CAACmB,GAAG,CAAC,GAClBA,GAAG,CAACE,KAAK,GACTtB,UAAU,CAACoB,GAAG,CAAC,GACb;UAACG,IAAI,EAAE,GAAGH,GAAG,CAACI,KAAK;QAAE,CAAC,GACtBtB,UAAU,CAACkB,GAAG,CAAC,GACb;UAACG,IAAI,EAAE,GAAGH,GAAG,CAAC,OAAO,CAAC;QAAE,CAAC,GACzBK,SAAS;MACnB,CAAC,CAA6C;MAE9C,MAAMC,MAAM,GAAGV,WAAW,CAAC,CAAC,CAAC,KAAKlB,UAAU,GAAG,GAAG,GAAG,EAAE;MAEvD,IAAImB,IAAI,CAAC,CAAC,CAAC,IAAIA,IAAI,CAAC,CAAC,CAAC,EAAE;QACtBL,MAAM,GAAG,IAAIN,YAAY,CAACM,MAAM,EAAEE,KAAK,CAACC,cAAc,EAAE,EAAEE,IAAI,EAAE,CAC9DH,KAAK,CAACa,OAAO,CAAC,IAAID,MAAM,EAAE,CAAC,EAC3BZ,KAAK,CAACa,OAAO,CAAC,IAAID,MAAM,EAAE,CAAC,CAC5B,CAAC;MACJ;IACF;IAEA,OAAOd,MAAM;EACf;EAEOgB,eAAeA,CAAA;IACpB,OAAO,IAAIC,GAAG,CAAC,IAAI,CAACpB,MAAM,CAACqB,MAAM,CAACpC,QAAQ,CAAC,CAAC;EAC9C;EAEOqC,cAAcA,CAAA;IACnB,OAAO,IAAIF,GAAG,CAAC,IAAI,CAACnB,EAAE,CAAC;EACzB;EAEON,IAAIA,CAAA;IACT,OAAO,YAAY,IAAI,CAACI,UAAU,IAAIJ,IAAI,CAAC,IAAI,CAACK,MAAM,CAAC,IAAIL,IAAI,CAAC,IAAI,CAACM,EAAE,CAAC,EAAE;EAC5E;EAEOsB,QAAQA,CAAA;IACb,OAAO;MACLC,IAAI,EAAE,UAAU;MAChBzB,UAAU,EAAE,IAAI,CAACA,UAAU;MAC3BC,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBC,EAAE,EAAE,IAAI,CAACA;KACV;EACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}