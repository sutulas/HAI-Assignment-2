{"ast":null,"code":"import { array, isArray, stringValue } from 'vega-util';\nimport { vgField } from '../channeldef';\nimport { isExprRef } from '../expr';\nimport { isText } from '../title';\nimport { deepEqual, getFirstDefined, hasProperty } from '../util';\nimport { isSignalRef } from '../vega.schema';\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\nexport function signalOrValueRefWithCondition(val) {\n  const condition = isArray(val.condition) ? val.condition.map(conditionalSignalRefOrValue) : conditionalSignalRefOrValue(val.condition);\n  return {\n    ...signalRefOrValue(val),\n    condition\n  };\n}\nexport function signalRefOrValue(value) {\n  if (isExprRef(value)) {\n    const {\n      expr,\n      ...rest\n    } = value;\n    return {\n      signal: expr,\n      ...rest\n    };\n  }\n  return value;\n}\nexport function conditionalSignalRefOrValue(value) {\n  if (isExprRef(value)) {\n    const {\n      expr,\n      ...rest\n    } = value;\n    return {\n      signal: expr,\n      ...rest\n    };\n  }\n  return value;\n}\nexport function signalOrValueRef(value) {\n  if (isExprRef(value)) {\n    const {\n      expr,\n      ...rest\n    } = value;\n    return {\n      signal: expr,\n      ...rest\n    };\n  }\n  if (isSignalRef(value)) {\n    return value;\n  }\n  return value !== undefined ? {\n    value\n  } : undefined;\n}\nexport function exprFromSignalRefOrValue(ref) {\n  if (isSignalRef(ref)) {\n    return ref.signal;\n  }\n  return stringValue(ref);\n}\nexport function exprFromValueRefOrSignalRef(ref) {\n  if (isSignalRef(ref)) {\n    return ref.signal;\n  }\n  return stringValue(ref.value);\n}\nexport function signalOrStringValue(v) {\n  if (isSignalRef(v)) {\n    return v.signal;\n  }\n  return v == null ? null : stringValue(v);\n}\nexport function applyMarkConfig(e, model, propsList) {\n  for (const property of propsList) {\n    const value = getMarkConfig(property, model.markDef, model.config);\n    if (value !== undefined) {\n      e[property] = signalOrValueRef(value);\n    }\n  }\n  return e;\n}\nexport function getStyles(mark) {\n  return [].concat(mark.type, mark.style ?? []);\n}\nexport function getMarkPropOrConfig(channel, mark, config) {\n  let opt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    vgChannel,\n    ignoreVgConfig\n  } = opt;\n  if (vgChannel && hasProperty(mark, vgChannel)) {\n    return mark[vgChannel];\n  } else if (mark[channel] !== undefined) {\n    return mark[channel];\n  } else if (ignoreVgConfig && (!vgChannel || vgChannel === channel)) {\n    return undefined;\n  }\n  return getMarkConfig(channel, mark, config, opt);\n}\n/**\n * Return property value from style or mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\nexport function getMarkConfig(channel, mark, config) {\n  let {\n    vgChannel\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const cfg = getMarkStyleConfig(channel, mark, config.style);\n  return getFirstDefined(\n  // style config has highest precedence\n  vgChannel ? cfg : undefined, cfg,\n  // then mark-specific config\n  vgChannel ? config[mark.type][vgChannel] : undefined, config[mark.type][channel],\n  // Need to cast because MarkDef doesn't perfectly match with AnyMarkConfig, but if the type isn't available, we'll get nothing here, which is fine\n  // If there is vgChannel, skip vl channel.\n  // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.\n  vgChannel ? config.mark[vgChannel] : config.mark[channel] // Need to cast for the same reason as above\n  );\n}\nexport function getMarkStyleConfig(prop, mark, styleConfigIndex) {\n  return getStyleConfig(prop, getStyles(mark), styleConfigIndex);\n}\nexport function getStyleConfig(p, styles, styleConfigIndex) {\n  styles = array(styles);\n  let value;\n  for (const style of styles) {\n    const styleConfig = styleConfigIndex[style];\n    if (hasProperty(styleConfig, p)) {\n      value = styleConfig[p];\n    }\n  }\n  return value;\n}\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\nexport function sortParams(orderDef, fieldRefOption) {\n  return array(orderDef).reduce((s, orderChannelDef) => {\n    s.field.push(vgField(orderChannelDef, fieldRefOption));\n    s.order.push(orderChannelDef.sort ?? 'ascending');\n    return s;\n  }, {\n    field: [],\n    order: []\n  });\n}\nexport function mergeTitleFieldDefs(f1, f2) {\n  const merged = [...f1];\n  f2.forEach(fdToMerge => {\n    for (const fieldDef1 of merged) {\n      // If already exists, no need to append to merged array\n      if (deepEqual(fieldDef1, fdToMerge)) {\n        return;\n      }\n    }\n    merged.push(fdToMerge);\n  });\n  return merged;\n}\nexport function mergeTitle(title1, title2) {\n  if (deepEqual(title1, title2) || !title2) {\n    // if titles are the same or title2 is falsy\n    return title1;\n  } else if (!title1) {\n    // if title1 is falsy\n    return title2;\n  } else {\n    return [...array(title1), ...array(title2)].join(', ');\n  }\n}\nexport function mergeTitleComponent(v1, v2) {\n  const v1Val = v1.value;\n  const v2Val = v2.value;\n  if (v1Val == null || v2Val === null) {\n    return {\n      explicit: v1.explicit,\n      value: null\n    };\n  } else if ((isText(v1Val) || isSignalRef(v1Val)) && (isText(v2Val) || isSignalRef(v2Val))) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitle(v1Val, v2Val)\n    };\n  } else if (isText(v1Val) || isSignalRef(v1Val)) {\n    return {\n      explicit: v1.explicit,\n      value: v1Val\n    };\n  } else if (isText(v2Val) || isSignalRef(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: v2Val\n    };\n  } else if (!isText(v1Val) && !isSignalRef(v1Val) && !isText(v2Val) && !isSignalRef(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitleFieldDefs(v1Val, v2Val)\n    };\n  }\n  /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n  throw new Error('It should never reach here');\n}","map":{"version":3,"names":["array","isArray","stringValue","vgField","isExprRef","isText","deepEqual","getFirstDefined","hasProperty","isSignalRef","BIN_RANGE_DELIMITER","signalOrValueRefWithCondition","val","condition","map","conditionalSignalRefOrValue","signalRefOrValue","value","expr","rest","signal","signalOrValueRef","undefined","exprFromSignalRefOrValue","ref","exprFromValueRefOrSignalRef","signalOrStringValue","v","applyMarkConfig","e","model","propsList","property","getMarkConfig","markDef","config","getStyles","mark","concat","type","style","getMarkPropOrConfig","channel","opt","arguments","length","vgChannel","ignoreVgConfig","cfg","getMarkStyleConfig","prop","styleConfigIndex","getStyleConfig","p","styles","styleConfig","sortParams","orderDef","fieldRefOption","reduce","s","orderChannelDef","field","push","order","sort","mergeTitleFieldDefs","f1","f2","merged","forEach","fdToMerge","fieldDef1","mergeTitle","title1","title2","join","mergeTitleComponent","v1","v2","v1Val","v2Val","explicit","Error"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\common.ts"],"sourcesContent":["import type {ExprRef, SignalRef, Text} from 'vega';\nimport {array, isArray, stringValue} from 'vega-util';\nimport {AxisConfig, ConditionalAxisProperty} from '../axis';\nimport {\n  ConditionalPredicate,\n  DatumDef,\n  FieldDef,\n  FieldDefBase,\n  FieldRefOption,\n  OrderFieldDef,\n  Value,\n  ValueDef,\n  vgField\n} from '../channeldef';\nimport {Config, StyleConfigIndex} from '../config';\nimport {isExprRef} from '../expr';\nimport {Mark, MarkConfig, MarkDef} from '../mark';\nimport {SortFields} from '../sort';\nimport {isText} from '../title';\nimport {deepEqual, getFirstDefined, hasProperty} from '../util';\nimport {isSignalRef, VgEncodeChannel, VgEncodeEntry, VgValueRef} from '../vega.schema';\nimport {AxisComponentProps} from './axis/component';\nimport {Explicit} from './split';\nimport {UnitModel} from './unit';\n\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\n\nexport function signalOrValueRefWithCondition<V extends Value | number[]>(\n  val: ConditionalAxisProperty<V, SignalRef | ExprRef>\n): ConditionalAxisProperty<V, SignalRef> {\n  const condition = isArray(val.condition)\n    ? (val.condition as ConditionalPredicate<ValueDef<any> | ExprRef | SignalRef>[]).map(conditionalSignalRefOrValue)\n    : conditionalSignalRefOrValue(val.condition);\n\n  return {\n    ...signalRefOrValue<ValueDef<any>>(val),\n    condition\n  };\n}\n\nexport function signalRefOrValue<T>(value: T | SignalRef | ExprRef): T | SignalRef {\n  if (isExprRef(value)) {\n    const {expr, ...rest} = value;\n    return {signal: expr, ...rest};\n  }\n  return value;\n}\n\nexport function conditionalSignalRefOrValue<T extends FieldDef<any> | DatumDef | ValueDef<any>>(\n  value: ConditionalPredicate<T | ExprRef | SignalRef>\n): ConditionalPredicate<T | SignalRef> {\n  if (isExprRef(value)) {\n    const {expr, ...rest} = value;\n    return {signal: expr, ...rest};\n  }\n  return value;\n}\n\nexport function signalOrValueRef<T>(value: T | SignalRef | ExprRef): {value: T} | SignalRef {\n  if (isExprRef(value)) {\n    const {expr, ...rest} = value;\n    return {signal: expr, ...rest};\n  }\n  if (isSignalRef(value)) {\n    return value;\n  }\n  return value !== undefined ? {value} : undefined;\n}\n\nexport function exprFromSignalRefOrValue<T extends SignalRef>(ref: Value<T> | SignalRef): string {\n  if (isSignalRef(ref)) {\n    return ref.signal;\n  }\n  return stringValue(ref);\n}\nexport function exprFromValueRefOrSignalRef(ref: VgValueRef | SignalRef): string {\n  if (isSignalRef(ref)) {\n    return ref.signal;\n  }\n  return stringValue(ref.value);\n}\n\nexport function signalOrStringValue(v: SignalRef | any) {\n  if (isSignalRef(v)) {\n    return v.signal;\n  }\n  return v == null ? null : stringValue(v);\n}\n\nexport function applyMarkConfig(e: VgEncodeEntry, model: UnitModel, propsList: (keyof MarkConfig<any>)[]) {\n  for (const property of propsList) {\n    const value = getMarkConfig(property, model.markDef, model.config);\n    if (value !== undefined) {\n      (e as any)[property] = signalOrValueRef(value);\n    }\n  }\n  return e;\n}\n\nexport function getStyles(mark: MarkDef): string[] {\n  return [].concat(mark.type, mark.style ?? []);\n}\n\nexport function getMarkPropOrConfig<P extends keyof MarkDef, ES extends ExprRef | SignalRef>(\n  channel: P,\n  mark: MarkDef<Mark, ES>,\n  config: Config<SignalRef>,\n  opt: {\n    vgChannel?: VgEncodeChannel;\n    ignoreVgConfig?: boolean;\n  } = {}\n): MarkDef<Mark, ES>[P] {\n  const {vgChannel, ignoreVgConfig} = opt;\n  if (vgChannel && hasProperty(mark, vgChannel)) {\n    return mark[vgChannel] as any;\n  } else if (mark[channel] !== undefined) {\n    return mark[channel];\n  } else if (ignoreVgConfig && (!vgChannel || vgChannel === channel)) {\n    return undefined;\n  }\n\n  return getMarkConfig(channel, mark, config, opt);\n}\n\n/**\n * Return property value from style or mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\nexport function getMarkConfig<P extends keyof MarkDef, ES extends ExprRef | SignalRef>(\n  channel: P,\n  mark: MarkDef<Mark, ES>,\n  config: Config<SignalRef>,\n  {vgChannel}: {vgChannel?: VgEncodeChannel} = {}\n): MarkDef<Mark, ES>[P] {\n  const cfg = getMarkStyleConfig(channel, mark, config.style) as MarkDef<Mark, ES>[P];\n  return getFirstDefined<MarkDef<Mark, ES>[P]>(\n    // style config has highest precedence\n    vgChannel ? cfg : undefined,\n    cfg,\n    // then mark-specific config\n    vgChannel ? (config[mark.type] as any)[vgChannel] : undefined,\n\n    (config[mark.type] as any)[channel], // Need to cast because MarkDef doesn't perfectly match with AnyMarkConfig, but if the type isn't available, we'll get nothing here, which is fine\n\n    // If there is vgChannel, skip vl channel.\n    // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.\n    vgChannel ? (config.mark as any)[vgChannel] : (config.mark as any)[channel] // Need to cast for the same reason as above\n  );\n}\n\nexport function getMarkStyleConfig<P extends keyof MarkDef, ES extends ExprRef | SignalRef>(\n  prop: P,\n  mark: MarkDef<Mark, ES>,\n  styleConfigIndex: StyleConfigIndex<SignalRef>\n) {\n  return getStyleConfig(prop, getStyles(mark), styleConfigIndex);\n}\n\nexport function getStyleConfig<P extends keyof MarkDef | keyof AxisConfig<SignalRef>>(\n  p: P,\n  styles: string | string[],\n  styleConfigIndex: StyleConfigIndex<SignalRef>\n) {\n  styles = array(styles);\n  let value;\n  for (const style of styles) {\n    const styleConfig = styleConfigIndex[style];\n\n    if (hasProperty(styleConfig, p)) {\n      value = styleConfig[p];\n    }\n  }\n  return value;\n}\n\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\nexport function sortParams(\n  orderDef: OrderFieldDef<string> | OrderFieldDef<string>[],\n  fieldRefOption?: FieldRefOption\n): SortFields {\n  return array(orderDef).reduce(\n    (s, orderChannelDef) => {\n      s.field.push(vgField(orderChannelDef, fieldRefOption));\n      s.order.push(orderChannelDef.sort ?? 'ascending');\n      return s;\n    },\n    {field: [], order: []}\n  );\n}\n\nexport type AxisTitleComponent = AxisComponentProps['title'];\n\nexport function mergeTitleFieldDefs(f1: readonly FieldDefBase<string>[], f2: readonly FieldDefBase<string>[]) {\n  const merged = [...f1];\n\n  f2.forEach(fdToMerge => {\n    for (const fieldDef1 of merged) {\n      // If already exists, no need to append to merged array\n      if (deepEqual(fieldDef1, fdToMerge)) {\n        return;\n      }\n    }\n    merged.push(fdToMerge);\n  });\n  return merged;\n}\n\nexport function mergeTitle(title1: Text | SignalRef, title2: Text | SignalRef) {\n  if (deepEqual(title1, title2) || !title2) {\n    // if titles are the same or title2 is falsy\n    return title1;\n  } else if (!title1) {\n    // if title1 is falsy\n    return title2;\n  } else {\n    return [...array(title1), ...array(title2)].join(', ');\n  }\n}\n\nexport function mergeTitleComponent(v1: Explicit<AxisTitleComponent>, v2: Explicit<AxisTitleComponent>) {\n  const v1Val = v1.value;\n  const v2Val = v2.value;\n\n  if (v1Val == null || v2Val === null) {\n    return {\n      explicit: v1.explicit,\n      value: null\n    };\n  } else if ((isText(v1Val) || isSignalRef(v1Val)) && (isText(v2Val) || isSignalRef(v2Val))) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitle(v1Val, v2Val)\n    };\n  } else if (isText(v1Val) || isSignalRef(v1Val)) {\n    return {\n      explicit: v1.explicit,\n      value: v1Val\n    };\n  } else if (isText(v2Val) || isSignalRef(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: v2Val\n    };\n  } else if (!isText(v1Val) && !isSignalRef(v1Val) && !isText(v2Val) && !isSignalRef(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitleFieldDefs(v1Val, v2Val)\n    };\n  }\n  /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n  throw new Error('It should never reach here');\n}\n"],"mappings":"AACA,SAAQA,KAAK,EAAEC,OAAO,EAAEC,WAAW,QAAO,WAAW;AAErD,SASEC,OAAO,QACF,eAAe;AAEtB,SAAQC,SAAS,QAAO,SAAS;AAGjC,SAAQC,MAAM,QAAO,UAAU;AAC/B,SAAQC,SAAS,EAAEC,eAAe,EAAEC,WAAW,QAAO,SAAS;AAC/D,SAAQC,WAAW,QAAmD,gBAAgB;AAKtF,OAAO,MAAMC,mBAAmB,GAAG,UAAU;AAE7C,OAAM,SAAUC,6BAA6BA,CAC3CC,GAAoD;EAEpD,MAAMC,SAAS,GAAGZ,OAAO,CAACW,GAAG,CAACC,SAAS,CAAC,GACnCD,GAAG,CAACC,SAAyE,CAACC,GAAG,CAACC,2BAA2B,CAAC,GAC/GA,2BAA2B,CAACH,GAAG,CAACC,SAAS,CAAC;EAE9C,OAAO;IACL,GAAGG,gBAAgB,CAAgBJ,GAAG,CAAC;IACvCC;GACD;AACH;AAEA,OAAM,SAAUG,gBAAgBA,CAAIC,KAA8B;EAChE,IAAIb,SAAS,CAACa,KAAK,CAAC,EAAE;IACpB,MAAM;MAACC,IAAI;MAAE,GAAGC;IAAI,CAAC,GAAGF,KAAK;IAC7B,OAAO;MAACG,MAAM,EAAEF,IAAI;MAAE,GAAGC;IAAI,CAAC;EAChC;EACA,OAAOF,KAAK;AACd;AAEA,OAAM,SAAUF,2BAA2BA,CACzCE,KAAoD;EAEpD,IAAIb,SAAS,CAACa,KAAK,CAAC,EAAE;IACpB,MAAM;MAACC,IAAI;MAAE,GAAGC;IAAI,CAAC,GAAGF,KAAK;IAC7B,OAAO;MAACG,MAAM,EAAEF,IAAI;MAAE,GAAGC;IAAI,CAAC;EAChC;EACA,OAAOF,KAAK;AACd;AAEA,OAAM,SAAUI,gBAAgBA,CAAIJ,KAA8B;EAChE,IAAIb,SAAS,CAACa,KAAK,CAAC,EAAE;IACpB,MAAM;MAACC,IAAI;MAAE,GAAGC;IAAI,CAAC,GAAGF,KAAK;IAC7B,OAAO;MAACG,MAAM,EAAEF,IAAI;MAAE,GAAGC;IAAI,CAAC;EAChC;EACA,IAAIV,WAAW,CAACQ,KAAK,CAAC,EAAE;IACtB,OAAOA,KAAK;EACd;EACA,OAAOA,KAAK,KAAKK,SAAS,GAAG;IAACL;EAAK,CAAC,GAAGK,SAAS;AAClD;AAEA,OAAM,SAAUC,wBAAwBA,CAAsBC,GAAyB;EACrF,IAAIf,WAAW,CAACe,GAAG,CAAC,EAAE;IACpB,OAAOA,GAAG,CAACJ,MAAM;EACnB;EACA,OAAOlB,WAAW,CAACsB,GAAG,CAAC;AACzB;AACA,OAAM,SAAUC,2BAA2BA,CAACD,GAA2B;EACrE,IAAIf,WAAW,CAACe,GAAG,CAAC,EAAE;IACpB,OAAOA,GAAG,CAACJ,MAAM;EACnB;EACA,OAAOlB,WAAW,CAACsB,GAAG,CAACP,KAAK,CAAC;AAC/B;AAEA,OAAM,SAAUS,mBAAmBA,CAACC,CAAkB;EACpD,IAAIlB,WAAW,CAACkB,CAAC,CAAC,EAAE;IAClB,OAAOA,CAAC,CAACP,MAAM;EACjB;EACA,OAAOO,CAAC,IAAI,IAAI,GAAG,IAAI,GAAGzB,WAAW,CAACyB,CAAC,CAAC;AAC1C;AAEA,OAAM,SAAUC,eAAeA,CAACC,CAAgB,EAAEC,KAAgB,EAAEC,SAAoC;EACtG,KAAK,MAAMC,QAAQ,IAAID,SAAS,EAAE;IAChC,MAAMd,KAAK,GAAGgB,aAAa,CAACD,QAAQ,EAAEF,KAAK,CAACI,OAAO,EAAEJ,KAAK,CAACK,MAAM,CAAC;IAClE,IAAIlB,KAAK,KAAKK,SAAS,EAAE;MACtBO,CAAS,CAACG,QAAQ,CAAC,GAAGX,gBAAgB,CAACJ,KAAK,CAAC;IAChD;EACF;EACA,OAAOY,CAAC;AACV;AAEA,OAAM,SAAUO,SAASA,CAACC,IAAa;EACrC,OAAO,EAAE,CAACC,MAAM,CAACD,IAAI,CAACE,IAAI,EAAEF,IAAI,CAACG,KAAK,IAAI,EAAE,CAAC;AAC/C;AAEA,OAAM,SAAUC,mBAAmBA,CACjCC,OAAU,EACVL,IAAuB,EACvBF,MAAyB,EAInB;EAAA,IAHNQ,GAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAtB,SAAA,GAAAsB,SAAA,MAGI,EAAE;EAEN,MAAM;IAACE,SAAS;IAAEC;EAAc,CAAC,GAAGJ,GAAG;EACvC,IAAIG,SAAS,IAAItC,WAAW,CAAC6B,IAAI,EAAES,SAAS,CAAC,EAAE;IAC7C,OAAOT,IAAI,CAACS,SAAS,CAAQ;EAC/B,CAAC,MAAM,IAAIT,IAAI,CAACK,OAAO,CAAC,KAAKpB,SAAS,EAAE;IACtC,OAAOe,IAAI,CAACK,OAAO,CAAC;EACtB,CAAC,MAAM,IAAIK,cAAc,KAAK,CAACD,SAAS,IAAIA,SAAS,KAAKJ,OAAO,CAAC,EAAE;IAClE,OAAOpB,SAAS;EAClB;EAEA,OAAOW,aAAa,CAACS,OAAO,EAAEL,IAAI,EAAEF,MAAM,EAAEQ,GAAG,CAAC;AAClD;AAEA;;;;AAIA,OAAM,SAAUV,aAAaA,CAC3BS,OAAU,EACVL,IAAuB,EACvBF,MAAyB,EACsB;EAAA,IAA/C;IAACW;EAAS,IAAAF,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAtB,SAAA,GAAAsB,SAAA,MAAmC,EAAE;EAE/C,MAAMI,GAAG,GAAGC,kBAAkB,CAACP,OAAO,EAAEL,IAAI,EAAEF,MAAM,CAACK,KAAK,CAAyB;EACnF,OAAOjC,eAAe;EACpB;EACAuC,SAAS,GAAGE,GAAG,GAAG1B,SAAS,EAC3B0B,GAAG;EACH;EACAF,SAAS,GAAIX,MAAM,CAACE,IAAI,CAACE,IAAI,CAAS,CAACO,SAAS,CAAC,GAAGxB,SAAS,EAE5Da,MAAM,CAACE,IAAI,CAACE,IAAI,CAAS,CAACG,OAAO,CAAC;EAAE;EAErC;EACA;EACAI,SAAS,GAAIX,MAAM,CAACE,IAAY,CAACS,SAAS,CAAC,GAAIX,MAAM,CAACE,IAAY,CAACK,OAAO,CAAC,CAAC;GAC7E;AACH;AAEA,OAAM,SAAUO,kBAAkBA,CAChCC,IAAO,EACPb,IAAuB,EACvBc,gBAA6C;EAE7C,OAAOC,cAAc,CAACF,IAAI,EAAEd,SAAS,CAACC,IAAI,CAAC,EAAEc,gBAAgB,CAAC;AAChE;AAEA,OAAM,SAAUC,cAAcA,CAC5BC,CAAI,EACJC,MAAyB,EACzBH,gBAA6C;EAE7CG,MAAM,GAAGtD,KAAK,CAACsD,MAAM,CAAC;EACtB,IAAIrC,KAAK;EACT,KAAK,MAAMuB,KAAK,IAAIc,MAAM,EAAE;IAC1B,MAAMC,WAAW,GAAGJ,gBAAgB,CAACX,KAAK,CAAC;IAE3C,IAAIhC,WAAW,CAAC+C,WAAW,EAAEF,CAAC,CAAC,EAAE;MAC/BpC,KAAK,GAAGsC,WAAW,CAACF,CAAC,CAAC;IACxB;EACF;EACA,OAAOpC,KAAK;AACd;AAEA;;;AAGA,OAAM,SAAUuC,UAAUA,CACxBC,QAAyD,EACzDC,cAA+B;EAE/B,OAAO1D,KAAK,CAACyD,QAAQ,CAAC,CAACE,MAAM,CAC3B,CAACC,CAAC,EAAEC,eAAe,KAAI;IACrBD,CAAC,CAACE,KAAK,CAACC,IAAI,CAAC5D,OAAO,CAAC0D,eAAe,EAAEH,cAAc,CAAC,CAAC;IACtDE,CAAC,CAACI,KAAK,CAACD,IAAI,CAACF,eAAe,CAACI,IAAI,IAAI,WAAW,CAAC;IACjD,OAAOL,CAAC;EACV,CAAC,EACD;IAACE,KAAK,EAAE,EAAE;IAAEE,KAAK,EAAE;EAAE,CAAC,CACvB;AACH;AAIA,OAAM,SAAUE,mBAAmBA,CAACC,EAAmC,EAAEC,EAAmC;EAC1G,MAAMC,MAAM,GAAG,CAAC,GAAGF,EAAE,CAAC;EAEtBC,EAAE,CAACE,OAAO,CAACC,SAAS,IAAG;IACrB,KAAK,MAAMC,SAAS,IAAIH,MAAM,EAAE;MAC9B;MACA,IAAI/D,SAAS,CAACkE,SAAS,EAAED,SAAS,CAAC,EAAE;QACnC;MACF;IACF;IACAF,MAAM,CAACN,IAAI,CAACQ,SAAS,CAAC;EACxB,CAAC,CAAC;EACF,OAAOF,MAAM;AACf;AAEA,OAAM,SAAUI,UAAUA,CAACC,MAAwB,EAAEC,MAAwB;EAC3E,IAAIrE,SAAS,CAACoE,MAAM,EAAEC,MAAM,CAAC,IAAI,CAACA,MAAM,EAAE;IACxC;IACA,OAAOD,MAAM;EACf,CAAC,MAAM,IAAI,CAACA,MAAM,EAAE;IAClB;IACA,OAAOC,MAAM;EACf,CAAC,MAAM;IACL,OAAO,CAAC,GAAG3E,KAAK,CAAC0E,MAAM,CAAC,EAAE,GAAG1E,KAAK,CAAC2E,MAAM,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;EACxD;AACF;AAEA,OAAM,SAAUC,mBAAmBA,CAACC,EAAgC,EAAEC,EAAgC;EACpG,MAAMC,KAAK,GAAGF,EAAE,CAAC7D,KAAK;EACtB,MAAMgE,KAAK,GAAGF,EAAE,CAAC9D,KAAK;EAEtB,IAAI+D,KAAK,IAAI,IAAI,IAAIC,KAAK,KAAK,IAAI,EAAE;IACnC,OAAO;MACLC,QAAQ,EAAEJ,EAAE,CAACI,QAAQ;MACrBjE,KAAK,EAAE;KACR;EACH,CAAC,MAAM,IAAI,CAACZ,MAAM,CAAC2E,KAAK,CAAC,IAAIvE,WAAW,CAACuE,KAAK,CAAC,MAAM3E,MAAM,CAAC4E,KAAK,CAAC,IAAIxE,WAAW,CAACwE,KAAK,CAAC,CAAC,EAAE;IACzF,OAAO;MACLC,QAAQ,EAAEJ,EAAE,CAACI,QAAQ;MACrBjE,KAAK,EAAEwD,UAAU,CAACO,KAAK,EAAEC,KAAK;KAC/B;EACH,CAAC,MAAM,IAAI5E,MAAM,CAAC2E,KAAK,CAAC,IAAIvE,WAAW,CAACuE,KAAK,CAAC,EAAE;IAC9C,OAAO;MACLE,QAAQ,EAAEJ,EAAE,CAACI,QAAQ;MACrBjE,KAAK,EAAE+D;KACR;EACH,CAAC,MAAM,IAAI3E,MAAM,CAAC4E,KAAK,CAAC,IAAIxE,WAAW,CAACwE,KAAK,CAAC,EAAE;IAC9C,OAAO;MACLC,QAAQ,EAAEJ,EAAE,CAACI,QAAQ;MACrBjE,KAAK,EAAEgE;KACR;EACH,CAAC,MAAM,IAAI,CAAC5E,MAAM,CAAC2E,KAAK,CAAC,IAAI,CAACvE,WAAW,CAACuE,KAAK,CAAC,IAAI,CAAC3E,MAAM,CAAC4E,KAAK,CAAC,IAAI,CAACxE,WAAW,CAACwE,KAAK,CAAC,EAAE;IACzF,OAAO;MACLC,QAAQ,EAAEJ,EAAE,CAACI,QAAQ;MACrBjE,KAAK,EAAEiD,mBAAmB,CAACc,KAAK,EAAEC,KAAK;KACxC;EACH;EACA;EACA,MAAM,IAAIE,KAAK,CAAC,4BAA4B,CAAC;AAC/C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}