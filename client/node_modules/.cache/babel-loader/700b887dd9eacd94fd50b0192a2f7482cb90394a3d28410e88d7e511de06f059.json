{"ast":null,"code":"import { isArray, isBoolean, isString } from 'vega-util';\nimport { isContinuousFieldOrDatumDef, isFieldDef, isFieldOrDatumDefForTimeFormat } from '../channeldef';\nimport { fieldDefs } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { getFirstDefined, hash, unique } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { toStringFieldDef } from './../channeldef';\nexport function filterTooltipWithAggregatedField(oldEncoding) {\n  const {\n    tooltip,\n    ...filteredEncoding\n  } = oldEncoding;\n  if (!tooltip) {\n    return {\n      filteredEncoding\n    };\n  }\n  let customTooltipWithAggregatedField;\n  let customTooltipWithoutAggregatedField;\n  if (isArray(tooltip)) {\n    for (const t of tooltip) {\n      if (t.aggregate) {\n        if (!customTooltipWithAggregatedField) {\n          customTooltipWithAggregatedField = [];\n        }\n        customTooltipWithAggregatedField.push(t);\n      } else {\n        if (!customTooltipWithoutAggregatedField) {\n          customTooltipWithoutAggregatedField = [];\n        }\n        customTooltipWithoutAggregatedField.push(t);\n      }\n    }\n    if (customTooltipWithAggregatedField) {\n      filteredEncoding.tooltip = customTooltipWithAggregatedField;\n    }\n  } else {\n    if (tooltip.aggregate) {\n      filteredEncoding.tooltip = tooltip;\n    } else {\n      customTooltipWithoutAggregatedField = tooltip;\n    }\n  }\n  if (isArray(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {\n    customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];\n  }\n  return {\n    customTooltipWithoutAggregatedField,\n    filteredEncoding\n  };\n}\nexport function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis) {\n  let withFieldName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  if ('tooltip' in encodingWithoutContinuousAxis) {\n    return {\n      tooltip: encodingWithoutContinuousAxis.tooltip\n    };\n  }\n  const fiveSummaryTooltip = tooltipSummary.map(_ref => {\n    let {\n      fieldPrefix,\n      titlePrefix\n    } = _ref;\n    const mainTitle = withFieldName ? ` of ${getTitle(continuousAxisChannelDef)}` : '';\n    return {\n      field: fieldPrefix + continuousAxisChannelDef.field,\n      type: continuousAxisChannelDef.type,\n      title: isSignalRef(titlePrefix) ? {\n        signal: `${titlePrefix}\"${escape(mainTitle)}\"`\n      } : titlePrefix + mainTitle\n    };\n  });\n  const tooltipFieldDefs = fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);\n  return {\n    tooltip: [...fiveSummaryTooltip,\n    // need to cast because TextFieldDef supports fewer types of bin\n    ...unique(tooltipFieldDefs, hash)]\n  };\n}\nexport function getTitle(continuousAxisChannelDef) {\n  const {\n    title,\n    field\n  } = continuousAxisChannelDef;\n  return getFirstDefined(title, field);\n}\nexport function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {\n  const {\n    scale,\n    axis\n  } = continuousAxisChannelDef;\n  return _ref2 => {\n    let {\n      partName,\n      mark,\n      positionPrefix,\n      endPositionPrefix = undefined,\n      extraEncoding = {}\n    } = _ref2;\n    const title = getTitle(continuousAxisChannelDef);\n    return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, {\n      mark,\n      // TODO better remove this method and just have mark as a parameter of the method\n      encoding: {\n        [continuousAxis]: {\n          field: `${positionPrefix}_${continuousAxisChannelDef.field}`,\n          type: continuousAxisChannelDef.type,\n          ...(title !== undefined ? {\n            title\n          } : {}),\n          ...(scale !== undefined ? {\n            scale\n          } : {}),\n          ...(axis !== undefined ? {\n            axis\n          } : {})\n        },\n        ...(isString(endPositionPrefix) ? {\n          [`${continuousAxis}2`]: {\n            field: `${endPositionPrefix}_${continuousAxisChannelDef.field}`\n          }\n        } : {}),\n        ...sharedEncoding,\n        ...extraEncoding\n      }\n    });\n  };\n}\nexport function partLayerMixins(markDef, part, compositeMarkConfig, partBaseSpec) {\n  const {\n    clip,\n    color,\n    opacity\n  } = markDef;\n  const mark = markDef.type;\n  if (markDef[part] || markDef[part] === undefined && compositeMarkConfig[part]) {\n    return [{\n      ...partBaseSpec,\n      mark: {\n        ...compositeMarkConfig[part],\n        ...(clip ? {\n          clip\n        } : {}),\n        ...(color ? {\n          color\n        } : {}),\n        ...(opacity ? {\n          opacity\n        } : {}),\n        ...(isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : {\n          type: partBaseSpec.mark\n        }),\n        style: `${mark}-${String(part)}`,\n        ...(isBoolean(markDef[part]) ? {} : markDef[part])\n      }\n    }];\n  }\n  return [];\n}\nexport function compositeMarkContinuousAxis(spec, orient, compositeMark) {\n  const {\n    encoding\n  } = spec;\n  const continuousAxis = orient === 'vertical' ? 'y' : 'x';\n  const continuousAxisChannelDef = encoding[continuousAxis]; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n  const continuousAxisChannelDef2 = encoding[`${continuousAxis}2`];\n  const continuousAxisChannelDefError = encoding[`${continuousAxis}Error`];\n  const continuousAxisChannelDefError2 = encoding[`${continuousAxis}Error2`];\n  return {\n    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),\n    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),\n    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),\n    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),\n    continuousAxis\n  };\n}\nfunction filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {\n  if (continuousAxisChannelDef?.aggregate) {\n    const {\n      aggregate,\n      ...continuousAxisWithoutAggregate\n    } = continuousAxisChannelDef;\n    if (aggregate !== compositeMark) {\n      log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n    }\n    return continuousAxisWithoutAggregate;\n  } else {\n    return continuousAxisChannelDef;\n  }\n}\nexport function compositeMarkOrient(spec, compositeMark) {\n  const {\n    mark,\n    encoding\n  } = spec;\n  const {\n    x,\n    y\n  } = encoding;\n  if (isMarkDef(mark) && mark.orient) {\n    return mark.orient;\n  }\n  if (isContinuousFieldOrDatumDef(x)) {\n    // x is continuous\n    if (isContinuousFieldOrDatumDef(y)) {\n      // both x and y are continuous\n      const xAggregate = isFieldDef(x) && x.aggregate;\n      const yAggregate = isFieldDef(y) && y.aggregate;\n      if (!xAggregate && yAggregate === compositeMark) {\n        return 'vertical';\n      } else if (!yAggregate && xAggregate === compositeMark) {\n        return 'horizontal';\n      } else if (xAggregate === compositeMark && yAggregate === compositeMark) {\n        throw new Error('Both x and y cannot have aggregate');\n      } else {\n        if (isFieldOrDatumDefForTimeFormat(y) && !isFieldOrDatumDefForTimeFormat(x)) {\n          // y is temporal but x is not\n          return 'horizontal';\n        }\n        // default orientation for two continuous\n        return 'vertical';\n      }\n    }\n    return 'horizontal';\n  } else if (isContinuousFieldOrDatumDef(y)) {\n    // y is continuous but x is not\n    return 'vertical';\n  } else {\n    // Neither x nor y is continuous.\n    throw new Error(`Need a valid continuous axis for ${compositeMark}s`);\n  }\n}","map":{"version":3,"names":["isArray","isBoolean","isString","isContinuousFieldOrDatumDef","isFieldDef","isFieldOrDatumDefForTimeFormat","fieldDefs","log","isMarkDef","getFirstDefined","hash","unique","isSignalRef","toStringFieldDef","filterTooltipWithAggregatedField","oldEncoding","tooltip","filteredEncoding","customTooltipWithAggregatedField","customTooltipWithoutAggregatedField","t","aggregate","push","length","getCompositeMarkTooltip","tooltipSummary","continuousAxisChannelDef","encodingWithoutContinuousAxis","withFieldName","arguments","undefined","fiveSummaryTooltip","map","_ref","fieldPrefix","titlePrefix","mainTitle","getTitle","field","type","title","signal","escape","tooltipFieldDefs","makeCompositeAggregatePartFactory","compositeMarkDef","continuousAxis","sharedEncoding","compositeMarkConfig","scale","axis","_ref2","partName","mark","positionPrefix","endPositionPrefix","extraEncoding","partLayerMixins","encoding","markDef","part","partBaseSpec","clip","color","opacity","style","String","compositeMarkContinuousAxis","spec","orient","compositeMark","continuousAxisChannelDef2","continuousAxisChannelDefError","continuousAxisChannelDefError2","filterAggregateFromChannelDef","continuousAxisWithoutAggregate","warn","message","errorBarContinuousAxisHasCustomizedAggregate","compositeMarkOrient","x","y","xAggregate","yAggregate","Error"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compositemark\\common.ts"],"sourcesContent":["import {Orientation, SignalRef, Text} from 'vega';\nimport {isArray, isBoolean, isString} from 'vega-util';\nimport {CompositeMark, CompositeMarkDef} from '.';\nimport {\n  Field,\n  FieldDefBase,\n  isContinuousFieldOrDatumDef,\n  isFieldDef,\n  isFieldOrDatumDefForTimeFormat,\n  PositionFieldDef,\n  SecondaryFieldDef,\n  StringFieldDef,\n  StringFieldDefWithCondition,\n  StringValueDefWithCondition\n} from '../channeldef';\nimport {Encoding, fieldDefs} from '../encoding';\nimport {ExprRef} from '../expr';\nimport * as log from '../log';\nimport {ColorMixins, GenericMarkDef, isMarkDef, Mark, AnyMarkConfig, MarkDef} from '../mark';\nimport {GenericUnitSpec, NormalizedUnitSpec} from '../spec';\nimport {getFirstDefined, hash, unique} from '../util';\nimport {isSignalRef} from '../vega.schema';\nimport {toStringFieldDef} from './../channeldef';\n\n// Parts mixins can be any mark type. We could make a more specific type for each part.\nexport type PartsMixins<P extends string> = Partial<Record<P, boolean | AnyMarkConfig<ExprRef | SignalRef>>>;\n\nexport type GenericCompositeMarkDef<T> = GenericMarkDef<T> &\n  ColorMixins<ExprRef | SignalRef> & {\n    /**\n     * The opacity (value between [0,1]) of the mark.\n     *\n     * @minimum 0\n     * @maximum 1\n     */\n    opacity?: number;\n\n    /**\n     * Whether a composite mark be clipped to the enclosing group’s width and height.\n     */\n    clip?: boolean;\n  };\n\nexport interface CompositeMarkTooltipSummary {\n  /**\n   * The prefix of the field to be shown in tooltip\n   */\n  fieldPrefix: string;\n\n  /**\n   * The title prefix to show, corresponding to the field with field prefix `fieldPrefix`\n   */\n  titlePrefix: Text | SignalRef;\n}\n\nexport function filterTooltipWithAggregatedField<F extends Field>(\n  oldEncoding: Encoding<F>\n): {\n  customTooltipWithoutAggregatedField?:\n    | StringFieldDefWithCondition<F>\n    | StringValueDefWithCondition<F>\n    | StringFieldDef<F>[];\n  filteredEncoding: Encoding<F>;\n} {\n  const {tooltip, ...filteredEncoding} = oldEncoding;\n  if (!tooltip) {\n    return {filteredEncoding};\n  }\n\n  let customTooltipWithAggregatedField:\n    | StringFieldDefWithCondition<F>\n    | StringValueDefWithCondition<F>\n    | StringFieldDef<F>[];\n  let customTooltipWithoutAggregatedField:\n    | StringFieldDefWithCondition<F>\n    | StringValueDefWithCondition<F>\n    | StringFieldDef<F>[];\n\n  if (isArray(tooltip)) {\n    for (const t of tooltip) {\n      if (t.aggregate) {\n        if (!customTooltipWithAggregatedField) {\n          customTooltipWithAggregatedField = [];\n        }\n        (customTooltipWithAggregatedField as StringFieldDef<F>[]).push(t);\n      } else {\n        if (!customTooltipWithoutAggregatedField) {\n          customTooltipWithoutAggregatedField = [];\n        }\n        (customTooltipWithoutAggregatedField as StringFieldDef<F>[]).push(t);\n      }\n    }\n\n    if (customTooltipWithAggregatedField) {\n      (filteredEncoding as Encoding<F>).tooltip = customTooltipWithAggregatedField;\n    }\n  } else {\n    if ((tooltip as any).aggregate) {\n      (filteredEncoding as Encoding<F>).tooltip = tooltip;\n    } else {\n      customTooltipWithoutAggregatedField = tooltip;\n    }\n  }\n\n  if (isArray(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {\n    customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];\n  }\n  return {customTooltipWithoutAggregatedField, filteredEncoding};\n}\n\nexport function getCompositeMarkTooltip(\n  tooltipSummary: CompositeMarkTooltipSummary[],\n  continuousAxisChannelDef: PositionFieldDef<string>,\n  encodingWithoutContinuousAxis: Encoding<string>,\n  withFieldName = true\n): Encoding<string> {\n  if ('tooltip' in encodingWithoutContinuousAxis) {\n    return {tooltip: encodingWithoutContinuousAxis.tooltip};\n  }\n\n  const fiveSummaryTooltip: StringFieldDef<string>[] = tooltipSummary.map(\n    ({fieldPrefix, titlePrefix}): StringFieldDef<string> => {\n      const mainTitle = withFieldName ? ` of ${getTitle(continuousAxisChannelDef)}` : '';\n      return {\n        field: fieldPrefix + continuousAxisChannelDef.field,\n        type: continuousAxisChannelDef.type,\n        title: isSignalRef(titlePrefix) ? {signal: `${titlePrefix}\"${escape(mainTitle)}\"`} : titlePrefix + mainTitle\n      };\n    }\n  );\n\n  const tooltipFieldDefs = fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);\n\n  return {\n    tooltip: [\n      ...fiveSummaryTooltip,\n      // need to cast because TextFieldDef supports fewer types of bin\n      ...unique(tooltipFieldDefs, hash)\n    ]\n  };\n}\n\nexport function getTitle(continuousAxisChannelDef: PositionFieldDef<string>) {\n  const {title, field} = continuousAxisChannelDef;\n  return getFirstDefined(title, field);\n}\n\nexport function makeCompositeAggregatePartFactory<P extends PartsMixins<any>>(\n  compositeMarkDef: GenericCompositeMarkDef<any> & P,\n  continuousAxis: 'x' | 'y',\n  continuousAxisChannelDef: PositionFieldDef<string>,\n  sharedEncoding: Encoding<string>,\n  compositeMarkConfig: P\n) {\n  const {scale, axis} = continuousAxisChannelDef;\n\n  return ({\n    partName,\n    mark,\n    positionPrefix,\n    endPositionPrefix = undefined,\n    extraEncoding = {}\n  }: {\n    partName: keyof P;\n    mark: Mark | MarkDef;\n    positionPrefix: string;\n    endPositionPrefix?: string;\n    extraEncoding?: Encoding<string>;\n  }) => {\n    const title = getTitle(continuousAxisChannelDef);\n\n    return partLayerMixins<P>(compositeMarkDef, partName, compositeMarkConfig, {\n      mark, // TODO better remove this method and just have mark as a parameter of the method\n      encoding: {\n        [continuousAxis]: {\n          field: `${positionPrefix}_${continuousAxisChannelDef.field}`,\n          type: continuousAxisChannelDef.type,\n          ...(title !== undefined ? {title} : {}),\n          ...(scale !== undefined ? {scale} : {}),\n          ...(axis !== undefined ? {axis} : {})\n        },\n        ...(isString(endPositionPrefix)\n          ? {\n              [`${continuousAxis}2`]: {\n                field: `${endPositionPrefix}_${continuousAxisChannelDef.field}`\n              }\n            }\n          : {}),\n        ...sharedEncoding,\n        ...extraEncoding\n      }\n    });\n  };\n}\n\nexport function partLayerMixins<P extends PartsMixins<any>>(\n  markDef: GenericCompositeMarkDef<any> & P,\n  part: keyof P,\n  compositeMarkConfig: P,\n  partBaseSpec: NormalizedUnitSpec\n): NormalizedUnitSpec[] {\n  const {clip, color, opacity} = markDef;\n\n  const mark = markDef.type;\n\n  if (markDef[part] || (markDef[part] === undefined && compositeMarkConfig[part])) {\n    return [\n      {\n        ...partBaseSpec,\n        mark: {\n          ...(compositeMarkConfig[part] as AnyMarkConfig<ExprRef | SignalRef>),\n          ...(clip ? {clip} : {}),\n          ...(color ? {color} : {}),\n          ...(opacity ? {opacity} : {}),\n          ...(isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : {type: partBaseSpec.mark}),\n          style: `${mark}-${String(part)}`,\n          ...(isBoolean(markDef[part]) ? {} : (markDef[part] as AnyMarkConfig<ExprRef | SignalRef>))\n        }\n      }\n    ];\n  }\n  return [];\n}\n\nexport function compositeMarkContinuousAxis<M extends CompositeMark>(\n  spec: GenericUnitSpec<Encoding<string>, CompositeMark | CompositeMarkDef>,\n  orient: Orientation,\n  compositeMark: M\n): {\n  continuousAxisChannelDef: PositionFieldDef<string>;\n  continuousAxisChannelDef2: SecondaryFieldDef<string>;\n  continuousAxisChannelDefError: SecondaryFieldDef<string>;\n  continuousAxisChannelDefError2: SecondaryFieldDef<string>;\n  continuousAxis: 'x' | 'y';\n} {\n  const {encoding} = spec;\n  const continuousAxis: 'x' | 'y' = orient === 'vertical' ? 'y' : 'x';\n\n  const continuousAxisChannelDef = encoding[continuousAxis] as PositionFieldDef<string>; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n  const continuousAxisChannelDef2 = encoding[`${continuousAxis}2`] as SecondaryFieldDef<string>;\n  const continuousAxisChannelDefError = (encoding as any)[`${continuousAxis}Error`] as SecondaryFieldDef<string>;\n  const continuousAxisChannelDefError2 = (encoding as any)[`${continuousAxis}Error2`] as SecondaryFieldDef<string>;\n\n  return {\n    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),\n    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),\n    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),\n    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),\n    continuousAxis\n  };\n}\n\nfunction filterAggregateFromChannelDef<M extends CompositeMark, F extends FieldDefBase<string>>(\n  continuousAxisChannelDef: F,\n  compositeMark: M\n): F {\n  if (continuousAxisChannelDef?.aggregate) {\n    const {aggregate, ...continuousAxisWithoutAggregate} = continuousAxisChannelDef;\n    if (aggregate !== compositeMark) {\n      log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n    }\n    return continuousAxisWithoutAggregate as F;\n  } else {\n    return continuousAxisChannelDef;\n  }\n}\n\nexport function compositeMarkOrient<M extends CompositeMark>(\n  spec: GenericUnitSpec<Encoding<string>, CompositeMark | CompositeMarkDef>,\n  compositeMark: M\n): Orientation {\n  const {mark, encoding} = spec;\n  const {x, y} = encoding;\n\n  if (isMarkDef(mark) && mark.orient) {\n    return mark.orient;\n  }\n\n  if (isContinuousFieldOrDatumDef(x)) {\n    // x is continuous\n    if (isContinuousFieldOrDatumDef(y)) {\n      // both x and y are continuous\n      const xAggregate = isFieldDef(x) && x.aggregate;\n      const yAggregate = isFieldDef(y) && y.aggregate;\n\n      if (!xAggregate && yAggregate === compositeMark) {\n        return 'vertical';\n      } else if (!yAggregate && xAggregate === compositeMark) {\n        return 'horizontal';\n      } else if (xAggregate === compositeMark && yAggregate === compositeMark) {\n        throw new Error('Both x and y cannot have aggregate');\n      } else {\n        if (isFieldOrDatumDefForTimeFormat(y) && !isFieldOrDatumDefForTimeFormat(x)) {\n          // y is temporal but x is not\n          return 'horizontal';\n        }\n\n        // default orientation for two continuous\n        return 'vertical';\n      }\n    }\n\n    return 'horizontal';\n  } else if (isContinuousFieldOrDatumDef(y)) {\n    // y is continuous but x is not\n    return 'vertical';\n  } else {\n    // Neither x nor y is continuous.\n    throw new Error(`Need a valid continuous axis for ${compositeMark}s`);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}