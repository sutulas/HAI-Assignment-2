{"ast":null,"code":"import * as log from '../log';\nimport { isHConcatSpec, isVConcatSpec } from '../spec';\nimport { keys } from '../util';\nimport { buildModel } from './buildmodel';\nimport { parseData } from './data/parse';\nimport { assembleLayoutSignals } from './layoutsize/assemble';\nimport { parseConcatLayoutSize } from './layoutsize/parse';\nimport { Model } from './model';\nexport class ConcatModel extends Model {\n  constructor(spec, parent, parentGivenName, config) {\n    super(spec, 'concat', parent, parentGivenName, config, spec.resolve);\n    if (spec.resolve?.axis?.x === 'shared' || spec.resolve?.axis?.y === 'shared') {\n      log.warn(log.message.CONCAT_CANNOT_SHARE_AXIS);\n    }\n    this.children = this.getChildren(spec).map((child, i) => {\n      return buildModel(child, this, this.getName(`concat_${i}`), undefined, config);\n    });\n  }\n  parseData() {\n    this.component.data = parseData(this);\n    for (const child of this.children) {\n      child.parseData();\n    }\n  }\n  parseSelections() {\n    // Merge selections up the hierarchy so that they may be referenced\n    // across unit specs. Persist their definitions within each child\n    // to assemble signals which remain within output Vega unit groups.\n    this.component.selection = {};\n    for (const child of this.children) {\n      child.parseSelections();\n      for (const key of keys(child.component.selection)) {\n        this.component.selection[key] = child.component.selection[key];\n      }\n    }\n  }\n  parseMarkGroup() {\n    for (const child of this.children) {\n      child.parseMarkGroup();\n    }\n  }\n  parseAxesAndHeaders() {\n    for (const child of this.children) {\n      child.parseAxesAndHeaders();\n    }\n    // TODO(#2415): support shared axes\n  }\n  getChildren(spec) {\n    if (isVConcatSpec(spec)) {\n      return spec.vconcat;\n    } else if (isHConcatSpec(spec)) {\n      return spec.hconcat;\n    }\n    return spec.concat;\n  }\n  parseLayoutSize() {\n    parseConcatLayoutSize(this);\n  }\n  parseAxisGroup() {\n    return null;\n  }\n  assembleSelectionTopLevelSignals(signals) {\n    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);\n  }\n  assembleSignals() {\n    this.children.forEach(child => child.assembleSignals());\n    return [];\n  }\n  assembleLayoutSignals() {\n    const layoutSignals = assembleLayoutSignals(this);\n    for (const child of this.children) {\n      layoutSignals.push(...child.assembleLayoutSignals());\n    }\n    return layoutSignals;\n  }\n  assembleSelectionData(data) {\n    return this.children.reduce((db, child) => child.assembleSelectionData(db), data);\n  }\n  assembleMarks() {\n    // only children have marks\n    return this.children.map(child => {\n      const title = child.assembleTitle();\n      const style = child.assembleGroupStyle();\n      const encodeEntry = child.assembleGroupEncodeEntry(false);\n      return {\n        type: 'group',\n        name: child.getName('group'),\n        ...(title ? {\n          title\n        } : {}),\n        ...(style ? {\n          style\n        } : {}),\n        ...(encodeEntry ? {\n          encode: {\n            update: encodeEntry\n          }\n        } : {}),\n        ...child.assembleGroup()\n      };\n    });\n  }\n  assembleGroupStyle() {\n    return undefined;\n  }\n  assembleDefaultLayout() {\n    const columns = this.layout.columns;\n    return {\n      ...(columns != null ? {\n        columns\n      } : {}),\n      bounds: 'full',\n      // Use align each so it can work with multiple plots with different size\n      align: 'each'\n    };\n  }\n}","map":{"version":3,"names":["log","isHConcatSpec","isVConcatSpec","keys","buildModel","parseData","assembleLayoutSignals","parseConcatLayoutSize","Model","ConcatModel","constructor","spec","parent","parentGivenName","config","resolve","axis","x","y","warn","message","CONCAT_CANNOT_SHARE_AXIS","children","getChildren","map","child","i","getName","undefined","component","data","parseSelections","selection","key","parseMarkGroup","parseAxesAndHeaders","vconcat","hconcat","concat","parseLayoutSize","parseAxisGroup","assembleSelectionTopLevelSignals","signals","reduce","sg","assembleSignals","forEach","layoutSignals","push","assembleSelectionData","db","assembleMarks","title","assembleTitle","style","assembleGroupStyle","encodeEntry","assembleGroupEncodeEntry","type","name","encode","update","assembleGroup","assembleDefaultLayout","columns","layout","bounds","align"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\concat.ts"],"sourcesContent":["import {NewSignal, SignalRef} from 'vega';\nimport {Config} from '../config';\nimport * as log from '../log';\nimport {isHConcatSpec, isVConcatSpec, NormalizedConcatSpec, NormalizedSpec} from '../spec';\nimport {keys} from '../util';\nimport {VgData, VgLayout} from '../vega.schema';\nimport {buildModel} from './buildmodel';\nimport {parseData} from './data/parse';\nimport {assembleLayoutSignals} from './layoutsize/assemble';\nimport {parseConcatLayoutSize} from './layoutsize/parse';\nimport {Model} from './model';\n\nexport class ConcatModel extends Model {\n  public readonly children: Model[];\n\n  constructor(spec: NormalizedConcatSpec, parent: Model, parentGivenName: string, config: Config<SignalRef>) {\n    super(spec, 'concat', parent, parentGivenName, config, spec.resolve);\n\n    if (spec.resolve?.axis?.x === 'shared' || spec.resolve?.axis?.y === 'shared') {\n      log.warn(log.message.CONCAT_CANNOT_SHARE_AXIS);\n    }\n\n    this.children = this.getChildren(spec).map((child, i) => {\n      return buildModel(child, this, this.getName(`concat_${i}`), undefined, config);\n    });\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n    for (const child of this.children) {\n      child.parseData();\n    }\n  }\n\n  public parseSelections() {\n    // Merge selections up the hierarchy so that they may be referenced\n    // across unit specs. Persist their definitions within each child\n    // to assemble signals which remain within output Vega unit groups.\n    this.component.selection = {};\n    for (const child of this.children) {\n      child.parseSelections();\n      for (const key of keys(child.component.selection)) {\n        this.component.selection[key] = child.component.selection[key];\n      }\n    }\n  }\n\n  public parseMarkGroup() {\n    for (const child of this.children) {\n      child.parseMarkGroup();\n    }\n  }\n\n  public parseAxesAndHeaders() {\n    for (const child of this.children) {\n      child.parseAxesAndHeaders();\n    }\n\n    // TODO(#2415): support shared axes\n  }\n\n  private getChildren(spec: NormalizedConcatSpec): NormalizedSpec[] {\n    if (isVConcatSpec(spec)) {\n      return spec.vconcat;\n    } else if (isHConcatSpec(spec)) {\n      return spec.hconcat;\n    }\n    return spec.concat;\n  }\n\n  public parseLayoutSize() {\n    parseConcatLayoutSize(this);\n  }\n\n  public parseAxisGroup(): void {\n    return null;\n  }\n\n  public assembleSelectionTopLevelSignals(signals: NewSignal[]): NewSignal[] {\n    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);\n  }\n\n  public assembleSignals(): NewSignal[] {\n    this.children.forEach(child => child.assembleSignals());\n    return [];\n  }\n\n  public assembleLayoutSignals(): NewSignal[] {\n    const layoutSignals = assembleLayoutSignals(this);\n\n    for (const child of this.children) {\n      layoutSignals.push(...child.assembleLayoutSignals());\n    }\n\n    return layoutSignals;\n  }\n\n  public assembleSelectionData(data: readonly VgData[]): readonly VgData[] {\n    return this.children.reduce((db, child) => child.assembleSelectionData(db), data);\n  }\n\n  public assembleMarks(): any[] {\n    // only children have marks\n    return this.children.map(child => {\n      const title = child.assembleTitle();\n      const style = child.assembleGroupStyle();\n      const encodeEntry = child.assembleGroupEncodeEntry(false);\n\n      return {\n        type: 'group',\n        name: child.getName('group'),\n        ...(title ? {title} : {}),\n        ...(style ? {style} : {}),\n        ...(encodeEntry ? {encode: {update: encodeEntry}} : {}),\n        ...child.assembleGroup()\n      };\n    });\n  }\n\n  public assembleGroupStyle(): string | string[] {\n    return undefined;\n  }\n\n  protected assembleDefaultLayout(): VgLayout {\n    const columns = this.layout.columns;\n    return {\n      ...(columns != null ? {columns} : {}),\n      bounds: 'full',\n      // Use align each so it can work with multiple plots with different size\n      align: 'each'\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}