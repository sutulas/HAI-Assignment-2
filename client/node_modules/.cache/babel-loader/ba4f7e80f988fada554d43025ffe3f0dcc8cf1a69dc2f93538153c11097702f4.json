{"ast":null,"code":"import { extend, error, stringValue, isFunction, toBoolean, toNumber, toDate, toString, identity, field, isObject, isArray, isIterable, hasOwnProperty } from 'vega-util';\nimport { dsvFormat } from 'd3-dsv';\nimport { feature, mesh } from 'topojson-client';\nimport { timeFormatDefaultLocale } from 'vega-format';\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nconst protocol_re = /^(data:|([A-Za-z]+:)?\\/\\/)/;\n\n// Matches allowed URIs. From https://github.com/cure53/DOMPurify/blob/master/src/regexp.js with added file://\nconst allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i; // eslint-disable-line no-useless-escape\nconst whitespace_re = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g; // eslint-disable-line no-control-regex\n\n// Special treatment in node.js for the file: protocol\nconst fileProtocol = 'file://';\n\n/**\n * Factory for a loader constructor that provides methods for requesting\n * files from either the network or disk, and for sanitizing request URIs.\n * @param {function} fetch - The Fetch API for HTTP network requests.\n *   If null or undefined, HTTP loading will be disabled.\n * @param {object} fs - The file system interface for file loading.\n *   If null or undefined, local file loading will be disabled.\n * @return {function} A loader constructor with the following signature:\n *   param {object} [options] - Optional default loading options to use.\n *   return {object} - A new loader instance.\n */\nfunction loaderFactory(fetch, fs) {\n  return options => ({\n    options: options || {},\n    sanitize: sanitize,\n    load: load,\n    fileAccess: !!fs,\n    file: fileLoader(fs),\n    http: httpLoader(fetch)\n  });\n}\n\n/**\n * Load an external resource, typically either from the web or from the local\n * filesystem. This function uses {@link sanitize} to first sanitize the uri,\n * then calls either {@link http} (for web requests) or {@link file} (for\n * filesystem loading).\n * @param {string} uri - The resource indicator (e.g., URL or filename).\n * @param {object} [options] - Optional loading options. These options will\n *   override any existing default options.\n * @return {Promise} - A promise that resolves to the loaded content.\n */\nasync function load(uri, options) {\n  const opt = await this.sanitize(uri, options),\n    url = opt.href;\n  return opt.localFile ? this.file(url) : this.http(url, options);\n}\n\n/**\n * URI sanitizer function.\n * @param {string} uri - The uri (url or filename) to check.\n * @param {object} options - An options hash.\n * @return {Promise} - A promise that resolves to an object containing\n *  sanitized uri data, or rejects it the input uri is deemed invalid.\n *  The properties of the resolved object are assumed to be\n *  valid attributes for an HTML 'a' tag. The sanitized uri *must* be\n *  provided by the 'href' property of the returned object.\n */\nasync function sanitize(uri, options) {\n  options = extend({}, this.options, options);\n  const fileAccess = this.fileAccess,\n    result = {\n      href: null\n    };\n  let isFile, loadFile, base;\n  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ''));\n  if (uri == null || typeof uri !== 'string' || !isAllowed) {\n    error('Sanitize failure, invalid URI: ' + stringValue(uri));\n  }\n  const hasProtocol = protocol_re.test(uri);\n\n  // if relative url (no protocol/host), prepend baseURL\n  if ((base = options.baseURL) && !hasProtocol) {\n    // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    if (!uri.startsWith('/') && !base.endsWith('/')) {\n      uri = '/' + uri;\n    }\n    uri = base + uri;\n  }\n\n  // should we load from file system?\n  loadFile = (isFile = uri.startsWith(fileProtocol)) || options.mode === 'file' || options.mode !== 'http' && !hasProtocol && fileAccess;\n  if (isFile) {\n    // strip file protocol\n    uri = uri.slice(fileProtocol.length);\n  } else if (uri.startsWith('//')) {\n    if (options.defaultProtocol === 'file') {\n      // if is file, strip protocol and set loadFile flag\n      uri = uri.slice(2);\n      loadFile = true;\n    } else {\n      // if relative protocol (starts with '//'), prepend default protocol\n      uri = (options.defaultProtocol || 'http') + ':' + uri;\n    }\n  }\n\n  // set non-enumerable mode flag to indicate local file load\n  Object.defineProperty(result, 'localFile', {\n    value: !!loadFile\n  });\n\n  // set uri\n  result.href = uri;\n\n  // set default result target, if specified\n  if (options.target) {\n    result.target = options.target + '';\n  }\n\n  // set default result rel, if specified (#1542)\n  if (options.rel) {\n    result.rel = options.rel + '';\n  }\n\n  // provide control over cross-origin image handling (#2238)\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image\n  if (options.context === 'image' && options.crossOrigin) {\n    result.crossOrigin = options.crossOrigin + '';\n  }\n\n  // return\n  return result;\n}\n\n/**\n * File system loader factory.\n * @param {object} fs - The file system interface.\n * @return {function} - A file loader with the following signature:\n *   param {string} filename - The file system path to load.\n *   param {string} filename - The file system path to load.\n *   return {Promise} A promise that resolves to the file contents.\n */\nfunction fileLoader(fs) {\n  return fs ? filename => new Promise((accept, reject) => {\n    fs.readFile(filename, (error, data) => {\n      if (error) reject(error);else accept(data);\n    });\n  }) : fileReject;\n}\n\n/**\n * Default file system loader that simply rejects.\n */\nasync function fileReject() {\n  error('No file system access.');\n}\n\n/**\n * HTTP request handler factory.\n * @param {function} fetch - The Fetch API method.\n * @return {function} - An http loader with the following signature:\n *   param {string} url - The url to request.\n *   param {object} options - An options hash.\n *   return {Promise} - A promise that resolves to the file contents.\n */\nfunction httpLoader(fetch) {\n  return fetch ? async function (url, options) {\n    const opt = extend({}, this.options.http, options),\n      type = options && options.response,\n      response = await fetch(url, opt);\n    return !response.ok ? error(response.status + '' + response.statusText) : isFunction(response[type]) ? response[type]() : response.text();\n  } : httpReject;\n}\n\n/**\n * Default http request handler that simply rejects.\n */\nasync function httpReject() {\n  error('No HTTP fetch method available.');\n}\nconst isValid = _ => _ != null && _ === _;\nconst isBoolean = _ => _ === 'true' || _ === 'false' || _ === true || _ === false;\nconst isDate = _ => !Number.isNaN(Date.parse(_));\nconst isNumber = _ => !Number.isNaN(+_) && !(_ instanceof Date);\nconst isInteger = _ => isNumber(_) && Number.isInteger(+_);\nconst typeParsers = {\n  boolean: toBoolean,\n  integer: toNumber,\n  number: toNumber,\n  date: toDate,\n  string: toString,\n  unknown: identity\n};\nconst typeTests = [isBoolean, isInteger, isNumber, isDate];\nconst typeList = ['boolean', 'integer', 'number', 'date'];\nfunction inferType(values, field) {\n  if (!values || !values.length) return 'unknown';\n  const n = values.length,\n    m = typeTests.length,\n    a = typeTests.map((_, i) => i + 1);\n  for (let i = 0, t = 0, j, value; i < n; ++i) {\n    value = field ? values[i][field] : values[i];\n    for (j = 0; j < m; ++j) {\n      if (a[j] && isValid(value) && !typeTests[j](value)) {\n        a[j] = 0;\n        ++t;\n        if (t === typeTests.length) return 'string';\n      }\n    }\n  }\n  return typeList[a.reduce((u, v) => u === 0 ? v : u, 0) - 1];\n}\nfunction inferTypes(data, fields) {\n  return fields.reduce((types, field) => {\n    types[field] = inferType(data, field);\n    return types;\n  }, {});\n}\nfunction delimitedFormat(delimiter) {\n  const parse = function (data, format) {\n    const delim = {\n      delimiter: delimiter\n    };\n    return dsv(data, format ? extend(format, delim) : delim);\n  };\n  parse.responseType = 'text';\n  return parse;\n}\nfunction dsv(data, format) {\n  if (format.header) {\n    data = format.header.map(stringValue).join(format.delimiter) + '\\n' + data;\n  }\n  return dsvFormat(format.delimiter).parse(data + '');\n}\ndsv.responseType = 'text';\nfunction isBuffer(_) {\n  return typeof Buffer === 'function' && isFunction(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;\n}\nfunction json(data, format) {\n  const prop = format && format.property ? field(format.property) : identity;\n  return isObject(data) && !isBuffer(data) ? parseJSON(prop(data), format) : prop(JSON.parse(data));\n}\njson.responseType = 'json';\nfunction parseJSON(data, format) {\n  if (!isArray(data) && isIterable(data)) {\n    data = [...data];\n  }\n  return format && format.copy ? JSON.parse(JSON.stringify(data)) : data;\n}\nconst filters = {\n  interior: (a, b) => a !== b,\n  exterior: (a, b) => a === b\n};\nfunction topojson(data, format) {\n  let method, object, property, filter;\n  data = json(data, format);\n  if (format && format.feature) {\n    method = feature;\n    property = format.feature;\n  } else if (format && format.mesh) {\n    method = mesh;\n    property = format.mesh;\n    filter = filters[format.filter];\n  } else {\n    error('Missing TopoJSON feature or mesh parameter.');\n  }\n  object = (object = data.objects[property]) ? method(data, object, filter) : error('Invalid TopoJSON object: ' + property);\n  return object && object.features || [object];\n}\ntopojson.responseType = 'json';\nconst format = {\n  dsv: dsv,\n  csv: delimitedFormat(','),\n  tsv: delimitedFormat('\\t'),\n  json: json,\n  topojson: topojson\n};\nfunction formats(name, reader) {\n  if (arguments.length > 1) {\n    format[name] = reader;\n    return this;\n  } else {\n    return hasOwnProperty(format, name) ? format[name] : null;\n  }\n}\nfunction responseType(type) {\n  const f = formats(type);\n  return f && f.responseType || 'text';\n}\nfunction read(data, schema, timeParser, utcParser) {\n  schema = schema || {};\n  const reader = formats(schema.type || 'json');\n  if (!reader) error('Unknown data format type: ' + schema.type);\n  data = reader(data, schema);\n  if (schema.parse) parse(data, schema.parse, timeParser, utcParser);\n  if (hasOwnProperty(data, 'columns')) delete data.columns;\n  return data;\n}\nfunction parse(data, types, timeParser, utcParser) {\n  if (!data.length) return; // early exit for empty data\n\n  const locale = timeFormatDefaultLocale();\n  timeParser = timeParser || locale.timeParse;\n  utcParser = utcParser || locale.utcParse;\n  let fields = data.columns || Object.keys(data[0]),\n    datum,\n    field,\n    i,\n    j,\n    n,\n    m;\n  if (types === 'auto') types = inferTypes(data, fields);\n  fields = Object.keys(types);\n  const parsers = fields.map(field => {\n    const type = types[field];\n    let parts, pattern;\n    if (type && (type.startsWith('date:') || type.startsWith('utc:'))) {\n      parts = type.split(/:(.+)?/, 2); // split on first :\n      pattern = parts[1];\n      if (pattern[0] === '\\'' && pattern[pattern.length - 1] === '\\'' || pattern[0] === '\"' && pattern[pattern.length - 1] === '\"') {\n        pattern = pattern.slice(1, -1);\n      }\n      const parse = parts[0] === 'utc' ? utcParser : timeParser;\n      return parse(pattern);\n    }\n    if (!typeParsers[type]) {\n      throw Error('Illegal format pattern: ' + field + ':' + type);\n    }\n    return typeParsers[type];\n  });\n  for (i = 0, n = data.length, m = fields.length; i < n; ++i) {\n    datum = data[i];\n    for (j = 0; j < m; ++j) {\n      field = fields[j];\n      datum[field] = parsers[j](datum[field]);\n    }\n  }\n}\nconst loader = loaderFactory(typeof fetch !== 'undefined' && fetch,\n// use built-in fetch API\nnull // no file system access\n);\nexport { format, formats, inferType, inferTypes, loader, read, responseType, typeParsers };","map":{"version":3,"names":["extend","error","stringValue","isFunction","toBoolean","toNumber","toDate","toString","identity","field","isObject","isArray","isIterable","hasOwnProperty","dsvFormat","feature","mesh","timeFormatDefaultLocale","protocol_re","allowed_re","whitespace_re","fileProtocol","loaderFactory","fetch","fs","options","sanitize","load","fileAccess","file","fileLoader","http","httpLoader","uri","opt","url","href","localFile","result","isFile","loadFile","base","isAllowed","test","replace","hasProtocol","baseURL","startsWith","endsWith","mode","slice","length","defaultProtocol","Object","defineProperty","value","target","rel","context","crossOrigin","filename","Promise","accept","reject","readFile","data","fileReject","type","response","ok","status","statusText","text","httpReject","isValid","_","isBoolean","isDate","Number","isNaN","Date","parse","isNumber","isInteger","typeParsers","boolean","integer","number","date","string","unknown","typeTests","typeList","inferType","values","n","m","a","map","i","t","j","reduce","u","v","inferTypes","fields","types","delimitedFormat","delimiter","format","delim","dsv","responseType","header","join","isBuffer","Buffer","json","prop","property","parseJSON","JSON","copy","stringify","filters","interior","b","exterior","topojson","method","object","filter","objects","features","csv","tsv","formats","name","reader","arguments","f","read","schema","timeParser","utcParser","columns","locale","timeParse","utcParse","keys","datum","parsers","parts","pattern","split","Error","loader"],"sources":["C:/Users/sutul/node_modules/vega-loader/build/vega-loader.browser.module.js"],"sourcesContent":["import { extend, error, stringValue, isFunction, toBoolean, toNumber, toDate, toString, identity, field, isObject, isArray, isIterable, hasOwnProperty } from 'vega-util';\nimport { dsvFormat } from 'd3-dsv';\nimport { feature, mesh } from 'topojson-client';\nimport { timeFormatDefaultLocale } from 'vega-format';\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nconst protocol_re = /^(data:|([A-Za-z]+:)?\\/\\/)/;\n\n// Matches allowed URIs. From https://github.com/cure53/DOMPurify/blob/master/src/regexp.js with added file://\nconst allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i; // eslint-disable-line no-useless-escape\nconst whitespace_re = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g; // eslint-disable-line no-control-regex\n\n// Special treatment in node.js for the file: protocol\nconst fileProtocol = 'file://';\n\n/**\n * Factory for a loader constructor that provides methods for requesting\n * files from either the network or disk, and for sanitizing request URIs.\n * @param {function} fetch - The Fetch API for HTTP network requests.\n *   If null or undefined, HTTP loading will be disabled.\n * @param {object} fs - The file system interface for file loading.\n *   If null or undefined, local file loading will be disabled.\n * @return {function} A loader constructor with the following signature:\n *   param {object} [options] - Optional default loading options to use.\n *   return {object} - A new loader instance.\n */\nfunction loaderFactory (fetch, fs) {\n  return options => ({\n    options: options || {},\n    sanitize: sanitize,\n    load: load,\n    fileAccess: !!fs,\n    file: fileLoader(fs),\n    http: httpLoader(fetch)\n  });\n}\n\n/**\n * Load an external resource, typically either from the web or from the local\n * filesystem. This function uses {@link sanitize} to first sanitize the uri,\n * then calls either {@link http} (for web requests) or {@link file} (for\n * filesystem loading).\n * @param {string} uri - The resource indicator (e.g., URL or filename).\n * @param {object} [options] - Optional loading options. These options will\n *   override any existing default options.\n * @return {Promise} - A promise that resolves to the loaded content.\n */\nasync function load(uri, options) {\n  const opt = await this.sanitize(uri, options),\n    url = opt.href;\n  return opt.localFile ? this.file(url) : this.http(url, options);\n}\n\n/**\n * URI sanitizer function.\n * @param {string} uri - The uri (url or filename) to check.\n * @param {object} options - An options hash.\n * @return {Promise} - A promise that resolves to an object containing\n *  sanitized uri data, or rejects it the input uri is deemed invalid.\n *  The properties of the resolved object are assumed to be\n *  valid attributes for an HTML 'a' tag. The sanitized uri *must* be\n *  provided by the 'href' property of the returned object.\n */\nasync function sanitize(uri, options) {\n  options = extend({}, this.options, options);\n  const fileAccess = this.fileAccess,\n    result = {\n      href: null\n    };\n  let isFile, loadFile, base;\n  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ''));\n  if (uri == null || typeof uri !== 'string' || !isAllowed) {\n    error('Sanitize failure, invalid URI: ' + stringValue(uri));\n  }\n  const hasProtocol = protocol_re.test(uri);\n\n  // if relative url (no protocol/host), prepend baseURL\n  if ((base = options.baseURL) && !hasProtocol) {\n    // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    if (!uri.startsWith('/') && !base.endsWith('/')) {\n      uri = '/' + uri;\n    }\n    uri = base + uri;\n  }\n\n  // should we load from file system?\n  loadFile = (isFile = uri.startsWith(fileProtocol)) || options.mode === 'file' || options.mode !== 'http' && !hasProtocol && fileAccess;\n  if (isFile) {\n    // strip file protocol\n    uri = uri.slice(fileProtocol.length);\n  } else if (uri.startsWith('//')) {\n    if (options.defaultProtocol === 'file') {\n      // if is file, strip protocol and set loadFile flag\n      uri = uri.slice(2);\n      loadFile = true;\n    } else {\n      // if relative protocol (starts with '//'), prepend default protocol\n      uri = (options.defaultProtocol || 'http') + ':' + uri;\n    }\n  }\n\n  // set non-enumerable mode flag to indicate local file load\n  Object.defineProperty(result, 'localFile', {\n    value: !!loadFile\n  });\n\n  // set uri\n  result.href = uri;\n\n  // set default result target, if specified\n  if (options.target) {\n    result.target = options.target + '';\n  }\n\n  // set default result rel, if specified (#1542)\n  if (options.rel) {\n    result.rel = options.rel + '';\n  }\n\n  // provide control over cross-origin image handling (#2238)\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image\n  if (options.context === 'image' && options.crossOrigin) {\n    result.crossOrigin = options.crossOrigin + '';\n  }\n\n  // return\n  return result;\n}\n\n/**\n * File system loader factory.\n * @param {object} fs - The file system interface.\n * @return {function} - A file loader with the following signature:\n *   param {string} filename - The file system path to load.\n *   param {string} filename - The file system path to load.\n *   return {Promise} A promise that resolves to the file contents.\n */\nfunction fileLoader(fs) {\n  return fs ? filename => new Promise((accept, reject) => {\n    fs.readFile(filename, (error, data) => {\n      if (error) reject(error);else accept(data);\n    });\n  }) : fileReject;\n}\n\n/**\n * Default file system loader that simply rejects.\n */\nasync function fileReject() {\n  error('No file system access.');\n}\n\n/**\n * HTTP request handler factory.\n * @param {function} fetch - The Fetch API method.\n * @return {function} - An http loader with the following signature:\n *   param {string} url - The url to request.\n *   param {object} options - An options hash.\n *   return {Promise} - A promise that resolves to the file contents.\n */\nfunction httpLoader(fetch) {\n  return fetch ? async function (url, options) {\n    const opt = extend({}, this.options.http, options),\n      type = options && options.response,\n      response = await fetch(url, opt);\n    return !response.ok ? error(response.status + '' + response.statusText) : isFunction(response[type]) ? response[type]() : response.text();\n  } : httpReject;\n}\n\n/**\n * Default http request handler that simply rejects.\n */\nasync function httpReject() {\n  error('No HTTP fetch method available.');\n}\n\nconst isValid = _ => _ != null && _ === _;\nconst isBoolean = _ => _ === 'true' || _ === 'false' || _ === true || _ === false;\nconst isDate = _ => !Number.isNaN(Date.parse(_));\nconst isNumber = _ => !Number.isNaN(+_) && !(_ instanceof Date);\nconst isInteger = _ => isNumber(_) && Number.isInteger(+_);\nconst typeParsers = {\n  boolean: toBoolean,\n  integer: toNumber,\n  number: toNumber,\n  date: toDate,\n  string: toString,\n  unknown: identity\n};\nconst typeTests = [isBoolean, isInteger, isNumber, isDate];\nconst typeList = ['boolean', 'integer', 'number', 'date'];\nfunction inferType(values, field) {\n  if (!values || !values.length) return 'unknown';\n  const n = values.length,\n    m = typeTests.length,\n    a = typeTests.map((_, i) => i + 1);\n  for (let i = 0, t = 0, j, value; i < n; ++i) {\n    value = field ? values[i][field] : values[i];\n    for (j = 0; j < m; ++j) {\n      if (a[j] && isValid(value) && !typeTests[j](value)) {\n        a[j] = 0;\n        ++t;\n        if (t === typeTests.length) return 'string';\n      }\n    }\n  }\n  return typeList[a.reduce((u, v) => u === 0 ? v : u, 0) - 1];\n}\nfunction inferTypes(data, fields) {\n  return fields.reduce((types, field) => {\n    types[field] = inferType(data, field);\n    return types;\n  }, {});\n}\n\nfunction delimitedFormat(delimiter) {\n  const parse = function (data, format) {\n    const delim = {\n      delimiter: delimiter\n    };\n    return dsv(data, format ? extend(format, delim) : delim);\n  };\n  parse.responseType = 'text';\n  return parse;\n}\nfunction dsv(data, format) {\n  if (format.header) {\n    data = format.header.map(stringValue).join(format.delimiter) + '\\n' + data;\n  }\n  return dsvFormat(format.delimiter).parse(data + '');\n}\ndsv.responseType = 'text';\n\nfunction isBuffer(_) {\n  return typeof Buffer === 'function' && isFunction(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;\n}\nfunction json(data, format) {\n  const prop = format && format.property ? field(format.property) : identity;\n  return isObject(data) && !isBuffer(data) ? parseJSON(prop(data), format) : prop(JSON.parse(data));\n}\njson.responseType = 'json';\nfunction parseJSON(data, format) {\n  if (!isArray(data) && isIterable(data)) {\n    data = [...data];\n  }\n  return format && format.copy ? JSON.parse(JSON.stringify(data)) : data;\n}\n\nconst filters = {\n  interior: (a, b) => a !== b,\n  exterior: (a, b) => a === b\n};\nfunction topojson(data, format) {\n  let method, object, property, filter;\n  data = json(data, format);\n  if (format && format.feature) {\n    method = feature;\n    property = format.feature;\n  } else if (format && format.mesh) {\n    method = mesh;\n    property = format.mesh;\n    filter = filters[format.filter];\n  } else {\n    error('Missing TopoJSON feature or mesh parameter.');\n  }\n  object = (object = data.objects[property]) ? method(data, object, filter) : error('Invalid TopoJSON object: ' + property);\n  return object && object.features || [object];\n}\ntopojson.responseType = 'json';\n\nconst format = {\n  dsv: dsv,\n  csv: delimitedFormat(','),\n  tsv: delimitedFormat('\\t'),\n  json: json,\n  topojson: topojson\n};\nfunction formats(name, reader) {\n  if (arguments.length > 1) {\n    format[name] = reader;\n    return this;\n  } else {\n    return hasOwnProperty(format, name) ? format[name] : null;\n  }\n}\nfunction responseType(type) {\n  const f = formats(type);\n  return f && f.responseType || 'text';\n}\n\nfunction read (data, schema, timeParser, utcParser) {\n  schema = schema || {};\n  const reader = formats(schema.type || 'json');\n  if (!reader) error('Unknown data format type: ' + schema.type);\n  data = reader(data, schema);\n  if (schema.parse) parse(data, schema.parse, timeParser, utcParser);\n  if (hasOwnProperty(data, 'columns')) delete data.columns;\n  return data;\n}\nfunction parse(data, types, timeParser, utcParser) {\n  if (!data.length) return; // early exit for empty data\n\n  const locale = timeFormatDefaultLocale();\n  timeParser = timeParser || locale.timeParse;\n  utcParser = utcParser || locale.utcParse;\n  let fields = data.columns || Object.keys(data[0]),\n    datum,\n    field,\n    i,\n    j,\n    n,\n    m;\n  if (types === 'auto') types = inferTypes(data, fields);\n  fields = Object.keys(types);\n  const parsers = fields.map(field => {\n    const type = types[field];\n    let parts, pattern;\n    if (type && (type.startsWith('date:') || type.startsWith('utc:'))) {\n      parts = type.split(/:(.+)?/, 2); // split on first :\n      pattern = parts[1];\n      if (pattern[0] === '\\'' && pattern[pattern.length - 1] === '\\'' || pattern[0] === '\"' && pattern[pattern.length - 1] === '\"') {\n        pattern = pattern.slice(1, -1);\n      }\n      const parse = parts[0] === 'utc' ? utcParser : timeParser;\n      return parse(pattern);\n    }\n    if (!typeParsers[type]) {\n      throw Error('Illegal format pattern: ' + field + ':' + type);\n    }\n    return typeParsers[type];\n  });\n  for (i = 0, n = data.length, m = fields.length; i < n; ++i) {\n    datum = data[i];\n    for (j = 0; j < m; ++j) {\n      field = fields[j];\n      datum[field] = parsers[j](datum[field]);\n    }\n  }\n}\n\nconst loader = loaderFactory(typeof fetch !== 'undefined' && fetch,\n// use built-in fetch API\nnull // no file system access\n);\n\nexport { format, formats, inferType, inferTypes, loader, read, responseType, typeParsers };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}