{"ast":null,"code":"import { array, isArray } from 'vega-util';\nimport { AXIS_PARTS, AXIS_PROPERTY_TYPE, CONDITIONAL_AXIS_PROP_INDEX, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { defaultTitle } from '../../channeldef';\nimport { isText } from '../../title';\nimport { contains, getFirstDefined, isEmpty, replaceAll } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { exprFromValueRefOrSignalRef } from '../common';\nimport { expression } from '../predicate';\nfunction assembleTitle(title, config) {\n  if (!title) {\n    return undefined;\n  }\n  if (isArray(title) && !isText(title)) {\n    return title.map(fieldDef => defaultTitle(fieldDef, config)).join(', ');\n  }\n  return title;\n}\nfunction setAxisEncode(axis, part, vgProp, vgRef) {\n  var _a, _b;\n  axis.encode ?? (axis.encode = {});\n  (_a = axis.encode)[part] ?? (_a[part] = {});\n  (_b = axis.encode[part]).update ?? (_b.update = {});\n  // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n  axis.encode[part].update[vgProp] = vgRef;\n}\nexport function assembleAxis(axisCmpt, kind, config) {\n  let opt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n    header: false\n  };\n  const {\n    disable,\n    orient,\n    scale,\n    labelExpr,\n    title,\n    zindex,\n    ...axis\n  } = axisCmpt.combine();\n  if (disable) {\n    return undefined;\n  }\n  for (const p in axis) {\n    const prop = p;\n    const propType = AXIS_PROPERTY_TYPE[prop];\n    const propValue = axis[prop];\n    if (propType && propType !== kind && propType !== 'both') {\n      // Remove properties that are not valid for this kind of axis\n      delete axis[prop];\n    } else if (isConditionalAxisValue(propValue)) {\n      // deal with conditional axis value\n      const {\n        condition,\n        ...valueOrSignalRef\n      } = propValue;\n      const conditions = array(condition);\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n      if (propIndex) {\n        const {\n          vgProp,\n          part\n        } = propIndex;\n        // If there is a corresponding Vega property for the channel,\n        // use Vega's custom axis encoding and delete the original axis property to avoid conflicts\n        const vgRef = [...conditions.map(c => {\n          const {\n            test,\n            ...valueOrSignalCRef\n          } = c;\n          return {\n            test: expression(null, test),\n            ...valueOrSignalCRef\n          };\n        }), valueOrSignalRef];\n        setAxisEncode(axis, part, vgProp, vgRef);\n        delete axis[prop];\n      } else if (propIndex === null) {\n        // If propIndex is null, this means we support conditional axis property by converting the condition to signal instead.\n        const signalRef = {\n          signal: conditions.map(c => {\n            const {\n              test,\n              ...valueOrSignalCRef\n            } = c;\n            return `${expression(null, test)} ? ${exprFromValueRefOrSignalRef(valueOrSignalCRef)} : `;\n          }).join('') + exprFromValueRefOrSignalRef(valueOrSignalRef)\n        };\n        axis[prop] = signalRef;\n      }\n    } else if (isSignalRef(propValue)) {\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n      if (propIndex) {\n        const {\n          vgProp,\n          part\n        } = propIndex;\n        // FIXME: remove as any\n        setAxisEncode(axis, part, vgProp, propValue);\n        delete axis[prop];\n      } // else do nothing since the property already supports signal\n    }\n    // Do not pass labelAlign/Baseline = null to Vega since it won't pass the schema\n    // Note that we need to use null so the default labelAlign is preserved.\n    if (contains(['labelAlign', 'labelBaseline'], prop) && axis[prop] === null) {\n      delete axis[prop];\n    }\n  }\n  if (kind === 'grid') {\n    if (!axis.grid) {\n      return undefined;\n    }\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      // Only need to keep encode block for grid\n      const {\n        grid\n      } = axis.encode;\n      axis.encode = {\n        ...(grid ? {\n          grid\n        } : {})\n      };\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n    return {\n      scale,\n      orient,\n      ...axis,\n      domain: false,\n      labels: false,\n      aria: false,\n      // always hide grid axis\n      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n      // would not affect gridAxis\n      maxExtent: 0,\n      minExtent: 0,\n      ticks: false,\n      zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n    };\n  } else {\n    // kind === 'main'\n    if (!opt.header && axisCmpt.mainExtracted) {\n      // if mainExtracted has been extracted to a separate facet\n      return undefined;\n    }\n    if (labelExpr !== undefined) {\n      let expr = labelExpr;\n      if (axis.encode?.labels?.update && isSignalRef(axis.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n      }\n      setAxisEncode(axis, 'labels', 'text', {\n        signal: expr\n      });\n    }\n    if (axis.labelAlign === null) {\n      delete axis.labelAlign;\n    }\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      for (const part of AXIS_PARTS) {\n        if (!axisCmpt.hasAxisPart(part)) {\n          delete axis.encode[part];\n        }\n      }\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n    const titleString = assembleTitle(title, config);\n    return {\n      scale,\n      orient,\n      grid: false,\n      ...(titleString ? {\n        title: titleString\n      } : {}),\n      ...axis,\n      ...(config.aria === false ? {\n        aria: false\n      } : {}),\n      zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n    };\n  }\n}\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\nexport function assembleAxisSignals(model) {\n  const {\n    axes\n  } = model.component;\n  const signals = [];\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    if (axes[channel]) {\n      for (const axis of axes[channel]) {\n        if (!axis.get('disable') && !axis.get('gridScale')) {\n          // If there is x-axis but no y-scale for gridScale, need to set height/width so x-axis can draw the grid with the right height. Same for y-axis and width.\n          const sizeType = channel === 'x' ? 'height' : 'width';\n          const update = model.getSizeSignalRef(sizeType).signal;\n          if (sizeType !== update) {\n            signals.push({\n              name: sizeType,\n              update\n            });\n          }\n        }\n      }\n    }\n  }\n  return signals;\n}\nexport function assembleAxes(axisComponents, config) {\n  const {\n    x = [],\n    y = []\n  } = axisComponents;\n  return [...x.map(a => assembleAxis(a, 'grid', config)), ...y.map(a => assembleAxis(a, 'grid', config)), ...x.map(a => assembleAxis(a, 'main', config)), ...y.map(a => assembleAxis(a, 'main', config))].filter(a => a); // filter undefined\n}","map":{"version":3,"names":["array","isArray","AXIS_PARTS","AXIS_PROPERTY_TYPE","CONDITIONAL_AXIS_PROP_INDEX","isConditionalAxisValue","POSITION_SCALE_CHANNELS","defaultTitle","isText","contains","getFirstDefined","isEmpty","replaceAll","isSignalRef","exprFromValueRefOrSignalRef","expression","assembleTitle","title","config","undefined","map","fieldDef","join","setAxisEncode","axis","part","vgProp","vgRef","encode","_a","_b","update","assembleAxis","axisCmpt","kind","opt","arguments","length","header","disable","orient","scale","labelExpr","zindex","combine","p","prop","propType","propValue","condition","valueOrSignalRef","conditions","propIndex","c","test","valueOrSignalCRef","signalRef","signal","grid","domain","labels","aria","maxExtent","minExtent","ticks","mainExtracted","expr","text","labelAlign","hasAxisPart","titleString","assembleAxisSignals","model","axes","component","signals","channel","get","sizeType","getSizeSignalRef","push","name","assembleAxes","axisComponents","x","y","a","filter"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\axis\\assemble.ts"],"sourcesContent":["import {Axis as VgAxis, AxisEncode, NewSignal, SignalRef, Text} from 'vega';\nimport {array, isArray} from 'vega-util';\nimport {\n  AXIS_PARTS,\n  AXIS_PROPERTY_TYPE,\n  CONDITIONAL_AXIS_PROP_INDEX,\n  ConditionalAxisProp,\n  isConditionalAxisValue\n} from '../../axis';\nimport {POSITION_SCALE_CHANNELS} from '../../channel';\nimport {defaultTitle, FieldDefBase} from '../../channeldef';\nimport {Config} from '../../config';\nimport {isText} from '../../title';\nimport {contains, getFirstDefined, isEmpty, replaceAll} from '../../util';\nimport {isSignalRef, VgEncodeChannel, VgValueRef} from '../../vega.schema';\nimport {exprFromValueRefOrSignalRef} from '../common';\nimport {Model} from '../model';\nimport {expression} from '../predicate';\nimport {AxisComponent, AxisComponentIndex} from './component';\n\nfunction assembleTitle(title: Text | FieldDefBase<string>[] | SignalRef, config: Config): Text | SignalRef {\n  if (!title) {\n    return undefined;\n  }\n  if (isArray(title) && !isText(title)) {\n    return title.map(fieldDef => defaultTitle(fieldDef, config)).join(', ');\n  }\n  return title;\n}\n\nfunction setAxisEncode(\n  axis: Omit<VgAxis, 'orient' | 'scale'>,\n  part: keyof AxisEncode,\n  vgProp: VgEncodeChannel,\n  vgRef: VgValueRef | readonly VgValueRef[]\n) {\n  axis.encode ??= {};\n  axis.encode[part] ??= {};\n  axis.encode[part].update ??= {};\n  // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n  (axis.encode[part].update[vgProp] as any) = vgRef;\n}\n\nexport function assembleAxis(\n  axisCmpt: AxisComponent,\n  kind: 'main' | 'grid',\n  config: Config<SignalRef>,\n  opt: {\n    header: boolean; // whether this is called via a header\n  } = {header: false}\n): VgAxis {\n  const {disable, orient, scale, labelExpr, title, zindex, ...axis} = axisCmpt.combine();\n\n  if (disable) {\n    return undefined;\n  }\n\n  for (const p in axis) {\n    const prop = p as keyof typeof axis;\n    const propType = AXIS_PROPERTY_TYPE[prop];\n    const propValue = axis[prop];\n\n    if (propType && propType !== kind && propType !== 'both') {\n      // Remove properties that are not valid for this kind of axis\n      delete axis[prop];\n    } else if (isConditionalAxisValue<any, SignalRef>(propValue)) {\n      // deal with conditional axis value\n\n      const {condition, ...valueOrSignalRef} = propValue as any;\n      const conditions = array(condition);\n\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop as ConditionalAxisProp];\n      if (propIndex) {\n        const {vgProp, part} = propIndex;\n        // If there is a corresponding Vega property for the channel,\n        // use Vega's custom axis encoding and delete the original axis property to avoid conflicts\n\n        const vgRef = [\n          ...conditions.map(c => {\n            const {test, ...valueOrSignalCRef} = c;\n            return {\n              test: expression(null, test),\n              ...valueOrSignalCRef\n            };\n          }),\n          valueOrSignalRef\n        ];\n        setAxisEncode(axis, part, vgProp, vgRef);\n        delete axis[prop];\n      } else if (propIndex === null) {\n        // If propIndex is null, this means we support conditional axis property by converting the condition to signal instead.\n        const signalRef: SignalRef = {\n          signal:\n            conditions\n              .map(c => {\n                const {test, ...valueOrSignalCRef} = c;\n                return `${expression(null, test)} ? ${exprFromValueRefOrSignalRef(valueOrSignalCRef)} : `;\n              })\n              .join('') + exprFromValueRefOrSignalRef(valueOrSignalRef)\n        };\n        (axis as any)[prop] = signalRef;\n      }\n    } else if (isSignalRef(propValue)) {\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop as ConditionalAxisProp];\n      if (propIndex) {\n        const {vgProp, part} = propIndex;\n        // FIXME: remove as any\n        setAxisEncode(axis, part, vgProp, propValue as any);\n        delete axis[prop];\n      } // else do nothing since the property already supports signal\n    }\n\n    // Do not pass labelAlign/Baseline = null to Vega since it won't pass the schema\n    // Note that we need to use null so the default labelAlign is preserved.\n    if (contains(['labelAlign', 'labelBaseline'], prop) && axis[prop] === null) {\n      delete axis[prop];\n    }\n  }\n\n  if (kind === 'grid') {\n    if (!axis.grid) {\n      return undefined;\n    }\n\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      // Only need to keep encode block for grid\n      const {grid} = axis.encode;\n      axis.encode = {\n        ...(grid ? {grid} : {})\n      };\n\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n\n    return {\n      scale,\n      orient,\n      ...axis,\n      domain: false,\n      labels: false,\n      aria: false, // always hide grid axis\n\n      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n      // would not affect gridAxis\n      maxExtent: 0,\n      minExtent: 0,\n      ticks: false,\n      zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n    };\n  } else {\n    // kind === 'main'\n\n    if (!opt.header && axisCmpt.mainExtracted) {\n      // if mainExtracted has been extracted to a separate facet\n      return undefined;\n    }\n\n    if (labelExpr !== undefined) {\n      let expr = labelExpr;\n      if (axis.encode?.labels?.update && isSignalRef(axis.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n      }\n      setAxisEncode(axis, 'labels', 'text', {signal: expr});\n    }\n\n    if (axis.labelAlign === null) {\n      delete axis.labelAlign;\n    }\n\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      for (const part of AXIS_PARTS) {\n        if (!axisCmpt.hasAxisPart(part)) {\n          delete axis.encode[part];\n        }\n      }\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n\n    const titleString = assembleTitle(title, config);\n\n    return {\n      scale,\n      orient,\n      grid: false,\n      ...(titleString ? {title: titleString} : {}),\n      ...axis,\n      ...(config.aria === false ? {aria: false} : {}),\n      zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n    };\n  }\n}\n\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\nexport function assembleAxisSignals(model: Model): NewSignal[] {\n  const {axes} = model.component;\n  const signals: NewSignal[] = [];\n\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    if (axes[channel]) {\n      for (const axis of axes[channel]) {\n        if (!axis.get('disable') && !axis.get('gridScale')) {\n          // If there is x-axis but no y-scale for gridScale, need to set height/width so x-axis can draw the grid with the right height. Same for y-axis and width.\n\n          const sizeType = channel === 'x' ? 'height' : 'width';\n          const update = model.getSizeSignalRef(sizeType).signal;\n\n          if (sizeType !== update) {\n            signals.push({\n              name: sizeType,\n              update\n            });\n          }\n        }\n      }\n    }\n  }\n  return signals;\n}\n\nexport function assembleAxes(axisComponents: AxisComponentIndex, config: Config<SignalRef>): VgAxis[] {\n  const {x = [], y = []} = axisComponents;\n  return [\n    ...x.map(a => assembleAxis(a, 'grid', config)),\n    ...y.map(a => assembleAxis(a, 'grid', config)),\n    ...x.map(a => assembleAxis(a, 'main', config)),\n    ...y.map(a => assembleAxis(a, 'main', config))\n  ].filter(a => a); // filter undefined\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}