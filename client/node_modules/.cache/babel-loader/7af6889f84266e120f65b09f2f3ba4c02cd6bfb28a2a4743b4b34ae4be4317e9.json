{"ast":null,"code":"import { isString } from 'vega-util';\nimport { binToString, isBinning, isParameterExtent } from '../../bin';\nimport { binRequiresRange, isTypedFieldDef, normalizeBin, vgField } from '../../channeldef';\nimport { duplicate, hash, isEmpty, keys, replacePathInField, unique, vals } from '../../util';\nimport { binFormatExpression } from '../format';\nimport { isUnitModel } from '../model';\nimport { parseSelectionExtent } from '../selection/parse';\nimport { DataFlowNode } from './dataflow';\nfunction rangeFormula(model, fieldDef, channel, config) {\n  if (binRequiresRange(fieldDef, channel)) {\n    // read format from axis or legend, if there is no format then use config.numberFormat\n    const guide = isUnitModel(model) ? model.axis(channel) ?? model.legend(channel) ?? {} : {};\n    const startField = vgField(fieldDef, {\n      expr: 'datum'\n    });\n    const endField = vgField(fieldDef, {\n      expr: 'datum',\n      binSuffix: 'end'\n    });\n    return {\n      formulaAs: vgField(fieldDef, {\n        binSuffix: 'range',\n        forAs: true\n      }),\n      formula: binFormatExpression(startField, endField, guide.format, guide.formatType, config)\n    };\n  }\n  return {};\n}\nfunction binKey(bin, field) {\n  return `${binToString(bin)}_${field}`;\n}\nfunction getSignalsFromModel(model, key) {\n  return {\n    signal: model.getName(`${key}_bins`),\n    extentSignal: model.getName(`${key}_extent`)\n  };\n}\nexport function getBinSignalName(model, field, bin) {\n  const normalizedBin = normalizeBin(bin, undefined) ?? {};\n  const key = binKey(normalizedBin, field);\n  return model.getName(`${key}_bins`);\n}\nfunction isBinTransform(t) {\n  return 'as' in t;\n}\nfunction createBinComponent(t, bin, model) {\n  let as;\n  let span;\n  if (isBinTransform(t)) {\n    as = isString(t.as) ? [t.as, `${t.as}_end`] : [t.as[0], t.as[1]];\n  } else {\n    as = [vgField(t, {\n      forAs: true\n    }), vgField(t, {\n      binSuffix: 'end',\n      forAs: true\n    })];\n  }\n  const normalizedBin = {\n    ...normalizeBin(bin, undefined)\n  };\n  const key = binKey(normalizedBin, t.field);\n  const {\n    signal,\n    extentSignal\n  } = getSignalsFromModel(model, key);\n  if (isParameterExtent(normalizedBin.extent)) {\n    const ext = normalizedBin.extent;\n    span = parseSelectionExtent(model, ext.param, ext);\n    delete normalizedBin.extent; // Vega-Lite selection extent map to Vega's span property.\n  }\n  const binComponent = {\n    bin: normalizedBin,\n    field: t.field,\n    as: [as],\n    ...(signal ? {\n      signal\n    } : {}),\n    ...(extentSignal ? {\n      extentSignal\n    } : {}),\n    ...(span ? {\n      span\n    } : {})\n  };\n  return {\n    key,\n    binComponent\n  };\n}\nexport class BinNode extends DataFlowNode {\n  clone() {\n    return new BinNode(null, duplicate(this.bins));\n  }\n  constructor(parent, bins) {\n    super(parent);\n    this.bins = bins;\n  }\n  static makeFromEncoding(parent, model) {\n    const bins = model.reduceFieldDef((binComponentIndex, fieldDef, channel) => {\n      if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n        const {\n          key,\n          binComponent\n        } = createBinComponent(fieldDef, fieldDef.bin, model);\n        binComponentIndex[key] = {\n          ...binComponent,\n          ...binComponentIndex[key],\n          ...rangeFormula(model, fieldDef, channel, model.config)\n        };\n      }\n      return binComponentIndex;\n    }, {});\n    if (isEmpty(bins)) {\n      return null;\n    }\n    return new BinNode(parent, bins);\n  }\n  /**\n   * Creates a bin node from BinTransform.\n   * The optional parameter should provide\n   */\n  static makeFromTransform(parent, t, model) {\n    const {\n      key,\n      binComponent\n    } = createBinComponent(t, t.bin, model);\n    return new BinNode(parent, {\n      [key]: binComponent\n    });\n  }\n  /**\n   * Merge bin nodes. This method either integrates the bin config from the other node\n   * or if this node already has a bin config, renames the corresponding signal in the model.\n   */\n  merge(other, renameSignal) {\n    for (const key of keys(other.bins)) {\n      if (key in this.bins) {\n        renameSignal(other.bins[key].signal, this.bins[key].signal);\n        // Ensure that we don't have duplicate names for signal pairs\n        this.bins[key].as = unique([...this.bins[key].as, ...other.bins[key].as], hash);\n      } else {\n        this.bins[key] = other.bins[key];\n      }\n    }\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n    other.remove();\n  }\n  producedFields() {\n    return new Set(vals(this.bins).map(c => c.as).flat(2));\n  }\n  dependentFields() {\n    return new Set(vals(this.bins).map(c => c.field));\n  }\n  hash() {\n    return `Bin ${hash(this.bins)}`;\n  }\n  assemble() {\n    return vals(this.bins).flatMap(bin => {\n      const transform = [];\n      const [binAs, ...remainingAs] = bin.as;\n      const {\n        extent,\n        ...params\n      } = bin.bin;\n      const binTrans = {\n        type: 'bin',\n        field: replacePathInField(bin.field),\n        as: binAs,\n        signal: bin.signal,\n        ...(!isParameterExtent(extent) ? {\n          extent\n        } : {\n          extent: null\n        }),\n        ...(bin.span ? {\n          span: {\n            signal: `span(${bin.span})`\n          }\n        } : {}),\n        ...params\n      };\n      if (!extent && bin.extentSignal) {\n        transform.push({\n          type: 'extent',\n          field: replacePathInField(bin.field),\n          signal: bin.extentSignal\n        });\n        binTrans.extent = {\n          signal: bin.extentSignal\n        };\n      }\n      transform.push(binTrans);\n      for (const as of remainingAs) {\n        for (let i = 0; i < 2; i++) {\n          transform.push({\n            type: 'formula',\n            expr: vgField({\n              field: binAs[i]\n            }, {\n              expr: 'datum'\n            }),\n            as: as[i]\n          });\n        }\n      }\n      if (bin.formula) {\n        transform.push({\n          type: 'formula',\n          expr: bin.formula,\n          as: bin.formulaAs\n        });\n      }\n      return transform;\n    });\n  }\n}","map":{"version":3,"names":["isString","binToString","isBinning","isParameterExtent","binRequiresRange","isTypedFieldDef","normalizeBin","vgField","duplicate","hash","isEmpty","keys","replacePathInField","unique","vals","binFormatExpression","isUnitModel","parseSelectionExtent","DataFlowNode","rangeFormula","model","fieldDef","channel","config","guide","axis","legend","startField","expr","endField","binSuffix","formulaAs","forAs","formula","format","formatType","binKey","bin","field","getSignalsFromModel","key","signal","getName","extentSignal","getBinSignalName","normalizedBin","undefined","isBinTransform","t","createBinComponent","as","span","extent","ext","param","binComponent","BinNode","clone","bins","constructor","parent","makeFromEncoding","reduceFieldDef","binComponentIndex","makeFromTransform","merge","other","renameSignal","child","children","removeChild","remove","producedFields","Set","map","c","flat","dependentFields","assemble","flatMap","transform","binAs","remainingAs","params","binTrans","type","push","i"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\data\\bin.ts"],"sourcesContent":["import {BinTransform as VgBinTransform, Transforms as VgTransform} from 'vega';\nimport {isString} from 'vega-util';\nimport {BinParams, binToString, isBinning, isParameterExtent} from '../../bin';\nimport {Channel} from '../../channel';\nimport {binRequiresRange, FieldName, isTypedFieldDef, normalizeBin, TypedFieldDef, vgField} from '../../channeldef';\nimport {Config} from '../../config';\nimport {BinTransform} from '../../transform';\nimport {Dict, duplicate, hash, isEmpty, keys, replacePathInField, unique, vals} from '../../util';\nimport {binFormatExpression} from '../format';\nimport {isUnitModel, Model, ModelWithField} from '../model';\nimport {parseSelectionExtent} from '../selection/parse';\nimport {NonPositionScaleChannel, PositionChannel} from './../../channel';\nimport {DataFlowNode} from './dataflow';\n\nfunction rangeFormula(model: ModelWithField, fieldDef: TypedFieldDef<string>, channel: Channel, config: Config) {\n  if (binRequiresRange(fieldDef, channel)) {\n    // read format from axis or legend, if there is no format then use config.numberFormat\n\n    const guide = isUnitModel(model)\n      ? (model.axis(channel as PositionChannel) ?? model.legend(channel as NonPositionScaleChannel) ?? {})\n      : {};\n\n    const startField = vgField(fieldDef, {expr: 'datum'});\n    const endField = vgField(fieldDef, {expr: 'datum', binSuffix: 'end'});\n\n    return {\n      formulaAs: vgField(fieldDef, {binSuffix: 'range', forAs: true}),\n      formula: binFormatExpression(startField, endField, guide.format, guide.formatType, config)\n    };\n  }\n  return {};\n}\n\nfunction binKey(bin: BinParams, field: string) {\n  return `${binToString(bin)}_${field}`;\n}\n\nfunction getSignalsFromModel(model: Model, key: string) {\n  return {\n    signal: model.getName(`${key}_bins`),\n    extentSignal: model.getName(`${key}_extent`)\n  };\n}\n\nexport function getBinSignalName(model: Model, field: string, bin: boolean | BinParams) {\n  const normalizedBin = normalizeBin(bin, undefined) ?? {};\n  const key = binKey(normalizedBin, field);\n  return model.getName(`${key}_bins`);\n}\n\nfunction isBinTransform(t: TypedFieldDef<string> | BinTransform): t is BinTransform {\n  return 'as' in t;\n}\n\nfunction createBinComponent(t: TypedFieldDef<string> | BinTransform, bin: boolean | BinParams, model: Model) {\n  let as: [string, string];\n  let span: string;\n\n  if (isBinTransform(t)) {\n    as = isString(t.as) ? [t.as, `${t.as}_end`] : [t.as[0], t.as[1]];\n  } else {\n    as = [vgField(t, {forAs: true}), vgField(t, {binSuffix: 'end', forAs: true})];\n  }\n\n  const normalizedBin = {...normalizeBin(bin, undefined)};\n  const key = binKey(normalizedBin, t.field);\n  const {signal, extentSignal} = getSignalsFromModel(model, key);\n\n  if (isParameterExtent(normalizedBin.extent)) {\n    const ext = normalizedBin.extent;\n    span = parseSelectionExtent(model, ext.param, ext);\n    delete normalizedBin.extent; // Vega-Lite selection extent map to Vega's span property.\n  }\n\n  const binComponent: BinComponent = {\n    bin: normalizedBin,\n    field: t.field,\n    as: [as],\n    ...(signal ? {signal} : {}),\n    ...(extentSignal ? {extentSignal} : {}),\n    ...(span ? {span} : {})\n  };\n\n  return {key, binComponent};\n}\n\nexport interface BinComponent {\n  bin: BinParams;\n  field: FieldName;\n  extentSignal?: string;\n  signal?: string;\n  span?: string;\n\n  /** Pairs of strings of the names of start and end signals */\n  as: [string, string][];\n\n  // Range Formula\n\n  formula?: string;\n  formulaAs?: string;\n}\n\nexport class BinNode extends DataFlowNode {\n  public clone() {\n    return new BinNode(null, duplicate(this.bins));\n  }\n\n  constructor(\n    parent: DataFlowNode,\n    private bins: Dict<BinComponent>\n  ) {\n    super(parent);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: ModelWithField) {\n    const bins = model.reduceFieldDef((binComponentIndex: Dict<BinComponent>, fieldDef, channel) => {\n      if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n        const {key, binComponent} = createBinComponent(fieldDef, fieldDef.bin, model);\n        binComponentIndex[key] = {\n          ...binComponent,\n          ...binComponentIndex[key],\n          ...rangeFormula(model, fieldDef, channel, model.config)\n        };\n      }\n      return binComponentIndex;\n    }, {} as Dict<BinComponent>);\n\n    if (isEmpty(bins)) {\n      return null;\n    }\n\n    return new BinNode(parent, bins);\n  }\n\n  /**\n   * Creates a bin node from BinTransform.\n   * The optional parameter should provide\n   */\n  public static makeFromTransform(parent: DataFlowNode, t: BinTransform, model: Model) {\n    const {key, binComponent} = createBinComponent(t, t.bin, model);\n    return new BinNode(parent, {\n      [key]: binComponent\n    });\n  }\n\n  /**\n   * Merge bin nodes. This method either integrates the bin config from the other node\n   * or if this node already has a bin config, renames the corresponding signal in the model.\n   */\n  public merge(other: BinNode, renameSignal: (s1: string, s2: string) => void) {\n    for (const key of keys(other.bins)) {\n      if (key in this.bins) {\n        renameSignal(other.bins[key].signal, this.bins[key].signal);\n        // Ensure that we don't have duplicate names for signal pairs\n        this.bins[key].as = unique([...this.bins[key].as, ...other.bins[key].as], hash);\n      } else {\n        this.bins[key] = other.bins[key];\n      }\n    }\n\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n    other.remove();\n  }\n\n  public producedFields() {\n    return new Set(\n      vals(this.bins)\n        .map(c => c.as)\n        .flat(2)\n    );\n  }\n\n  public dependentFields() {\n    return new Set(vals(this.bins).map(c => c.field));\n  }\n\n  public hash() {\n    return `Bin ${hash(this.bins)}`;\n  }\n\n  public assemble(): VgTransform[] {\n    return vals(this.bins).flatMap(bin => {\n      const transform: VgTransform[] = [];\n\n      const [binAs, ...remainingAs] = bin.as;\n      const {extent, ...params} = bin.bin;\n      const binTrans: VgBinTransform = {\n        type: 'bin',\n        field: replacePathInField(bin.field),\n        as: binAs,\n        signal: bin.signal,\n        ...(!isParameterExtent(extent) ? {extent} : {extent: null}),\n        ...(bin.span ? {span: {signal: `span(${bin.span})`}} : {}),\n        ...params\n      };\n\n      if (!extent && bin.extentSignal) {\n        transform.push({\n          type: 'extent',\n          field: replacePathInField(bin.field),\n          signal: bin.extentSignal\n        });\n        binTrans.extent = {signal: bin.extentSignal};\n      }\n\n      transform.push(binTrans);\n\n      for (const as of remainingAs) {\n        for (let i = 0; i < 2; i++) {\n          transform.push({\n            type: 'formula',\n            expr: vgField({field: binAs[i]}, {expr: 'datum'}),\n            as: as[i]\n          });\n        }\n      }\n\n      if (bin.formula) {\n        transform.push({\n          type: 'formula',\n          expr: bin.formula,\n          as: bin.formulaAs\n        });\n      }\n      return transform;\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}