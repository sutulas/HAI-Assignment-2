{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW } from '../channel';\nimport { initFieldDef, vgField } from '../channeldef';\nimport { replaceExprRef } from '../expr';\nimport * as log from '../log';\nimport { hasDiscreteDomain } from '../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../sort';\nimport { isFacetMapping } from '../spec/facet';\nimport { hasProperty, keys } from '../util';\nimport { isVgRangeStep } from '../vega.schema';\nimport { buildModel } from './buildmodel';\nimport { assembleFacetData } from './data/assemble';\nimport { sortArrayIndexField } from './data/calculate';\nimport { parseData } from './data/parse';\nimport { assembleLabelTitle } from './header/assemble';\nimport { getHeaderChannel, getHeaderProperty } from './header/common';\nimport { HEADER_CHANNELS, HEADER_TYPES } from './header/component';\nimport { parseFacetHeaders } from './header/parse';\nimport { parseChildrenLayoutSize } from './layoutsize/parse';\nimport { ModelWithField } from './model';\nimport { assembleDomain, getFieldFromDomain } from './scale/domain';\nimport { assembleFacetSignals } from './selection/assemble';\nexport function facetSortFieldName(fieldDef, sort, opt) {\n  return vgField(sort, {\n    suffix: `by_${vgField(fieldDef)}`,\n    ...opt\n  });\n}\nexport class FacetModel extends ModelWithField {\n  constructor(spec, parent, parentGivenName, config) {\n    super(spec, 'facet', parent, parentGivenName, config, spec.resolve);\n    this.child = buildModel(spec.spec, this, this.getName('child'), undefined, config);\n    this.children = [this.child];\n    this.facet = this.initFacet(spec.facet);\n  }\n  initFacet(facet) {\n    // clone to prevent side effect to the original spec\n    if (!isFacetMapping(facet)) {\n      return {\n        facet: this.initFacetFieldDef(facet, 'facet')\n      };\n    }\n    const channels = keys(facet);\n    const normalizedFacet = {};\n    for (const channel of channels) {\n      if (![ROW, COLUMN].includes(channel)) {\n        // Drop unsupported channel\n        log.warn(log.message.incompatibleChannel(channel, 'facet'));\n        break;\n      }\n      const fieldDef = facet[channel];\n      if (fieldDef.field === undefined) {\n        log.warn(log.message.emptyFieldDef(fieldDef, channel));\n        break;\n      }\n      normalizedFacet[channel] = this.initFacetFieldDef(fieldDef, channel);\n    }\n    return normalizedFacet;\n  }\n  initFacetFieldDef(fieldDef, channel) {\n    // Cast because we call initFieldDef, which assumes general FieldDef.\n    // However, FacetFieldDef is a bit more constrained than the general FieldDef\n    const facetFieldDef = initFieldDef(fieldDef, channel);\n    if (facetFieldDef.header) {\n      facetFieldDef.header = replaceExprRef(facetFieldDef.header);\n    } else if (facetFieldDef.header === null) {\n      facetFieldDef.header = null;\n    }\n    return facetFieldDef;\n  }\n  channelHasField(channel) {\n    return hasProperty(this.facet, channel);\n  }\n  fieldDef(channel) {\n    return this.facet[channel];\n  }\n  parseData() {\n    this.component.data = parseData(this);\n    this.child.parseData();\n  }\n  parseLayoutSize() {\n    parseChildrenLayoutSize(this);\n  }\n  parseSelections() {\n    // As a facet has a single child, the selection components are the same.\n    // The child maintains its selections to assemble signals, which remain\n    // within its unit.\n    this.child.parseSelections();\n    this.component.selection = this.child.component.selection;\n  }\n  parseMarkGroup() {\n    this.child.parseMarkGroup();\n  }\n  parseAxesAndHeaders() {\n    this.child.parseAxesAndHeaders();\n    parseFacetHeaders(this);\n  }\n  assembleSelectionTopLevelSignals(signals) {\n    return this.child.assembleSelectionTopLevelSignals(signals);\n  }\n  assembleSignals() {\n    this.child.assembleSignals();\n    return [];\n  }\n  assembleSelectionData(data) {\n    return this.child.assembleSelectionData(data);\n  }\n  getHeaderLayoutMixins() {\n    const layoutMixins = {};\n    for (const channel of FACET_CHANNELS) {\n      for (const headerType of HEADER_TYPES) {\n        const layoutHeaderComponent = this.component.layoutHeaders[channel];\n        const headerComponent = layoutHeaderComponent[headerType];\n        const {\n          facetFieldDef\n        } = layoutHeaderComponent;\n        if (facetFieldDef) {\n          const titleOrient = getHeaderProperty('titleOrient', facetFieldDef.header, this.config, channel);\n          if (['right', 'bottom'].includes(titleOrient)) {\n            const headerChannel = getHeaderChannel(channel, titleOrient);\n            layoutMixins.titleAnchor ?? (layoutMixins.titleAnchor = {});\n            layoutMixins.titleAnchor[headerChannel] = 'end';\n          }\n        }\n        if (headerComponent?.[0]) {\n          // set header/footerBand\n          const sizeType = channel === 'row' ? 'height' : 'width';\n          const bandType = headerType === 'header' ? 'headerBand' : 'footerBand';\n          if (channel !== 'facet' && !this.child.component.layoutSize.get(sizeType)) {\n            // If facet child does not have size signal, then apply headerBand\n            layoutMixins[bandType] ?? (layoutMixins[bandType] = {});\n            layoutMixins[bandType][channel] = 0.5;\n          }\n          if (layoutHeaderComponent.title) {\n            layoutMixins.offset ?? (layoutMixins.offset = {});\n            layoutMixins.offset[channel === 'row' ? 'rowTitle' : 'columnTitle'] = 10;\n          }\n        }\n      }\n    }\n    return layoutMixins;\n  }\n  assembleDefaultLayout() {\n    const {\n      column,\n      row\n    } = this.facet;\n    const columns = column ? this.columnDistinctSignal() : row ? 1 : undefined;\n    let align = 'all';\n    // Do not align the cells if the scale corresponding to the direction is indepent.\n    // We always align when we facet into both row and column.\n    if (!row && this.component.resolve.scale.x === 'independent') {\n      align = 'none';\n    } else if (!column && this.component.resolve.scale.y === 'independent') {\n      align = 'none';\n    }\n    return {\n      ...this.getHeaderLayoutMixins(),\n      ...(columns ? {\n        columns\n      } : {}),\n      bounds: 'full',\n      align\n    };\n  }\n  assembleLayoutSignals() {\n    // FIXME(https://github.com/vega/vega-lite/issues/1193): this can be incorrect if we have independent scales.\n    return this.child.assembleLayoutSignals();\n  }\n  columnDistinctSignal() {\n    if (this.parent && this.parent instanceof FacetModel) {\n      // For nested facet, we will add columns to group mark instead\n      // See discussion in https://github.com/vega/vega/issues/952\n      // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n      return undefined;\n    } else {\n      // In facetNode.assemble(), the name is always this.getName('column') + '_layout'.\n      const facetLayoutDataName = this.getName('column_domain');\n      return {\n        signal: `length(data('${facetLayoutDataName}'))`\n      };\n    }\n  }\n  assembleGroupStyle() {\n    return undefined;\n  }\n  assembleGroup(signals) {\n    if (this.parent && this.parent instanceof FacetModel) {\n      // Provide number of columns for layout.\n      // See discussion in https://github.com/vega/vega/issues/952\n      // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n      return {\n        ...(this.channelHasField('column') ? {\n          encode: {\n            update: {\n              // TODO(https://github.com/vega/vega-lite/issues/2759):\n              // Correct the signal for facet of concat of facet_column\n              columns: {\n                field: vgField(this.facet.column, {\n                  prefix: 'distinct'\n                })\n              }\n            }\n          }\n        } : {}),\n        ...super.assembleGroup(signals)\n      };\n    }\n    return super.assembleGroup(signals);\n  }\n  /**\n   * Aggregate cardinality for calculating size\n   */\n  getCardinalityAggregateForChild() {\n    const fields = [];\n    const ops = [];\n    const as = [];\n    if (this.child instanceof FacetModel) {\n      if (this.child.channelHasField('column')) {\n        const field = vgField(this.child.facet.column);\n        fields.push(field);\n        ops.push('distinct');\n        as.push(`distinct_${field}`);\n      }\n    } else {\n      for (const channel of POSITION_SCALE_CHANNELS) {\n        const childScaleComponent = this.child.component.scales[channel];\n        if (childScaleComponent && !childScaleComponent.merged) {\n          const type = childScaleComponent.get('type');\n          const range = childScaleComponent.get('range');\n          if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n            const domain = assembleDomain(this.child, channel);\n            const field = getFieldFromDomain(domain);\n            if (field) {\n              fields.push(field);\n              ops.push('distinct');\n              as.push(`distinct_${field}`);\n            } else {\n              log.warn(log.message.unknownField(channel));\n            }\n          }\n        }\n      }\n    }\n    return {\n      fields,\n      ops,\n      as\n    };\n  }\n  assembleFacet() {\n    const {\n      name,\n      data\n    } = this.component.data.facetRoot;\n    const {\n      row,\n      column\n    } = this.facet;\n    const {\n      fields,\n      ops,\n      as\n    } = this.getCardinalityAggregateForChild();\n    const groupby = [];\n    for (const channel of FACET_CHANNELS) {\n      const fieldDef = this.facet[channel];\n      if (fieldDef) {\n        groupby.push(vgField(fieldDef));\n        const {\n          bin,\n          sort\n        } = fieldDef;\n        if (isBinning(bin)) {\n          groupby.push(vgField(fieldDef, {\n            binSuffix: 'end'\n          }));\n        }\n        if (isSortField(sort)) {\n          const {\n            field,\n            op = DEFAULT_SORT_OP\n          } = sort;\n          const outputName = facetSortFieldName(fieldDef, sort);\n          if (row && column) {\n            // For crossed facet, use pre-calculate field as it requires a different groupby\n            // For each calculated field, apply max and assign them to the same name as\n            // all values of the same group should be the same anyway.\n            fields.push(outputName);\n            ops.push('max');\n            as.push(outputName);\n          } else {\n            fields.push(field);\n            ops.push(op);\n            as.push(outputName);\n          }\n        } else if (isArray(sort)) {\n          const outputName = sortArrayIndexField(fieldDef, channel);\n          fields.push(outputName);\n          ops.push('max');\n          as.push(outputName);\n        }\n      }\n    }\n    const cross = !!row && !!column;\n    return {\n      name,\n      data,\n      groupby,\n      ...(cross || fields.length > 0 ? {\n        aggregate: {\n          ...(cross ? {\n            cross\n          } : {}),\n          ...(fields.length ? {\n            fields,\n            ops,\n            as\n          } : {})\n        }\n      } : {})\n    };\n  }\n  facetSortFields(channel) {\n    const {\n      facet\n    } = this;\n    const fieldDef = facet[channel];\n    if (fieldDef) {\n      if (isSortField(fieldDef.sort)) {\n        return [facetSortFieldName(fieldDef, fieldDef.sort, {\n          expr: 'datum'\n        })];\n      } else if (isArray(fieldDef.sort)) {\n        return [sortArrayIndexField(fieldDef, channel, {\n          expr: 'datum'\n        })];\n      }\n      return [vgField(fieldDef, {\n        expr: 'datum'\n      })];\n    }\n    return [];\n  }\n  facetSortOrder(channel) {\n    const {\n      facet\n    } = this;\n    const fieldDef = facet[channel];\n    if (fieldDef) {\n      const {\n        sort\n      } = fieldDef;\n      const order = (isSortField(sort) ? sort.order : !isArray(sort) && sort) || 'ascending';\n      return [order];\n    }\n    return [];\n  }\n  assembleLabelTitle() {\n    const {\n      facet,\n      config\n    } = this;\n    if (facet.facet) {\n      // Facet always uses title to display labels\n      return assembleLabelTitle(facet.facet, 'facet', config);\n    }\n    const ORTHOGONAL_ORIENT = {\n      row: ['top', 'bottom'],\n      column: ['left', 'right']\n    };\n    for (const channel of HEADER_CHANNELS) {\n      if (facet[channel]) {\n        const labelOrient = getHeaderProperty('labelOrient', facet[channel]?.header, config, channel);\n        if (ORTHOGONAL_ORIENT[channel].includes(labelOrient)) {\n          // Row/Column with orthogonal labelOrient must use title to display labels\n          return assembleLabelTitle(facet[channel], channel, config);\n        }\n      }\n    }\n    return undefined;\n  }\n  assembleMarks() {\n    const {\n      child\n    } = this;\n    // If we facet by two dimensions, we need to add a cross operator to the aggregation\n    // so that we create all groups\n    const facetRoot = this.component.data.facetRoot;\n    const data = assembleFacetData(facetRoot);\n    const encodeEntry = child.assembleGroupEncodeEntry(false);\n    const title = this.assembleLabelTitle() || child.assembleTitle();\n    const style = child.assembleGroupStyle();\n    const markGroup = {\n      name: this.getName('cell'),\n      type: 'group',\n      ...(title ? {\n        title\n      } : {}),\n      ...(style ? {\n        style\n      } : {}),\n      from: {\n        facet: this.assembleFacet()\n      },\n      // TODO: move this to after data\n      sort: {\n        field: FACET_CHANNELS.map(c => this.facetSortFields(c)).flat(),\n        order: FACET_CHANNELS.map(c => this.facetSortOrder(c)).flat()\n      },\n      ...(data.length > 0 ? {\n        data\n      } : {}),\n      ...(encodeEntry ? {\n        encode: {\n          update: encodeEntry\n        }\n      } : {}),\n      ...child.assembleGroup(assembleFacetSignals(this, []))\n    };\n    return [markGroup];\n  }\n  getMapping() {\n    return this.facet;\n  }\n}","map":{"version":3,"names":["isArray","isBinning","COLUMN","FACET_CHANNELS","POSITION_SCALE_CHANNELS","ROW","initFieldDef","vgField","replaceExprRef","log","hasDiscreteDomain","DEFAULT_SORT_OP","isSortField","isFacetMapping","hasProperty","keys","isVgRangeStep","buildModel","assembleFacetData","sortArrayIndexField","parseData","assembleLabelTitle","getHeaderChannel","getHeaderProperty","HEADER_CHANNELS","HEADER_TYPES","parseFacetHeaders","parseChildrenLayoutSize","ModelWithField","assembleDomain","getFieldFromDomain","assembleFacetSignals","facetSortFieldName","fieldDef","sort","opt","suffix","FacetModel","constructor","spec","parent","parentGivenName","config","resolve","child","getName","undefined","children","facet","initFacet","initFacetFieldDef","channels","normalizedFacet","channel","includes","warn","message","incompatibleChannel","field","emptyFieldDef","facetFieldDef","header","channelHasField","component","data","parseLayoutSize","parseSelections","selection","parseMarkGroup","parseAxesAndHeaders","assembleSelectionTopLevelSignals","signals","assembleSignals","assembleSelectionData","getHeaderLayoutMixins","layoutMixins","headerType","layoutHeaderComponent","layoutHeaders","headerComponent","titleOrient","headerChannel","titleAnchor","sizeType","bandType","layoutSize","get","title","offset","assembleDefaultLayout","column","row","columns","columnDistinctSignal","align","scale","x","y","bounds","assembleLayoutSignals","facetLayoutDataName","signal","assembleGroupStyle","assembleGroup","encode","update","prefix","getCardinalityAggregateForChild","fields","ops","as","push","childScaleComponent","scales","merged","type","range","domain","unknownField","assembleFacet","name","facetRoot","groupby","bin","binSuffix","op","outputName","cross","length","aggregate","facetSortFields","expr","facetSortOrder","order","ORTHOGONAL_ORIENT","labelOrient","assembleMarks","encodeEntry","assembleGroupEncodeEntry","assembleTitle","style","markGroup","from","map","c","flat","getMapping"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\facet.ts"],"sourcesContent":["import {AggregateOp, LayoutAlign, NewSignal, SignalRef} from 'vega';\nimport {isArray} from 'vega-util';\nimport {isBinning} from '../bin';\nimport {COLUMN, ExtendedChannel, FacetChannel, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW} from '../channel';\nimport {FieldName, FieldRefOption, initFieldDef, TypedFieldDef, vgField} from '../channeldef';\nimport {Config} from '../config';\nimport {ExprRef, replaceExprRef} from '../expr';\nimport * as log from '../log';\nimport {hasDiscreteDomain} from '../scale';\nimport {DEFAULT_SORT_OP, EncodingSortField, isSortField, SortOrder} from '../sort';\nimport {NormalizedFacetSpec} from '../spec';\nimport {EncodingFacetMapping, FacetFieldDef, FacetMapping, isFacetMapping} from '../spec/facet';\nimport {hasProperty, keys} from '../util';\nimport {isVgRangeStep, VgData, VgLayout, VgMarkGroup} from '../vega.schema';\nimport {buildModel} from './buildmodel';\nimport {assembleFacetData} from './data/assemble';\nimport {sortArrayIndexField} from './data/calculate';\nimport {parseData} from './data/parse';\nimport {assembleLabelTitle} from './header/assemble';\nimport {getHeaderChannel, getHeaderProperty} from './header/common';\nimport {HEADER_CHANNELS, HEADER_TYPES} from './header/component';\nimport {parseFacetHeaders} from './header/parse';\nimport {parseChildrenLayoutSize} from './layoutsize/parse';\nimport {Model, ModelWithField} from './model';\nimport {assembleDomain, getFieldFromDomain} from './scale/domain';\nimport {assembleFacetSignals} from './selection/assemble';\n\nexport function facetSortFieldName(\n  fieldDef: FacetFieldDef<string>,\n  sort: EncodingSortField<string>,\n  opt?: FieldRefOption\n) {\n  return vgField(sort, {suffix: `by_${vgField(fieldDef)}`, ...opt});\n}\n\nexport class FacetModel extends ModelWithField {\n  public readonly facet: EncodingFacetMapping<string, SignalRef>;\n\n  public readonly child: Model;\n\n  public readonly children: Model[];\n\n  constructor(spec: NormalizedFacetSpec, parent: Model, parentGivenName: string, config: Config<SignalRef>) {\n    super(spec, 'facet', parent, parentGivenName, config, spec.resolve);\n\n    this.child = buildModel(spec.spec, this, this.getName('child'), undefined, config);\n    this.children = [this.child];\n\n    this.facet = this.initFacet(spec.facet);\n  }\n\n  private initFacet(\n    facet: FacetFieldDef<FieldName> | FacetMapping<FieldName>\n  ): EncodingFacetMapping<FieldName, SignalRef> {\n    // clone to prevent side effect to the original spec\n    if (!isFacetMapping(facet)) {\n      return {facet: this.initFacetFieldDef(facet, 'facet')};\n    }\n\n    const channels = keys(facet);\n    const normalizedFacet: EncodingFacetMapping<FieldName, SignalRef> = {};\n    for (const channel of channels) {\n      if (![ROW, COLUMN].includes(channel)) {\n        // Drop unsupported channel\n        log.warn(log.message.incompatibleChannel(channel, 'facet'));\n        break;\n      }\n\n      const fieldDef = facet[channel];\n      if (fieldDef.field === undefined) {\n        log.warn(log.message.emptyFieldDef(fieldDef, channel));\n        break;\n      }\n\n      normalizedFacet[channel] = this.initFacetFieldDef(fieldDef, channel);\n    }\n\n    return normalizedFacet;\n  }\n\n  private initFacetFieldDef(fieldDef: FacetFieldDef<FieldName, ExprRef | SignalRef>, channel: FacetChannel) {\n    // Cast because we call initFieldDef, which assumes general FieldDef.\n    // However, FacetFieldDef is a bit more constrained than the general FieldDef\n    const facetFieldDef = initFieldDef(fieldDef, channel) as FacetFieldDef<FieldName, SignalRef>;\n    if (facetFieldDef.header) {\n      facetFieldDef.header = replaceExprRef(facetFieldDef.header);\n    } else if (facetFieldDef.header === null) {\n      facetFieldDef.header = null;\n    }\n    return facetFieldDef;\n  }\n\n  public channelHasField(channel: ExtendedChannel): boolean {\n    return hasProperty(this.facet, channel);\n  }\n\n  public fieldDef(channel: ExtendedChannel): TypedFieldDef<string> {\n    return (this.facet as any)[channel];\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n    this.child.parseData();\n  }\n\n  public parseLayoutSize() {\n    parseChildrenLayoutSize(this);\n  }\n\n  public parseSelections() {\n    // As a facet has a single child, the selection components are the same.\n    // The child maintains its selections to assemble signals, which remain\n    // within its unit.\n    this.child.parseSelections();\n    this.component.selection = this.child.component.selection;\n  }\n\n  public parseMarkGroup() {\n    this.child.parseMarkGroup();\n  }\n\n  public parseAxesAndHeaders() {\n    this.child.parseAxesAndHeaders();\n\n    parseFacetHeaders(this);\n  }\n\n  public assembleSelectionTopLevelSignals(signals: NewSignal[]): NewSignal[] {\n    return this.child.assembleSelectionTopLevelSignals(signals);\n  }\n\n  public assembleSignals(): NewSignal[] {\n    this.child.assembleSignals();\n    return [];\n  }\n\n  public assembleSelectionData(data: readonly VgData[]): readonly VgData[] {\n    return this.child.assembleSelectionData(data);\n  }\n\n  private getHeaderLayoutMixins(): VgLayout {\n    const layoutMixins: VgLayout = {};\n\n    for (const channel of FACET_CHANNELS) {\n      for (const headerType of HEADER_TYPES) {\n        const layoutHeaderComponent = this.component.layoutHeaders[channel];\n        const headerComponent = layoutHeaderComponent[headerType];\n\n        const {facetFieldDef} = layoutHeaderComponent;\n        if (facetFieldDef) {\n          const titleOrient = getHeaderProperty('titleOrient', facetFieldDef.header, this.config, channel);\n\n          if (['right', 'bottom'].includes(titleOrient)) {\n            const headerChannel = getHeaderChannel(channel, titleOrient);\n            layoutMixins.titleAnchor ??= {};\n            (layoutMixins.titleAnchor as any)[headerChannel] = 'end';\n          }\n        }\n\n        if (headerComponent?.[0]) {\n          // set header/footerBand\n          const sizeType = channel === 'row' ? 'height' : 'width';\n          const bandType = headerType === 'header' ? 'headerBand' : 'footerBand';\n          if (channel !== 'facet' && !this.child.component.layoutSize.get(sizeType)) {\n            // If facet child does not have size signal, then apply headerBand\n            layoutMixins[bandType] ??= {};\n            (layoutMixins[bandType] as any)[channel] = 0.5;\n          }\n\n          if (layoutHeaderComponent.title) {\n            layoutMixins.offset ??= {};\n            (layoutMixins.offset as any)[channel === 'row' ? 'rowTitle' : 'columnTitle'] = 10;\n          }\n        }\n      }\n    }\n    return layoutMixins;\n  }\n\n  protected assembleDefaultLayout(): VgLayout {\n    const {column, row} = this.facet;\n\n    const columns = column ? this.columnDistinctSignal() : row ? 1 : undefined;\n\n    let align: LayoutAlign = 'all';\n\n    // Do not align the cells if the scale corresponding to the direction is indepent.\n    // We always align when we facet into both row and column.\n    if (!row && this.component.resolve.scale.x === 'independent') {\n      align = 'none';\n    } else if (!column && this.component.resolve.scale.y === 'independent') {\n      align = 'none';\n    }\n\n    return {\n      ...this.getHeaderLayoutMixins(),\n\n      ...(columns ? {columns} : {}),\n      bounds: 'full',\n      align\n    };\n  }\n\n  public assembleLayoutSignals(): NewSignal[] {\n    // FIXME(https://github.com/vega/vega-lite/issues/1193): this can be incorrect if we have independent scales.\n    return this.child.assembleLayoutSignals();\n  }\n\n  private columnDistinctSignal() {\n    if (this.parent && this.parent instanceof FacetModel) {\n      // For nested facet, we will add columns to group mark instead\n      // See discussion in https://github.com/vega/vega/issues/952\n      // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n      return undefined;\n    } else {\n      // In facetNode.assemble(), the name is always this.getName('column') + '_layout'.\n      const facetLayoutDataName = this.getName('column_domain');\n      return {signal: `length(data('${facetLayoutDataName}'))`};\n    }\n  }\n\n  public assembleGroupStyle(): string | string[] {\n    return undefined;\n  }\n\n  public assembleGroup(signals: NewSignal[]) {\n    if (this.parent && this.parent instanceof FacetModel) {\n      // Provide number of columns for layout.\n      // See discussion in https://github.com/vega/vega/issues/952\n      // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n      return {\n        ...(this.channelHasField('column')\n          ? {\n              encode: {\n                update: {\n                  // TODO(https://github.com/vega/vega-lite/issues/2759):\n                  // Correct the signal for facet of concat of facet_column\n                  columns: {field: vgField(this.facet.column, {prefix: 'distinct'})}\n                }\n              }\n            }\n          : {}),\n        ...super.assembleGroup(signals)\n      };\n    }\n    return super.assembleGroup(signals);\n  }\n\n  /**\n   * Aggregate cardinality for calculating size\n   */\n  private getCardinalityAggregateForChild() {\n    const fields: string[] = [];\n    const ops: AggregateOp[] = [];\n    const as: string[] = [];\n\n    if (this.child instanceof FacetModel) {\n      if (this.child.channelHasField('column')) {\n        const field = vgField(this.child.facet.column);\n        fields.push(field);\n        ops.push('distinct');\n        as.push(`distinct_${field}`);\n      }\n    } else {\n      for (const channel of POSITION_SCALE_CHANNELS) {\n        const childScaleComponent = this.child.component.scales[channel];\n        if (childScaleComponent && !childScaleComponent.merged) {\n          const type = childScaleComponent.get('type');\n          const range = childScaleComponent.get('range');\n\n          if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n            const domain = assembleDomain(this.child, channel);\n            const field = getFieldFromDomain(domain);\n            if (field) {\n              fields.push(field);\n              ops.push('distinct');\n              as.push(`distinct_${field}`);\n            } else {\n              log.warn(log.message.unknownField(channel));\n            }\n          }\n        }\n      }\n    }\n    return {fields, ops, as};\n  }\n\n  private assembleFacet() {\n    const {name, data} = this.component.data.facetRoot;\n    const {row, column} = this.facet;\n    const {fields, ops, as} = this.getCardinalityAggregateForChild();\n    const groupby: string[] = [];\n\n    for (const channel of FACET_CHANNELS) {\n      const fieldDef = this.facet[channel];\n      if (fieldDef) {\n        groupby.push(vgField(fieldDef));\n\n        const {bin, sort} = fieldDef;\n\n        if (isBinning(bin)) {\n          groupby.push(vgField(fieldDef, {binSuffix: 'end'}));\n        }\n\n        if (isSortField(sort)) {\n          const {field, op = DEFAULT_SORT_OP} = sort;\n          const outputName = facetSortFieldName(fieldDef, sort);\n          if (row && column) {\n            // For crossed facet, use pre-calculate field as it requires a different groupby\n            // For each calculated field, apply max and assign them to the same name as\n            // all values of the same group should be the same anyway.\n            fields.push(outputName);\n            ops.push('max');\n            as.push(outputName);\n          } else {\n            fields.push(field);\n            ops.push(op);\n            as.push(outputName);\n          }\n        } else if (isArray(sort)) {\n          const outputName = sortArrayIndexField(fieldDef, channel);\n          fields.push(outputName);\n          ops.push('max');\n          as.push(outputName);\n        }\n      }\n    }\n\n    const cross = !!row && !!column;\n\n    return {\n      name,\n      data,\n      groupby,\n      ...(cross || fields.length > 0\n        ? {\n            aggregate: {\n              ...(cross ? {cross} : {}),\n              ...(fields.length ? {fields, ops, as} : {})\n            }\n          }\n        : {})\n    };\n  }\n\n  private facetSortFields(channel: FacetChannel): string[] {\n    const {facet} = this;\n    const fieldDef = facet[channel];\n\n    if (fieldDef) {\n      if (isSortField(fieldDef.sort)) {\n        return [facetSortFieldName(fieldDef, fieldDef.sort, {expr: 'datum'})];\n      } else if (isArray(fieldDef.sort)) {\n        return [sortArrayIndexField(fieldDef, channel, {expr: 'datum'})];\n      }\n      return [vgField(fieldDef, {expr: 'datum'})];\n    }\n    return [];\n  }\n\n  private facetSortOrder(channel: FacetChannel): SortOrder[] {\n    const {facet} = this;\n    const fieldDef = facet[channel];\n    if (fieldDef) {\n      const {sort} = fieldDef;\n      const order = (isSortField(sort) ? sort.order : !isArray(sort) && sort) || 'ascending';\n      return [order];\n    }\n    return [];\n  }\n\n  private assembleLabelTitle() {\n    const {facet, config} = this;\n    if (facet.facet) {\n      // Facet always uses title to display labels\n      return assembleLabelTitle(facet.facet, 'facet', config);\n    }\n\n    const ORTHOGONAL_ORIENT = {\n      row: ['top', 'bottom'],\n      column: ['left', 'right']\n    };\n\n    for (const channel of HEADER_CHANNELS) {\n      if (facet[channel]) {\n        const labelOrient = getHeaderProperty('labelOrient', facet[channel]?.header, config, channel);\n        if (ORTHOGONAL_ORIENT[channel].includes(labelOrient)) {\n          // Row/Column with orthogonal labelOrient must use title to display labels\n          return assembleLabelTitle(facet[channel], channel, config);\n        }\n      }\n    }\n    return undefined;\n  }\n\n  public assembleMarks(): VgMarkGroup[] {\n    const {child} = this;\n\n    // If we facet by two dimensions, we need to add a cross operator to the aggregation\n    // so that we create all groups\n    const facetRoot = this.component.data.facetRoot;\n    const data = assembleFacetData(facetRoot);\n\n    const encodeEntry = child.assembleGroupEncodeEntry(false);\n\n    const title = this.assembleLabelTitle() || child.assembleTitle();\n    const style = child.assembleGroupStyle();\n\n    const markGroup = {\n      name: this.getName('cell'),\n      type: 'group',\n      ...(title ? {title} : {}),\n      ...(style ? {style} : {}),\n      from: {\n        facet: this.assembleFacet()\n      },\n      // TODO: move this to after data\n      sort: {\n        field: FACET_CHANNELS.map(c => this.facetSortFields(c)).flat(),\n        order: FACET_CHANNELS.map(c => this.facetSortOrder(c)).flat()\n      },\n      ...(data.length > 0 ? {data} : {}),\n      ...(encodeEntry ? {encode: {update: encodeEntry}} : {}),\n      ...child.assembleGroup(assembleFacetSignals(this, []))\n    };\n\n    return [markGroup];\n  }\n\n  protected getMapping() {\n    return this.facet;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}