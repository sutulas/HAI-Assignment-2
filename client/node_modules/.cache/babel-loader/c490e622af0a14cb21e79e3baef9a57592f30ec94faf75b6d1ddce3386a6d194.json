{"ast":null,"code":"import { isScaleFieldDef, vgField } from '../../channeldef';\nimport { fieldFilterExpression } from '../../predicate';\nimport { isSortArray } from '../../sort';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nimport { getDependentFields } from './expressions';\nexport class CalculateNode extends DataFlowNode {\n  clone() {\n    return new CalculateNode(null, duplicate(this.transform));\n  }\n  constructor(parent, transform) {\n    super(parent);\n    this.transform = transform;\n    this._dependentFields = getDependentFields(this.transform.calculate);\n  }\n  static parseAllForSortIndex(parent, model) {\n    // get all the encoding with sort fields from model\n    model.forEachFieldDef((fieldDef, channel) => {\n      if (!isScaleFieldDef(fieldDef)) {\n        return;\n      }\n      if (isSortArray(fieldDef.sort)) {\n        const {\n          field,\n          timeUnit\n        } = fieldDef;\n        const sort = fieldDef.sort;\n        // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n        const calculate = sort.map((sortValue, i) => {\n          return `${fieldFilterExpression({\n            field,\n            timeUnit,\n            equal: sortValue\n          })} ? ${i} : `;\n        }).join('') + sort.length;\n        parent = new CalculateNode(parent, {\n          calculate,\n          as: sortArrayIndexField(fieldDef, channel, {\n            forAs: true\n          })\n        });\n      }\n    });\n    return parent;\n  }\n  producedFields() {\n    return new Set([this.transform.as]);\n  }\n  dependentFields() {\n    return this._dependentFields;\n  }\n  assemble() {\n    return {\n      type: 'formula',\n      expr: this.transform.calculate,\n      as: this.transform.as\n    };\n  }\n  hash() {\n    return `Calculate ${hash(this.transform)}`;\n  }\n}\nexport function sortArrayIndexField(fieldDef, channel, opt) {\n  return vgField(fieldDef, {\n    prefix: channel,\n    suffix: 'sort_index',\n    ...opt\n  });\n}","map":{"version":3,"names":["isScaleFieldDef","vgField","fieldFilterExpression","isSortArray","duplicate","hash","DataFlowNode","getDependentFields","CalculateNode","clone","transform","constructor","parent","_dependentFields","calculate","parseAllForSortIndex","model","forEachFieldDef","fieldDef","channel","sort","field","timeUnit","map","sortValue","i","equal","join","length","as","sortArrayIndexField","forAs","producedFields","Set","dependentFields","assemble","type","expr","opt","prefix","suffix"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\data\\calculate.ts"],"sourcesContent":["import {FormulaTransform as VgFormulaTransform} from 'vega';\nimport {SingleDefChannel} from '../../channel';\nimport {FieldRefOption, isScaleFieldDef, TypedFieldDef, vgField} from '../../channeldef';\nimport {DateTime} from '../../datetime';\nimport {fieldFilterExpression} from '../../predicate';\nimport {isSortArray} from '../../sort';\nimport {CalculateTransform} from '../../transform';\nimport {duplicate, hash} from '../../util';\nimport {ModelWithField} from '../model';\nimport {DataFlowNode} from './dataflow';\nimport {getDependentFields} from './expressions';\n\nexport class CalculateNode extends DataFlowNode {\n  private _dependentFields: Set<string>;\n\n  public clone() {\n    return new CalculateNode(null, duplicate(this.transform));\n  }\n\n  constructor(\n    parent: DataFlowNode,\n    private readonly transform: CalculateTransform\n  ) {\n    super(parent);\n\n    this._dependentFields = getDependentFields(this.transform.calculate);\n  }\n\n  public static parseAllForSortIndex(parent: DataFlowNode, model: ModelWithField) {\n    // get all the encoding with sort fields from model\n    model.forEachFieldDef((fieldDef: TypedFieldDef<string>, channel: SingleDefChannel) => {\n      if (!isScaleFieldDef(fieldDef)) {\n        return;\n      }\n      if (isSortArray(fieldDef.sort)) {\n        const {field, timeUnit} = fieldDef;\n        const sort: (number | string | boolean | DateTime)[] = fieldDef.sort;\n        // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n        const calculate =\n          sort\n            .map((sortValue, i) => {\n              return `${fieldFilterExpression({field, timeUnit, equal: sortValue})} ? ${i} : `;\n            })\n            .join('') + sort.length;\n\n        parent = new CalculateNode(parent, {\n          calculate,\n          as: sortArrayIndexField(fieldDef, channel, {forAs: true})\n        });\n      }\n    });\n    return parent;\n  }\n\n  public producedFields() {\n    return new Set([this.transform.as]);\n  }\n\n  public dependentFields() {\n    return this._dependentFields;\n  }\n\n  public assemble(): VgFormulaTransform {\n    return {\n      type: 'formula',\n      expr: this.transform.calculate,\n      as: this.transform.as\n    };\n  }\n\n  public hash() {\n    return `Calculate ${hash(this.transform)}`;\n  }\n}\n\nexport function sortArrayIndexField(fieldDef: TypedFieldDef<string>, channel: SingleDefChannel, opt?: FieldRefOption) {\n  return vgField(fieldDef, {prefix: channel, suffix: 'sort_index', ...opt});\n}\n"],"mappings":"AAEA,SAAwBA,eAAe,EAAiBC,OAAO,QAAO,kBAAkB;AAExF,SAAQC,qBAAqB,QAAO,iBAAiB;AACrD,SAAQC,WAAW,QAAO,YAAY;AAEtC,SAAQC,SAAS,EAAEC,IAAI,QAAO,YAAY;AAE1C,SAAQC,YAAY,QAAO,YAAY;AACvC,SAAQC,kBAAkB,QAAO,eAAe;AAEhD,OAAM,MAAOC,aAAc,SAAQF,YAAY;EAGtCG,KAAKA,CAAA;IACV,OAAO,IAAID,aAAa,CAAC,IAAI,EAAEJ,SAAS,CAAC,IAAI,CAACM,SAAS,CAAC,CAAC;EAC3D;EAEAC,YACEC,MAAoB,EACHF,SAA6B;IAE9C,KAAK,CAACE,MAAM,CAAC;IAFI,KAAAF,SAAS,GAATA,SAAS;IAI1B,IAAI,CAACG,gBAAgB,GAAGN,kBAAkB,CAAC,IAAI,CAACG,SAAS,CAACI,SAAS,CAAC;EACtE;EAEO,OAAOC,oBAAoBA,CAACH,MAAoB,EAAEI,KAAqB;IAC5E;IACAA,KAAK,CAACC,eAAe,CAAC,CAACC,QAA+B,EAAEC,OAAyB,KAAI;MACnF,IAAI,CAACnB,eAAe,CAACkB,QAAQ,CAAC,EAAE;QAC9B;MACF;MACA,IAAIf,WAAW,CAACe,QAAQ,CAACE,IAAI,CAAC,EAAE;QAC9B,MAAM;UAACC,KAAK;UAAEC;QAAQ,CAAC,GAAGJ,QAAQ;QAClC,MAAME,IAAI,GAA6CF,QAAQ,CAACE,IAAI;QACpE;QACA,MAAMN,SAAS,GACbM,IAAI,CACDG,GAAG,CAAC,CAACC,SAAS,EAAEC,CAAC,KAAI;UACpB,OAAO,GAAGvB,qBAAqB,CAAC;YAACmB,KAAK;YAAEC,QAAQ;YAAEI,KAAK,EAAEF;UAAS,CAAC,CAAC,MAAMC,CAAC,KAAK;QAClF,CAAC,CAAC,CACDE,IAAI,CAAC,EAAE,CAAC,GAAGP,IAAI,CAACQ,MAAM;QAE3BhB,MAAM,GAAG,IAAIJ,aAAa,CAACI,MAAM,EAAE;UACjCE,SAAS;UACTe,EAAE,EAAEC,mBAAmB,CAACZ,QAAQ,EAAEC,OAAO,EAAE;YAACY,KAAK,EAAE;UAAI,CAAC;SACzD,CAAC;MACJ;IACF,CAAC,CAAC;IACF,OAAOnB,MAAM;EACf;EAEOoB,cAAcA,CAAA;IACnB,OAAO,IAAIC,GAAG,CAAC,CAAC,IAAI,CAACvB,SAAS,CAACmB,EAAE,CAAC,CAAC;EACrC;EAEOK,eAAeA,CAAA;IACpB,OAAO,IAAI,CAACrB,gBAAgB;EAC9B;EAEOsB,QAAQA,CAAA;IACb,OAAO;MACLC,IAAI,EAAE,SAAS;MACfC,IAAI,EAAE,IAAI,CAAC3B,SAAS,CAACI,SAAS;MAC9Be,EAAE,EAAE,IAAI,CAACnB,SAAS,CAACmB;KACpB;EACH;EAEOxB,IAAIA,CAAA;IACT,OAAO,aAAaA,IAAI,CAAC,IAAI,CAACK,SAAS,CAAC,EAAE;EAC5C;;AAGF,OAAM,SAAUoB,mBAAmBA,CAACZ,QAA+B,EAAEC,OAAyB,EAAEmB,GAAoB;EAClH,OAAOrC,OAAO,CAACiB,QAAQ,EAAE;IAACqB,MAAM,EAAEpB,OAAO;IAAEqB,MAAM,EAAE,YAAY;IAAE,GAAGF;EAAG,CAAC,CAAC;AAC3E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}