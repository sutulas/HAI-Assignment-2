{"ast":null,"code":"import { isArray, isNumber, isObject } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { ANGLE, COLOR, FILL, FILLOPACITY, getOffsetScaleChannel, getSizeChannel, isXorY, isXorYOffset, OPACITY, RADIUS, SCALE_CHANNELS, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, THETA, X, XOFFSET, Y, YOFFSET } from '../../channel';\nimport { getBandPosition, getFieldOrDatumDef, isFieldDef, isFieldOrDatumDef } from '../../channeldef';\nimport { getViewConfigDiscreteSize, getViewConfigDiscreteStep } from '../../config';\nimport { DataSourceType } from '../../data';\nimport { channelHasFieldOrDatum } from '../../encoding';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, hasDiscreteDomain, isContinuousToDiscrete, isExtendedScheme, scaleTypeSupportProperty } from '../../scale';\nimport { getStepFor, isStep } from '../../spec/base';\nimport { isDiscrete } from '../../type';\nimport * as util from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { exprFromSignalRefOrValue, signalOrStringValue } from '../common';\nimport { getBinSignalName } from '../data/bin';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit } from '../split';\nimport { durationExpr } from '../../timeunit';\nimport { isFacetModel } from '../model';\nexport const RANGE_PROPERTIES = ['range', 'scheme'];\nexport function parseUnitScaleRange(model) {\n  const localScaleComponents = model.component.scales;\n  // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n  for (const channel of SCALE_CHANNELS) {\n    const localScaleCmpt = localScaleComponents[channel];\n    if (!localScaleCmpt) {\n      continue;\n    }\n    const rangeWithExplicit = parseRangeForChannel(channel, model);\n    localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n  }\n}\nfunction getBinStepSignal(model, channel) {\n  const fieldDef = model.fieldDef(channel);\n  if (fieldDef?.bin) {\n    const {\n      bin,\n      field\n    } = fieldDef;\n    const sizeType = getSizeChannel(channel);\n    const sizeSignal = model.getName(sizeType);\n    if (isObject(bin) && bin.binned && bin.step !== undefined) {\n      return new SignalRefWrapper(() => {\n        const scaleName = model.scaleName(channel);\n        const binCount = `(domain(\"${scaleName}\")[1] - domain(\"${scaleName}\")[0]) / ${bin.step}`;\n        return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n      });\n    } else if (isBinning(bin)) {\n      const binSignal = getBinSignalName(model, field, bin);\n      // TODO: extract this to be range step signal\n      return new SignalRefWrapper(() => {\n        const updatedName = model.getSignalName(binSignal);\n        const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;\n        return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n      });\n    }\n  }\n  return undefined;\n}\n/**\n * Return mixins that includes one of the Vega range types (explicit range, range.step, range.scheme).\n */\nexport function parseRangeForChannel(channel, model) {\n  const specifiedScale = model.specifiedScales[channel];\n  const {\n    size\n  } = model;\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type');\n  // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n  for (const property of RANGE_PROPERTIES) {\n    if (specifiedScale[property] !== undefined) {\n      const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      } else {\n        switch (property) {\n          case 'range':\n            {\n              const range = specifiedScale.range;\n              if (isArray(range)) {\n                if (isXorY(channel)) {\n                  return makeExplicit(range.map(v => {\n                    if (v === 'width' || v === 'height') {\n                      // get signal for width/height\n                      // Just like default range logic below, we use SignalRefWrapper to account for potential merges and renames.\n                      const sizeSignal = model.getName(v);\n                      const getSignalName = model.getSignalName.bind(model);\n                      return SignalRefWrapper.fromName(getSignalName, sizeSignal);\n                    }\n                    return v;\n                  }));\n                }\n              } else if (isObject(range)) {\n                return makeExplicit({\n                  data: model.requestDataName(DataSourceType.Main),\n                  field: range.field,\n                  sort: {\n                    op: 'min',\n                    field: model.vgField(channel)\n                  }\n                });\n              }\n              return makeExplicit(range);\n            }\n          case 'scheme':\n            return makeExplicit(parseScheme(specifiedScale[property]));\n        }\n      }\n    }\n  }\n  const sizeChannel = channel === X || channel === 'xOffset' ? 'width' : 'height';\n  const sizeValue = size[sizeChannel];\n  if (isStep(sizeValue)) {\n    if (isXorY(channel)) {\n      if (hasDiscreteDomain(scaleType)) {\n        const step = getPositionStep(sizeValue, model, channel);\n        // Need to be explicit so layer with step wins over layer without step\n        if (step) {\n          return makeExplicit({\n            step\n          });\n        }\n      } else {\n        log.warn(log.message.stepDropped(sizeChannel));\n      }\n    } else if (isXorYOffset(channel)) {\n      const positionChannel = channel === XOFFSET ? 'x' : 'y';\n      const positionScaleCmpt = model.getScaleComponent(positionChannel);\n      const positionScaleType = positionScaleCmpt.get('type');\n      if (positionScaleType === 'band') {\n        const step = getOffsetStep(sizeValue, scaleType);\n        if (step) {\n          return makeExplicit(step);\n        }\n      }\n    }\n  }\n  const {\n    rangeMin,\n    rangeMax\n  } = specifiedScale;\n  const d = defaultRange(channel, model);\n  if ((rangeMin !== undefined || rangeMax !== undefined) &&\n  // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same\n  scaleTypeSupportProperty(scaleType, 'rangeMin') && isArray(d) && d.length === 2) {\n    return makeExplicit([rangeMin ?? d[0], rangeMax ?? d[1]]);\n  }\n  return makeImplicit(d);\n}\nfunction parseScheme(scheme) {\n  if (isExtendedScheme(scheme)) {\n    return {\n      scheme: scheme.name,\n      ...util.omit(scheme, ['name'])\n    };\n  }\n  return {\n    scheme\n  };\n}\nfunction fullWidthOrHeightRange(channel, model, scaleType) {\n  let {\n    center\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  // If step is null, use zero to width or height.\n  // Note that we use SignalRefWrapper to account for potential merges and renames.\n  const sizeType = getSizeChannel(channel);\n  const sizeSignal = model.getName(sizeType);\n  const getSignalName = model.getSignalName.bind(model);\n  if (channel === Y && hasContinuousDomain(scaleType)) {\n    // For y continuous scale, we have to start from the height as the bottom part has the max value.\n    return center ? [SignalRefWrapper.fromName(name => `${getSignalName(name)}/2`, sizeSignal), SignalRefWrapper.fromName(name => `-${getSignalName(name)}/2`, sizeSignal)] : [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];\n  } else {\n    return center ? [SignalRefWrapper.fromName(name => `-${getSignalName(name)}/2`, sizeSignal), SignalRefWrapper.fromName(name => `${getSignalName(name)}/2`, sizeSignal)] : [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];\n  }\n}\nfunction defaultRange(channel, model) {\n  const {\n    size,\n    config,\n    mark,\n    encoding\n  } = model;\n  const {\n    type\n  } = getFieldOrDatumDef(encoding[channel]);\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type');\n  const {\n    domain,\n    domainMid\n  } = model.specifiedScales[channel];\n  switch (channel) {\n    case X:\n    case Y:\n      {\n        // If there is no explicit width/height for discrete x/y scales\n        if (util.contains(['point', 'band'], scaleType)) {\n          const positionSize = getDiscretePositionSize(channel, size, config.view);\n          if (isStep(positionSize)) {\n            const step = getPositionStep(positionSize, model, channel);\n            return {\n              step\n            };\n          }\n        }\n        return fullWidthOrHeightRange(channel, model, scaleType);\n      }\n    case XOFFSET:\n    case YOFFSET:\n      return getOffsetRange(channel, model, scaleType);\n    case SIZE:\n      {\n        // TODO: support custom rangeMin, rangeMax\n        const rangeMin = sizeRangeMin(mark, config);\n        const rangeMax = sizeRangeMax(mark, size, model, config);\n        if (isContinuousToDiscrete(scaleType)) {\n          return interpolateRange(rangeMin, rangeMax, defaultContinuousToDiscreteCount(scaleType, config, domain, channel));\n        } else {\n          return [rangeMin, rangeMax];\n        }\n      }\n    case THETA:\n      return [0, Math.PI * 2];\n    case ANGLE:\n      // TODO: add config.scale.min/maxAngleDegree (for point and text) and config.scale.min/maxAngleRadian (for arc) once we add arc marks.\n      // (It's weird to add just config.scale.min/maxAngleDegree for now)\n      return [0, 360];\n    case RADIUS:\n      {\n        // max radius = half od min(width,height)\n        return [0, new SignalRefWrapper(() => {\n          const w = model.getSignalName(isFacetModel(model.parent) ? 'child_width' : 'width');\n          const h = model.getSignalName(isFacetModel(model.parent) ? 'child_height' : 'height');\n          return `min(${w},${h})/2`;\n        })];\n      }\n    case STROKEWIDTH:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];\n    case STROKEDASH:\n      return [\n      // TODO: add this to Vega's config.range?\n      [1, 0], [4, 2], [2, 1], [1, 1], [1, 2, 4, 2]];\n    case SHAPE:\n      return 'symbol';\n    case COLOR:\n    case FILL:\n    case STROKE:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      } else {\n        if (domainMid !== undefined) {\n          return 'diverging';\n        } else {\n          return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n        }\n      }\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minOpacity, config.scale.maxOpacity];\n  }\n}\nfunction getPositionStep(step, model, channel) {\n  const {\n    encoding\n  } = model;\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const offsetChannel = getOffsetScaleChannel(channel);\n  const offsetDef = encoding[offsetChannel];\n  const stepFor = getStepFor({\n    step,\n    offsetIsDiscrete: isFieldOrDatumDef(offsetDef) && isDiscrete(offsetDef.type)\n  });\n  if (stepFor === 'offset' && channelHasFieldOrDatum(encoding, offsetChannel)) {\n    const offsetScaleCmpt = model.getScaleComponent(offsetChannel);\n    const offsetScaleName = model.scaleName(offsetChannel);\n    let stepCount = `domain('${offsetScaleName}').length`;\n    if (offsetScaleCmpt.get('type') === 'band') {\n      const offsetPaddingInner = offsetScaleCmpt.get('paddingInner') ?? offsetScaleCmpt.get('padding') ?? 0;\n      const offsetPaddingOuter = offsetScaleCmpt.get('paddingOuter') ?? offsetScaleCmpt.get('padding') ?? 0;\n      stepCount = `bandspace(${stepCount}, ${offsetPaddingInner}, ${offsetPaddingOuter})`;\n    }\n    const paddingInner = mergedScaleCmpt.get('paddingInner') ?? mergedScaleCmpt.get('padding');\n    return {\n      signal: `${step.step} * ${stepCount} / (1-${exprFromSignalRefOrValue(paddingInner)})`\n    };\n  } else {\n    return step.step;\n  }\n}\nfunction getOffsetStep(step, offsetScaleType) {\n  const stepFor = getStepFor({\n    step,\n    offsetIsDiscrete: hasDiscreteDomain(offsetScaleType)\n  });\n  if (stepFor === 'offset') {\n    return {\n      step: step.step\n    };\n  }\n  return undefined;\n}\nfunction getOffsetRange(channel, model, offsetScaleType) {\n  const positionChannel = channel === XOFFSET ? 'x' : 'y';\n  const positionScaleCmpt = model.getScaleComponent(positionChannel);\n  if (!positionScaleCmpt) {\n    return fullWidthOrHeightRange(positionChannel, model, offsetScaleType, {\n      center: true\n    });\n  }\n  const positionScaleType = positionScaleCmpt.get('type');\n  const positionScaleName = model.scaleName(positionChannel);\n  const {\n    markDef,\n    config\n  } = model;\n  if (positionScaleType === 'band') {\n    const size = getDiscretePositionSize(positionChannel, model.size, model.config.view);\n    if (isStep(size)) {\n      // step is for offset\n      const step = getOffsetStep(size, offsetScaleType);\n      if (step) {\n        return step;\n      }\n    }\n    // otherwise use the position\n    return [0, {\n      signal: `bandwidth('${positionScaleName}')`\n    }];\n  } else {\n    // continuous scale\n    const positionDef = model.encoding[positionChannel];\n    if (isFieldDef(positionDef) && positionDef.timeUnit) {\n      const duration = durationExpr(positionDef.timeUnit, expr => `scale('${positionScaleName}', ${expr})`);\n      const padding = model.config.scale.bandWithNestedOffsetPaddingInner;\n      const bandPositionOffset = getBandPosition({\n        fieldDef: positionDef,\n        markDef,\n        config\n      }) - 0.5;\n      const bandPositionOffsetExpr = bandPositionOffset !== 0 ? ` + ${bandPositionOffset}` : '';\n      if (padding) {\n        const startRatio = isSignalRef(padding) ? `${padding.signal}/2` + bandPositionOffsetExpr : `${padding / 2 + bandPositionOffset}`;\n        const endRatio = isSignalRef(padding) ? `(1 - ${padding.signal}/2)` + bandPositionOffsetExpr : `${1 - padding / 2 + bandPositionOffset}`;\n        return [{\n          signal: `${startRatio} * (${duration})`\n        }, {\n          signal: `${endRatio} * (${duration})`\n        }];\n      }\n      return [0, {\n        signal: duration\n      }];\n    }\n    return util.never(`Cannot use ${channel} scale if ${positionChannel} scale is not discrete.`);\n  }\n}\nfunction getDiscretePositionSize(channel, size, viewConfig) {\n  const sizeChannel = channel === X ? 'width' : 'height';\n  const sizeValue = size[sizeChannel];\n  if (sizeValue) {\n    return sizeValue;\n  }\n  return getViewConfigDiscreteSize(viewConfig, sizeChannel);\n}\nexport function defaultContinuousToDiscreteCount(scaleType, config, domain, channel) {\n  switch (scaleType) {\n    case 'quantile':\n      return config.scale.quantileCount;\n    case 'quantize':\n      return config.scale.quantizeCount;\n    case 'threshold':\n      if (domain !== undefined && isArray(domain)) {\n        return domain.length + 1;\n      } else {\n        log.warn(log.message.domainRequiredForThresholdScale(channel));\n        // default threshold boundaries for threshold scale since domain has cardinality of 2\n        return 3;\n      }\n  }\n}\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\nexport function interpolateRange(rangeMin, rangeMax, cardinality) {\n  // always return a signal since it's better to compute the sequence in Vega later\n  const f = () => {\n    const rMax = signalOrStringValue(rangeMax);\n    const rMin = signalOrStringValue(rangeMin);\n    const step = `(${rMax} - ${rMin}) / (${cardinality} - 1)`;\n    return `sequence(${rMin}, ${rMax} + ${step}, ${step})`;\n  };\n  if (isSignalRef(rangeMax)) {\n    return new SignalRefWrapper(f);\n  } else {\n    return {\n      signal: f()\n    };\n  }\n}\nfunction sizeRangeMin(mark, config) {\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      return config.scale.minBandSize;\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n    case 'text':\n      return config.scale.minFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      return config.scale.minSize;\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\nexport const MAX_SIZE_RANGE_STEP_RATIO = 0.95;\nfunction sizeRangeMax(mark, size, model, config) {\n  const xyStepSignals = {\n    x: getBinStepSignal(model, 'x'),\n    y: getBinStepSignal(model, 'y')\n  };\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      {\n        if (config.scale.maxBandSize !== undefined) {\n          return config.scale.maxBandSize;\n        }\n        const min = minXYStep(size, xyStepSignals, config.view);\n        if (isNumber(min)) {\n          return min - 1;\n        } else {\n          return new SignalRefWrapper(() => `${min.signal} - 1`);\n        }\n      }\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n    case 'text':\n      return config.scale.maxFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      {\n        if (config.scale.maxSize) {\n          return config.scale.maxSize;\n        }\n        const pointStep = minXYStep(size, xyStepSignals, config.view);\n        if (isNumber(pointStep)) {\n          return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);\n        } else {\n          return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);\n        }\n      }\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\nfunction minXYStep(size, xyStepSignals, viewConfig) {\n  const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, 'width');\n  const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, 'height');\n  if (xyStepSignals.x || xyStepSignals.y) {\n    return new SignalRefWrapper(() => {\n      const exprs = [xyStepSignals.x ? xyStepSignals.x.signal : widthStep, xyStepSignals.y ? xyStepSignals.y.signal : heightStep];\n      return `min(${exprs.join(', ')})`;\n    });\n  }\n  return Math.min(widthStep, heightStep);\n}","map":{"version":3,"names":["isArray","isNumber","isObject","isBinning","ANGLE","COLOR","FILL","FILLOPACITY","getOffsetScaleChannel","getSizeChannel","isXorY","isXorYOffset","OPACITY","RADIUS","SCALE_CHANNELS","SHAPE","SIZE","STROKE","STROKEDASH","STROKEOPACITY","STROKEWIDTH","THETA","X","XOFFSET","Y","YOFFSET","getBandPosition","getFieldOrDatumDef","isFieldDef","isFieldOrDatumDef","getViewConfigDiscreteSize","getViewConfigDiscreteStep","DataSourceType","channelHasFieldOrDatum","log","channelScalePropertyIncompatability","hasContinuousDomain","hasDiscreteDomain","isContinuousToDiscrete","isExtendedScheme","scaleTypeSupportProperty","getStepFor","isStep","isDiscrete","util","isSignalRef","exprFromSignalRefOrValue","signalOrStringValue","getBinSignalName","SignalRefWrapper","makeExplicit","makeImplicit","durationExpr","isFacetModel","RANGE_PROPERTIES","parseUnitScaleRange","model","localScaleComponents","component","scales","channel","localScaleCmpt","rangeWithExplicit","parseRangeForChannel","setWithExplicit","getBinStepSignal","fieldDef","bin","field","sizeType","sizeSignal","getName","binned","step","undefined","scaleName","binCount","getSignalName","binSignal","updatedName","specifiedScale","specifiedScales","size","mergedScaleCmpt","getScaleComponent","scaleType","get","property","supportedByScaleType","channelIncompatability","warn","message","scalePropertyNotWorkWithScaleType","range","map","v","bind","fromName","data","requestDataName","Main","sort","op","vgField","parseScheme","sizeChannel","sizeValue","getPositionStep","stepDropped","positionChannel","positionScaleCmpt","positionScaleType","getOffsetStep","rangeMin","rangeMax","d","defaultRange","length","scheme","name","omit","fullWidthOrHeightRange","center","arguments","config","mark","encoding","type","domain","domainMid","contains","positionSize","getDiscretePositionSize","view","getOffsetRange","sizeRangeMin","sizeRangeMax","interpolateRange","defaultContinuousToDiscreteCount","Math","PI","w","parent","h","scale","minStrokeWidth","maxStrokeWidth","minOpacity","maxOpacity","offsetChannel","offsetDef","stepFor","offsetIsDiscrete","offsetScaleCmpt","offsetScaleName","stepCount","offsetPaddingInner","offsetPaddingOuter","paddingInner","signal","offsetScaleType","positionScaleName","markDef","positionDef","timeUnit","duration","expr","padding","bandWithNestedOffsetPaddingInner","bandPositionOffset","bandPositionOffsetExpr","startRatio","endRatio","never","viewConfig","quantileCount","quantizeCount","domainRequiredForThresholdScale","cardinality","f","rMax","rMin","minBandSize","minFontSize","minSize","Error","incompatibleChannel","MAX_SIZE_RANGE_STEP_RATIO","xyStepSignals","x","y","maxBandSize","min","minXYStep","maxFontSize","maxSize","pointStep","pow","widthStep","width","heightStep","height","exprs","join"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\scale\\range.ts"],"sourcesContent":["import {RangeScheme, SignalRef} from 'vega';\nimport {isArray, isNumber, isObject} from 'vega-util';\nimport {isBinning} from '../../bin';\nimport {\n  ANGLE,\n  COLOR,\n  FILL,\n  FILLOPACITY,\n  getOffsetScaleChannel,\n  getSizeChannel,\n  isXorY,\n  isXorYOffset,\n  OPACITY,\n  PositionScaleChannel,\n  RADIUS,\n  ScaleChannel,\n  SCALE_CHANNELS,\n  SHAPE,\n  SIZE,\n  STROKE,\n  STROKEDASH,\n  STROKEOPACITY,\n  STROKEWIDTH,\n  THETA,\n  X,\n  XOFFSET,\n  Y,\n  YOFFSET\n} from '../../channel';\nimport {\n  getBandPosition,\n  getFieldOrDatumDef,\n  isFieldDef,\n  isFieldOrDatumDef,\n  ScaleDatumDef,\n  ScaleFieldDef\n} from '../../channeldef';\nimport {Config, getViewConfigDiscreteSize, getViewConfigDiscreteStep, ViewConfig} from '../../config';\nimport {DataSourceType} from '../../data';\nimport {channelHasFieldOrDatum} from '../../encoding';\nimport * as log from '../../log';\nimport {Mark} from '../../mark';\nimport {\n  channelScalePropertyIncompatability,\n  Domain,\n  hasContinuousDomain,\n  hasDiscreteDomain,\n  isContinuousToDiscrete,\n  isExtendedScheme,\n  Scale,\n  ScaleType,\n  scaleTypeSupportProperty,\n  Scheme\n} from '../../scale';\nimport {getStepFor, isStep, LayoutSizeMixins, Step} from '../../spec/base';\nimport {isDiscrete} from '../../type';\nimport * as util from '../../util';\nimport {isSignalRef, VgRange} from '../../vega.schema';\nimport {exprFromSignalRefOrValue, signalOrStringValue} from '../common';\nimport {getBinSignalName} from '../data/bin';\nimport {SignalRefWrapper} from '../signal';\nimport {Explicit, makeExplicit, makeImplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex} from './component';\nimport {durationExpr} from '../../timeunit';\nimport {isFacetModel} from '../model';\n\nexport const RANGE_PROPERTIES: (keyof Scale)[] = ['range', 'scheme'];\n\nexport function parseUnitScaleRange(model: UnitModel) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n  for (const channel of SCALE_CHANNELS) {\n    const localScaleCmpt = localScaleComponents[channel];\n    if (!localScaleCmpt) {\n      continue;\n    }\n\n    const rangeWithExplicit = parseRangeForChannel(channel, model);\n\n    localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n  }\n}\n\nfunction getBinStepSignal(model: UnitModel, channel: 'x' | 'y'): SignalRefWrapper {\n  const fieldDef = model.fieldDef(channel);\n\n  if (fieldDef?.bin) {\n    const {bin, field} = fieldDef;\n    const sizeType = getSizeChannel(channel);\n    const sizeSignal = model.getName(sizeType);\n\n    if (isObject(bin) && bin.binned && bin.step !== undefined) {\n      return new SignalRefWrapper(() => {\n        const scaleName = model.scaleName(channel);\n        const binCount = `(domain(\"${scaleName}\")[1] - domain(\"${scaleName}\")[0]) / ${bin.step}`;\n        return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n      });\n    } else if (isBinning(bin)) {\n      const binSignal = getBinSignalName(model, field, bin);\n\n      // TODO: extract this to be range step signal\n      return new SignalRefWrapper(() => {\n        const updatedName = model.getSignalName(binSignal);\n        const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;\n        return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n      });\n    }\n  }\n  return undefined;\n}\n\n/**\n * Return mixins that includes one of the Vega range types (explicit range, range.step, range.scheme).\n */\nexport function parseRangeForChannel(channel: ScaleChannel, model: UnitModel): Explicit<VgRange> {\n  const specifiedScale = model.specifiedScales[channel];\n  const {size} = model;\n\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type');\n\n  // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n  for (const property of RANGE_PROPERTIES) {\n    if (specifiedScale[property] !== undefined) {\n      const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      } else {\n        switch (property) {\n          case 'range': {\n            const range = specifiedScale.range;\n            if (isArray(range)) {\n              if (isXorY(channel)) {\n                return makeExplicit(\n                  range.map(v => {\n                    if (v === 'width' || v === 'height') {\n                      // get signal for width/height\n\n                      // Just like default range logic below, we use SignalRefWrapper to account for potential merges and renames.\n\n                      const sizeSignal = model.getName(v);\n                      const getSignalName = model.getSignalName.bind(model);\n                      return SignalRefWrapper.fromName(getSignalName, sizeSignal);\n                    }\n                    return v;\n                  })\n                );\n              }\n            } else if (isObject(range)) {\n              return makeExplicit({\n                data: model.requestDataName(DataSourceType.Main),\n                field: range.field,\n                sort: {op: 'min', field: model.vgField(channel)}\n              });\n            }\n\n            return makeExplicit(range);\n          }\n          case 'scheme':\n            return makeExplicit(parseScheme(specifiedScale[property]));\n        }\n      }\n    }\n  }\n\n  const sizeChannel = channel === X || channel === 'xOffset' ? 'width' : 'height';\n  const sizeValue = size[sizeChannel];\n  if (isStep(sizeValue)) {\n    if (isXorY(channel)) {\n      if (hasDiscreteDomain(scaleType)) {\n        const step = getPositionStep(sizeValue, model, channel);\n        // Need to be explicit so layer with step wins over layer without step\n        if (step) {\n          return makeExplicit({step});\n        }\n      } else {\n        log.warn(log.message.stepDropped(sizeChannel));\n      }\n    } else if (isXorYOffset(channel)) {\n      const positionChannel = channel === XOFFSET ? 'x' : 'y';\n      const positionScaleCmpt = model.getScaleComponent(positionChannel);\n      const positionScaleType = positionScaleCmpt.get('type');\n      if (positionScaleType === 'band') {\n        const step = getOffsetStep(sizeValue, scaleType);\n        if (step) {\n          return makeExplicit(step);\n        }\n      }\n    }\n  }\n\n  const {rangeMin, rangeMax} = specifiedScale;\n  const d = defaultRange(channel, model);\n\n  if (\n    (rangeMin !== undefined || rangeMax !== undefined) &&\n    // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same\n    scaleTypeSupportProperty(scaleType, 'rangeMin') &&\n    isArray(d) &&\n    d.length === 2\n  ) {\n    return makeExplicit([rangeMin ?? d[0], rangeMax ?? d[1]]);\n  }\n\n  return makeImplicit(d);\n}\n\nfunction parseScheme(scheme: Scheme | SignalRef): RangeScheme {\n  if (isExtendedScheme(scheme)) {\n    return {\n      scheme: scheme.name,\n      ...util.omit(scheme, ['name'])\n    };\n  }\n  return {scheme};\n}\n\nfunction fullWidthOrHeightRange(\n  channel: 'x' | 'y',\n  model: UnitModel,\n  scaleType: ScaleType,\n  {center}: {center?: boolean} = {}\n) {\n  // If step is null, use zero to width or height.\n  // Note that we use SignalRefWrapper to account for potential merges and renames.\n  const sizeType = getSizeChannel(channel);\n  const sizeSignal = model.getName(sizeType);\n  const getSignalName = model.getSignalName.bind(model);\n\n  if (channel === Y && hasContinuousDomain(scaleType)) {\n    // For y continuous scale, we have to start from the height as the bottom part has the max value.\n    return center\n      ? [\n          SignalRefWrapper.fromName(name => `${getSignalName(name)}/2`, sizeSignal),\n          SignalRefWrapper.fromName(name => `-${getSignalName(name)}/2`, sizeSignal)\n        ]\n      : [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];\n  } else {\n    return center\n      ? [\n          SignalRefWrapper.fromName(name => `-${getSignalName(name)}/2`, sizeSignal),\n          SignalRefWrapper.fromName(name => `${getSignalName(name)}/2`, sizeSignal)\n        ]\n      : [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];\n  }\n}\n\nfunction defaultRange(channel: ScaleChannel, model: UnitModel): VgRange {\n  const {size, config, mark, encoding} = model;\n\n  const {type} = getFieldOrDatumDef(encoding[channel]) as ScaleFieldDef<string> | ScaleDatumDef;\n\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const scaleType = mergedScaleCmpt.get('type');\n\n  const {domain, domainMid} = model.specifiedScales[channel];\n\n  switch (channel) {\n    case X:\n    case Y: {\n      // If there is no explicit width/height for discrete x/y scales\n      if (util.contains(['point', 'band'], scaleType)) {\n        const positionSize = getDiscretePositionSize(channel, size, config.view);\n        if (isStep(positionSize)) {\n          const step = getPositionStep(positionSize, model, channel);\n          return {step};\n        }\n      }\n\n      return fullWidthOrHeightRange(channel, model, scaleType);\n    }\n\n    case XOFFSET:\n    case YOFFSET:\n      return getOffsetRange(channel, model, scaleType);\n\n    case SIZE: {\n      // TODO: support custom rangeMin, rangeMax\n      const rangeMin = sizeRangeMin(mark, config);\n      const rangeMax = sizeRangeMax(mark, size, model, config);\n      if (isContinuousToDiscrete(scaleType)) {\n        return interpolateRange(\n          rangeMin,\n          rangeMax,\n          defaultContinuousToDiscreteCount(scaleType, config, domain, channel)\n        );\n      } else {\n        return [rangeMin, rangeMax];\n      }\n    }\n\n    case THETA:\n      return [0, Math.PI * 2];\n\n    case ANGLE:\n      // TODO: add config.scale.min/maxAngleDegree (for point and text) and config.scale.min/maxAngleRadian (for arc) once we add arc marks.\n      // (It's weird to add just config.scale.min/maxAngleDegree for now)\n      return [0, 360];\n\n    case RADIUS: {\n      // max radius = half od min(width,height)\n\n      return [\n        0,\n        new SignalRefWrapper(() => {\n          const w = model.getSignalName(isFacetModel(model.parent) ? 'child_width' : 'width');\n          const h = model.getSignalName(isFacetModel(model.parent) ? 'child_height' : 'height');\n          return `min(${w},${h})/2`;\n        })\n      ];\n    }\n\n    case STROKEWIDTH:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];\n    case STROKEDASH:\n      return [\n        // TODO: add this to Vega's config.range?\n        [1, 0],\n        [4, 2],\n        [2, 1],\n        [1, 1],\n        [1, 2, 4, 2]\n      ];\n    case SHAPE:\n      return 'symbol';\n    case COLOR:\n    case FILL:\n    case STROKE:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      } else {\n        if (domainMid !== undefined) {\n          return 'diverging';\n        } else {\n          return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n        }\n      }\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minOpacity, config.scale.maxOpacity];\n  }\n}\n\nfunction getPositionStep(step: Step, model: UnitModel, channel: PositionScaleChannel): number | SignalRef {\n  const {encoding} = model;\n\n  const mergedScaleCmpt = model.getScaleComponent(channel);\n  const offsetChannel = getOffsetScaleChannel(channel);\n  const offsetDef = encoding[offsetChannel];\n  const stepFor = getStepFor({step, offsetIsDiscrete: isFieldOrDatumDef(offsetDef) && isDiscrete(offsetDef.type)});\n\n  if (stepFor === 'offset' && channelHasFieldOrDatum(encoding, offsetChannel)) {\n    const offsetScaleCmpt = model.getScaleComponent(offsetChannel);\n    const offsetScaleName = model.scaleName(offsetChannel);\n\n    let stepCount = `domain('${offsetScaleName}').length`;\n\n    if (offsetScaleCmpt.get('type') === 'band') {\n      const offsetPaddingInner = offsetScaleCmpt.get('paddingInner') ?? offsetScaleCmpt.get('padding') ?? 0;\n      const offsetPaddingOuter = offsetScaleCmpt.get('paddingOuter') ?? offsetScaleCmpt.get('padding') ?? 0;\n      stepCount = `bandspace(${stepCount}, ${offsetPaddingInner}, ${offsetPaddingOuter})`;\n    }\n\n    const paddingInner = mergedScaleCmpt.get('paddingInner') ?? mergedScaleCmpt.get('padding');\n    return {\n      signal: `${step.step} * ${stepCount} / (1-${exprFromSignalRefOrValue(paddingInner)})`\n    };\n  } else {\n    return step.step;\n  }\n}\n\nfunction getOffsetStep(step: Step, offsetScaleType: ScaleType) {\n  const stepFor = getStepFor({step, offsetIsDiscrete: hasDiscreteDomain(offsetScaleType)});\n  if (stepFor === 'offset') {\n    return {step: step.step};\n  }\n  return undefined;\n}\n\nfunction getOffsetRange(channel: string, model: UnitModel, offsetScaleType: ScaleType): VgRange {\n  const positionChannel = channel === XOFFSET ? 'x' : 'y';\n  const positionScaleCmpt = model.getScaleComponent(positionChannel);\n\n  if (!positionScaleCmpt) {\n    return fullWidthOrHeightRange(positionChannel, model, offsetScaleType, {center: true});\n  }\n\n  const positionScaleType = positionScaleCmpt.get('type');\n  const positionScaleName = model.scaleName(positionChannel);\n\n  const {markDef, config} = model;\n\n  if (positionScaleType === 'band') {\n    const size = getDiscretePositionSize(positionChannel, model.size, model.config.view);\n\n    if (isStep(size)) {\n      // step is for offset\n      const step = getOffsetStep(size, offsetScaleType);\n      if (step) {\n        return step;\n      }\n    }\n    // otherwise use the position\n    return [0, {signal: `bandwidth('${positionScaleName}')`}];\n  } else {\n    // continuous scale\n    const positionDef = model.encoding[positionChannel];\n    if (isFieldDef(positionDef) && positionDef.timeUnit) {\n      const duration = durationExpr(positionDef.timeUnit, expr => `scale('${positionScaleName}', ${expr})`);\n      const padding = model.config.scale.bandWithNestedOffsetPaddingInner;\n      const bandPositionOffset =\n        getBandPosition({\n          fieldDef: positionDef,\n          markDef,\n          config\n        }) - 0.5;\n      const bandPositionOffsetExpr = bandPositionOffset !== 0 ? ` + ${bandPositionOffset}` : '';\n      if (padding) {\n        const startRatio = isSignalRef(padding)\n          ? `${padding.signal}/2` + bandPositionOffsetExpr\n          : `${padding / 2 + bandPositionOffset}`;\n        const endRatio = isSignalRef(padding)\n          ? `(1 - ${padding.signal}/2)` + bandPositionOffsetExpr\n          : `${1 - padding / 2 + bandPositionOffset}`;\n        return [{signal: `${startRatio} * (${duration})`}, {signal: `${endRatio} * (${duration})`}];\n      }\n      return [0, {signal: duration}];\n    }\n    return util.never(`Cannot use ${channel} scale if ${positionChannel} scale is not discrete.`);\n  }\n}\n\nfunction getDiscretePositionSize(\n  channel: 'x' | 'y',\n  size: LayoutSizeMixins,\n  viewConfig: ViewConfig<SignalRef>\n): Step | number | 'container' {\n  const sizeChannel = channel === X ? 'width' : 'height';\n  const sizeValue = size[sizeChannel];\n  if (sizeValue) {\n    return sizeValue;\n  }\n  return getViewConfigDiscreteSize(viewConfig, sizeChannel);\n}\n\nexport function defaultContinuousToDiscreteCount(\n  scaleType: 'quantile' | 'quantize' | 'threshold',\n  config: Config,\n  domain: Domain,\n  channel: ScaleChannel\n) {\n  switch (scaleType) {\n    case 'quantile':\n      return config.scale.quantileCount;\n    case 'quantize':\n      return config.scale.quantizeCount;\n    case 'threshold':\n      if (domain !== undefined && isArray(domain)) {\n        return domain.length + 1;\n      } else {\n        log.warn(log.message.domainRequiredForThresholdScale(channel));\n        // default threshold boundaries for threshold scale since domain has cardinality of 2\n        return 3;\n      }\n  }\n}\n\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\nexport function interpolateRange(\n  rangeMin: number | SignalRef,\n  rangeMax: number | SignalRef,\n  cardinality: number\n): SignalRef {\n  // always return a signal since it's better to compute the sequence in Vega later\n  const f = () => {\n    const rMax = signalOrStringValue(rangeMax);\n    const rMin = signalOrStringValue(rangeMin);\n    const step = `(${rMax} - ${rMin}) / (${cardinality} - 1)`;\n    return `sequence(${rMin}, ${rMax} + ${step}, ${step})`;\n  };\n  if (isSignalRef(rangeMax)) {\n    return new SignalRefWrapper(f);\n  } else {\n    return {signal: f()};\n  }\n}\n\nfunction sizeRangeMin(mark: Mark, config: Config): number | SignalRef {\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      return config.scale.minBandSize;\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n    case 'text':\n      return config.scale.minFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      return config.scale.minSize;\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\nexport const MAX_SIZE_RANGE_STEP_RATIO = 0.95;\n\nfunction sizeRangeMax(\n  mark: Mark,\n  size: LayoutSizeMixins,\n  model: UnitModel,\n  config: Config<SignalRef>\n): number | SignalRef {\n  const xyStepSignals = {\n    x: getBinStepSignal(model, 'x'),\n    y: getBinStepSignal(model, 'y')\n  };\n\n  switch (mark) {\n    case 'bar':\n    case 'tick': {\n      if (config.scale.maxBandSize !== undefined) {\n        return config.scale.maxBandSize;\n      }\n      const min = minXYStep(size, xyStepSignals, config.view);\n\n      if (isNumber(min)) {\n        return min - 1;\n      } else {\n        return new SignalRefWrapper(() => `${min.signal} - 1`);\n      }\n    }\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n    case 'text':\n      return config.scale.maxFontSize;\n    case 'point':\n    case 'square':\n    case 'circle': {\n      if (config.scale.maxSize) {\n        return config.scale.maxSize;\n      }\n\n      const pointStep = minXYStep(size, xyStepSignals, config.view);\n      if (isNumber(pointStep)) {\n        return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);\n      } else {\n        return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);\n      }\n    }\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\nfunction minXYStep(\n  size: LayoutSizeMixins,\n  xyStepSignals: {x?: SignalRefWrapper; y?: SignalRefWrapper},\n  viewConfig: ViewConfig<SignalRef>\n): number | SignalRef {\n  const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, 'width');\n  const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, 'height');\n\n  if (xyStepSignals.x || xyStepSignals.y) {\n    return new SignalRefWrapper(() => {\n      const exprs = [\n        xyStepSignals.x ? xyStepSignals.x.signal : widthStep,\n        xyStepSignals.y ? xyStepSignals.y.signal : heightStep\n      ];\n      return `min(${exprs.join(', ')})`;\n    });\n  }\n\n  return Math.min(widthStep, heightStep);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}