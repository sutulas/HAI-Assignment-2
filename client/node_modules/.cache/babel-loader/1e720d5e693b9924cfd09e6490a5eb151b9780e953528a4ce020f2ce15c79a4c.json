{"ast":null,"code":"import { isPathMark } from '../../mark';\nimport { hasContinuousDomain } from '../../scale';\nimport { getMarkPropOrConfig } from '../common';\nimport { normalizeInvalidDataMode } from './normalizeInvalidDataMode';\nexport function getScaleInvalidDataMode(_ref) {\n  let {\n    markDef,\n    config,\n    scaleChannel,\n    scaleType,\n    isCountAggregate\n  } = _ref;\n  if (!scaleType || !hasContinuousDomain(scaleType) || isCountAggregate) {\n    // - Discrete scales can always display null as another category\n    // - Count cannot output null values\n    return 'always-valid';\n  }\n  const invalidMode = normalizeInvalidDataMode(getMarkPropOrConfig('invalid', markDef, config), {\n    isPath: isPathMark(markDef.type)\n  });\n  const scaleOutputForInvalid = config.scale?.invalid?.[scaleChannel];\n  if (scaleOutputForInvalid !== undefined) {\n    // Regardless of the current invalid mode, if the channel has a default value, we consider the field valid.\n    return 'show';\n  }\n  return invalidMode;\n}\nexport function shouldBreakPath(mode) {\n  return mode === 'break-paths-filter-domains' || mode === 'break-paths-show-domains';\n}","map":{"version":3,"names":["isPathMark","hasContinuousDomain","getMarkPropOrConfig","normalizeInvalidDataMode","getScaleInvalidDataMode","_ref","markDef","config","scaleChannel","scaleType","isCountAggregate","invalidMode","isPath","type","scaleOutputForInvalid","scale","invalid","undefined","shouldBreakPath","mode"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\invalid\\ScaleInvalidDataMode.ts"],"sourcesContent":["import {SignalRef} from 'vega';\nimport {ScaleChannel} from '../../channel';\nimport {Config} from '../../config';\nimport {MarkInvalidDataMode} from '../../invalid';\nimport {MarkDef, isPathMark} from '../../mark';\nimport {ScaleType, hasContinuousDomain} from '../../scale';\nimport {getMarkPropOrConfig} from '../common';\nimport {normalizeInvalidDataMode} from './normalizeInvalidDataMode';\n\nexport type ScaleInvalidDataMode =\n  // remove 'break-paths-show-path-domains' from MarkInvalidDataMode\n  // because it is a macro for '\"filter\"' or `\"break-path-keep-domains`\n  | Omit<MarkInvalidDataMode, 'break-paths-show-path-domains'>\n\n  // Add always-valid because at scale level, categorical scales can handle any values and thus is always valid.\n  | 'always-valid';\n\nexport function getScaleInvalidDataMode<C extends ScaleChannel>({\n  markDef,\n  config,\n  scaleChannel,\n  scaleType,\n  isCountAggregate\n}: {\n  markDef: MarkDef;\n  config: Config<SignalRef>;\n  scaleChannel: C;\n  scaleType: ScaleType;\n  isCountAggregate: boolean;\n}): ScaleInvalidDataMode {\n  if (!scaleType || !hasContinuousDomain(scaleType) || isCountAggregate) {\n    // - Discrete scales can always display null as another category\n    // - Count cannot output null values\n    return 'always-valid';\n  }\n\n  const invalidMode = normalizeInvalidDataMode(getMarkPropOrConfig('invalid', markDef, config), {\n    isPath: isPathMark(markDef.type)\n  });\n\n  const scaleOutputForInvalid = config.scale?.invalid?.[scaleChannel];\n  if (scaleOutputForInvalid !== undefined) {\n    // Regardless of the current invalid mode, if the channel has a default value, we consider the field valid.\n    return 'show';\n  }\n\n  return invalidMode;\n}\nexport function shouldBreakPath(mode: ScaleInvalidDataMode): boolean {\n  return mode === 'break-paths-filter-domains' || mode === 'break-paths-show-domains';\n}\n"],"mappings":"AAIA,SAAiBA,UAAU,QAAO,YAAY;AAC9C,SAAmBC,mBAAmB,QAAO,aAAa;AAC1D,SAAQC,mBAAmB,QAAO,WAAW;AAC7C,SAAQC,wBAAwB,QAAO,4BAA4B;AAUnE,OAAM,SAAUC,uBAAuBA,CAAAC,IAAA,EAYtC;EAAA,IAZ+D;IAC9DC,OAAO;IACPC,MAAM;IACNC,YAAY;IACZC,SAAS;IACTC;EAAgB,CAOjB,GAAAL,IAAA;EACC,IAAI,CAACI,SAAS,IAAI,CAACR,mBAAmB,CAACQ,SAAS,CAAC,IAAIC,gBAAgB,EAAE;IACrE;IACA;IACA,OAAO,cAAc;EACvB;EAEA,MAAMC,WAAW,GAAGR,wBAAwB,CAACD,mBAAmB,CAAC,SAAS,EAAEI,OAAO,EAAEC,MAAM,CAAC,EAAE;IAC5FK,MAAM,EAAEZ,UAAU,CAACM,OAAO,CAACO,IAAI;GAChC,CAAC;EAEF,MAAMC,qBAAqB,GAAGP,MAAM,CAACQ,KAAK,EAAEC,OAAO,GAAGR,YAAY,CAAC;EACnE,IAAIM,qBAAqB,KAAKG,SAAS,EAAE;IACvC;IACA,OAAO,MAAM;EACf;EAEA,OAAON,WAAW;AACpB;AACA,OAAM,SAAUO,eAAeA,CAACC,IAA0B;EACxD,OAAOA,IAAI,KAAK,4BAA4B,IAAIA,IAAI,KAAK,0BAA0B;AACrF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}