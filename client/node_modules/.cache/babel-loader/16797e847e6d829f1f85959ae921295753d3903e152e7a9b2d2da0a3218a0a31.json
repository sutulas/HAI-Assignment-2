{"ast":null,"code":"import { isString } from 'vega-util';\nimport { initConfig } from '../config';\nimport * as log from '../log';\nimport { isLayerSpec, isUnitSpec } from '../spec';\nimport { deepEqual } from '../util';\nimport { CoreNormalizer } from './core';\nimport { SelectionCompatibilityNormalizer } from './selectioncompat';\nimport { TopLevelSelectionsNormalizer } from './toplevelselection';\nexport function normalize(spec, config) {\n  if (config === undefined) {\n    config = initConfig(spec.config);\n  }\n  const normalizedSpec = normalizeGenericSpec(spec, config);\n  const {\n    width,\n    height\n  } = spec;\n  const autosize = normalizeAutoSize(normalizedSpec, {\n    width,\n    height,\n    autosize: spec.autosize\n  }, config);\n  return {\n    ...normalizedSpec,\n    ...(autosize ? {\n      autosize\n    } : {})\n  };\n}\nconst coreNormalizer = new CoreNormalizer();\nconst selectionCompatNormalizer = new SelectionCompatibilityNormalizer();\nconst topLevelSelectionNormalizer = new TopLevelSelectionsNormalizer();\n/**\n * Decompose extended unit specs into composition of pure unit specs.\n * And push top-level selection definitions down to unit specs.\n */\nfunction normalizeGenericSpec(spec) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const normParams = {\n    config\n  };\n  return topLevelSelectionNormalizer.map(coreNormalizer.map(selectionCompatNormalizer.map(spec, normParams), normParams), normParams);\n}\nfunction _normalizeAutoSize(autosize) {\n  return isString(autosize) ? {\n    type: autosize\n  } : autosize ?? {};\n}\n/**\n * Normalize autosize and deal with width or height == \"container\".\n */\nexport function normalizeAutoSize(spec, sizeInfo, config) {\n  let {\n    width,\n    height\n  } = sizeInfo;\n  const isFitCompatible = isUnitSpec(spec) || isLayerSpec(spec);\n  const autosizeDefault = {};\n  if (!isFitCompatible) {\n    // If spec is not compatible with autosize == \"fit\", discard width/height == container\n    if (width == 'container') {\n      log.warn(log.message.containerSizeNonSingle('width'));\n      width = undefined;\n    }\n    if (height == 'container') {\n      log.warn(log.message.containerSizeNonSingle('height'));\n      height = undefined;\n    }\n  } else {\n    // Default autosize parameters to fit when width/height is \"container\"\n    if (width == 'container' && height == 'container') {\n      autosizeDefault.type = 'fit';\n      autosizeDefault.contains = 'padding';\n    } else if (width == 'container') {\n      autosizeDefault.type = 'fit-x';\n      autosizeDefault.contains = 'padding';\n    } else if (height == 'container') {\n      autosizeDefault.type = 'fit-y';\n      autosizeDefault.contains = 'padding';\n    }\n  }\n  const autosize = {\n    type: 'pad',\n    ...autosizeDefault,\n    ...(config ? _normalizeAutoSize(config.autosize) : {}),\n    ..._normalizeAutoSize(spec.autosize)\n  };\n  if (autosize.type === 'fit' && !isFitCompatible) {\n    log.warn(log.message.FIT_NON_SINGLE);\n    autosize.type = 'pad';\n  }\n  if (width == 'container' && !(autosize.type == 'fit' || autosize.type == 'fit-x')) {\n    log.warn(log.message.containerSizeNotCompatibleWithAutosize('width'));\n  }\n  if (height == 'container' && !(autosize.type == 'fit' || autosize.type == 'fit-y')) {\n    log.warn(log.message.containerSizeNotCompatibleWithAutosize('height'));\n  }\n  // Delete autosize property if it's Vega's default\n  if (deepEqual(autosize, {\n    type: 'pad'\n  })) {\n    return undefined;\n  }\n  return autosize;\n}","map":{"version":3,"names":["isString","initConfig","log","isLayerSpec","isUnitSpec","deepEqual","CoreNormalizer","SelectionCompatibilityNormalizer","TopLevelSelectionsNormalizer","normalize","spec","config","undefined","normalizedSpec","normalizeGenericSpec","width","height","autosize","normalizeAutoSize","coreNormalizer","selectionCompatNormalizer","topLevelSelectionNormalizer","arguments","length","normParams","map","_normalizeAutoSize","type","sizeInfo","isFitCompatible","autosizeDefault","warn","message","containerSizeNonSingle","contains","FIT_NON_SINGLE","containerSizeNotCompatibleWithAutosize"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\normalize\\index.ts"],"sourcesContent":["import type {SignalRef} from 'vega';\nimport {isString} from 'vega-util';\nimport {Field} from '../channeldef';\nimport {Config, initConfig} from '../config';\nimport * as log from '../log';\nimport {\n  FacetedUnitSpec,\n  isLayerSpec,\n  isUnitSpec,\n  LayoutSizeMixins,\n  NonNormalizedSpec,\n  NormalizedSpec,\n  RepeatSpec,\n  TopLevelSpec\n} from '../spec';\nimport {AutoSizeParams, AutosizeType, TopLevel} from '../spec/toplevel';\nimport {deepEqual} from '../util';\nimport {NormalizerParams} from './base';\nimport {CoreNormalizer} from './core';\nimport {SelectionCompatibilityNormalizer} from './selectioncompat';\nimport {TopLevelSelectionsNormalizer} from './toplevelselection';\n\nexport function normalize(\n  spec: TopLevelSpec & LayoutSizeMixins,\n  config?: Config<SignalRef>\n): TopLevel<NormalizedSpec> & LayoutSizeMixins {\n  if (config === undefined) {\n    config = initConfig(spec.config);\n  }\n\n  const normalizedSpec = normalizeGenericSpec(spec, config);\n\n  const {width, height} = spec;\n  const autosize = normalizeAutoSize(normalizedSpec, {width, height, autosize: spec.autosize}, config);\n\n  return {\n    ...normalizedSpec,\n    ...(autosize ? {autosize} : {})\n  };\n}\n\nconst coreNormalizer = new CoreNormalizer();\nconst selectionCompatNormalizer = new SelectionCompatibilityNormalizer();\nconst topLevelSelectionNormalizer = new TopLevelSelectionsNormalizer();\n\n/**\n * Decompose extended unit specs into composition of pure unit specs.\n * And push top-level selection definitions down to unit specs.\n */\nfunction normalizeGenericSpec(\n  spec: NonNormalizedSpec | FacetedUnitSpec<Field, any> | RepeatSpec,\n  config: Config<SignalRef> = {}\n) {\n  const normParams = {config};\n  return topLevelSelectionNormalizer.map(\n    coreNormalizer.map(selectionCompatNormalizer.map(spec, normParams), normParams),\n    normParams\n  );\n}\n\nfunction _normalizeAutoSize(autosize: AutosizeType | AutoSizeParams) {\n  return isString(autosize) ? {type: autosize} : (autosize ?? {});\n}\n\n/**\n * Normalize autosize and deal with width or height == \"container\".\n */\nexport function normalizeAutoSize(\n  spec: TopLevel<NormalizedSpec>,\n  sizeInfo: {autosize: AutosizeType | AutoSizeParams} & LayoutSizeMixins,\n  config?: Config\n) {\n  let {width, height} = sizeInfo;\n\n  const isFitCompatible = isUnitSpec(spec) || isLayerSpec(spec);\n  const autosizeDefault: AutoSizeParams = {};\n\n  if (!isFitCompatible) {\n    // If spec is not compatible with autosize == \"fit\", discard width/height == container\n    if (width == 'container') {\n      log.warn(log.message.containerSizeNonSingle('width'));\n      width = undefined;\n    }\n    if (height == 'container') {\n      log.warn(log.message.containerSizeNonSingle('height'));\n      height = undefined;\n    }\n  } else {\n    // Default autosize parameters to fit when width/height is \"container\"\n    if (width == 'container' && height == 'container') {\n      autosizeDefault.type = 'fit';\n      autosizeDefault.contains = 'padding';\n    } else if (width == 'container') {\n      autosizeDefault.type = 'fit-x';\n      autosizeDefault.contains = 'padding';\n    } else if (height == 'container') {\n      autosizeDefault.type = 'fit-y';\n      autosizeDefault.contains = 'padding';\n    }\n  }\n\n  const autosize: AutoSizeParams = {\n    type: 'pad',\n    ...autosizeDefault,\n    ...(config ? _normalizeAutoSize(config.autosize) : {}),\n    ..._normalizeAutoSize(spec.autosize)\n  };\n\n  if (autosize.type === 'fit' && !isFitCompatible) {\n    log.warn(log.message.FIT_NON_SINGLE);\n    autosize.type = 'pad';\n  }\n\n  if (width == 'container' && !(autosize.type == 'fit' || autosize.type == 'fit-x')) {\n    log.warn(log.message.containerSizeNotCompatibleWithAutosize('width'));\n  }\n  if (height == 'container' && !(autosize.type == 'fit' || autosize.type == 'fit-y')) {\n    log.warn(log.message.containerSizeNotCompatibleWithAutosize('height'));\n  }\n\n  // Delete autosize property if it's Vega's default\n  if (deepEqual(autosize, {type: 'pad'})) {\n    return undefined;\n  }\n\n  return autosize;\n}\n\nexport type {NormalizerParams};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}