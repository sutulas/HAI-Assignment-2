{"ast":null,"code":"import { hasProperty } from './util';\nexport function isLogicalOr(op) {\n  return hasProperty(op, 'or');\n}\nexport function isLogicalAnd(op) {\n  return hasProperty(op, 'and');\n}\nexport function isLogicalNot(op) {\n  return hasProperty(op, 'not');\n}\nexport function forEachLeaf(op, fn) {\n  if (isLogicalNot(op)) {\n    forEachLeaf(op.not, fn);\n  } else if (isLogicalAnd(op)) {\n    for (const subop of op.and) {\n      forEachLeaf(subop, fn);\n    }\n  } else if (isLogicalOr(op)) {\n    for (const subop of op.or) {\n      forEachLeaf(subop, fn);\n    }\n  } else {\n    fn(op);\n  }\n}\nexport function normalizeLogicalComposition(op, normalizer) {\n  if (isLogicalNot(op)) {\n    return {\n      not: normalizeLogicalComposition(op.not, normalizer)\n    };\n  } else if (isLogicalAnd(op)) {\n    return {\n      and: op.and.map(o => normalizeLogicalComposition(o, normalizer))\n    };\n  } else if (isLogicalOr(op)) {\n    return {\n      or: op.or.map(o => normalizeLogicalComposition(o, normalizer))\n    };\n  } else {\n    return normalizer(op);\n  }\n}","map":{"version":3,"names":["hasProperty","isLogicalOr","op","isLogicalAnd","isLogicalNot","forEachLeaf","fn","not","subop","and","or","normalizeLogicalComposition","normalizer","map","o"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\logical.ts"],"sourcesContent":["import {hasProperty} from './util';\n\nexport type LogicalComposition<T> = LogicalNot<T> | LogicalAnd<T> | LogicalOr<T> | T;\n\nexport interface LogicalOr<T> {\n  or: LogicalComposition<T>[];\n}\n\nexport interface LogicalAnd<T> {\n  and: LogicalComposition<T>[];\n}\n\nexport interface LogicalNot<T> {\n  not: LogicalComposition<T>;\n}\n\nexport function isLogicalOr(op: LogicalComposition<any>): op is LogicalOr<any> {\n  return hasProperty(op, 'or');\n}\n\nexport function isLogicalAnd(op: LogicalComposition<any>): op is LogicalAnd<any> {\n  return hasProperty(op, 'and');\n}\n\nexport function isLogicalNot(op: LogicalComposition<any>): op is LogicalNot<any> {\n  return hasProperty(op, 'not');\n}\n\nexport function forEachLeaf<T>(op: LogicalComposition<T>, fn: (op: T) => void) {\n  if (isLogicalNot(op)) {\n    forEachLeaf(op.not, fn);\n  } else if (isLogicalAnd(op)) {\n    for (const subop of op.and) {\n      forEachLeaf(subop, fn);\n    }\n  } else if (isLogicalOr(op)) {\n    for (const subop of op.or) {\n      forEachLeaf(subop, fn);\n    }\n  } else {\n    fn(op);\n  }\n}\n\nexport function normalizeLogicalComposition<T>(\n  op: LogicalComposition<T>,\n  normalizer: (o: T) => T\n): LogicalComposition<T> {\n  if (isLogicalNot(op)) {\n    return {not: normalizeLogicalComposition(op.not, normalizer)};\n  } else if (isLogicalAnd(op)) {\n    return {and: op.and.map(o => normalizeLogicalComposition(o, normalizer))};\n  } else if (isLogicalOr(op)) {\n    return {or: op.or.map(o => normalizeLogicalComposition(o, normalizer))};\n  } else {\n    return normalizer(op);\n  }\n}\n"],"mappings":"AAAA,SAAQA,WAAW,QAAO,QAAQ;AAgBlC,OAAM,SAAUC,WAAWA,CAACC,EAA2B;EACrD,OAAOF,WAAW,CAACE,EAAE,EAAE,IAAI,CAAC;AAC9B;AAEA,OAAM,SAAUC,YAAYA,CAACD,EAA2B;EACtD,OAAOF,WAAW,CAACE,EAAE,EAAE,KAAK,CAAC;AAC/B;AAEA,OAAM,SAAUE,YAAYA,CAACF,EAA2B;EACtD,OAAOF,WAAW,CAACE,EAAE,EAAE,KAAK,CAAC;AAC/B;AAEA,OAAM,SAAUG,WAAWA,CAAIH,EAAyB,EAAEI,EAAmB;EAC3E,IAAIF,YAAY,CAACF,EAAE,CAAC,EAAE;IACpBG,WAAW,CAACH,EAAE,CAACK,GAAG,EAAED,EAAE,CAAC;EACzB,CAAC,MAAM,IAAIH,YAAY,CAACD,EAAE,CAAC,EAAE;IAC3B,KAAK,MAAMM,KAAK,IAAIN,EAAE,CAACO,GAAG,EAAE;MAC1BJ,WAAW,CAACG,KAAK,EAAEF,EAAE,CAAC;IACxB;EACF,CAAC,MAAM,IAAIL,WAAW,CAACC,EAAE,CAAC,EAAE;IAC1B,KAAK,MAAMM,KAAK,IAAIN,EAAE,CAACQ,EAAE,EAAE;MACzBL,WAAW,CAACG,KAAK,EAAEF,EAAE,CAAC;IACxB;EACF,CAAC,MAAM;IACLA,EAAE,CAACJ,EAAE,CAAC;EACR;AACF;AAEA,OAAM,SAAUS,2BAA2BA,CACzCT,EAAyB,EACzBU,UAAuB;EAEvB,IAAIR,YAAY,CAACF,EAAE,CAAC,EAAE;IACpB,OAAO;MAACK,GAAG,EAAEI,2BAA2B,CAACT,EAAE,CAACK,GAAG,EAAEK,UAAU;IAAC,CAAC;EAC/D,CAAC,MAAM,IAAIT,YAAY,CAACD,EAAE,CAAC,EAAE;IAC3B,OAAO;MAACO,GAAG,EAAEP,EAAE,CAACO,GAAG,CAACI,GAAG,CAACC,CAAC,IAAIH,2BAA2B,CAACG,CAAC,EAAEF,UAAU,CAAC;IAAC,CAAC;EAC3E,CAAC,MAAM,IAAIX,WAAW,CAACC,EAAE,CAAC,EAAE;IAC1B,OAAO;MAACQ,EAAE,EAAER,EAAE,CAACQ,EAAE,CAACG,GAAG,CAACC,CAAC,IAAIH,2BAA2B,CAACG,CAAC,EAAEF,UAAU,CAAC;IAAC,CAAC;EACzE,CAAC,MAAM;IACL,OAAOA,UAAU,CAACV,EAAE,CAAC;EACvB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}