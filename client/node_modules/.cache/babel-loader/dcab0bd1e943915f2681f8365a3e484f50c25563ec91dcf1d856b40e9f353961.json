{"ast":null,"code":"import { isObject } from 'vega-util';\nimport { normalizeEncoding } from '../encoding';\nimport { isMarkDef } from '../mark';\nimport { isUnitSpec } from '../spec/unit';\nimport { stack } from '../stack';\nimport { keys, omit, pick } from '../util';\nimport { initMarkdef } from '../compile/mark/init';\nfunction dropLineAndPoint(markDef) {\n  const {\n    point: _point,\n    line: _line,\n    ...mark\n  } = markDef;\n  return keys(mark).length > 1 ? mark : mark.type;\n}\nfunction dropLineAndPointFromConfig(config) {\n  for (const mark of ['line', 'area', 'rule', 'trail']) {\n    if (config[mark]) {\n      config = {\n        ...config,\n        // TODO: remove as any\n        [mark]: omit(config[mark], ['point', 'line'])\n      };\n    }\n  }\n  return config;\n}\nfunction getPointOverlay(markDef) {\n  let markConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let encoding = arguments.length > 2 ? arguments[2] : undefined;\n  if (markDef.point === 'transparent') {\n    return {\n      opacity: 0\n    };\n  } else if (markDef.point) {\n    // truthy : true or object\n    return isObject(markDef.point) ? markDef.point : {};\n  } else if (markDef.point !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.point || encoding.shape) {\n      // enable point overlay if config[mark].point is truthy or if encoding.shape is provided\n      return isObject(markConfig.point) ? markConfig.point : {};\n    }\n    // markDef.point is defined as falsy\n    return undefined;\n  }\n}\nfunction getLineOverlay(markDef) {\n  let markConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (markDef.line) {\n    // true or object\n    return markDef.line === true ? {} : markDef.line;\n  } else if (markDef.line !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.line) {\n      // enable line overlay if config[mark].line is truthy\n      return markConfig.line === true ? {} : markConfig.line;\n    }\n    // markDef.point is defined as falsy\n    return undefined;\n  }\n}\nexport class PathOverlayNormalizer {\n  constructor() {\n    this.name = 'path-overlay';\n  }\n  hasMatchingType(spec, config) {\n    if (isUnitSpec(spec)) {\n      const {\n        mark,\n        encoding\n      } = spec;\n      const markDef = isMarkDef(mark) ? mark : {\n        type: mark\n      };\n      switch (markDef.type) {\n        case 'line':\n        case 'rule':\n        case 'trail':\n          return !!getPointOverlay(markDef, config[markDef.type], encoding);\n        case 'area':\n          return (\n            // false / null are also included as we want to remove the properties\n            !!getPointOverlay(markDef, config[markDef.type], encoding) || !!getLineOverlay(markDef, config[markDef.type])\n          );\n      }\n    }\n    return false;\n  }\n  run(spec, normParams, normalize) {\n    const {\n      config\n    } = normParams;\n    const {\n      params,\n      projection,\n      mark,\n      name,\n      encoding: e,\n      ...outerSpec\n    } = spec;\n    // Need to call normalizeEncoding because we need the inferred types to correctly determine stack\n    const encoding = normalizeEncoding(e, config);\n    const markDef = isMarkDef(mark) ? mark : {\n      type: mark\n    };\n    const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);\n    const lineOverlay = markDef.type === 'area' && getLineOverlay(markDef, config[markDef.type]);\n    const layer = [{\n      name,\n      ...(params ? {\n        params\n      } : {}),\n      mark: dropLineAndPoint({\n        // TODO: extract this 0.7 to be shared with default opacity for point/tick/...\n        ...(markDef.type === 'area' && markDef.opacity === undefined && markDef.fillOpacity === undefined ? {\n          opacity: 0.7\n        } : {}),\n        ...markDef\n      }),\n      // drop shape from encoding as this might be used to trigger point overlay\n      encoding: omit(encoding, ['shape'])\n    }];\n    // FIXME: determine rules for applying selections.\n    // Need to copy stack config to overlayed layer\n    // FIXME: normalizer shouldn't call `initMarkdef`, a method from an init phase.\n    const stackProps = stack(initMarkdef(markDef, encoding, config), encoding);\n    let overlayEncoding = encoding;\n    if (stackProps) {\n      const {\n        fieldChannel: stackFieldChannel,\n        offset\n      } = stackProps;\n      overlayEncoding = {\n        ...encoding,\n        [stackFieldChannel]: {\n          ...encoding[stackFieldChannel],\n          ...(offset ? {\n            stack: offset\n          } : {})\n        }\n      };\n    }\n    // overlay line layer should be on the edge of area but passing y2/x2 makes\n    // it as \"rule\" mark so that it draws unwanted vertical/horizontal lines.\n    // point overlay also should not have y2/x2 as it does not support.\n    overlayEncoding = omit(overlayEncoding, ['y2', 'x2']);\n    if (lineOverlay) {\n      layer.push({\n        ...(projection ? {\n          projection\n        } : {}),\n        mark: {\n          type: 'line',\n          ...pick(markDef, ['clip', 'interpolate', 'tension', 'tooltip']),\n          ...lineOverlay\n        },\n        encoding: overlayEncoding\n      });\n    }\n    if (pointOverlay) {\n      layer.push({\n        ...(projection ? {\n          projection\n        } : {}),\n        mark: {\n          type: 'point',\n          opacity: 1,\n          filled: true,\n          ...pick(markDef, ['clip', 'tooltip']),\n          ...pointOverlay\n        },\n        encoding: overlayEncoding\n      });\n    }\n    return normalize({\n      ...outerSpec,\n      layer\n    }, {\n      ...normParams,\n      config: dropLineAndPointFromConfig(config)\n    });\n  }\n}","map":{"version":3,"names":["isObject","normalizeEncoding","isMarkDef","isUnitSpec","stack","keys","omit","pick","initMarkdef","dropLineAndPoint","markDef","point","_point","line","_line","mark","length","type","dropLineAndPointFromConfig","config","getPointOverlay","markConfig","arguments","undefined","encoding","opacity","shape","getLineOverlay","PathOverlayNormalizer","constructor","name","hasMatchingType","spec","run","normParams","normalize","params","projection","e","outerSpec","pointOverlay","lineOverlay","layer","fillOpacity","stackProps","overlayEncoding","fieldChannel","stackFieldChannel","offset","push","filled"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\normalize\\pathoverlay.ts"],"sourcesContent":["import type {SignalRef} from 'vega';\nimport {isObject} from 'vega-util';\nimport {Config} from '../config';\nimport {Encoding, normalizeEncoding} from '../encoding';\nimport {ExprRef} from '../expr';\nimport {AreaConfig, isMarkDef, LineConfig, Mark, MarkConfig, MarkDef} from '../mark';\nimport {GenericUnitSpec, NormalizedUnitSpec} from '../spec';\nimport {isUnitSpec} from '../spec/unit';\nimport {stack} from '../stack';\nimport {keys, omit, pick} from '../util';\nimport {NonFacetUnitNormalizer, NormalizeLayerOrUnit, NormalizerParams} from './base';\nimport {initMarkdef} from '../compile/mark/init';\n\ntype UnitSpecWithPathOverlay = GenericUnitSpec<Encoding<string>, Mark | MarkDef<'line' | 'area' | 'rule' | 'trail'>>;\n\nfunction dropLineAndPoint(markDef: MarkDef): MarkDef | Mark {\n  const {point: _point, line: _line, ...mark} = markDef;\n\n  return keys(mark).length > 1 ? mark : mark.type;\n}\n\nfunction dropLineAndPointFromConfig(config: Config<SignalRef>) {\n  for (const mark of ['line', 'area', 'rule', 'trail'] as const) {\n    if (config[mark]) {\n      config = {\n        ...config,\n        // TODO: remove as any\n        [mark]: omit(config[mark], ['point', 'line'] as any)\n      };\n    }\n  }\n  return config;\n}\n\nfunction getPointOverlay(\n  markDef: MarkDef,\n  markConfig: LineConfig<ExprRef | SignalRef> = {},\n  encoding: Encoding<string>\n): MarkConfig<ExprRef | SignalRef> {\n  if (markDef.point === 'transparent') {\n    return {opacity: 0};\n  } else if (markDef.point) {\n    // truthy : true or object\n    return isObject(markDef.point) ? markDef.point : {};\n  } else if (markDef.point !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.point || encoding.shape) {\n      // enable point overlay if config[mark].point is truthy or if encoding.shape is provided\n      return isObject(markConfig.point) ? markConfig.point : {};\n    }\n    // markDef.point is defined as falsy\n    return undefined;\n  }\n}\n\nfunction getLineOverlay(\n  markDef: MarkDef,\n  markConfig: AreaConfig<ExprRef | SignalRef> = {}\n): MarkConfig<ExprRef | SignalRef> {\n  if (markDef.line) {\n    // true or object\n    return markDef.line === true ? {} : markDef.line;\n  } else if (markDef.line !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.line) {\n      // enable line overlay if config[mark].line is truthy\n      return markConfig.line === true ? {} : markConfig.line;\n    }\n    // markDef.point is defined as falsy\n    return undefined;\n  }\n}\n\nexport class PathOverlayNormalizer implements NonFacetUnitNormalizer<UnitSpecWithPathOverlay> {\n  public name = 'path-overlay';\n\n  public hasMatchingType(spec: GenericUnitSpec<any, Mark | MarkDef>, config: Config): spec is UnitSpecWithPathOverlay {\n    if (isUnitSpec(spec)) {\n      const {mark, encoding} = spec;\n      const markDef = isMarkDef(mark) ? mark : {type: mark};\n      switch (markDef.type) {\n        case 'line':\n        case 'rule':\n        case 'trail':\n          return !!getPointOverlay(markDef, config[markDef.type], encoding);\n        case 'area':\n          return (\n            // false / null are also included as we want to remove the properties\n            !!getPointOverlay(markDef, config[markDef.type], encoding) ||\n            !!getLineOverlay(markDef, config[markDef.type])\n          );\n      }\n    }\n    return false;\n  }\n\n  public run(spec: UnitSpecWithPathOverlay, normParams: NormalizerParams, normalize: NormalizeLayerOrUnit) {\n    const {config} = normParams;\n    const {params, projection, mark, name, encoding: e, ...outerSpec} = spec;\n\n    // Need to call normalizeEncoding because we need the inferred types to correctly determine stack\n    const encoding = normalizeEncoding(e, config);\n\n    const markDef: MarkDef = isMarkDef(mark) ? mark : {type: mark};\n\n    const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);\n\n    const lineOverlay = markDef.type === 'area' && getLineOverlay(markDef, config[markDef.type]);\n\n    const layer: NormalizedUnitSpec[] = [\n      {\n        name,\n        ...(params ? {params} : {}),\n        mark: dropLineAndPoint({\n          // TODO: extract this 0.7 to be shared with default opacity for point/tick/...\n          ...(markDef.type === 'area' && markDef.opacity === undefined && markDef.fillOpacity === undefined\n            ? {opacity: 0.7}\n            : {}),\n          ...markDef\n        }),\n        // drop shape from encoding as this might be used to trigger point overlay\n        encoding: omit(encoding, ['shape'])\n      }\n    ];\n\n    // FIXME: determine rules for applying selections.\n\n    // Need to copy stack config to overlayed layer\n    // FIXME: normalizer shouldn't call `initMarkdef`, a method from an init phase.\n    const stackProps = stack(initMarkdef(markDef, encoding, config), encoding);\n\n    let overlayEncoding = encoding;\n    if (stackProps) {\n      const {fieldChannel: stackFieldChannel, offset} = stackProps;\n      overlayEncoding = {\n        ...encoding,\n        [stackFieldChannel]: {\n          ...encoding[stackFieldChannel],\n          ...(offset ? {stack: offset} : {})\n        }\n      };\n    }\n\n    // overlay line layer should be on the edge of area but passing y2/x2 makes\n    // it as \"rule\" mark so that it draws unwanted vertical/horizontal lines.\n    // point overlay also should not have y2/x2 as it does not support.\n    overlayEncoding = omit(overlayEncoding, ['y2', 'x2']);\n\n    if (lineOverlay) {\n      layer.push({\n        ...(projection ? {projection} : {}),\n        mark: {\n          type: 'line',\n          ...pick(markDef, ['clip', 'interpolate', 'tension', 'tooltip']),\n          ...lineOverlay\n        },\n        encoding: overlayEncoding\n      });\n    }\n    if (pointOverlay) {\n      layer.push({\n        ...(projection ? {projection} : {}),\n        mark: {\n          type: 'point',\n          opacity: 1,\n          filled: true,\n          ...pick(markDef, ['clip', 'tooltip']),\n          ...pointOverlay\n        },\n        encoding: overlayEncoding\n      });\n    }\n\n    return normalize(\n      {\n        ...outerSpec,\n        layer\n      },\n      {\n        ...normParams,\n        config: dropLineAndPointFromConfig(config)\n      }\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}