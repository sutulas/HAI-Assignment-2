{"ast":null,"code":"import { getPositionScaleChannel } from '../channel';\nimport { signalRefOrValue } from '../compile/common';\nexport function isFitType(autoSizeType) {\n  return ['fit', 'fit-x', 'fit-y'].includes(autoSizeType);\n}\nexport function getFitType(sizeType) {\n  return sizeType ? `fit-${getPositionScaleChannel(sizeType)}` : 'fit';\n}\nconst TOP_LEVEL_PROPERTIES = ['background', 'padding'\n// We do not include \"autosize\" here as it is supported by only unit and layer specs and thus need to be normalized\n];\nexport function extractTopLevelProperties(t, includeParams) {\n  const o = {};\n  for (const p of TOP_LEVEL_PROPERTIES) {\n    if (t && t[p] !== undefined) {\n      o[p] = signalRefOrValue(t[p]);\n    }\n  }\n  if (includeParams) {\n    o.params = t.params;\n  }\n  return o;\n}","map":{"version":3,"names":["getPositionScaleChannel","signalRefOrValue","isFitType","autoSizeType","includes","getFitType","sizeType","TOP_LEVEL_PROPERTIES","extractTopLevelProperties","t","includeParams","o","p","undefined","params"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\spec\\toplevel.ts"],"sourcesContent":["import type {Color, SignalRef} from 'vega';\nimport {BaseSpec} from '.';\nimport {getPositionScaleChannel} from '../channel';\nimport {signalRefOrValue} from '../compile/common';\nimport {Config} from '../config';\nimport {InlineDataset} from '../data';\nimport {ExprRef} from '../expr';\nimport {VariableParameter} from '../parameter';\nimport {TopLevelSelectionParameter} from '../selection';\nimport {Dict} from '../util';\n\n/**\n * @minimum 0\n */\nexport type Padding = number | {top?: number; bottom?: number; left?: number; right?: number};\n\nexport type Datasets = Dict<InlineDataset>;\n\nexport type TopLevelParameter = VariableParameter | TopLevelSelectionParameter;\n\nexport type TopLevel<S extends BaseSpec> = S &\n  TopLevelProperties & {\n    /**\n     * URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.\n     * @format uri\n     */\n    $schema?: string;\n\n    /**\n     * Vega-Lite configuration object. This property can only be defined at the top-level of a specification.\n     */\n    config?: Config;\n\n    /**\n     * A global data store for named datasets. This is a mapping from names to inline datasets.\n     * This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property.\n     */\n    datasets?: Datasets;\n\n    /**\n     * Optional metadata that will be passed to Vega.\n     * This object is completely ignored by Vega and Vega-Lite and can be used for custom metadata.\n     */\n    usermeta?: Dict<unknown>;\n  };\n\n/**\n * Shared properties between Top-Level specs and Config\n */\nexport interface TopLevelProperties<ES extends ExprRef | SignalRef = ExprRef | SignalRef> {\n  /**\n   * CSS color property to use as the background of the entire view.\n   *\n   * __Default value:__ `\"white\"`\n   */\n  background?: Color | ES;\n\n  /**\n   * The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. If a number, specifies padding for all sides.\n   * If an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n   *\n   * __Default value__: `5`\n   */\n  padding?: Padding | ES;\n\n  /**\n   * How the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`.\n   * Object values can additionally specify parameters for content sizing and automatic resizing.\n   *\n   * __Default value__: `pad`\n   */\n  autosize?: AutosizeType | AutoSizeParams; // Vega actually supports signal for autosize. However, we need to check autosize at compile time to infer the rest of the spec. Thus VL's autosize won't support SignalRef for now.\n\n  /**\n   * Dynamic variables or selections that parameterize a visualization.\n   */\n  params?: TopLevelParameter[];\n}\n\nexport type FitType = 'fit' | 'fit-x' | 'fit-y';\n\nexport function isFitType(autoSizeType: AutosizeType): autoSizeType is FitType {\n  return ['fit', 'fit-x', 'fit-y'].includes(autoSizeType);\n}\n\nexport function getFitType(sizeType?: 'width' | 'height'): FitType {\n  return sizeType ? (`fit-${getPositionScaleChannel(sizeType)}` as FitType) : 'fit';\n}\n\nexport type AutosizeType = 'pad' | 'none' | 'fit' | 'fit-x' | 'fit-y';\n\nexport interface AutoSizeParams {\n  /**\n   * The sizing format type. One of `\"pad\"`, `\"fit\"`, `\"fit-x\"`, `\"fit-y\"`,  or `\"none\"`. See the [autosize type](https://vega.github.io/vega-lite/docs/size.html#autosize) documentation for descriptions of each.\n   *\n   * __Default value__: `\"pad\"`\n   */\n  type?: AutosizeType;\n\n  /**\n   * A boolean flag indicating if autosize layout should be re-calculated on every view update.\n   *\n   * __Default value__: `false`\n   */\n  resize?: boolean;\n\n  /**\n   * Determines how size calculation should be performed, one of `\"content\"` or `\"padding\"`. The default setting (`\"content\"`) interprets the width and height settings as the data rectangle (plotting) dimensions, to which padding is then added. In contrast, the `\"padding\"` setting includes the padding within the view size calculations, such that the width and height settings indicate the **total** intended size of the view.\n   *\n   * __Default value__: `\"content\"`\n   */\n  contains?: 'content' | 'padding';\n}\n\nconst TOP_LEVEL_PROPERTIES: (keyof TopLevelProperties)[] = [\n  'background',\n  'padding'\n  // We do not include \"autosize\" here as it is supported by only unit and layer specs and thus need to be normalized\n];\n\nexport function extractTopLevelProperties(t: TopLevelProperties, includeParams: boolean) {\n  const o: TopLevelProperties<SignalRef> = {};\n  for (const p of TOP_LEVEL_PROPERTIES) {\n    if (t && t[p] !== undefined) {\n      (o as any)[p] = signalRefOrValue(t[p]);\n    }\n  }\n  if (includeParams) {\n    o.params = t.params;\n  }\n  return o;\n}\n"],"mappings":"AAEA,SAAQA,uBAAuB,QAAO,YAAY;AAClD,SAAQC,gBAAgB,QAAO,mBAAmB;AA8ElD,OAAM,SAAUC,SAASA,CAACC,YAA0B;EAClD,OAAO,CAAC,KAAK,EAAE,OAAO,EAAE,OAAO,CAAC,CAACC,QAAQ,CAACD,YAAY,CAAC;AACzD;AAEA,OAAM,SAAUE,UAAUA,CAACC,QAA6B;EACtD,OAAOA,QAAQ,GAAI,OAAON,uBAAuB,CAACM,QAAQ,CAAC,EAAc,GAAG,KAAK;AACnF;AA2BA,MAAMC,oBAAoB,GAAiC,CACzD,YAAY,EACZ;AACA;AAAA,CACD;AAED,OAAM,SAAUC,yBAAyBA,CAACC,CAAqB,EAAEC,aAAsB;EACrF,MAAMC,CAAC,GAAkC,EAAE;EAC3C,KAAK,MAAMC,CAAC,IAAIL,oBAAoB,EAAE;IACpC,IAAIE,CAAC,IAAIA,CAAC,CAACG,CAAC,CAAC,KAAKC,SAAS,EAAE;MAC1BF,CAAS,CAACC,CAAC,CAAC,GAAGX,gBAAgB,CAACQ,CAAC,CAACG,CAAC,CAAC,CAAC;IACxC;EACF;EACA,IAAIF,aAAa,EAAE;IACjBC,CAAC,CAACG,MAAM,GAAGL,CAAC,CAACK,MAAM;EACrB;EACA,OAAOH,CAAC;AACV","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}