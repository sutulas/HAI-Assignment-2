{"ast":null,"code":"import { hasOwnProperty, isFunction, inherits, truthy, lruCache, isArray, error, toSet, array, peek, extend, isNumber, isObject } from 'vega-util';\nimport { curveBasis, curveBasisClosed, curveBasisOpen, curveBundle, curveCardinal, curveCardinalOpen, curveCardinalClosed, curveCatmullRom, curveCatmullRomClosed, curveCatmullRomOpen, curveLinear, curveLinearClosed, curveMonotoneY, curveMonotoneX, curveNatural, curveStep, curveStepAfter, curveStepBefore, arc as arc$2, area as area$2, line as line$2, symbol as symbol$2 } from 'd3-shape';\nimport { path as path$3 } from 'd3-path';\nexport { path } from 'd3-path';\nimport { image as image$1, canvas } from 'vega-canvas';\nimport { loader } from 'vega-loader';\nimport { isDiscrete, domainCaption } from 'vega-scale';\nlet gradient_id = 0;\nfunction resetSVGGradientId() {\n  gradient_id = 0;\n}\nconst patternPrefix = 'p_';\nfunction isGradient(value) {\n  return value && value.gradient;\n}\nfunction gradientRef(g, defs, base) {\n  const type = g.gradient;\n  let id = g.id,\n    prefix = type === 'radial' ? patternPrefix : '';\n\n  // check id, assign default values as needed\n  if (!id) {\n    id = g.id = 'gradient_' + gradient_id++;\n    if (type === 'radial') {\n      g.x1 = get(g.x1, 0.5);\n      g.y1 = get(g.y1, 0.5);\n      g.r1 = get(g.r1, 0);\n      g.x2 = get(g.x2, 0.5);\n      g.y2 = get(g.y2, 0.5);\n      g.r2 = get(g.r2, 0.5);\n      prefix = patternPrefix;\n    } else {\n      g.x1 = get(g.x1, 0);\n      g.y1 = get(g.y1, 0);\n      g.x2 = get(g.x2, 1);\n      g.y2 = get(g.y2, 0);\n    }\n  }\n\n  // register definition\n  defs[id] = g;\n\n  // return url reference\n  return 'url(' + (base || '') + '#' + prefix + id + ')';\n}\nfunction get(val, def) {\n  return val != null ? val : def;\n}\nfunction Gradient(p0, p1) {\n  var stops = [],\n    gradient;\n  return gradient = {\n    gradient: 'linear',\n    x1: p0 ? p0[0] : 0,\n    y1: p0 ? p0[1] : 0,\n    x2: p1 ? p1[0] : 1,\n    y2: p1 ? p1[1] : 0,\n    stops: stops,\n    stop: function (offset, color) {\n      stops.push({\n        offset: offset,\n        color: color\n      });\n      return gradient;\n    }\n  };\n}\nconst lookup = {\n  'basis': {\n    curve: curveBasis\n  },\n  'basis-closed': {\n    curve: curveBasisClosed\n  },\n  'basis-open': {\n    curve: curveBasisOpen\n  },\n  'bundle': {\n    curve: curveBundle,\n    tension: 'beta',\n    value: 0.85\n  },\n  'cardinal': {\n    curve: curveCardinal,\n    tension: 'tension',\n    value: 0\n  },\n  'cardinal-open': {\n    curve: curveCardinalOpen,\n    tension: 'tension',\n    value: 0\n  },\n  'cardinal-closed': {\n    curve: curveCardinalClosed,\n    tension: 'tension',\n    value: 0\n  },\n  'catmull-rom': {\n    curve: curveCatmullRom,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'catmull-rom-closed': {\n    curve: curveCatmullRomClosed,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'catmull-rom-open': {\n    curve: curveCatmullRomOpen,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'linear': {\n    curve: curveLinear\n  },\n  'linear-closed': {\n    curve: curveLinearClosed\n  },\n  'monotone': {\n    horizontal: curveMonotoneY,\n    vertical: curveMonotoneX\n  },\n  'natural': {\n    curve: curveNatural\n  },\n  'step': {\n    curve: curveStep\n  },\n  'step-after': {\n    curve: curveStepAfter\n  },\n  'step-before': {\n    curve: curveStepBefore\n  }\n};\nfunction curves(type, orientation, tension) {\n  var entry = hasOwnProperty(lookup, type) && lookup[type],\n    curve = null;\n  if (entry) {\n    curve = entry.curve || entry[orientation || 'vertical'];\n    if (entry.tension && tension != null) {\n      curve = curve[entry.tension](tension);\n    }\n  }\n  return curve;\n}\nconst paramCounts = {\n  m: 2,\n  l: 2,\n  h: 1,\n  v: 1,\n  z: 0,\n  c: 6,\n  s: 4,\n  q: 4,\n  t: 2,\n  a: 7\n};\nconst commandPattern = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi;\nconst numberPattern = /^[+-]?(([0-9]*\\.[0-9]+)|([0-9]+\\.)|([0-9]+))([eE][+-]?[0-9]+)?/;\nconst spacePattern = /^((\\s+,?\\s*)|(,\\s*))/;\nconst flagPattern = /^[01]/;\nfunction parse(path) {\n  const commands = [];\n  const matches = path.match(commandPattern) || [];\n  matches.forEach(str => {\n    let cmd = str[0];\n    const type = cmd.toLowerCase();\n\n    // parse parameters\n    const paramCount = paramCounts[type];\n    const params = parseParams(type, paramCount, str.slice(1).trim());\n    const count = params.length;\n\n    // error checking based on parameter count\n    if (count < paramCount || count && count % paramCount !== 0) {\n      throw Error('Invalid SVG path, incorrect parameter count');\n    }\n\n    // register the command\n    commands.push([cmd, ...params.slice(0, paramCount)]);\n\n    // exit now if we're done, also handles zero-param 'z'\n    if (count === paramCount) {\n      return;\n    }\n\n    // handle implicit line-to\n    if (type === 'm') {\n      cmd = cmd === 'M' ? 'L' : 'l';\n    }\n\n    // repeat command when given extended param list\n    for (let i = paramCount; i < count; i += paramCount) {\n      commands.push([cmd, ...params.slice(i, i + paramCount)]);\n    }\n  });\n  return commands;\n}\nfunction parseParams(type, paramCount, segment) {\n  const params = [];\n  for (let index = 0; paramCount && index < segment.length;) {\n    for (let i = 0; i < paramCount; ++i) {\n      const pattern = type === 'a' && (i === 3 || i === 4) ? flagPattern : numberPattern;\n      const match = segment.slice(index).match(pattern);\n      if (match === null) {\n        throw Error('Invalid SVG path, incorrect parameter type');\n      }\n      index += match[0].length;\n      params.push(+match[0]);\n      const ws = segment.slice(index).match(spacePattern);\n      if (ws !== null) {\n        index += ws[0].length;\n      }\n    }\n  }\n  return params;\n}\nconst DegToRad = Math.PI / 180;\nconst Epsilon = 1e-14;\nconst HalfPi = Math.PI / 2;\nconst Tau = Math.PI * 2;\nconst HalfSqrt3 = Math.sqrt(3) / 2;\nvar segmentCache = {};\nvar bezierCache = {};\nvar join = [].join;\n\n// Copied from Inkscape svgtopdf, thanks!\nfunction segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  const key = join.call(arguments);\n  if (segmentCache[key]) {\n    return segmentCache[key];\n  }\n  const th = rotateX * DegToRad;\n  const sin_th = Math.sin(th);\n  const cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  const py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  let pl = px * px / (rx * rx) + py * py / (ry * ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n  const a00 = cos_th / rx;\n  const a01 = sin_th / rx;\n  const a10 = -sin_th / ry;\n  const a11 = cos_th / ry;\n  const x0 = a00 * ox + a01 * oy;\n  const y0 = a10 * ox + a11 * oy;\n  const x1 = a00 * x + a01 * y;\n  const y1 = a10 * x + a11 * y;\n  const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);\n  let sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  let sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);\n  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);\n  const th0 = Math.atan2(y0 - yc, x0 - xc);\n  const th1 = Math.atan2(y1 - yc, x1 - xc);\n  let th_arc = th1 - th0;\n  if (th_arc < 0 && sweep === 1) {\n    th_arc += Tau;\n  } else if (th_arc > 0 && sweep === 0) {\n    th_arc -= Tau;\n  }\n  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 0.001)));\n  const result = [];\n  for (let i = 0; i < segs; ++i) {\n    const th2 = th0 + i * th_arc / segs;\n    const th3 = th0 + (i + 1) * th_arc / segs;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n  return segmentCache[key] = result;\n}\nfunction bezier(params) {\n  const key = join.call(params);\n  if (bezierCache[key]) {\n    return bezierCache[key];\n  }\n  var cx = params[0],\n    cy = params[1],\n    th0 = params[2],\n    th1 = params[3],\n    rx = params[4],\n    ry = params[5],\n    sin_th = params[6],\n    cos_th = params[7];\n  const a00 = cos_th * rx;\n  const a01 = -sin_th * ry;\n  const a10 = sin_th * rx;\n  const a11 = cos_th * ry;\n  const cos_th0 = Math.cos(th0);\n  const sin_th0 = Math.sin(th0);\n  const cos_th1 = Math.cos(th1);\n  const sin_th1 = Math.sin(th1);\n  const th_half = 0.5 * (th1 - th0);\n  const sin_th_h2 = Math.sin(th_half * 0.5);\n  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  const x1 = cx + cos_th0 - t * sin_th0;\n  const y1 = cy + sin_th0 + t * cos_th0;\n  const x3 = cx + cos_th1;\n  const y3 = cy + sin_th1;\n  const x2 = x3 + t * sin_th1;\n  const y2 = y3 - t * cos_th1;\n  return bezierCache[key] = [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];\n}\nconst temp = ['l', 0, 0, 0, 0, 0, 0, 0];\nfunction scale$1(current, sX, sY) {\n  const c = temp[0] = current[0];\n  if (c === 'a' || c === 'A') {\n    temp[1] = sX * current[1];\n    temp[2] = sY * current[2];\n    temp[3] = current[3];\n    temp[4] = current[4];\n    temp[5] = current[5];\n    temp[6] = sX * current[6];\n    temp[7] = sY * current[7];\n  } else if (c === 'h' || c === 'H') {\n    temp[1] = sX * current[1];\n  } else if (c === 'v' || c === 'V') {\n    temp[1] = sY * current[1];\n  } else {\n    for (var i = 1, n = current.length; i < n; ++i) {\n      temp[i] = (i % 2 == 1 ? sX : sY) * current[i];\n    }\n  }\n  return temp;\n}\nfunction pathRender(context, path, l, t, sX, sY) {\n  var current,\n    // current instruction\n    previous = null,\n    x = 0,\n    // current x\n    y = 0,\n    // current y\n    controlX = 0,\n    // current control point x\n    controlY = 0,\n    // current control point y\n    tempX,\n    tempY,\n    tempControlX,\n    tempControlY,\n    anchorX = 0,\n    anchorY = 0;\n  if (l == null) l = 0;\n  if (t == null) t = 0;\n  if (sX == null) sX = 1;\n  if (sY == null) sY = sX;\n  if (context.beginPath) context.beginPath();\n  for (var i = 0, len = path.length; i < len; ++i) {\n    current = path[i];\n    if (sX !== 1 || sY !== 1) {\n      current = scale$1(current, sX, sY);\n    }\n    switch (current[0]) {\n      // first letter\n\n      case 'l':\n        // lineto, relative\n        x += current[1];\n        y += current[2];\n        context.lineTo(x + l, y + t);\n        break;\n      case 'L':\n        // lineto, absolute\n        x = current[1];\n        y = current[2];\n        context.lineTo(x + l, y + t);\n        break;\n      case 'h':\n        // horizontal lineto, relative\n        x += current[1];\n        context.lineTo(x + l, y + t);\n        break;\n      case 'H':\n        // horizontal lineto, absolute\n        x = current[1];\n        context.lineTo(x + l, y + t);\n        break;\n      case 'v':\n        // vertical lineto, relative\n        y += current[1];\n        context.lineTo(x + l, y + t);\n        break;\n      case 'V':\n        // verical lineto, absolute\n        y = current[1];\n        context.lineTo(x + l, y + t);\n        break;\n      case 'm':\n        // moveTo, relative\n        x += current[1];\n        y += current[2];\n        anchorX = x;\n        anchorY = y;\n        context.moveTo(x + l, y + t);\n        break;\n      case 'M':\n        // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        anchorX = x;\n        anchorY = y;\n        context.moveTo(x + l, y + t);\n        break;\n      case 'c':\n        // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        context.bezierCurveTo(x + current[1] + l,\n        // x1\n        y + current[2] + t,\n        // y1\n        controlX + l,\n        // x2\n        controlY + t,\n        // y2\n        tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n      case 'C':\n        // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        context.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);\n        break;\n      case 's':\n        // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t);\n\n        // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n        controlX = x + current[1];\n        controlY = y + current[2];\n        x = tempX;\n        y = tempY;\n        break;\n      case 'S':\n        // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n        controlX = current[1];\n        controlY = current[2];\n        break;\n      case 'q':\n        // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        controlX = x + current[1];\n        controlY = y + current[2];\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n      case 'Q':\n        // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        context.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        break;\n      case 't':\n        // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        } else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        } else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n        tempControlX = controlX;\n        tempControlY = controlY;\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        break;\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n      case 'a':\n        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]);\n        x += current[6];\n        y += current[7];\n        break;\n      case 'A':\n        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]);\n        x = current[6];\n        y = current[7];\n        break;\n      case 'z':\n      case 'Z':\n        x = anchorX;\n        y = anchorY;\n        context.closePath();\n        break;\n    }\n    previous = current;\n  }\n}\nfunction drawArc(context, x, y, coords) {\n  const seg = segments(coords[5],\n  // end x\n  coords[6],\n  // end y\n  coords[0],\n  // radius x\n  coords[1],\n  // radius y\n  coords[3],\n  // large flag\n  coords[4],\n  // sweep flag\n  coords[2],\n  // rotation\n  x, y);\n  for (let i = 0; i < seg.length; ++i) {\n    const bez = bezier(seg[i]);\n    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);\n  }\n}\nconst Tan30 = 0.5773502691896257;\nconst builtins = {\n  'circle': {\n    draw: function (context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(r, 0);\n      context.arc(0, 0, r, 0, Tau);\n    }\n  },\n  'cross': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n        s = r / 2.5;\n      context.moveTo(-r, -s);\n      context.lineTo(-r, s);\n      context.lineTo(-s, s);\n      context.lineTo(-s, r);\n      context.lineTo(s, r);\n      context.lineTo(s, s);\n      context.lineTo(r, s);\n      context.lineTo(r, -s);\n      context.lineTo(s, -s);\n      context.lineTo(s, -r);\n      context.lineTo(-s, -r);\n      context.lineTo(-s, -s);\n      context.closePath();\n    }\n  },\n  'diamond': {\n    draw: function (context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(-r, 0);\n      context.lineTo(0, -r);\n      context.lineTo(r, 0);\n      context.lineTo(0, r);\n      context.closePath();\n    }\n  },\n  'square': {\n    draw: function (context, size) {\n      var w = Math.sqrt(size),\n        x = -w / 2;\n      context.rect(x, x, w, w);\n    }\n  },\n  'arrow': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n        s = r / 7,\n        t = r / 2.5,\n        v = r / 8;\n      context.moveTo(-s, r);\n      context.lineTo(s, r);\n      context.lineTo(s, -v);\n      context.lineTo(t, -v);\n      context.lineTo(0, -r);\n      context.lineTo(-t, -v);\n      context.lineTo(-s, -v);\n      context.closePath();\n    }\n  },\n  'wedge': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n        h = HalfSqrt3 * r,\n        o = h - r * Tan30,\n        b = r / 4;\n      context.moveTo(0, -h - o);\n      context.lineTo(-b, h - o);\n      context.lineTo(b, h - o);\n      context.closePath();\n    }\n  },\n  'triangle': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n        h = HalfSqrt3 * r,\n        o = h - r * Tan30;\n      context.moveTo(0, -h - o);\n      context.lineTo(-r, h - o);\n      context.lineTo(r, h - o);\n      context.closePath();\n    }\n  },\n  'triangle-up': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n        h = HalfSqrt3 * r;\n      context.moveTo(0, -h);\n      context.lineTo(-r, h);\n      context.lineTo(r, h);\n      context.closePath();\n    }\n  },\n  'triangle-down': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n        h = HalfSqrt3 * r;\n      context.moveTo(0, h);\n      context.lineTo(-r, -h);\n      context.lineTo(r, -h);\n      context.closePath();\n    }\n  },\n  'triangle-right': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n        h = HalfSqrt3 * r;\n      context.moveTo(h, 0);\n      context.lineTo(-h, -r);\n      context.lineTo(-h, r);\n      context.closePath();\n    }\n  },\n  'triangle-left': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n        h = HalfSqrt3 * r;\n      context.moveTo(-h, 0);\n      context.lineTo(h, -r);\n      context.lineTo(h, r);\n      context.closePath();\n    }\n  },\n  'stroke': {\n    draw: function (context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(-r, 0);\n      context.lineTo(r, 0);\n    }\n  }\n};\nfunction symbols(_) {\n  return hasOwnProperty(builtins, _) ? builtins[_] : customSymbol(_);\n}\nvar custom = {};\nfunction customSymbol(path) {\n  if (!hasOwnProperty(custom, path)) {\n    const parsed = parse(path);\n    custom[path] = {\n      draw: function (context, size) {\n        pathRender(context, parsed, 0, 0, Math.sqrt(size) / 2);\n      }\n    };\n  }\n  return custom[path];\n}\n\n// See http://spencermortensen.com/articles/bezier-circle/\nconst C = 0.448084975506; // C = 1 - c\n\nfunction rectangleX(d) {\n  return d.x;\n}\nfunction rectangleY(d) {\n  return d.y;\n}\nfunction rectangleWidth(d) {\n  return d.width;\n}\nfunction rectangleHeight(d) {\n  return d.height;\n}\nfunction number(_) {\n  return typeof _ === 'function' ? _ : () => +_;\n}\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n}\nfunction vg_rect() {\n  var x = rectangleX,\n    y = rectangleY,\n    width = rectangleWidth,\n    height = rectangleHeight,\n    crTL = number(0),\n    crTR = crTL,\n    crBL = crTL,\n    crBR = crTL,\n    context = null;\n  function rectangle(_, x0, y0) {\n    var buffer,\n      x1 = x0 != null ? x0 : +x.call(this, _),\n      y1 = y0 != null ? y0 : +y.call(this, _),\n      w = +width.call(this, _),\n      h = +height.call(this, _),\n      s = Math.min(w, h) / 2,\n      tl = clamp(+crTL.call(this, _), 0, s),\n      tr = clamp(+crTR.call(this, _), 0, s),\n      bl = clamp(+crBL.call(this, _), 0, s),\n      br = clamp(+crBR.call(this, _), 0, s);\n    if (!context) context = buffer = path$3();\n    if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {\n      context.rect(x1, y1, w, h);\n    } else {\n      var x2 = x1 + w,\n        y2 = y1 + h;\n      context.moveTo(x1 + tl, y1);\n      context.lineTo(x2 - tr, y1);\n      context.bezierCurveTo(x2 - C * tr, y1, x2, y1 + C * tr, x2, y1 + tr);\n      context.lineTo(x2, y2 - br);\n      context.bezierCurveTo(x2, y2 - C * br, x2 - C * br, y2, x2 - br, y2);\n      context.lineTo(x1 + bl, y2);\n      context.bezierCurveTo(x1 + C * bl, y2, x1, y2 - C * bl, x1, y2 - bl);\n      context.lineTo(x1, y1 + tl);\n      context.bezierCurveTo(x1, y1 + C * tl, x1 + C * tl, y1, x1 + tl, y1);\n      context.closePath();\n    }\n    if (buffer) {\n      context = null;\n      return buffer + '' || null;\n    }\n  }\n  rectangle.x = function (_) {\n    if (arguments.length) {\n      x = number(_);\n      return rectangle;\n    } else {\n      return x;\n    }\n  };\n  rectangle.y = function (_) {\n    if (arguments.length) {\n      y = number(_);\n      return rectangle;\n    } else {\n      return y;\n    }\n  };\n  rectangle.width = function (_) {\n    if (arguments.length) {\n      width = number(_);\n      return rectangle;\n    } else {\n      return width;\n    }\n  };\n  rectangle.height = function (_) {\n    if (arguments.length) {\n      height = number(_);\n      return rectangle;\n    } else {\n      return height;\n    }\n  };\n  rectangle.cornerRadius = function (tl, tr, br, bl) {\n    if (arguments.length) {\n      crTL = number(tl);\n      crTR = tr != null ? number(tr) : crTL;\n      crBR = br != null ? number(br) : crTL;\n      crBL = bl != null ? number(bl) : crTR;\n      return rectangle;\n    } else {\n      return crTL;\n    }\n  };\n  rectangle.context = function (_) {\n    if (arguments.length) {\n      context = _ == null ? null : _;\n      return rectangle;\n    } else {\n      return context;\n    }\n  };\n  return rectangle;\n}\nfunction vg_trail() {\n  var x,\n    y,\n    size,\n    defined,\n    context = null,\n    ready,\n    x1,\n    y1,\n    r1;\n  function point(x2, y2, w2) {\n    const r2 = w2 / 2;\n    if (ready) {\n      var ux = y1 - y2,\n        uy = x2 - x1;\n      if (ux || uy) {\n        // get normal vector\n        var ud = Math.hypot(ux, uy),\n          rx = (ux /= ud) * r1,\n          ry = (uy /= ud) * r1,\n          t = Math.atan2(uy, ux);\n\n        // draw segment\n        context.moveTo(x1 - rx, y1 - ry);\n        context.lineTo(x2 - ux * r2, y2 - uy * r2);\n        context.arc(x2, y2, r2, t - Math.PI, t);\n        context.lineTo(x1 + rx, y1 + ry);\n        context.arc(x1, y1, r1, t, t + Math.PI);\n      } else {\n        context.arc(x2, y2, r2, 0, Tau);\n      }\n      context.closePath();\n    } else {\n      ready = 1;\n    }\n    x1 = x2;\n    y1 = y2;\n    r1 = r2;\n  }\n  function trail(data) {\n    var i,\n      n = data.length,\n      d,\n      defined0 = false,\n      buffer;\n    if (context == null) context = buffer = path$3();\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) ready = 0;\n      }\n      if (defined0) point(+x(d, i, data), +y(d, i, data), +size(d, i, data));\n    }\n    if (buffer) {\n      context = null;\n      return buffer + '' || null;\n    }\n  }\n  trail.x = function (_) {\n    if (arguments.length) {\n      x = _;\n      return trail;\n    } else {\n      return x;\n    }\n  };\n  trail.y = function (_) {\n    if (arguments.length) {\n      y = _;\n      return trail;\n    } else {\n      return y;\n    }\n  };\n  trail.size = function (_) {\n    if (arguments.length) {\n      size = _;\n      return trail;\n    } else {\n      return size;\n    }\n  };\n  trail.defined = function (_) {\n    if (arguments.length) {\n      defined = _;\n      return trail;\n    } else {\n      return defined;\n    }\n  };\n  trail.context = function (_) {\n    if (arguments.length) {\n      if (_ == null) {\n        context = null;\n      } else {\n        context = _;\n      }\n      return trail;\n    } else {\n      return context;\n    }\n  };\n  return trail;\n}\nfunction value$1(a, b) {\n  return a != null ? a : b;\n}\nconst x = item => item.x || 0,\n  y = item => item.y || 0,\n  w = item => item.width || 0,\n  h = item => item.height || 0,\n  xw = item => (item.x || 0) + (item.width || 0),\n  yh = item => (item.y || 0) + (item.height || 0),\n  sa = item => item.startAngle || 0,\n  ea = item => item.endAngle || 0,\n  pa = item => item.padAngle || 0,\n  ir = item => item.innerRadius || 0,\n  or = item => item.outerRadius || 0,\n  cr = item => item.cornerRadius || 0,\n  tl = item => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0,\n  tr = item => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0,\n  br = item => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0,\n  bl = item => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0,\n  sz = item => value$1(item.size, 64),\n  ts = item => item.size || 1,\n  def = item => !(item.defined === false),\n  type = item => symbols(item.shape || 'circle');\nconst arcShape = arc$2().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr),\n  areavShape = area$2().x(x).y1(y).y0(yh).defined(def),\n  areahShape = area$2().y(y).x1(x).x0(xw).defined(def),\n  lineShape = line$2().x(x).y(y).defined(def),\n  rectShape = vg_rect().x(x).y(y).width(w).height(h).cornerRadius(tl, tr, br, bl),\n  symbolShape = symbol$2().type(type).size(sz),\n  trailShape = vg_trail().x(x).y(y).defined(def).size(ts);\nfunction hasCornerRadius(item) {\n  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;\n}\nfunction arc$1(context, item) {\n  return arcShape.context(context)(item);\n}\nfunction area$1(context, items) {\n  const item = items[0],\n    interp = item.interpolate || 'linear';\n  return (item.orient === 'horizontal' ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context)(items);\n}\nfunction line$1(context, items) {\n  const item = items[0],\n    interp = item.interpolate || 'linear';\n  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context)(items);\n}\nfunction rectangle(context, item, x, y) {\n  return rectShape.context(context)(item, x, y);\n}\nfunction shape$1(context, item) {\n  return (item.mark.shape || item.shape).context(context)(item);\n}\nfunction symbol$1(context, item) {\n  return symbolShape.context(context)(item);\n}\nfunction trail$1(context, items) {\n  return trailShape.context(context)(items);\n}\nvar clip_id = 1;\nfunction resetSVGClipId() {\n  clip_id = 1;\n}\nfunction clip$1(renderer, item, size) {\n  var clip = item.clip,\n    defs = renderer._defs,\n    id = item.clip_id || (item.clip_id = 'clip' + clip_id++),\n    c = defs.clipping[id] || (defs.clipping[id] = {\n      id: id\n    });\n  if (isFunction(clip)) {\n    c.path = clip(null);\n  } else if (hasCornerRadius(size)) {\n    c.path = rectangle(null, size, 0, 0);\n  } else {\n    c.width = size.width || 0;\n    c.height = size.height || 0;\n  }\n  return 'url(#' + id + ')';\n}\nfunction Bounds(b) {\n  this.clear();\n  if (b) this.union(b);\n}\nBounds.prototype = {\n  clone() {\n    return new Bounds(this);\n  },\n  clear() {\n    this.x1 = +Number.MAX_VALUE;\n    this.y1 = +Number.MAX_VALUE;\n    this.x2 = -Number.MAX_VALUE;\n    this.y2 = -Number.MAX_VALUE;\n    return this;\n  },\n  empty() {\n    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;\n  },\n  equals(b) {\n    return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;\n  },\n  set(x1, y1, x2, y2) {\n    if (x2 < x1) {\n      this.x2 = x1;\n      this.x1 = x2;\n    } else {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n    if (y2 < y1) {\n      this.y2 = y1;\n      this.y1 = y2;\n    } else {\n      this.y1 = y1;\n      this.y2 = y2;\n    }\n    return this;\n  },\n  add(x, y) {\n    if (x < this.x1) this.x1 = x;\n    if (y < this.y1) this.y1 = y;\n    if (x > this.x2) this.x2 = x;\n    if (y > this.y2) this.y2 = y;\n    return this;\n  },\n  expand(d) {\n    this.x1 -= d;\n    this.y1 -= d;\n    this.x2 += d;\n    this.y2 += d;\n    return this;\n  },\n  round() {\n    this.x1 = Math.floor(this.x1);\n    this.y1 = Math.floor(this.y1);\n    this.x2 = Math.ceil(this.x2);\n    this.y2 = Math.ceil(this.y2);\n    return this;\n  },\n  scale(s) {\n    this.x1 *= s;\n    this.y1 *= s;\n    this.x2 *= s;\n    this.y2 *= s;\n    return this;\n  },\n  translate(dx, dy) {\n    this.x1 += dx;\n    this.x2 += dx;\n    this.y1 += dy;\n    this.y2 += dy;\n    return this;\n  },\n  rotate(angle, x, y) {\n    const p = this.rotatedPoints(angle, x, y);\n    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);\n  },\n  rotatedPoints(angle, x, y) {\n    var {\n        x1,\n        y1,\n        x2,\n        y2\n      } = this,\n      cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      cx = x - x * cos + y * sin,\n      cy = y - x * sin - y * cos;\n    return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];\n  },\n  union(b) {\n    if (b.x1 < this.x1) this.x1 = b.x1;\n    if (b.y1 < this.y1) this.y1 = b.y1;\n    if (b.x2 > this.x2) this.x2 = b.x2;\n    if (b.y2 > this.y2) this.y2 = b.y2;\n    return this;\n  },\n  intersect(b) {\n    if (b.x1 > this.x1) this.x1 = b.x1;\n    if (b.y1 > this.y1) this.y1 = b.y1;\n    if (b.x2 < this.x2) this.x2 = b.x2;\n    if (b.y2 < this.y2) this.y2 = b.y2;\n    return this;\n  },\n  encloses(b) {\n    return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;\n  },\n  alignsWith(b) {\n    return b && (this.x1 == b.x1 || this.x2 == b.x2 || this.y1 == b.y1 || this.y2 == b.y2);\n  },\n  intersects(b) {\n    return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);\n  },\n  contains(x, y) {\n    return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);\n  },\n  width() {\n    return this.x2 - this.x1;\n  },\n  height() {\n    return this.y2 - this.y1;\n  }\n};\nfunction Item(mark) {\n  this.mark = mark;\n  this.bounds = this.bounds || new Bounds();\n}\nfunction GroupItem(mark) {\n  Item.call(this, mark);\n  this.items = this.items || [];\n}\ninherits(GroupItem, Item);\nclass ResourceLoader {\n  constructor(customLoader) {\n    this._pending = 0;\n    this._loader = customLoader || loader();\n  }\n  pending() {\n    return this._pending;\n  }\n  sanitizeURL(uri) {\n    const loader = this;\n    increment(loader);\n    return loader._loader.sanitize(uri, {\n      context: 'href'\n    }).then(opt => {\n      decrement(loader);\n      return opt;\n    }).catch(() => {\n      decrement(loader);\n      return null;\n    });\n  }\n  loadImage(uri) {\n    const loader = this,\n      Image = image$1();\n    increment(loader);\n    return loader._loader.sanitize(uri, {\n      context: 'image'\n    }).then(opt => {\n      const url = opt.href;\n      if (!url || !Image) throw {\n        url: url\n      };\n      const img = new Image();\n\n      // set crossOrigin only if cors is defined; empty string sets anonymous mode\n      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/crossOrigin\n      const cors = hasOwnProperty(opt, 'crossOrigin') ? opt.crossOrigin : 'anonymous';\n      if (cors != null) img.crossOrigin = cors;\n\n      // attempt to load image resource\n      img.onload = () => decrement(loader);\n      img.onerror = () => decrement(loader);\n      img.src = url;\n      return img;\n    }).catch(e => {\n      decrement(loader);\n      return {\n        complete: false,\n        width: 0,\n        height: 0,\n        src: e && e.url || ''\n      };\n    });\n  }\n  ready() {\n    const loader = this;\n    return new Promise(accept => {\n      function poll(value) {\n        if (!loader.pending()) accept(value);else setTimeout(() => {\n          poll(true);\n        }, 10);\n      }\n      poll(false);\n    });\n  }\n}\nfunction increment(loader) {\n  loader._pending += 1;\n}\nfunction decrement(loader) {\n  loader._pending -= 1;\n}\nfunction boundStroke(bounds, item, miter) {\n  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {\n    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;\n    bounds.expand(sw + (miter ? miterAdjustment(item, sw) : 0));\n  }\n  return bounds;\n}\nfunction miterAdjustment(item, strokeWidth) {\n  // TODO: more sophisticated adjustment? Or miter support in boundContext?\n  return item.strokeJoin && item.strokeJoin !== 'miter' ? 0 : strokeWidth;\n}\nconst circleThreshold = Tau - 1e-8;\nlet bounds, lx, ly, rot, ma, mb, mc, md;\nconst add = (x, y) => bounds.add(x, y);\nconst addL = (x, y) => add(lx = x, ly = y);\nconst addX = x => add(x, bounds.y1);\nconst addY = y => add(bounds.x1, y);\nconst px = (x, y) => ma * x + mc * y;\nconst py = (x, y) => mb * x + md * y;\nconst addp = (x, y) => add(px(x, y), py(x, y));\nconst addpL = (x, y) => addL(px(x, y), py(x, y));\nfunction boundContext(_, deg) {\n  bounds = _;\n  if (deg) {\n    rot = deg * DegToRad;\n    ma = md = Math.cos(rot);\n    mb = Math.sin(rot);\n    mc = -mb;\n  } else {\n    ma = md = 1;\n    rot = mb = mc = 0;\n  }\n  return context$1;\n}\nconst context$1 = {\n  beginPath() {},\n  closePath() {},\n  moveTo: addpL,\n  lineTo: addpL,\n  rect(x, y, w, h) {\n    if (rot) {\n      addp(x + w, y);\n      addp(x + w, y + h);\n      addp(x, y + h);\n      addpL(x, y);\n    } else {\n      add(x + w, y + h);\n      addL(x, y);\n    }\n  },\n  quadraticCurveTo(x1, y1, x2, y2) {\n    const px1 = px(x1, y1),\n      py1 = py(x1, y1),\n      px2 = px(x2, y2),\n      py2 = py(x2, y2);\n    quadExtrema(lx, px1, px2, addX);\n    quadExtrema(ly, py1, py2, addY);\n    addL(px2, py2);\n  },\n  bezierCurveTo(x1, y1, x2, y2, x3, y3) {\n    const px1 = px(x1, y1),\n      py1 = py(x1, y1),\n      px2 = px(x2, y2),\n      py2 = py(x2, y2),\n      px3 = px(x3, y3),\n      py3 = py(x3, y3);\n    cubicExtrema(lx, px1, px2, px3, addX);\n    cubicExtrema(ly, py1, py2, py3, addY);\n    addL(px3, py3);\n  },\n  arc(cx, cy, r, sa, ea, ccw) {\n    sa += rot;\n    ea += rot;\n\n    // store last point on path\n    lx = r * Math.cos(ea) + cx;\n    ly = r * Math.sin(ea) + cy;\n    if (Math.abs(ea - sa) > circleThreshold) {\n      // treat as full circle\n      add(cx - r, cy - r);\n      add(cx + r, cy + r);\n    } else {\n      const update = a => add(r * Math.cos(a) + cx, r * Math.sin(a) + cy);\n      let s, i;\n\n      // sample end points\n      update(sa);\n      update(ea);\n\n      // sample interior points aligned with 90 degrees\n      if (ea !== sa) {\n        sa = sa % Tau;\n        if (sa < 0) sa += Tau;\n        ea = ea % Tau;\n        if (ea < 0) ea += Tau;\n        if (ea < sa) {\n          ccw = !ccw; // flip direction\n          s = sa;\n          sa = ea;\n          ea = s; // swap end-points\n        }\n        if (ccw) {\n          ea -= Tau;\n          s = sa - sa % HalfPi;\n          for (i = 0; i < 4 && s > ea; ++i, s -= HalfPi) update(s);\n        } else {\n          s = sa - sa % HalfPi + HalfPi;\n          for (i = 0; i < 4 && s < ea; ++i, s = s + HalfPi) update(s);\n        }\n      }\n    }\n  }\n};\nfunction quadExtrema(x0, x1, x2, cb) {\n  const t = (x0 - x1) / (x0 + x2 - 2 * x1);\n  if (0 < t && t < 1) cb(x0 + (x1 - x0) * t);\n}\nfunction cubicExtrema(x0, x1, x2, x3, cb) {\n  const a = x3 - x0 + 3 * x1 - 3 * x2,\n    b = x0 + x2 - 2 * x1,\n    c = x0 - x1;\n  let t0 = 0,\n    t1 = 0,\n    r;\n\n  // solve for parameter t\n  if (Math.abs(a) > Epsilon) {\n    // quadratic equation\n    r = b * b + c * a;\n    if (r >= 0) {\n      r = Math.sqrt(r);\n      t0 = (-b + r) / a;\n      t1 = (-b - r) / a;\n    }\n  } else {\n    // linear equation\n    t0 = 0.5 * c / b;\n  }\n\n  // calculate position\n  if (0 < t0 && t0 < 1) cb(cubic(t0, x0, x1, x2, x3));\n  if (0 < t1 && t1 < 1) cb(cubic(t1, x0, x1, x2, x3));\n}\nfunction cubic(t, x0, x1, x2, x3) {\n  const s = 1 - t,\n    s2 = s * s,\n    t2 = t * t;\n  return s2 * s * x0 + 3 * s2 * t * x1 + 3 * s * t2 * x2 + t2 * t * x3;\n}\nvar context = (context = canvas(1, 1)) ? context.getContext('2d') : null;\nconst b = new Bounds();\nfunction intersectPath(draw) {\n  return function (item, brush) {\n    // rely on (inaccurate) bounds intersection if no context\n    if (!context) return true;\n\n    // add path to offscreen graphics context\n    draw(context, item);\n\n    // get bounds intersection region\n    b.clear().union(item.bounds).intersect(brush).round();\n    const {\n      x1,\n      y1,\n      x2,\n      y2\n    } = b;\n\n    // iterate over intersection region\n    // perform fine grained inclusion test\n    for (let y = y1; y <= y2; ++y) {\n      for (let x = x1; x <= x2; ++x) {\n        if (context.isPointInPath(x, y)) {\n          return true;\n        }\n      }\n    }\n\n    // false if no hits in intersection region\n    return false;\n  };\n}\nfunction intersectPoint(item, box) {\n  return box.contains(item.x || 0, item.y || 0);\n}\nfunction intersectRect(item, box) {\n  const x = item.x || 0,\n    y = item.y || 0,\n    w = item.width || 0,\n    h = item.height || 0;\n  return box.intersects(b.set(x, y, x + w, y + h));\n}\nfunction intersectRule(item, box) {\n  const x = item.x || 0,\n    y = item.y || 0,\n    x2 = item.x2 != null ? item.x2 : x,\n    y2 = item.y2 != null ? item.y2 : y;\n  return intersectBoxLine(box, x, y, x2, y2);\n}\nfunction intersectBoxLine(box, x, y, u, v) {\n  const {\n      x1,\n      y1,\n      x2,\n      y2\n    } = box,\n    dx = u - x,\n    dy = v - y;\n  let t0 = 0,\n    t1 = 1,\n    p,\n    q,\n    r,\n    e;\n  for (e = 0; e < 4; ++e) {\n    if (e === 0) {\n      p = -dx;\n      q = -(x1 - x);\n    }\n    if (e === 1) {\n      p = dx;\n      q = x2 - x;\n    }\n    if (e === 2) {\n      p = -dy;\n      q = -(y1 - y);\n    }\n    if (e === 3) {\n      p = dy;\n      q = y2 - y;\n    }\n    if (Math.abs(p) < 1e-10 && q < 0) return false;\n    r = q / p;\n    if (p < 0) {\n      if (r > t1) return false;else if (r > t0) t0 = r;\n    } else if (p > 0) {\n      if (r < t0) return false;else if (r < t1) t1 = r;\n    }\n  }\n  return true;\n}\nfunction blend(context, item) {\n  context.globalCompositeOperation = item.blend || 'source-over';\n}\nfunction value(value, dflt) {\n  return value == null ? dflt : value;\n}\nfunction addStops(gradient, stops) {\n  const n = stops.length;\n  for (let i = 0; i < n; ++i) {\n    gradient.addColorStop(stops[i].offset, stops[i].color);\n  }\n  return gradient;\n}\nfunction gradient(context, spec, bounds) {\n  const w = bounds.width(),\n    h = bounds.height();\n  let gradient;\n  if (spec.gradient === 'radial') {\n    gradient = context.createRadialGradient(bounds.x1 + value(spec.x1, 0.5) * w, bounds.y1 + value(spec.y1, 0.5) * h, Math.max(w, h) * value(spec.r1, 0), bounds.x1 + value(spec.x2, 0.5) * w, bounds.y1 + value(spec.y2, 0.5) * h, Math.max(w, h) * value(spec.r2, 0.5));\n  } else {\n    // linear gradient\n    const x1 = value(spec.x1, 0),\n      y1 = value(spec.y1, 0),\n      x2 = value(spec.x2, 1),\n      y2 = value(spec.y2, 0);\n    if (x1 === x2 || y1 === y2 || w === h) {\n      // axis aligned: use normal gradient\n      gradient = context.createLinearGradient(bounds.x1 + x1 * w, bounds.y1 + y1 * h, bounds.x1 + x2 * w, bounds.y1 + y2 * h);\n    } else {\n      // not axis aligned: render gradient into a pattern (#2365)\n      // this allows us to use normalized bounding box coordinates\n      const image = canvas(Math.ceil(w), Math.ceil(h)),\n        ictx = image.getContext('2d');\n      ictx.scale(w, h);\n      ictx.fillStyle = addStops(ictx.createLinearGradient(x1, y1, x2, y2), spec.stops);\n      ictx.fillRect(0, 0, w, h);\n      return context.createPattern(image, 'no-repeat');\n    }\n  }\n  return addStops(gradient, spec.stops);\n}\nfunction color(context, item, value) {\n  return isGradient(value) ? gradient(context, value, item.bounds) : value;\n}\nfunction fill(context, item, opacity) {\n  opacity *= item.fillOpacity == null ? 1 : item.fillOpacity;\n  if (opacity > 0) {\n    context.globalAlpha = opacity;\n    context.fillStyle = color(context, item, item.fill);\n    return true;\n  } else {\n    return false;\n  }\n}\nvar Empty = [];\nfunction stroke(context, item, opacity) {\n  var lw = (lw = item.strokeWidth) != null ? lw : 1;\n  if (lw <= 0) return false;\n  opacity *= item.strokeOpacity == null ? 1 : item.strokeOpacity;\n  if (opacity > 0) {\n    context.globalAlpha = opacity;\n    context.strokeStyle = color(context, item, item.stroke);\n    context.lineWidth = lw;\n    context.lineCap = item.strokeCap || 'butt';\n    context.lineJoin = item.strokeJoin || 'miter';\n    context.miterLimit = item.strokeMiterLimit || 10;\n    if (context.setLineDash) {\n      context.setLineDash(item.strokeDash || Empty);\n      context.lineDashOffset = item.strokeDashOffset || 0;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction compare(a, b) {\n  return a.zindex - b.zindex || a.index - b.index;\n}\nfunction zorder(scene) {\n  if (!scene.zdirty) return scene.zitems;\n  var items = scene.items,\n    output = [],\n    item,\n    i,\n    n;\n  for (i = 0, n = items.length; i < n; ++i) {\n    item = items[i];\n    item.index = i;\n    if (item.zindex) output.push(item);\n  }\n  scene.zdirty = false;\n  return scene.zitems = output.sort(compare);\n}\nfunction visit(scene, visitor) {\n  var items = scene.items,\n    i,\n    n;\n  if (!items || !items.length) return;\n  const zitems = zorder(scene);\n  if (zitems && zitems.length) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      if (!items[i].zindex) visitor(items[i]);\n    }\n    items = zitems;\n  }\n  for (i = 0, n = items.length; i < n; ++i) {\n    visitor(items[i]);\n  }\n}\nfunction pickVisit(scene, visitor) {\n  var items = scene.items,\n    hit,\n    i;\n  if (!items || !items.length) return null;\n  const zitems = zorder(scene);\n  if (zitems && zitems.length) items = zitems;\n  for (i = items.length; --i >= 0;) {\n    if (hit = visitor(items[i])) return hit;\n  }\n  if (items === zitems) {\n    for (items = scene.items, i = items.length; --i >= 0;) {\n      if (!items[i].zindex) {\n        if (hit = visitor(items[i])) return hit;\n      }\n    }\n  }\n  return null;\n}\nfunction drawAll(path) {\n  return function (context, scene, bounds) {\n    visit(scene, item => {\n      if (!bounds || bounds.intersects(item.bounds)) {\n        drawPath(path, context, item, item);\n      }\n    });\n  };\n}\nfunction drawOne(path) {\n  return function (context, scene, bounds) {\n    if (scene.items.length && (!bounds || bounds.intersects(scene.bounds))) {\n      drawPath(path, context, scene.items[0], scene.items);\n    }\n  };\n}\nfunction drawPath(path, context, item, items) {\n  var opacity = item.opacity == null ? 1 : item.opacity;\n  if (opacity === 0) return;\n  if (path(context, items)) return;\n  blend(context, item);\n  if (item.fill && fill(context, item, opacity)) {\n    context.fill();\n  }\n  if (item.stroke && stroke(context, item, opacity)) {\n    context.stroke();\n  }\n}\nfunction pick$1(test) {\n  test = test || truthy;\n  return function (context, scene, x, y, gx, gy) {\n    x *= context.pixelRatio;\n    y *= context.pixelRatio;\n    return pickVisit(scene, item => {\n      const b = item.bounds;\n      // first hit test against bounding box\n      if (b && !b.contains(gx, gy) || !b) return;\n      // if in bounding box, perform more careful test\n      if (test(context, item, x, y, gx, gy)) return item;\n    });\n  };\n}\nfunction hitPath(path, filled) {\n  return function (context, o, x, y) {\n    var item = Array.isArray(o) ? o[0] : o,\n      fill = filled == null ? item.fill : filled,\n      stroke = item.stroke && context.isPointInStroke,\n      lw,\n      lc;\n    if (stroke) {\n      lw = item.strokeWidth;\n      lc = item.strokeCap;\n      context.lineWidth = lw != null ? lw : 1;\n      context.lineCap = lc != null ? lc : 'butt';\n    }\n    return path(context, o) ? false : fill && context.isPointInPath(x, y) || stroke && context.isPointInStroke(x, y);\n  };\n}\nfunction pickPath(path) {\n  return pick$1(hitPath(path));\n}\nfunction translate(x, y) {\n  return 'translate(' + x + ',' + y + ')';\n}\nfunction rotate(a) {\n  return 'rotate(' + a + ')';\n}\nfunction scale(scaleX, scaleY) {\n  return 'scale(' + scaleX + ',' + scaleY + ')';\n}\nfunction translateItem(item) {\n  return translate(item.x || 0, item.y || 0);\n}\nfunction rotateItem(item) {\n  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '');\n}\nfunction transformItem(item) {\n  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '') + (item.scaleX || item.scaleY ? ' ' + scale(item.scaleX || 1, item.scaleY || 1) : '');\n}\nfunction markItemPath(type, shape, isect) {\n  function attr(emit, item) {\n    emit('transform', rotateItem(item));\n    emit('d', shape(null, item));\n  }\n  function bound(bounds, item) {\n    shape(boundContext(bounds, item.angle), item);\n    return boundStroke(bounds, item).translate(item.x || 0, item.y || 0);\n  }\n  function draw(context, item) {\n    var x = item.x || 0,\n      y = item.y || 0,\n      a = item.angle || 0;\n    context.translate(x, y);\n    if (a) context.rotate(a *= DegToRad);\n    context.beginPath();\n    shape(context, item);\n    if (a) context.rotate(-a);\n    context.translate(-x, -y);\n  }\n  return {\n    type: type,\n    tag: 'path',\n    nested: false,\n    attr: attr,\n    bound: bound,\n    draw: drawAll(draw),\n    pick: pickPath(draw),\n    isect: isect || intersectPath(draw)\n  };\n}\nvar arc = markItemPath('arc', arc$1);\nfunction pickArea(a, p) {\n  var v = a[0].orient === 'horizontal' ? p[1] : p[0],\n    z = a[0].orient === 'horizontal' ? 'y' : 'x',\n    i = a.length,\n    min = +Infinity,\n    hit,\n    d;\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    d = Math.abs(a[i][z] - v);\n    if (d < min) {\n      min = d;\n      hit = a[i];\n    }\n  }\n  return hit;\n}\nfunction pickLine(a, p) {\n  var t = Math.pow(a[0].strokeWidth || 1, 2),\n    i = a.length,\n    dx,\n    dy,\n    dd;\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    dx = a[i].x - p[0];\n    dy = a[i].y - p[1];\n    dd = dx * dx + dy * dy;\n    if (dd < t) return a[i];\n  }\n  return null;\n}\nfunction pickTrail(a, p) {\n  var i = a.length,\n    dx,\n    dy,\n    dd;\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    dx = a[i].x - p[0];\n    dy = a[i].y - p[1];\n    dd = dx * dx + dy * dy;\n    dx = a[i].size || 1;\n    if (dd < dx * dx) return a[i];\n  }\n  return null;\n}\nfunction markMultiItemPath(type, shape, tip) {\n  function attr(emit, item) {\n    var items = item.mark.items;\n    if (items.length) emit('d', shape(null, items));\n  }\n  function bound(bounds, mark) {\n    var items = mark.items;\n    if (items.length === 0) {\n      return bounds;\n    } else {\n      shape(boundContext(bounds), items);\n      return boundStroke(bounds, items[0]);\n    }\n  }\n  function draw(context, items) {\n    context.beginPath();\n    shape(context, items);\n  }\n  const hit = hitPath(draw);\n  function pick(context, scene, x, y, gx, gy) {\n    var items = scene.items,\n      b = scene.bounds;\n    if (!items || !items.length || b && !b.contains(gx, gy)) {\n      return null;\n    }\n    x *= context.pixelRatio;\n    y *= context.pixelRatio;\n    return hit(context, items, x, y) ? items[0] : null;\n  }\n  return {\n    type: type,\n    tag: 'path',\n    nested: true,\n    attr: attr,\n    bound: bound,\n    draw: drawOne(draw),\n    pick: pick,\n    isect: intersectPoint,\n    tip: tip\n  };\n}\nvar area = markMultiItemPath('area', area$1, pickArea);\nfunction clip(context, scene) {\n  var clip = scene.clip;\n  context.save();\n  if (isFunction(clip)) {\n    context.beginPath();\n    clip(context);\n    context.clip();\n  } else {\n    clipGroup(context, scene.group);\n  }\n}\nfunction clipGroup(context, group) {\n  context.beginPath();\n  hasCornerRadius(group) ? rectangle(context, group, 0, 0) : context.rect(0, 0, group.width || 0, group.height || 0);\n  context.clip();\n}\nfunction offset$1(item) {\n  const sw = value(item.strokeWidth, 1);\n  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;\n}\nfunction attr$5(emit, item) {\n  emit('transform', translateItem(item));\n}\nfunction emitRectangle(emit, item) {\n  const off = offset$1(item);\n  emit('d', rectangle(null, item, off, off));\n}\nfunction background(emit, item) {\n  emit('class', 'background');\n  emit('aria-hidden', true);\n  emitRectangle(emit, item);\n}\nfunction foreground(emit, item) {\n  emit('class', 'foreground');\n  emit('aria-hidden', true);\n  if (item.strokeForeground) {\n    emitRectangle(emit, item);\n  } else {\n    emit('d', '');\n  }\n}\nfunction content(emit, item, renderer) {\n  const url = item.clip ? clip$1(renderer, item, item) : null;\n  emit('clip-path', url);\n}\nfunction bound$5(bounds, group) {\n  if (!group.clip && group.items) {\n    const items = group.items,\n      m = items.length;\n    for (let j = 0; j < m; ++j) {\n      bounds.union(items[j].bounds);\n    }\n  }\n  if ((group.clip || group.width || group.height) && !group.noBound) {\n    bounds.add(0, 0).add(group.width || 0, group.height || 0);\n  }\n  boundStroke(bounds, group);\n  return bounds.translate(group.x || 0, group.y || 0);\n}\nfunction rectanglePath(context, group, x, y) {\n  const off = offset$1(group);\n  context.beginPath();\n  rectangle(context, group, (x || 0) + off, (y || 0) + off);\n}\nconst hitBackground = hitPath(rectanglePath);\nconst hitForeground = hitPath(rectanglePath, false);\nconst hitCorner = hitPath(rectanglePath, true);\nfunction draw$4(context, scene, bounds, markTypes) {\n  visit(scene, group => {\n    const gx = group.x || 0,\n      gy = group.y || 0,\n      fore = group.strokeForeground,\n      opacity = group.opacity == null ? 1 : group.opacity;\n\n    // draw group background\n    if ((group.stroke || group.fill) && opacity) {\n      rectanglePath(context, group, gx, gy);\n      blend(context, group);\n      if (group.fill && fill(context, group, opacity)) {\n        context.fill();\n      }\n      if (group.stroke && !fore && stroke(context, group, opacity)) {\n        context.stroke();\n      }\n    }\n\n    // setup graphics context, set clip and bounds\n    context.save();\n    context.translate(gx, gy);\n    if (group.clip) clipGroup(context, group);\n    if (bounds) bounds.translate(-gx, -gy);\n\n    // draw group contents\n    visit(group, item => {\n      if (item.marktype === 'group' || markTypes == null || markTypes.includes(item.marktype)) {\n        this.draw(context, item, bounds, markTypes);\n      }\n    });\n\n    // restore graphics context\n    if (bounds) bounds.translate(gx, gy);\n    context.restore();\n\n    // draw group foreground\n    if (fore && group.stroke && opacity) {\n      rectanglePath(context, group, gx, gy);\n      blend(context, group);\n      if (stroke(context, group, opacity)) {\n        context.stroke();\n      }\n    }\n  });\n}\nfunction pick(context, scene, x, y, gx, gy) {\n  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {\n    return null;\n  }\n  const cx = x * context.pixelRatio,\n    cy = y * context.pixelRatio;\n  return pickVisit(scene, group => {\n    let hit, dx, dy;\n\n    // first hit test bounding box\n    const b = group.bounds;\n    if (b && !b.contains(gx, gy)) return;\n\n    // passed bounds check, test rectangular clip\n    dx = group.x || 0;\n    dy = group.y || 0;\n    const dw = dx + (group.width || 0),\n      dh = dy + (group.height || 0),\n      c = group.clip;\n    if (c && (gx < dx || gx > dw || gy < dy || gy > dh)) return;\n\n    // adjust coordinate system\n    context.save();\n    context.translate(dx, dy);\n    dx = gx - dx;\n    dy = gy - dy;\n\n    // test background for rounded corner clip\n    if (c && hasCornerRadius(group) && !hitCorner(context, group, cx, cy)) {\n      context.restore();\n      return null;\n    }\n    const fore = group.strokeForeground,\n      ix = scene.interactive !== false;\n\n    // hit test against group foreground\n    if (ix && fore && group.stroke && hitForeground(context, group, cx, cy)) {\n      context.restore();\n      return group;\n    }\n\n    // hit test against contained marks\n    hit = pickVisit(group, mark => pickMark(mark, dx, dy) ? this.pick(mark, x, y, dx, dy) : null);\n\n    // hit test against group background\n    if (!hit && ix && (group.fill || !fore && group.stroke) && hitBackground(context, group, cx, cy)) {\n      hit = group;\n    }\n\n    // restore state and return\n    context.restore();\n    return hit || null;\n  });\n}\nfunction pickMark(mark, x, y) {\n  return (mark.interactive !== false || mark.marktype === 'group') && mark.bounds && mark.bounds.contains(x, y);\n}\nvar group = {\n  type: 'group',\n  tag: 'g',\n  nested: false,\n  attr: attr$5,\n  bound: bound$5,\n  draw: draw$4,\n  pick: pick,\n  isect: intersectRect,\n  content: content,\n  background: background,\n  foreground: foreground\n};\nvar metadata = {\n  'xmlns': 'http://www.w3.org/2000/svg',\n  'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n  'version': '1.1'\n};\nfunction getImage(item, renderer) {\n  var image = item.image;\n  if (!image || item.url && item.url !== image.url) {\n    image = {\n      complete: false,\n      width: 0,\n      height: 0\n    };\n    renderer.loadImage(item.url).then(image => {\n      item.image = image;\n      item.image.url = item.url;\n    });\n  }\n  return image;\n}\nfunction imageWidth(item, image) {\n  return item.width != null ? item.width : !image || !image.width ? 0 : item.aspect !== false && item.height ? item.height * image.width / image.height : image.width;\n}\nfunction imageHeight(item, image) {\n  return item.height != null ? item.height : !image || !image.height ? 0 : item.aspect !== false && item.width ? item.width * image.height / image.width : image.height;\n}\nfunction imageXOffset(align, w) {\n  return align === 'center' ? w / 2 : align === 'right' ? w : 0;\n}\nfunction imageYOffset(baseline, h) {\n  return baseline === 'middle' ? h / 2 : baseline === 'bottom' ? h : 0;\n}\nfunction attr$4(emit, item, renderer) {\n  const img = getImage(item, renderer),\n    w = imageWidth(item, img),\n    h = imageHeight(item, img),\n    x = (item.x || 0) - imageXOffset(item.align, w),\n    y = (item.y || 0) - imageYOffset(item.baseline, h),\n    i = !img.src && img.toDataURL ? img.toDataURL() : img.src || '';\n  emit('href', i, metadata['xmlns:xlink'], 'xlink:href');\n  emit('transform', translate(x, y));\n  emit('width', w);\n  emit('height', h);\n  emit('preserveAspectRatio', item.aspect === false ? 'none' : 'xMidYMid');\n}\nfunction bound$4(bounds, item) {\n  const img = item.image,\n    w = imageWidth(item, img),\n    h = imageHeight(item, img),\n    x = (item.x || 0) - imageXOffset(item.align, w),\n    y = (item.y || 0) - imageYOffset(item.baseline, h);\n  return bounds.set(x, y, x + w, y + h);\n}\nfunction draw$3(context, scene, bounds) {\n  visit(scene, item => {\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n\n    const img = getImage(item, this);\n    let w = imageWidth(item, img);\n    let h = imageHeight(item, img);\n    if (w === 0 || h === 0) return; // early exit\n\n    let x = (item.x || 0) - imageXOffset(item.align, w),\n      y = (item.y || 0) - imageYOffset(item.baseline, h),\n      opacity,\n      ar0,\n      ar1,\n      t;\n    if (item.aspect !== false) {\n      ar0 = img.width / img.height;\n      ar1 = item.width / item.height;\n      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {\n        if (ar1 < ar0) {\n          t = w / ar0;\n          y += (h - t) / 2;\n          h = t;\n        } else {\n          t = h * ar0;\n          x += (w - t) / 2;\n          w = t;\n        }\n      }\n    }\n    if (img.complete || img.toDataURL) {\n      blend(context, item);\n      context.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;\n      context.imageSmoothingEnabled = item.smooth !== false;\n      context.drawImage(img, x, y, w, h);\n    }\n  });\n}\nvar image = {\n  type: 'image',\n  tag: 'image',\n  nested: false,\n  attr: attr$4,\n  bound: bound$4,\n  draw: draw$3,\n  pick: pick$1(),\n  isect: truthy,\n  // bounds check is sufficient\n  get: getImage,\n  xOffset: imageXOffset,\n  yOffset: imageYOffset\n};\nvar line = markMultiItemPath('line', line$1, pickLine);\nfunction attr$3(emit, item) {\n  var sx = item.scaleX || 1,\n    sy = item.scaleY || 1;\n  if (sx !== 1 || sy !== 1) {\n    emit('vector-effect', 'non-scaling-stroke');\n  }\n  emit('transform', transformItem(item));\n  emit('d', item.path);\n}\nfunction path$1(context, item) {\n  var path = item.path;\n  if (path == null) return true;\n  var x = item.x || 0,\n    y = item.y || 0,\n    sx = item.scaleX || 1,\n    sy = item.scaleY || 1,\n    a = (item.angle || 0) * DegToRad,\n    cache = item.pathCache;\n  if (!cache || cache.path !== path) {\n    (item.pathCache = cache = parse(path)).path = path;\n  }\n  if (a && context.rotate && context.translate) {\n    context.translate(x, y);\n    context.rotate(a);\n    pathRender(context, cache, 0, 0, sx, sy);\n    context.rotate(-a);\n    context.translate(-x, -y);\n  } else {\n    pathRender(context, cache, x, y, sx, sy);\n  }\n}\nfunction bound$3(bounds, item) {\n  return path$1(boundContext(bounds, item.angle), item) ? bounds.set(0, 0, 0, 0) : boundStroke(bounds, item, true);\n}\nvar path$2 = {\n  type: 'path',\n  tag: 'path',\n  nested: false,\n  attr: attr$3,\n  bound: bound$3,\n  draw: drawAll(path$1),\n  pick: pickPath(path$1),\n  isect: intersectPath(path$1)\n};\nfunction attr$2(emit, item) {\n  emit('d', rectangle(null, item));\n}\nfunction bound$2(bounds, item) {\n  var x, y;\n  return boundStroke(bounds.set(x = item.x || 0, y = item.y || 0, x + item.width || 0, y + item.height || 0), item);\n}\nfunction draw$2(context, item) {\n  context.beginPath();\n  rectangle(context, item);\n}\nvar rect = {\n  type: 'rect',\n  tag: 'path',\n  nested: false,\n  attr: attr$2,\n  bound: bound$2,\n  draw: drawAll(draw$2),\n  pick: pickPath(draw$2),\n  isect: intersectRect\n};\nfunction attr$1(emit, item) {\n  emit('transform', translateItem(item));\n  emit('x2', item.x2 != null ? item.x2 - (item.x || 0) : 0);\n  emit('y2', item.y2 != null ? item.y2 - (item.y || 0) : 0);\n}\nfunction bound$1(bounds, item) {\n  var x1, y1;\n  return boundStroke(bounds.set(x1 = item.x || 0, y1 = item.y || 0, item.x2 != null ? item.x2 : x1, item.y2 != null ? item.y2 : y1), item);\n}\nfunction path(context, item, opacity) {\n  var x1, y1, x2, y2;\n  if (item.stroke && stroke(context, item, opacity)) {\n    x1 = item.x || 0;\n    y1 = item.y || 0;\n    x2 = item.x2 != null ? item.x2 : x1;\n    y2 = item.y2 != null ? item.y2 : y1;\n    context.beginPath();\n    context.moveTo(x1, y1);\n    context.lineTo(x2, y2);\n    return true;\n  }\n  return false;\n}\nfunction draw$1(context, scene, bounds) {\n  visit(scene, item => {\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n    var opacity = item.opacity == null ? 1 : item.opacity;\n    if (opacity && path(context, item, opacity)) {\n      blend(context, item);\n      context.stroke();\n    }\n  });\n}\nfunction hit$1(context, item, x, y) {\n  if (!context.isPointInStroke) return false;\n  return path(context, item, 1) && context.isPointInStroke(x, y);\n}\nvar rule = {\n  type: 'rule',\n  tag: 'line',\n  nested: false,\n  attr: attr$1,\n  bound: bound$1,\n  draw: draw$1,\n  pick: pick$1(hit$1),\n  isect: intersectRule\n};\nvar shape = markItemPath('shape', shape$1);\nvar symbol = markItemPath('symbol', symbol$1, intersectPoint);\n\n// memoize text width measurement\nconst widthCache = lruCache();\nvar textMetrics = {\n  height: fontSize,\n  measureWidth: measureWidth,\n  estimateWidth: estimateWidth,\n  width: estimateWidth,\n  canvas: useCanvas\n};\nuseCanvas(true);\nfunction useCanvas(use) {\n  textMetrics.width = use && context ? measureWidth : estimateWidth;\n}\n\n// make simple estimate if no canvas is available\nfunction estimateWidth(item, text) {\n  return _estimateWidth(textValue(item, text), fontSize(item));\n}\nfunction _estimateWidth(text, currentFontHeight) {\n  return ~~(0.8 * text.length * currentFontHeight);\n}\n\n// measure text width if canvas is available\nfunction measureWidth(item, text) {\n  return fontSize(item) <= 0 || !(text = textValue(item, text)) ? 0 : _measureWidth(text, font(item));\n}\nfunction _measureWidth(text, currentFont) {\n  const key = `(${currentFont}) ${text}`;\n  let width = widthCache.get(key);\n  if (width === undefined) {\n    context.font = currentFont;\n    width = context.measureText(text).width;\n    widthCache.set(key, width);\n  }\n  return width;\n}\nfunction fontSize(item) {\n  return item.fontSize != null ? +item.fontSize || 0 : 11;\n}\nfunction lineHeight(item) {\n  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;\n}\nfunction lineArray(_) {\n  return isArray(_) ? _.length > 1 ? _ : _[0] : _;\n}\nfunction textLines(item) {\n  return lineArray(item.lineBreak && item.text && !isArray(item.text) ? item.text.split(item.lineBreak) : item.text);\n}\nfunction multiLineOffset(item) {\n  const tl = textLines(item);\n  return (isArray(tl) ? tl.length - 1 : 0) * lineHeight(item);\n}\nfunction textValue(item, line) {\n  const text = line == null ? '' : (line + '').trim();\n  return item.limit > 0 && text.length ? truncate(item, text) : text;\n}\nfunction widthGetter(item) {\n  if (textMetrics.width === measureWidth) {\n    // we are using canvas\n    const currentFont = font(item);\n    return text => _measureWidth(text, currentFont);\n  } else if (textMetrics.width === estimateWidth) {\n    // we are relying on estimates\n    const currentFontHeight = fontSize(item);\n    return text => _estimateWidth(text, currentFontHeight);\n  } else {\n    // User defined textMetrics.width function in use (e.g. vl-convert)\n    return text => textMetrics.width(item, text);\n  }\n}\nfunction truncate(item, text) {\n  var limit = +item.limit,\n    width = widthGetter(item);\n  if (width(text) < limit) return text;\n  var ellipsis = item.ellipsis || '\\u2026',\n    rtl = item.dir === 'rtl',\n    lo = 0,\n    hi = text.length,\n    mid;\n  limit -= width(ellipsis);\n  if (rtl) {\n    while (lo < hi) {\n      mid = lo + hi >>> 1;\n      if (width(text.slice(mid)) > limit) lo = mid + 1;else hi = mid;\n    }\n    return ellipsis + text.slice(lo);\n  } else {\n    while (lo < hi) {\n      mid = 1 + (lo + hi >>> 1);\n      if (width(text.slice(0, mid)) < limit) lo = mid;else hi = mid - 1;\n    }\n    return text.slice(0, lo) + ellipsis;\n  }\n}\nfunction fontFamily(item, quote) {\n  var font = item.font;\n  return (quote && font ? String(font).replace(/\"/g, '\\'') : font) || 'sans-serif';\n}\nfunction font(item, quote) {\n  return '' + (item.fontStyle ? item.fontStyle + ' ' : '') + (item.fontVariant ? item.fontVariant + ' ' : '') + (item.fontWeight ? item.fontWeight + ' ' : '') + fontSize(item) + 'px ' + fontFamily(item, quote);\n}\nfunction offset(item) {\n  // perform our own font baseline calculation\n  // why? not all browsers support SVG 1.1 'alignment-baseline' :(\n  // this also ensures consistent layout across renderers\n  var baseline = item.baseline,\n    h = fontSize(item);\n  return Math.round(baseline === 'top' ? 0.79 * h : baseline === 'middle' ? 0.30 * h : baseline === 'bottom' ? -0.21 * h : baseline === 'line-top' ? 0.29 * h + 0.5 * lineHeight(item) : baseline === 'line-bottom' ? 0.29 * h - 0.5 * lineHeight(item) : 0);\n}\nconst textAlign = {\n  'left': 'start',\n  'center': 'middle',\n  'right': 'end'\n};\nconst tempBounds = new Bounds();\nfunction anchorPoint(item) {\n  var x = item.x || 0,\n    y = item.y || 0,\n    r = item.radius || 0,\n    t;\n  if (r) {\n    t = (item.theta || 0) - HalfPi;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n  tempBounds.x1 = x;\n  tempBounds.y1 = y;\n  return tempBounds;\n}\nfunction attr(emit, item) {\n  var dx = item.dx || 0,\n    dy = (item.dy || 0) + offset(item),\n    p = anchorPoint(item),\n    x = p.x1,\n    y = p.y1,\n    a = item.angle || 0,\n    t;\n  emit('text-anchor', textAlign[item.align] || 'start');\n  if (a) {\n    t = translate(x, y) + ' ' + rotate(a);\n    if (dx || dy) t += ' ' + translate(dx, dy);\n  } else {\n    t = translate(x + dx, y + dy);\n  }\n  emit('transform', t);\n}\nfunction bound(bounds, item, mode) {\n  var h = textMetrics.height(item),\n    a = item.align,\n    p = anchorPoint(item),\n    x = p.x1,\n    y = p.y1,\n    dx = item.dx || 0,\n    dy = (item.dy || 0) + offset(item) - Math.round(0.8 * h),\n    // use 4/5 offset\n    tl = textLines(item),\n    w;\n\n  // get dimensions\n  if (isArray(tl)) {\n    // multi-line text\n    h += lineHeight(item) * (tl.length - 1);\n    w = tl.reduce((w, t) => Math.max(w, textMetrics.width(item, t)), 0);\n  } else {\n    // single-line text\n    w = textMetrics.width(item, tl);\n  }\n\n  // horizontal alignment\n  if (a === 'center') {\n    dx -= w / 2;\n  } else if (a === 'right') {\n    dx -= w;\n  } else ;\n  bounds.set(dx += x, dy += y, dx + w, dy + h);\n  if (item.angle && !mode) {\n    bounds.rotate(item.angle * DegToRad, x, y);\n  } else if (mode === 2) {\n    return bounds.rotatedPoints(item.angle * DegToRad, x, y);\n  }\n  return bounds;\n}\nfunction draw(context, scene, bounds) {\n  visit(scene, item => {\n    var opacity = item.opacity == null ? 1 : item.opacity,\n      p,\n      x,\n      y,\n      i,\n      lh,\n      tl,\n      str;\n    if (bounds && !bounds.intersects(item.bounds) ||\n    // bounds check\n    opacity === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0) return;\n    context.font = font(item);\n    context.textAlign = item.align || 'left';\n    p = anchorPoint(item);\n    x = p.x1, y = p.y1;\n    if (item.angle) {\n      context.save();\n      context.translate(x, y);\n      context.rotate(item.angle * DegToRad);\n      x = y = 0; // reset x, y\n    }\n    x += item.dx || 0;\n    y += (item.dy || 0) + offset(item);\n    tl = textLines(item);\n    blend(context, item);\n    if (isArray(tl)) {\n      lh = lineHeight(item);\n      for (i = 0; i < tl.length; ++i) {\n        str = textValue(item, tl[i]);\n        if (item.fill && fill(context, item, opacity)) {\n          context.fillText(str, x, y);\n        }\n        if (item.stroke && stroke(context, item, opacity)) {\n          context.strokeText(str, x, y);\n        }\n        y += lh;\n      }\n    } else {\n      str = textValue(item, tl);\n      if (item.fill && fill(context, item, opacity)) {\n        context.fillText(str, x, y);\n      }\n      if (item.stroke && stroke(context, item, opacity)) {\n        context.strokeText(str, x, y);\n      }\n    }\n    if (item.angle) context.restore();\n  });\n}\nfunction hit(context, item, x, y, gx, gy) {\n  if (item.fontSize <= 0) return false;\n  if (!item.angle) return true; // bounds sufficient if no rotation\n\n  // project point into space of unrotated bounds\n  var p = anchorPoint(item),\n    ax = p.x1,\n    ay = p.y1,\n    b = bound(tempBounds, item, 1),\n    a = -item.angle * DegToRad,\n    cos = Math.cos(a),\n    sin = Math.sin(a),\n    px = cos * gx - sin * gy + (ax - cos * ax + sin * ay),\n    py = sin * gx + cos * gy + (ay - sin * ax - cos * ay);\n  return b.contains(px, py);\n}\nfunction intersectText(item, box) {\n  const p = bound(tempBounds, item, 2);\n  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);\n}\nvar text = {\n  type: 'text',\n  tag: 'text',\n  nested: false,\n  attr: attr,\n  bound: bound,\n  draw: draw,\n  pick: pick$1(hit),\n  isect: intersectText\n};\nvar trail = markMultiItemPath('trail', trail$1, pickTrail);\nvar Marks = {\n  arc: arc,\n  area: area,\n  group: group,\n  image: image,\n  line: line,\n  path: path$2,\n  rect: rect,\n  rule: rule,\n  shape: shape,\n  symbol: symbol,\n  text: text,\n  trail: trail\n};\nfunction boundItem(item, func, opt) {\n  var type = Marks[item.mark.marktype],\n    bound = func || type.bound;\n  if (type.nested) item = item.mark;\n  return bound(item.bounds || (item.bounds = new Bounds()), item, opt);\n}\nvar DUMMY = {\n  mark: null\n};\nfunction boundMark(mark, bounds, opt) {\n  var type = Marks[mark.marktype],\n    bound = type.bound,\n    items = mark.items,\n    hasItems = items && items.length,\n    i,\n    n,\n    item,\n    b;\n  if (type.nested) {\n    if (hasItems) {\n      item = items[0];\n    } else {\n      // no items, fake it\n      DUMMY.mark = mark;\n      item = DUMMY;\n    }\n    b = boundItem(item, bound, opt);\n    bounds = bounds && bounds.union(b) || b;\n    return bounds;\n  }\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n  if (hasItems) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      bounds.union(boundItem(items[i], bound, opt));\n    }\n  }\n  return mark.bounds = bounds;\n}\nconst keys = ['marktype', 'name', 'role', 'interactive', 'clip', 'items', 'zindex', 'x', 'y', 'width', 'height', 'align', 'baseline',\n// layout\n'fill', 'fillOpacity', 'opacity', 'blend',\n// fill\n'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap',\n// stroke\n'strokeDash', 'strokeDashOffset',\n// stroke dash\n'strokeForeground', 'strokeOffset',\n// group\n'startAngle', 'endAngle', 'innerRadius', 'outerRadius',\n// arc\n'cornerRadius', 'padAngle',\n// arc, rect\n'cornerRadiusTopLeft', 'cornerRadiusTopRight',\n// rect, group\n'cornerRadiusBottomLeft', 'cornerRadiusBottomRight', 'interpolate', 'tension', 'orient', 'defined',\n// area, line\n'url', 'aspect', 'smooth',\n// image\n'path', 'scaleX', 'scaleY',\n// path\n'x2', 'y2',\n// rule\n'size', 'shape',\n// symbol\n'text', 'angle', 'theta', 'radius', 'dir', 'dx', 'dy',\n// text\n'ellipsis', 'limit', 'lineBreak', 'lineHeight', 'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant',\n// font\n'description', 'aria', 'ariaRole', 'ariaRoleDescription' // aria\n];\nfunction sceneToJSON(scene, indent) {\n  return JSON.stringify(scene, keys, indent);\n}\nfunction sceneFromJSON(json) {\n  const scene = typeof json === 'string' ? JSON.parse(json) : json;\n  return initialize(scene);\n}\nfunction initialize(scene) {\n  var type = scene.marktype,\n    items = scene.items,\n    parent,\n    i,\n    n;\n  if (items) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      parent = type ? 'mark' : 'group';\n      items[i][parent] = scene;\n      if (items[i].zindex) items[i][parent].zdirty = true;\n      if ('group' === (type || parent)) initialize(items[i]);\n    }\n  }\n  if (type) boundMark(scene);\n  return scene;\n}\nclass Scenegraph {\n  constructor(scene) {\n    if (arguments.length) {\n      this.root = sceneFromJSON(scene);\n    } else {\n      this.root = createMark({\n        marktype: 'group',\n        name: 'root',\n        role: 'frame'\n      });\n      this.root.items = [new GroupItem(this.root)];\n    }\n  }\n  toJSON(indent) {\n    return sceneToJSON(this.root, indent || 0);\n  }\n  mark(markdef, group, index) {\n    group = group || this.root.items[0];\n    const mark = createMark(markdef, group);\n    group.items[index] = mark;\n    if (mark.zindex) mark.group.zdirty = true;\n    return mark;\n  }\n}\nfunction createMark(def, group) {\n  const mark = {\n    bounds: new Bounds(),\n    clip: !!def.clip,\n    group: group,\n    interactive: def.interactive === false ? false : true,\n    items: [],\n    marktype: def.marktype,\n    name: def.name || undefined,\n    role: def.role || undefined,\n    zindex: def.zindex || 0\n  };\n\n  // add accessibility properties if defined\n  if (def.aria != null) {\n    mark.aria = def.aria;\n  }\n  if (def.description) {\n    mark.description = def.description;\n  }\n  return mark;\n}\n\n// create a new DOM element\nfunction domCreate(doc, tag, ns) {\n  if (!doc && typeof document !== 'undefined' && document.createElement) {\n    doc = document;\n  }\n  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;\n}\n\n// find first child element with matching tag\nfunction domFind(el, tag) {\n  tag = tag.toLowerCase();\n  var nodes = el.childNodes,\n    i = 0,\n    n = nodes.length;\n  for (; i < n; ++i) if (nodes[i].tagName.toLowerCase() === tag) {\n    return nodes[i];\n  }\n}\n\n// retrieve child element at given index\n// create & insert if doesn't exist or if tags do not match\nfunction domChild(el, index, tag, ns) {\n  var a = el.childNodes[index],\n    b;\n  if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {\n    b = a || null;\n    a = domCreate(el.ownerDocument, tag, ns);\n    el.insertBefore(a, b);\n  }\n  return a;\n}\n\n// remove all child elements at or above the given index\nfunction domClear(el, index) {\n  var nodes = el.childNodes,\n    curr = nodes.length;\n  while (curr > index) el.removeChild(nodes[--curr]);\n  return el;\n}\n\n// generate css class name for mark\nfunction cssClass(mark) {\n  return 'mark-' + mark.marktype + (mark.role ? ' role-' + mark.role : '') + (mark.name ? ' ' + mark.name : '');\n}\nfunction point(event, el) {\n  const rect = el.getBoundingClientRect();\n  return [event.clientX - rect.left - (el.clientLeft || 0), event.clientY - rect.top - (el.clientTop || 0)];\n}\nfunction resolveItem(item, event, el, origin) {\n  var mark = item && item.mark,\n    mdef,\n    p;\n  if (mark && (mdef = Marks[mark.marktype]).tip) {\n    p = point(event, el);\n    p[0] -= origin[0];\n    p[1] -= origin[1];\n    while (item = item.mark.group) {\n      p[0] -= item.x || 0;\n      p[1] -= item.y || 0;\n    }\n    item = mdef.tip(mark.items, p);\n  }\n  return item;\n}\nclass Handler {\n  /**\n   * Create a new Handler instance.\n   * @param {object} [customLoader] - Optional loader instance for\n   *   href URL sanitization. If not specified, a standard loader\n   *   instance will be generated.\n   * @param {function} [customTooltip] - Optional tooltip handler\n   *   function for custom tooltip display.\n   * @constructor\n   */\n  constructor(customLoader, customTooltip) {\n    this._active = null;\n    this._handlers = {};\n    this._loader = customLoader || loader();\n    this._tooltip = customTooltip || defaultTooltip;\n  }\n\n  /**\n   * Initialize a new Handler instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {object} [obj] - Optional context object that should serve as\n   *   the \"this\" context for event callbacks.\n   * @return {Handler} - This handler instance.\n   */\n  initialize(el, origin, obj) {\n    this._el = el;\n    this._obj = obj || null;\n    return this.origin(origin);\n  }\n\n  /**\n   * Returns the parent container element for a visualization.\n   * @return {DOMElement} - The containing DOM element.\n   */\n  element() {\n    return this._el;\n  }\n\n  /**\n   * Returns the scene element (e.g., canvas or SVG) of the visualization\n   * Subclasses must override if the first child is not the scene element.\n   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n   */\n  canvas() {\n    return this._el && this._el.firstChild;\n  }\n\n  /**\n   * Get / set the origin coordinates of the visualization.\n   */\n  origin(origin) {\n    if (arguments.length) {\n      this._origin = origin || [0, 0];\n      return this;\n    } else {\n      return this._origin.slice();\n    }\n  }\n\n  /**\n   * Get / set the scenegraph root.\n   */\n  scene(scene) {\n    if (!arguments.length) return this._scene;\n    this._scene = scene;\n    return this;\n  }\n\n  /**\n   * Add an event handler. Subclasses should override this method.\n   */\n  on(/*type, handler*/) {}\n\n  /**\n   * Remove an event handler. Subclasses should override this method.\n   */\n  off(/*type, handler*/) {}\n\n  /**\n   * Utility method for finding the array index of an event handler.\n   * @param {Array} h - An array of registered event handlers.\n   * @param {string} type - The event type.\n   * @param {function} handler - The event handler instance to find.\n   * @return {number} - The handler's array index or -1 if not registered.\n   */\n  _handlerIndex(h, type, handler) {\n    for (let i = h ? h.length : 0; --i >= 0;) {\n      if (h[i].type === type && (!handler || h[i].handler === handler)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns an array with registered event handlers.\n   * @param {string} [type] - The event type to query. Any annotations\n   *   are ignored; for example, for the argument \"click.foo\", \".foo\" will\n   *   be ignored and the method returns all \"click\" handlers. If type is\n   *   null or unspecified, this method returns handlers for all types.\n   * @return {Array} - A new array containing all registered event handlers.\n   */\n  handlers(type) {\n    const h = this._handlers,\n      a = [];\n    if (type) {\n      a.push(...h[this.eventName(type)]);\n    } else {\n      for (const k in h) {\n        a.push(...h[k]);\n      }\n    }\n    return a;\n  }\n\n  /**\n   * Parses an event name string to return the specific event type.\n   * For example, given \"click.foo\" returns \"click\"\n   * @param {string} name - The input event type string.\n   * @return {string} - A string with the event type only.\n   */\n  eventName(name) {\n    const i = name.indexOf('.');\n    return i < 0 ? name : name.slice(0, i);\n  }\n\n  /**\n   * Handle hyperlink navigation in response to an item.href value.\n   * @param {Event} event - The event triggering hyperlink navigation.\n   * @param {Item} item - The scenegraph item.\n   * @param {string} href - The URL to navigate to.\n   */\n  handleHref(event, item, href) {\n    this._loader.sanitize(href, {\n      context: 'href'\n    }).then(opt => {\n      const e = new MouseEvent(event.type, event),\n        a = domCreate(null, 'a');\n      for (const name in opt) a.setAttribute(name, opt[name]);\n      a.dispatchEvent(e);\n    }).catch(() => {});\n  }\n\n  /**\n   * Handle tooltip display in response to an item.tooltip value.\n   * @param {Event} event - The event triggering tooltip display.\n   * @param {Item} item - The scenegraph item.\n   * @param {boolean} show - A boolean flag indicating whether\n   *   to show or hide a tooltip for the given item.\n   */\n  handleTooltip(event, item, show) {\n    if (item && item.tooltip != null) {\n      item = resolveItem(item, event, this.canvas(), this._origin);\n      const value = show && item && item.tooltip || null;\n      this._tooltip.call(this._obj, this, event, item, value);\n    }\n  }\n\n  /**\n   * Returns the size of a scenegraph item and its position relative\n   * to the viewport.\n   * @param {Item} item - The scenegraph item.\n   * @return {object} - A bounding box object (compatible with the\n   *   DOMRect type) consisting of x, y, width, heigh, top, left,\n   *   right, and bottom properties.\n   */\n  getItemBoundingClientRect(item) {\n    const el = this.canvas();\n    if (!el) return;\n    const rect = el.getBoundingClientRect(),\n      origin = this._origin,\n      bounds = item.bounds,\n      width = bounds.width(),\n      height = bounds.height();\n    let x = bounds.x1 + origin[0] + rect.left,\n      y = bounds.y1 + origin[1] + rect.top;\n\n    // translate coordinate for each parent group\n    while (item.mark && (item = item.mark.group)) {\n      x += item.x || 0;\n      y += item.y || 0;\n    }\n\n    // return DOMRect-compatible bounding box\n    return {\n      x,\n      y,\n      width,\n      height,\n      left: x,\n      top: y,\n      right: x + width,\n      bottom: y + height\n    };\n  }\n}\n\n// The default tooltip display handler.\n// Sets the HTML title attribute on the visualization container.\nfunction defaultTooltip(handler, event, item, value) {\n  handler.element().setAttribute('title', value || '');\n}\nclass Renderer {\n  /**\n   * Create a new Renderer instance.\n   * @param {object} [loader] - Optional loader instance for\n   *   image and href URL sanitization. If not specified, a\n   *   standard loader instance will be generated.\n   * @constructor\n   */\n  constructor(loader) {\n    this._el = null;\n    this._bgcolor = null;\n    this._loader = new ResourceLoader(loader);\n  }\n\n  /**\n   * Initialize a new Renderer instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {number} width - The coordinate width of the display, in pixels.\n   * @param {number} height - The coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {Renderer} - This renderer instance.\n   */\n  initialize(el, width, height, origin, scaleFactor) {\n    this._el = el;\n    return this.resize(width, height, origin, scaleFactor);\n  }\n\n  /**\n   * Returns the parent container element for a visualization.\n   * @return {DOMElement} - The containing DOM element.\n   */\n  element() {\n    return this._el;\n  }\n\n  /**\n   * Returns the scene element (e.g., canvas or SVG) of the visualization\n   * Subclasses must override if the first child is not the scene element.\n   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n   */\n  canvas() {\n    return this._el && this._el.firstChild;\n  }\n\n  /**\n   * Get / set the background color.\n   */\n  background(bgcolor) {\n    if (arguments.length === 0) return this._bgcolor;\n    this._bgcolor = bgcolor;\n    return this;\n  }\n\n  /**\n   * Resize the display.\n   * @param {number} width - The new coordinate width of the display, in pixels.\n   * @param {number} height - The new coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The new origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {Renderer} - This renderer instance;\n   */\n  resize(width, height, origin, scaleFactor) {\n    this._width = width;\n    this._height = height;\n    this._origin = origin || [0, 0];\n    this._scale = scaleFactor || 1;\n    return this;\n  }\n\n  /**\n   * Report a dirty item whose bounds should be redrawn.\n   * This base class method does nothing. Subclasses that perform\n   * incremental should implement this method.\n   * @param {Item} item - The dirty item whose bounds should be redrawn.\n   */\n  dirty(/*item*/) {}\n\n  /**\n   * Render an input scenegraph, potentially with a set of dirty items.\n   * This method will perform an immediate rendering with available resources.\n   * The renderer may also need to perform image loading to perform a complete\n   * render. This process can lead to asynchronous re-rendering of the scene\n   * after this method returns. To receive notification when rendering is\n   * complete, use the renderAsync method instead.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @param {Array} markTypes - Array of the mark types to render.\n   *                            If undefined, render all mark types\n   * @return {Renderer} - This renderer instance.\n   */\n  render(scene, markTypes) {\n    const r = this;\n\n    // bind arguments into a render call, and cache it\n    // this function may be subsequently called for async redraw\n    r._call = function () {\n      r._render(scene, markTypes);\n    };\n\n    // invoke the renderer\n    r._call();\n\n    // clear the cached call for garbage collection\n    // async redraws will stash their own copy\n    r._call = null;\n    return r;\n  }\n\n  /**\n   * Internal rendering method. Renderer subclasses should override this\n   * method to actually perform rendering.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @param {Array} markTypes - Array of the mark types to render.\n   *                            If undefined, render all mark types\n   */\n  _render(/*scene, markTypes*/\n  ) {\n    // subclasses to override\n  }\n\n  /**\n   * Asynchronous rendering method. Similar to render, but returns a Promise\n   * that resolves when all rendering is completed. Sometimes a renderer must\n   * perform image loading to get a complete rendering. The returned\n   * Promise will not resolve until this process completes.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @param {Array} markTypes - Array of the mark types to render.\n   *                            If undefined, render all mark types\n   * @return {Promise} - A Promise that resolves when rendering is complete.\n   */\n  renderAsync(scene, markTypes) {\n    const r = this.render(scene, markTypes);\n    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);\n  }\n\n  /**\n   * Internal method for asynchronous resource loading.\n   * Proxies method calls to the ImageLoader, and tracks loading\n   * progress to invoke a re-render once complete.\n   * @param {string} method - The method name to invoke on the ImageLoader.\n   * @param {string} uri - The URI for the requested resource.\n   * @return {Promise} - A Promise that resolves to the requested resource.\n   */\n  _load(method, uri) {\n    var r = this,\n      p = r._loader[method](uri);\n    if (!r._ready) {\n      // re-render the scene when loading completes\n      const call = r._call;\n      r._ready = r._loader.ready().then(redraw => {\n        if (redraw) call();\n        r._ready = null;\n      });\n    }\n    return p;\n  }\n\n  /**\n   * Sanitize a URL to include as a hyperlink in the rendered scene.\n   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks\n   * image loading progress and invokes a re-render once complete.\n   * @param {string} uri - The URI string to sanitize.\n   * @return {Promise} - A Promise that resolves to the sanitized URL.\n   */\n  sanitizeURL(uri) {\n    return this._load('sanitizeURL', uri);\n  }\n\n  /**\n   * Requests an image to include in the rendered scene.\n   * This method proxies a call to ImageLoader.loadImage, but also tracks\n   * image loading progress and invokes a re-render once complete.\n   * @param {string} uri - The URI string of the image.\n   * @return {Promise} - A Promise that resolves to the loaded Image.\n   */\n  loadImage(uri) {\n    return this._load('loadImage', uri);\n  }\n}\nconst KeyDownEvent = 'keydown';\nconst KeyPressEvent = 'keypress';\nconst KeyUpEvent = 'keyup';\nconst DragEnterEvent = 'dragenter';\nconst DragLeaveEvent = 'dragleave';\nconst DragOverEvent = 'dragover';\nconst PointerDownEvent = 'pointerdown';\nconst PointerUpEvent = 'pointerup';\nconst PointerMoveEvent = 'pointermove';\nconst PointerOutEvent = 'pointerout';\nconst PointerOverEvent = 'pointerover';\nconst MouseDownEvent = 'mousedown';\nconst MouseUpEvent = 'mouseup';\nconst MouseMoveEvent = 'mousemove';\nconst MouseOutEvent = 'mouseout';\nconst MouseOverEvent = 'mouseover';\nconst ClickEvent = 'click';\nconst DoubleClickEvent = 'dblclick';\nconst WheelEvent = 'wheel';\nconst MouseWheelEvent = 'mousewheel';\nconst TouchStartEvent = 'touchstart';\nconst TouchMoveEvent = 'touchmove';\nconst TouchEndEvent = 'touchend';\nconst Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, PointerDownEvent, PointerUpEvent, PointerMoveEvent, PointerOutEvent, PointerOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];\nconst TooltipShowEvent = PointerMoveEvent;\nconst TooltipHideEvent = MouseOutEvent;\nconst HrefEvent = ClickEvent;\nclass CanvasHandler extends Handler {\n  constructor(loader, tooltip) {\n    super(loader, tooltip);\n    this._down = null;\n    this._touch = null;\n    this._first = true;\n    this._events = {};\n\n    // supported events\n    this.events = Events;\n    this.pointermove = move([PointerMoveEvent, MouseMoveEvent], [PointerOverEvent, MouseOverEvent], [PointerOutEvent, MouseOutEvent]);\n    this.dragover = move([DragOverEvent], [DragEnterEvent], [DragLeaveEvent]), this.pointerout = inactive([PointerOutEvent, MouseOutEvent]);\n    this.dragleave = inactive([DragLeaveEvent]);\n  }\n  initialize(el, origin, obj) {\n    this._canvas = el && domFind(el, 'canvas');\n\n    // add minimal events required for proper state management\n    [ClickEvent, MouseDownEvent, PointerDownEvent, PointerMoveEvent, PointerOutEvent, DragLeaveEvent].forEach(type => eventListenerCheck(this, type));\n    return super.initialize(el, origin, obj);\n  }\n\n  // return the backing canvas instance\n  canvas() {\n    return this._canvas;\n  }\n\n  // retrieve the current canvas context\n  context() {\n    return this._canvas.getContext('2d');\n  }\n\n  // to keep old versions of firefox happy\n  DOMMouseScroll(evt) {\n    this.fire(MouseWheelEvent, evt);\n  }\n  pointerdown(evt) {\n    this._down = this._active;\n    this.fire(PointerDownEvent, evt);\n  }\n  mousedown(evt) {\n    this._down = this._active;\n    this.fire(MouseDownEvent, evt);\n  }\n  click(evt) {\n    if (this._down === this._active) {\n      this.fire(ClickEvent, evt);\n      this._down = null;\n    }\n  }\n  touchstart(evt) {\n    this._touch = this.pickEvent(evt.changedTouches[0]);\n    if (this._first) {\n      this._active = this._touch;\n      this._first = false;\n    }\n    this.fire(TouchStartEvent, evt, true);\n  }\n  touchmove(evt) {\n    this.fire(TouchMoveEvent, evt, true);\n  }\n  touchend(evt) {\n    this.fire(TouchEndEvent, evt, true);\n    this._touch = null;\n  }\n\n  // fire an event\n  fire(type, evt, touch) {\n    const a = touch ? this._touch : this._active,\n      h = this._handlers[type];\n\n    // set event type relative to scenegraph items\n    evt.vegaType = type;\n\n    // handle hyperlinks and tooltips first\n    if (type === HrefEvent && a && a.href) {\n      this.handleHref(evt, a, a.href);\n    } else if (type === TooltipShowEvent || type === TooltipHideEvent) {\n      this.handleTooltip(evt, a, type !== TooltipHideEvent);\n    }\n\n    // invoke all registered handlers\n    if (h) {\n      for (let i = 0, len = h.length; i < len; ++i) {\n        h[i].handler.call(this._obj, evt, a);\n      }\n    }\n  }\n\n  // add an event handler\n  on(type, handler) {\n    const name = this.eventName(type),\n      h = this._handlers,\n      i = this._handlerIndex(h[name], type, handler);\n    if (i < 0) {\n      eventListenerCheck(this, type);\n      (h[name] || (h[name] = [])).push({\n        type: type,\n        handler: handler\n      });\n    }\n    return this;\n  }\n\n  // remove an event handler\n  off(type, handler) {\n    const name = this.eventName(type),\n      h = this._handlers[name],\n      i = this._handlerIndex(h, type, handler);\n    if (i >= 0) {\n      h.splice(i, 1);\n    }\n    return this;\n  }\n  pickEvent(evt) {\n    const p = point(evt, this._canvas),\n      o = this._origin;\n    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);\n  }\n\n  // find the scenegraph item at the current pointer position\n  // x, y -- the absolute x, y pointer coordinates on the canvas element\n  // gx, gy -- the relative coordinates within the current group\n  pick(scene, x, y, gx, gy) {\n    const g = this.context(),\n      mark = Marks[scene.marktype];\n    return mark.pick.call(this, g, scene, x, y, gx, gy);\n  }\n}\nconst eventBundle = type => type === TouchStartEvent || type === TouchMoveEvent || type === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type];\n\n// lazily add listeners to the canvas as needed\nfunction eventListenerCheck(handler, type) {\n  eventBundle(type).forEach(_ => addEventListener(handler, _));\n}\nfunction addEventListener(handler, type) {\n  const canvas = handler.canvas();\n  if (canvas && !handler._events[type]) {\n    handler._events[type] = 1;\n    canvas.addEventListener(type, handler[type] ? evt => handler[type](evt) : evt => handler.fire(type, evt));\n  }\n}\nfunction fireAll(handler, types, event) {\n  types.forEach(type => handler.fire(type, event));\n}\nfunction move(moveEvents, overEvents, outEvents) {\n  return function (evt) {\n    const a = this._active,\n      p = this.pickEvent(evt);\n    if (p === a) {\n      // active item and picked item are the same\n      fireAll(this, moveEvents, evt); // fire move\n    } else {\n      // active item and picked item are different\n      if (!a || !a.exit) {\n        // fire out for prior active item\n        // suppress if active item was removed from scene\n        fireAll(this, outEvents, evt);\n      }\n      this._active = p; // set new active item\n      fireAll(this, overEvents, evt); // fire over for new active item\n      fireAll(this, moveEvents, evt); // fire move for new active item\n    }\n  };\n}\nfunction inactive(types) {\n  return function (evt) {\n    fireAll(this, types, evt);\n    this._active = null;\n  };\n}\nfunction devicePixelRatio() {\n  return typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1;\n}\nfunction resize(canvas, width, height, origin, scaleFactor, opt) {\n  const inDOM = typeof HTMLElement !== 'undefined' && canvas instanceof HTMLElement && canvas.parentNode != null,\n    context = canvas.getContext('2d'),\n    ratio = inDOM ? devicePixelRatio() : scaleFactor;\n  canvas.width = width * ratio;\n  canvas.height = height * ratio;\n  for (const key in opt) {\n    context[key] = opt[key];\n  }\n  if (inDOM && ratio !== 1) {\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n  }\n  context.pixelRatio = ratio;\n  context.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);\n  return canvas;\n}\nclass CanvasRenderer extends Renderer {\n  constructor(loader) {\n    super(loader);\n    this._options = {};\n    this._redraw = false;\n    this._dirty = new Bounds();\n    this._tempb = new Bounds();\n  }\n  initialize(el, width, height, origin, scaleFactor, options) {\n    this._options = options || {};\n    this._canvas = this._options.externalContext ? null : canvas(1, 1, this._options.type); // instantiate a small canvas\n\n    if (el && this._canvas) {\n      domClear(el, 0).appendChild(this._canvas);\n      this._canvas.setAttribute('class', 'marks');\n    }\n\n    // this method will invoke resize to size the canvas appropriately\n    return super.initialize(el, width, height, origin, scaleFactor);\n  }\n  resize(width, height, origin, scaleFactor) {\n    super.resize(width, height, origin, scaleFactor);\n    if (this._canvas) {\n      // configure canvas size and transform\n      resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);\n    } else {\n      // external context needs to be scaled and positioned to origin\n      const ctx = this._options.externalContext;\n      if (!ctx) error('CanvasRenderer is missing a valid canvas or context');\n      ctx.scale(this._scale, this._scale);\n      ctx.translate(this._origin[0], this._origin[1]);\n    }\n    this._redraw = true;\n    return this;\n  }\n  canvas() {\n    return this._canvas;\n  }\n  context() {\n    return this._options.externalContext || (this._canvas ? this._canvas.getContext('2d') : null);\n  }\n  dirty(item) {\n    const b = this._tempb.clear().union(item.bounds);\n    let g = item.mark.group;\n    while (g) {\n      b.translate(g.x || 0, g.y || 0);\n      g = g.mark.group;\n    }\n    this._dirty.union(b);\n  }\n  _render(scene, markTypes) {\n    const g = this.context(),\n      o = this._origin,\n      w = this._width,\n      h = this._height,\n      db = this._dirty,\n      vb = viewBounds(o, w, h);\n\n    // setup\n    g.save();\n    const b = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);\n    this.clear(-o[0], -o[1], w, h);\n\n    // render\n    this.draw(g, scene, b, markTypes);\n\n    // takedown\n    g.restore();\n    db.clear();\n    return this;\n  }\n  draw(ctx, scene, bounds, markTypes) {\n    if (scene.marktype !== 'group' && markTypes != null && !markTypes.includes(scene.marktype)) {\n      return;\n    }\n    const mark = Marks[scene.marktype];\n    if (scene.clip) clip(ctx, scene);\n    mark.draw.call(this, ctx, scene, bounds, markTypes);\n    if (scene.clip) ctx.restore();\n  }\n  clear(x, y, w, h) {\n    const opt = this._options,\n      g = this.context();\n    if (opt.type !== 'pdf' && !opt.externalContext) {\n      // calling clear rect voids vector output in pdf mode\n      // and could remove external context content (#2615)\n      g.clearRect(x, y, w, h);\n    }\n    if (this._bgcolor != null) {\n      g.fillStyle = this._bgcolor;\n      g.fillRect(x, y, w, h);\n    }\n  }\n}\nconst viewBounds = (origin, width, height) => new Bounds().set(0, 0, width, height).translate(-origin[0], -origin[1]);\nfunction clipToBounds(g, b, origin) {\n  // expand bounds by 1 pixel, then round to pixel boundaries\n  b.expand(1).round();\n\n  // align to base pixel grid in case of non-integer scaling (#2425)\n  if (g.pixelRatio % 1) {\n    b.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);\n  }\n\n  // to avoid artifacts translate if origin has fractional pixels\n  b.translate(-(origin[0] % 1), -(origin[1] % 1));\n\n  // set clip path\n  g.beginPath();\n  g.rect(b.x1, b.y1, b.width(), b.height());\n  g.clip();\n  return b;\n}\nclass SVGHandler extends Handler {\n  constructor(loader, tooltip) {\n    super(loader, tooltip);\n    const h = this;\n    h._hrefHandler = listener(h, (evt, item) => {\n      if (item && item.href) h.handleHref(evt, item, item.href);\n    });\n    h._tooltipHandler = listener(h, (evt, item) => {\n      h.handleTooltip(evt, item, evt.type !== TooltipHideEvent);\n    });\n  }\n  initialize(el, origin, obj) {\n    let svg = this._svg;\n    if (svg) {\n      svg.removeEventListener(HrefEvent, this._hrefHandler);\n      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);\n      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);\n    }\n    this._svg = svg = el && domFind(el, 'svg');\n    if (svg) {\n      svg.addEventListener(HrefEvent, this._hrefHandler);\n      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);\n      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);\n    }\n    return super.initialize(el, origin, obj);\n  }\n  canvas() {\n    return this._svg;\n  }\n\n  // add an event handler\n  on(type, handler) {\n    const name = this.eventName(type),\n      h = this._handlers,\n      i = this._handlerIndex(h[name], type, handler);\n    if (i < 0) {\n      const x = {\n        type,\n        handler,\n        listener: listener(this, handler)\n      };\n      (h[name] || (h[name] = [])).push(x);\n      if (this._svg) {\n        this._svg.addEventListener(name, x.listener);\n      }\n    }\n    return this;\n  }\n\n  // remove an event handler\n  off(type, handler) {\n    const name = this.eventName(type),\n      h = this._handlers[name],\n      i = this._handlerIndex(h, type, handler);\n    if (i >= 0) {\n      if (this._svg) {\n        this._svg.removeEventListener(name, h[i].listener);\n      }\n      h.splice(i, 1);\n    }\n    return this;\n  }\n}\n\n// wrap an event listener for the SVG DOM\nconst listener = (context, handler) => evt => {\n  let item = evt.target.__data__;\n  item = Array.isArray(item) ? item[0] : item;\n  evt.vegaType = evt.type;\n  handler.call(context._obj, evt, item);\n};\nconst ARIA_HIDDEN = 'aria-hidden';\nconst ARIA_LABEL = 'aria-label';\nconst ARIA_ROLE = 'role';\nconst ARIA_ROLEDESCRIPTION = 'aria-roledescription';\nconst GRAPHICS_OBJECT = 'graphics-object';\nconst GRAPHICS_SYMBOL = 'graphics-symbol';\nconst bundle = (role, roledesc, label) => ({\n  [ARIA_ROLE]: role,\n  [ARIA_ROLEDESCRIPTION]: roledesc,\n  [ARIA_LABEL]: label || undefined\n});\n\n// these roles are covered by related roles\n// we can ignore them, no need to generate attributes\nconst AriaIgnore = toSet(['axis-domain', 'axis-grid', 'axis-label', 'axis-tick', 'axis-title', 'legend-band', 'legend-entry', 'legend-gradient', 'legend-label', 'legend-title', 'legend-symbol', 'title']);\n\n// aria attribute generators for guide roles\nconst AriaGuides = {\n  'axis': {\n    desc: 'axis',\n    caption: axisCaption\n  },\n  'legend': {\n    desc: 'legend',\n    caption: legendCaption\n  },\n  'title-text': {\n    desc: 'title',\n    caption: item => `Title text '${titleCaption(item)}'`\n  },\n  'title-subtitle': {\n    desc: 'subtitle',\n    caption: item => `Subtitle text '${titleCaption(item)}'`\n  }\n};\n\n// aria properties generated for mark item encoding channels\nconst AriaEncode = {\n  ariaRole: ARIA_ROLE,\n  ariaRoleDescription: ARIA_ROLEDESCRIPTION,\n  description: ARIA_LABEL\n};\nfunction ariaItemAttributes(emit, item) {\n  const hide = item.aria === false;\n  emit(ARIA_HIDDEN, hide || undefined);\n  if (hide || item.description == null) {\n    for (const prop in AriaEncode) {\n      emit(AriaEncode[prop], undefined);\n    }\n  } else {\n    const type = item.mark.marktype;\n    emit(ARIA_LABEL, item.description);\n    emit(ARIA_ROLE, item.ariaRole || (type === 'group' ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));\n    emit(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || `${type} mark`);\n  }\n}\nfunction ariaMarkAttributes(mark) {\n  return mark.aria === false ? {\n    [ARIA_HIDDEN]: true\n  } : AriaIgnore[mark.role] ? null : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role]) : ariaMark(mark);\n}\nfunction ariaMark(mark) {\n  const type = mark.marktype;\n  const recurse = type === 'group' || type === 'text' || mark.items.some(_ => _.description != null && _.aria !== false);\n  return bundle(recurse ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, `${type} mark container`, mark.description);\n}\nfunction ariaGuide(mark, opt) {\n  try {\n    const item = mark.items[0],\n      caption = opt.caption || (() => '');\n    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));\n  } catch (err) {\n    return null;\n  }\n}\nfunction titleCaption(item) {\n  return array(item.text).join(' ');\n}\nfunction axisCaption(item) {\n  const datum = item.datum,\n    orient = item.orient,\n    title = datum.title ? extractTitle(item) : null,\n    ctx = item.context,\n    scale = ctx.scales[datum.scale].value,\n    locale = ctx.dataflow.locale(),\n    type = scale.type,\n    xy = orient === 'left' || orient === 'right' ? 'Y' : 'X';\n  return `${xy}-axis` + (title ? ` titled '${title}'` : '') + ` for a ${isDiscrete(type) ? 'discrete' : type} scale` + ` with ${domainCaption(locale, scale, item)}`;\n}\nfunction legendCaption(item) {\n  const datum = item.datum,\n    title = datum.title ? extractTitle(item) : null,\n    type = `${datum.type || ''} legend`.trim(),\n    scales = datum.scales,\n    props = Object.keys(scales),\n    ctx = item.context,\n    scale = ctx.scales[scales[props[0]]].value,\n    locale = ctx.dataflow.locale();\n  return capitalize(type) + (title ? ` titled '${title}'` : '') + ` for ${channelCaption(props)}` + ` with ${domainCaption(locale, scale, item)}`;\n}\nfunction extractTitle(item) {\n  try {\n    return array(peek(item.items).items[0].text).join(' ');\n  } catch (err) {\n    return null;\n  }\n}\nfunction channelCaption(props) {\n  props = props.map(p => p + (p === 'fill' || p === 'stroke' ? ' color' : ''));\n  return props.length < 2 ? props[0] : props.slice(0, -1).join(', ') + ' and ' + peek(props);\n}\nfunction capitalize(s) {\n  return s.length ? s[0].toUpperCase() + s.slice(1) : s;\n}\nconst innerText = val => (val + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\nconst attrText = val => innerText(val).replace(/\"/g, '&quot;').replace(/\\t/g, '&#x9;').replace(/\\n/g, '&#xA;').replace(/\\r/g, '&#xD;');\nfunction markup() {\n  let buf = '',\n    outer = '',\n    inner = '';\n  const stack = [],\n    clear = () => outer = inner = '',\n    push = tag => {\n      if (outer) {\n        buf += `${outer}>${inner}`;\n        clear();\n      }\n      stack.push(tag);\n    },\n    attr = (name, value) => {\n      if (value != null) outer += ` ${name}=\"${attrText(value)}\"`;\n      return m;\n    },\n    m = {\n      open(tag) {\n        push(tag);\n        outer = '<' + tag;\n        for (var _len = arguments.length, attrs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          attrs[_key - 1] = arguments[_key];\n        }\n        for (const set of attrs) {\n          for (const key in set) attr(key, set[key]);\n        }\n        return m;\n      },\n      close() {\n        const tag = stack.pop();\n        if (outer) {\n          buf += outer + (inner ? `>${inner}</${tag}>` : '/>');\n        } else {\n          buf += `</${tag}>`;\n        }\n        clear();\n        return m;\n      },\n      attr,\n      text: t => (inner += innerText(t), m),\n      toString: () => buf\n    };\n  return m;\n}\nconst serializeXML = node => _serialize(markup(), node) + '';\nfunction _serialize(m, node) {\n  m.open(node.tagName);\n  if (node.hasAttributes()) {\n    const attrs = node.attributes,\n      n = attrs.length;\n    for (let i = 0; i < n; ++i) {\n      m.attr(attrs[i].name, attrs[i].value);\n    }\n  }\n  if (node.hasChildNodes()) {\n    const children = node.childNodes;\n    for (const child of children) {\n      child.nodeType === 3 // text node\n      ? m.text(child.nodeValue) : _serialize(m, child);\n    }\n  }\n  return m.close();\n}\nconst stylesAttr = {\n  fill: 'fill',\n  fillOpacity: 'fill-opacity',\n  stroke: 'stroke',\n  strokeOpacity: 'stroke-opacity',\n  strokeWidth: 'stroke-width',\n  strokeCap: 'stroke-linecap',\n  strokeJoin: 'stroke-linejoin',\n  strokeDash: 'stroke-dasharray',\n  strokeDashOffset: 'stroke-dashoffset',\n  strokeMiterLimit: 'stroke-miterlimit',\n  opacity: 'opacity'\n};\nconst stylesCss = {\n  blend: 'mix-blend-mode'\n};\n\n// ensure miter limit default is consistent with canvas (#2498)\nconst rootAttributes = {\n  'fill': 'none',\n  'stroke-miterlimit': 10\n};\nconst RootIndex = 0,\n  xmlns = 'http://www.w3.org/2000/xmlns/',\n  svgns = metadata.xmlns;\nclass SVGRenderer extends Renderer {\n  constructor(loader) {\n    super(loader);\n    this._dirtyID = 0;\n    this._dirty = [];\n    this._svg = null;\n    this._root = null;\n    this._defs = null;\n  }\n\n  /**\n   * Initialize a new SVGRenderer instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {number} width - The coordinate width of the display, in pixels.\n   * @param {number} height - The coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {SVGRenderer} - This renderer instance.\n   */\n  initialize(el, width, height, origin, scaleFactor) {\n    // create the svg definitions cache\n    this._defs = {};\n    this._clearDefs();\n    if (el) {\n      this._svg = domChild(el, 0, 'svg', svgns);\n      this._svg.setAttributeNS(xmlns, 'xmlns', svgns);\n      this._svg.setAttributeNS(xmlns, 'xmlns:xlink', metadata['xmlns:xlink']);\n      this._svg.setAttribute('version', metadata['version']);\n      this._svg.setAttribute('class', 'marks');\n      domClear(el, 1);\n\n      // set the svg root group\n      this._root = domChild(this._svg, RootIndex, 'g', svgns);\n      setAttributes(this._root, rootAttributes);\n\n      // ensure no additional child elements\n      domClear(this._svg, RootIndex + 1);\n    }\n\n    // set background color if defined\n    this.background(this._bgcolor);\n    return super.initialize(el, width, height, origin, scaleFactor);\n  }\n\n  /**\n   * Get / set the background color.\n   */\n  background(bgcolor) {\n    if (arguments.length && this._svg) {\n      this._svg.style.setProperty('background-color', bgcolor);\n    }\n    return super.background(...arguments);\n  }\n\n  /**\n   * Resize the display.\n   * @param {number} width - The new coordinate width of the display, in pixels.\n   * @param {number} height - The new coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The new origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {SVGRenderer} - This renderer instance;\n   */\n  resize(width, height, origin, scaleFactor) {\n    super.resize(width, height, origin, scaleFactor);\n    if (this._svg) {\n      setAttributes(this._svg, {\n        width: this._width * this._scale,\n        height: this._height * this._scale,\n        viewBox: `0 0 ${this._width} ${this._height}`\n      });\n      this._root.setAttribute('transform', `translate(${this._origin})`);\n    }\n    this._dirty = [];\n    return this;\n  }\n\n  /**\n   * Returns the SVG element of the visualization.\n   * @return {DOMElement} - The SVG element.\n   */\n  canvas() {\n    return this._svg;\n  }\n\n  /**\n   * Returns an SVG text string for the rendered content,\n   * or null if this renderer is currently headless.\n   */\n  svg() {\n    const svg = this._svg,\n      bg = this._bgcolor;\n    if (!svg) return null;\n    let node;\n    if (bg) {\n      svg.removeAttribute('style');\n      node = domChild(svg, RootIndex, 'rect', svgns);\n      setAttributes(node, {\n        width: this._width,\n        height: this._height,\n        fill: bg\n      });\n    }\n    const text = serializeXML(svg);\n    if (bg) {\n      svg.removeChild(node);\n      this._svg.style.setProperty('background-color', bg);\n    }\n    return text;\n  }\n\n  /**\n   * Internal rendering method.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @param {Array} markTypes - Array of the mark types to render.\n   *                            If undefined, render all mark types\n   */\n  _render(scene, markTypes) {\n    // perform spot updates and re-render markup\n    if (this._dirtyCheck()) {\n      if (this._dirtyAll) this._clearDefs();\n      this.mark(this._root, scene, undefined, markTypes);\n      domClear(this._root, 1);\n    }\n    this.defs();\n    this._dirty = [];\n    ++this._dirtyID;\n    return this;\n  }\n\n  // -- Manage rendering of items marked as dirty --\n\n  /**\n   * Flag a mark item as dirty.\n   * @param {Item} item - The mark item.\n   */\n  dirty(item) {\n    if (item.dirty !== this._dirtyID) {\n      item.dirty = this._dirtyID;\n      this._dirty.push(item);\n    }\n  }\n\n  /**\n   * Check if a mark item is considered dirty.\n   * @param {Item} item - The mark item.\n   */\n  isDirty(item) {\n    return this._dirtyAll || !item._svg || !item._svg.ownerSVGElement || item.dirty === this._dirtyID;\n  }\n\n  /**\n   * Internal method to check dirty status and, if possible,\n   * make targetted updates without a full rendering pass.\n   */\n  _dirtyCheck() {\n    this._dirtyAll = true;\n    const items = this._dirty;\n    if (!items.length || !this._dirtyID) return true;\n    const id = ++this._dirtyID;\n    let item, mark, type, mdef, i, n, o;\n    for (i = 0, n = items.length; i < n; ++i) {\n      item = items[i];\n      mark = item.mark;\n      if (mark.marktype !== type) {\n        // memoize mark instance lookup\n        type = mark.marktype;\n        mdef = Marks[type];\n      }\n      if (mark.zdirty && mark.dirty !== id) {\n        this._dirtyAll = false;\n        dirtyParents(item, id);\n        mark.items.forEach(i => {\n          i.dirty = id;\n        });\n      }\n      if (mark.zdirty) continue; // handle in standard drawing pass\n\n      if (item.exit) {\n        // EXIT\n        if (mdef.nested && mark.items.length) {\n          // if nested mark with remaining points, update instead\n          o = mark.items[0];\n          if (o._svg) this._update(mdef, o._svg, o);\n        } else if (item._svg) {\n          // otherwise remove from DOM\n          o = item._svg.parentNode;\n          if (o) o.removeChild(item._svg);\n        }\n        item._svg = null;\n        continue;\n      }\n      item = mdef.nested ? mark.items[0] : item;\n      if (item._update === id) continue; // already visited\n\n      if (!item._svg || !item._svg.ownerSVGElement) {\n        // ENTER\n        this._dirtyAll = false;\n        dirtyParents(item, id);\n      } else {\n        // IN-PLACE UPDATE\n        this._update(mdef, item._svg, item);\n      }\n      item._update = id;\n    }\n    return !this._dirtyAll;\n  }\n\n  // -- Construct & maintain scenegraph to SVG mapping ---\n\n  /**\n   * Render a set of mark items.\n   * @param {SVGElement} el - The parent element in the SVG tree.\n   * @param {object} scene - The mark parent to render.\n   * @param {SVGElement} prev - The previous sibling in the SVG tree.\n   * @param {Array} markTypes - Array of the mark types to render.\n   *                            If undefined, render all mark types\n   */\n  mark(el, scene, prev, markTypes) {\n    if (!this.isDirty(scene)) {\n      return scene._svg;\n    }\n    const svg = this._svg,\n      markType = scene.marktype,\n      mdef = Marks[markType],\n      events = scene.interactive === false ? 'none' : null,\n      isGroup = mdef.tag === 'g';\n    const parent = bind(scene, el, prev, 'g', svg);\n    if (markType !== 'group' && markTypes != null && !markTypes.includes(markType)) {\n      domClear(parent, 0);\n      return scene._svg;\n    }\n    parent.setAttribute('class', cssClass(scene));\n\n    // apply aria attributes to parent container element\n    const aria = ariaMarkAttributes(scene);\n    for (const key in aria) setAttribute(parent, key, aria[key]);\n    if (!isGroup) {\n      setAttribute(parent, 'pointer-events', events);\n    }\n    setAttribute(parent, 'clip-path', scene.clip ? clip$1(this, scene, scene.group) : null);\n    let sibling = null,\n      i = 0;\n    const process = item => {\n      const dirty = this.isDirty(item),\n        node = bind(item, parent, sibling, mdef.tag, svg);\n      if (dirty) {\n        this._update(mdef, node, item);\n        if (isGroup) recurse(this, node, item, markTypes);\n      }\n      sibling = node;\n      ++i;\n    };\n    if (mdef.nested) {\n      if (scene.items.length) process(scene.items[0]);\n    } else {\n      visit(scene, process);\n    }\n    domClear(parent, i);\n    return parent;\n  }\n\n  /**\n   * Update the attributes of an SVG element for a mark item.\n   * @param {object} mdef - The mark definition object\n   * @param {SVGElement} el - The SVG element.\n   * @param {Item} item - The mark item.\n   */\n  _update(mdef, el, item) {\n    // set dom element and values cache\n    // provides access to emit method\n    element = el;\n    values = el.__values__;\n\n    // apply aria-specific properties\n    ariaItemAttributes(emit, item);\n\n    // apply svg attributes\n    mdef.attr(emit, item, this);\n\n    // some marks need special treatment\n    const extra = mark_extras[mdef.type];\n    if (extra) extra.call(this, mdef, el, item);\n\n    // apply svg style attributes\n    // note: element state may have been modified by 'extra' method\n    if (element) this.style(element, item);\n  }\n\n  /**\n   * Update the presentation attributes of an SVG element for a mark item.\n   * @param {SVGElement} el - The SVG element.\n   * @param {Item} item - The mark item.\n   */\n  style(el, item) {\n    if (item == null) return;\n    for (const prop in stylesAttr) {\n      let value = prop === 'font' ? fontFamily(item) : item[prop];\n      if (value === values[prop]) continue;\n      const name = stylesAttr[prop];\n      if (value == null) {\n        el.removeAttribute(name);\n      } else {\n        if (isGradient(value)) {\n          value = gradientRef(value, this._defs.gradient, href());\n        }\n        el.setAttribute(name, value + '');\n      }\n      values[prop] = value;\n    }\n    for (const prop in stylesCss) {\n      setStyle(el, stylesCss[prop], item[prop]);\n    }\n  }\n\n  /**\n   * Render SVG defs, as needed.\n   * Must be called *after* marks have been processed to ensure the\n   * collected state is current and accurate.\n   */\n  defs() {\n    const svg = this._svg,\n      defs = this._defs;\n    let el = defs.el,\n      index = 0;\n    for (const id in defs.gradient) {\n      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);\n      index = updateGradient(el, defs.gradient[id], index);\n    }\n    for (const id in defs.clipping) {\n      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);\n      index = updateClipping(el, defs.clipping[id], index);\n    }\n\n    // clean-up\n    if (el) {\n      index === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index);\n    }\n  }\n\n  /**\n   * Clear defs caches.\n   */\n  _clearDefs() {\n    const def = this._defs;\n    def.gradient = {};\n    def.clipping = {};\n  }\n}\n\n// mark ancestor chain with a dirty id\nfunction dirtyParents(item, id) {\n  for (; item && item.dirty !== id; item = item.mark.group) {\n    item.dirty = id;\n    if (item.mark && item.mark.dirty !== id) {\n      item.mark.dirty = id;\n    } else return;\n  }\n}\n\n// update gradient definitions\nfunction updateGradient(el, grad, index) {\n  let i, n, stop;\n  if (grad.gradient === 'radial') {\n    // SVG radial gradients automatically transform to normalized bbox\n    // coordinates, in a way that is cumbersome to replicate in canvas.\n    // We wrap the radial gradient in a pattern element, allowing us to\n    // maintain a circular gradient that matches what canvas provides.\n    let pt = domChild(el, index++, 'pattern', svgns);\n    setAttributes(pt, {\n      id: patternPrefix + grad.id,\n      viewBox: '0,0,1,1',\n      width: '100%',\n      height: '100%',\n      preserveAspectRatio: 'xMidYMid slice'\n    });\n    pt = domChild(pt, 0, 'rect', svgns);\n    setAttributes(pt, {\n      width: 1,\n      height: 1,\n      fill: `url(${href()}#${grad.id})`\n    });\n    el = domChild(el, index++, 'radialGradient', svgns);\n    setAttributes(el, {\n      id: grad.id,\n      fx: grad.x1,\n      fy: grad.y1,\n      fr: grad.r1,\n      cx: grad.x2,\n      cy: grad.y2,\n      r: grad.r2\n    });\n  } else {\n    el = domChild(el, index++, 'linearGradient', svgns);\n    setAttributes(el, {\n      id: grad.id,\n      x1: grad.x1,\n      x2: grad.x2,\n      y1: grad.y1,\n      y2: grad.y2\n    });\n  }\n  for (i = 0, n = grad.stops.length; i < n; ++i) {\n    stop = domChild(el, i, 'stop', svgns);\n    stop.setAttribute('offset', grad.stops[i].offset);\n    stop.setAttribute('stop-color', grad.stops[i].color);\n  }\n  domClear(el, i);\n  return index;\n}\n\n// update clipping path definitions\nfunction updateClipping(el, clip, index) {\n  let mask;\n  el = domChild(el, index, 'clipPath', svgns);\n  el.setAttribute('id', clip.id);\n  if (clip.path) {\n    mask = domChild(el, 0, 'path', svgns);\n    mask.setAttribute('d', clip.path);\n  } else {\n    mask = domChild(el, 0, 'rect', svgns);\n    setAttributes(mask, {\n      x: 0,\n      y: 0,\n      width: clip.width,\n      height: clip.height\n    });\n  }\n  domClear(el, 1);\n  return index + 1;\n}\n\n// Recursively process group contents.\nfunction recurse(renderer, el, group, markTypes) {\n  // child 'g' element is second to last among children (path, g, path)\n  // other children here are foreground and background path elements\n  el = el.lastChild.previousSibling;\n  let prev,\n    idx = 0;\n  visit(group, item => {\n    prev = renderer.mark(el, item, prev, markTypes);\n    ++idx;\n  });\n\n  // remove any extraneous DOM elements\n  domClear(el, 1 + idx);\n}\n\n// Bind a scenegraph item to an SVG DOM element.\n// Create new SVG elements as needed.\nfunction bind(item, el, sibling, tag, svg) {\n  let node = item._svg,\n    doc;\n\n  // create a new dom node if needed\n  if (!node) {\n    doc = el.ownerDocument;\n    node = domCreate(doc, tag, svgns);\n    item._svg = node;\n    if (item.mark) {\n      node.__data__ = item;\n      node.__values__ = {\n        fill: 'default'\n      };\n\n      // if group, create background, content, and foreground elements\n      if (tag === 'g') {\n        const bg = domCreate(doc, 'path', svgns);\n        node.appendChild(bg);\n        bg.__data__ = item;\n        const cg = domCreate(doc, 'g', svgns);\n        node.appendChild(cg);\n        cg.__data__ = item;\n        const fg = domCreate(doc, 'path', svgns);\n        node.appendChild(fg);\n        fg.__data__ = item;\n        fg.__values__ = {\n          fill: 'default'\n        };\n      }\n    }\n  }\n\n  // (re-)insert if (a) not contained in SVG or (b) sibling order has changed\n  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {\n    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);\n  }\n  return node;\n}\n\n// check if two nodes are ordered siblings\nfunction siblingCheck(node, sibling) {\n  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling; // treat null/undefined the same\n}\n\n// -- Set attributes & styles on SVG elements ---\n\nlet element = null,\n  // temp var for current SVG element\n  values = null; // temp var for current values hash\n\n// Extra configuration for certain mark types\nconst mark_extras = {\n  group(mdef, el, item) {\n    const fg = element = el.childNodes[2];\n    values = fg.__values__;\n    mdef.foreground(emit, item, this);\n    values = el.__values__; // use parent's values hash\n    element = el.childNodes[1];\n    mdef.content(emit, item, this);\n    const bg = element = el.childNodes[0];\n    mdef.background(emit, item, this);\n    const value = item.mark.interactive === false ? 'none' : null;\n    if (value !== values.events) {\n      setAttribute(fg, 'pointer-events', value);\n      setAttribute(bg, 'pointer-events', value);\n      values.events = value;\n    }\n    if (item.strokeForeground && item.stroke) {\n      const fill = item.fill;\n      setAttribute(fg, 'display', null);\n\n      // set style of background\n      this.style(bg, item);\n      setAttribute(bg, 'stroke', null);\n\n      // set style of foreground\n      if (fill) item.fill = null;\n      values = fg.__values__;\n      this.style(fg, item);\n      if (fill) item.fill = fill;\n\n      // leave element null to prevent downstream styling\n      element = null;\n    } else {\n      // ensure foreground is ignored\n      setAttribute(fg, 'display', 'none');\n    }\n  },\n  image(mdef, el, item) {\n    if (item.smooth === false) {\n      setStyle(el, 'image-rendering', 'optimizeSpeed');\n      setStyle(el, 'image-rendering', 'pixelated');\n    } else {\n      setStyle(el, 'image-rendering', null);\n    }\n  },\n  text(mdef, el, item) {\n    const tl = textLines(item);\n    let key, value, doc, lh;\n    if (isArray(tl)) {\n      // multi-line text\n      value = tl.map(_ => textValue(item, _));\n      key = value.join('\\n'); // content cache key\n\n      if (key !== values.text) {\n        domClear(el, 0);\n        doc = el.ownerDocument;\n        lh = lineHeight(item);\n        value.forEach((t, i) => {\n          const ts = domCreate(doc, 'tspan', svgns);\n          ts.__data__ = item; // data binding\n          ts.textContent = t;\n          if (i) {\n            ts.setAttribute('x', 0);\n            ts.setAttribute('dy', lh);\n          }\n          el.appendChild(ts);\n        });\n        values.text = key;\n      }\n    } else {\n      // single-line text\n      value = textValue(item, tl);\n      if (value !== values.text) {\n        el.textContent = value;\n        values.text = value;\n      }\n    }\n    setAttribute(el, 'font-family', fontFamily(item));\n    setAttribute(el, 'font-size', fontSize(item) + 'px');\n    setAttribute(el, 'font-style', item.fontStyle);\n    setAttribute(el, 'font-variant', item.fontVariant);\n    setAttribute(el, 'font-weight', item.fontWeight);\n  }\n};\nfunction emit(name, value, ns) {\n  // early exit if value is unchanged\n  if (value === values[name]) return;\n\n  // use appropriate method given namespace (ns)\n  if (ns) {\n    setAttributeNS(element, name, value, ns);\n  } else {\n    setAttribute(element, name, value);\n  }\n\n  // note current value for future comparison\n  values[name] = value;\n}\nfunction setStyle(el, name, value) {\n  if (value !== values[name]) {\n    if (value == null) {\n      el.style.removeProperty(name);\n    } else {\n      el.style.setProperty(name, value + '');\n    }\n    values[name] = value;\n  }\n}\nfunction setAttributes(el, attrs) {\n  for (const key in attrs) {\n    setAttribute(el, key, attrs[key]);\n  }\n}\nfunction setAttribute(el, name, value) {\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    el.setAttribute(name, value);\n  } else {\n    // else remove DOM attribute\n    el.removeAttribute(name);\n  }\n}\nfunction setAttributeNS(el, name, value, ns) {\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    el.setAttributeNS(ns, name, value);\n  } else {\n    // else remove DOM attribute\n    el.removeAttributeNS(ns, name);\n  }\n}\nfunction href() {\n  let loc;\n  return typeof window === 'undefined' ? '' : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;\n}\nclass SVGStringRenderer extends Renderer {\n  constructor(loader) {\n    super(loader);\n    this._text = null;\n    this._defs = {\n      gradient: {},\n      clipping: {}\n    };\n  }\n\n  /**\n   * Returns the rendered SVG text string,\n   * or null if rendering has not yet occurred.\n   */\n  svg() {\n    return this._text;\n  }\n\n  /**\n   * Internal rendering method.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   */\n  _render(scene) {\n    const m = markup();\n\n    // svg tag\n    m.open('svg', extend({}, metadata, {\n      class: 'marks',\n      width: this._width * this._scale,\n      height: this._height * this._scale,\n      viewBox: `0 0 ${this._width} ${this._height}`\n    }));\n\n    // background, if defined\n    const bg = this._bgcolor;\n    if (bg && bg !== 'transparent' && bg !== 'none') {\n      m.open('rect', {\n        width: this._width,\n        height: this._height,\n        fill: bg\n      }).close();\n    }\n\n    // root content group\n    m.open('g', rootAttributes, {\n      transform: 'translate(' + this._origin + ')'\n    });\n    this.mark(m, scene);\n    m.close(); // </g>\n\n    // defs\n    this.defs(m);\n\n    // get SVG text string\n    this._text = m.close() + '';\n    return this;\n  }\n\n  /**\n   * Render a set of mark items.\n   * @param {object} m - The markup context.\n   * @param {object} scene - The mark parent to render.\n   */\n  mark(m, scene) {\n    const mdef = Marks[scene.marktype],\n      tag = mdef.tag,\n      attrList = [ariaItemAttributes, mdef.attr];\n\n    // render opening group tag\n    m.open('g', {\n      'class': cssClass(scene),\n      'clip-path': scene.clip ? clip$1(this, scene, scene.group) : null\n    }, ariaMarkAttributes(scene), {\n      'pointer-events': tag !== 'g' && scene.interactive === false ? 'none' : null\n    });\n\n    // render contained elements\n    const process = item => {\n      const href = this.href(item);\n      if (href) m.open('a', href);\n      m.open(tag, this.attr(scene, item, attrList, tag !== 'g' ? tag : null));\n      if (tag === 'text') {\n        const tl = textLines(item);\n        if (isArray(tl)) {\n          // multi-line text\n          const attrs = {\n            x: 0,\n            dy: lineHeight(item)\n          };\n          for (let i = 0; i < tl.length; ++i) {\n            m.open('tspan', i ? attrs : null).text(textValue(item, tl[i])).close();\n          }\n        } else {\n          // single-line text\n          m.text(textValue(item, tl));\n        }\n      } else if (tag === 'g') {\n        const fore = item.strokeForeground,\n          fill = item.fill,\n          stroke = item.stroke;\n        if (fore && stroke) {\n          item.stroke = null;\n        }\n        m.open('path', this.attr(scene, item, mdef.background, 'bgrect')).close();\n\n        // recurse for group content\n        m.open('g', this.attr(scene, item, mdef.content));\n        visit(item, scene => this.mark(m, scene));\n        m.close();\n        if (fore && stroke) {\n          if (fill) item.fill = null;\n          item.stroke = stroke;\n          m.open('path', this.attr(scene, item, mdef.foreground, 'bgrect')).close();\n          if (fill) item.fill = fill;\n        } else {\n          m.open('path', this.attr(scene, item, mdef.foreground, 'bgfore')).close();\n        }\n      }\n      m.close(); // </tag>\n      if (href) m.close(); // </a>\n    };\n    if (mdef.nested) {\n      if (scene.items && scene.items.length) process(scene.items[0]);\n    } else {\n      visit(scene, process);\n    }\n\n    // render closing group tag\n    return m.close(); // </g>\n  }\n\n  /**\n   * Get href attributes for a hyperlinked mark item.\n   * @param {Item} item - The mark item.\n   */\n  href(item) {\n    const href = item.href;\n    let attr;\n    if (href) {\n      if (attr = this._hrefs && this._hrefs[href]) {\n        return attr;\n      } else {\n        this.sanitizeURL(href).then(attr => {\n          // rewrite to use xlink namespace\n          attr['xlink:href'] = attr.href;\n          attr.href = null;\n          (this._hrefs || (this._hrefs = {}))[href] = attr;\n        });\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get an object of SVG attributes for a mark item.\n   * @param {object} scene - The mark parent.\n   * @param {Item} item - The mark item.\n   * @param {array|function} attrs - One or more attribute emitters.\n   * @param {string} tag - The tag being rendered.\n   */\n  attr(scene, item, attrs, tag) {\n    const object = {},\n      emit = (name, value, ns, prefixed) => {\n        object[prefixed || name] = value;\n      };\n\n    // apply mark specific attributes\n    if (Array.isArray(attrs)) {\n      attrs.forEach(fn => fn(emit, item, this));\n    } else {\n      attrs(emit, item, this);\n    }\n\n    // apply style attributes\n    if (tag) {\n      style(object, item, scene, tag, this._defs);\n    }\n    return object;\n  }\n\n  /**\n   * Render SVG defs, as needed.\n   * Must be called *after* marks have been processed to ensure the\n   * collected state is current and accurate.\n   * @param {object} m - The markup context.\n   */\n  defs(m) {\n    const gradient = this._defs.gradient,\n      clipping = this._defs.clipping,\n      count = Object.keys(gradient).length + Object.keys(clipping).length;\n    if (count === 0) return; // nothing to do\n\n    m.open('defs');\n    for (const id in gradient) {\n      const def = gradient[id],\n        stops = def.stops;\n      if (def.gradient === 'radial') {\n        // SVG radial gradients automatically transform to normalized bbox\n        // coordinates, in a way that is cumbersome to replicate in canvas.\n        // We wrap the radial gradient in a pattern element, allowing us to\n        // maintain a circular gradient that matches what canvas provides.\n\n        m.open('pattern', {\n          id: patternPrefix + id,\n          viewBox: '0,0,1,1',\n          width: '100%',\n          height: '100%',\n          preserveAspectRatio: 'xMidYMid slice'\n        });\n        m.open('rect', {\n          width: '1',\n          height: '1',\n          fill: 'url(#' + id + ')'\n        }).close();\n        m.close(); // </pattern>\n\n        m.open('radialGradient', {\n          id: id,\n          fx: def.x1,\n          fy: def.y1,\n          fr: def.r1,\n          cx: def.x2,\n          cy: def.y2,\n          r: def.r2\n        });\n      } else {\n        m.open('linearGradient', {\n          id: id,\n          x1: def.x1,\n          x2: def.x2,\n          y1: def.y1,\n          y2: def.y2\n        });\n      }\n      for (let i = 0; i < stops.length; ++i) {\n        m.open('stop', {\n          offset: stops[i].offset,\n          'stop-color': stops[i].color\n        }).close();\n      }\n      m.close();\n    }\n    for (const id in clipping) {\n      const def = clipping[id];\n      m.open('clipPath', {\n        id: id\n      });\n      if (def.path) {\n        m.open('path', {\n          d: def.path\n        }).close();\n      } else {\n        m.open('rect', {\n          x: 0,\n          y: 0,\n          width: def.width,\n          height: def.height\n        }).close();\n      }\n      m.close();\n    }\n    m.close();\n  }\n}\n\n// Helper function for attr for style presentation attributes\nfunction style(s, item, scene, tag, defs) {\n  let styleList;\n  if (item == null) return s;\n  if (tag === 'bgrect' && scene.interactive === false) {\n    s['pointer-events'] = 'none';\n  }\n  if (tag === 'bgfore') {\n    if (scene.interactive === false) {\n      s['pointer-events'] = 'none';\n    }\n    s.display = 'none';\n    if (item.fill !== null) return s;\n  }\n  if (tag === 'image' && item.smooth === false) {\n    styleList = ['image-rendering: optimizeSpeed;', 'image-rendering: pixelated;'];\n  }\n  if (tag === 'text') {\n    s['font-family'] = fontFamily(item);\n    s['font-size'] = fontSize(item) + 'px';\n    s['font-style'] = item.fontStyle;\n    s['font-variant'] = item.fontVariant;\n    s['font-weight'] = item.fontWeight;\n  }\n  for (const prop in stylesAttr) {\n    let value = item[prop];\n    const name = stylesAttr[prop];\n    if (value === 'transparent' && (name === 'fill' || name === 'stroke')) ;else if (value != null) {\n      if (isGradient(value)) {\n        value = gradientRef(value, defs.gradient, '');\n      }\n      s[name] = value;\n    }\n  }\n  for (const prop in stylesCss) {\n    const value = item[prop];\n    if (value != null) {\n      styleList = styleList || [];\n      styleList.push(`${stylesCss[prop]}: ${value};`);\n    }\n  }\n  if (styleList) {\n    s.style = styleList.join(' ');\n  }\n  return s;\n}\n\n/**\n * @typedef {Object} HybridRendererOptions\n *\n * @property {string[]} [svgMarkTypes=['text']] - An array of SVG mark types to render\n *                                                in the SVG layer. All other mark types\n *                                                will be rendered in the Canvas layer.\n * @property {boolean} [svgOnTop=true] - Flag to determine if SVG should be rendered on top.\n * @property {boolean} [debug=false] - Flag to enable or disable debugging mode. When true,\n *                                     the top layer will be stacked below the bottom layer\n *                                     rather than overlaid on top.\n */\n\n/** @type {HybridRendererOptions} */\nconst OPTS = {\n  svgMarkTypes: ['text'],\n  svgOnTop: true,\n  debug: false\n};\n\n/**\n * Configure the HybridRenderer\n *\n * @param {HybridRendererOptions} options - HybridRenderer configuration options.\n */\nfunction setHybridRendererOptions(options) {\n  OPTS['svgMarkTypes'] = options.svgMarkTypes ?? ['text'];\n  OPTS['svgOnTop'] = options.svgOnTop ?? true;\n  OPTS['debug'] = options.debug ?? false;\n}\nclass HybridRenderer extends Renderer {\n  constructor(loader) {\n    super(loader);\n    this._svgRenderer = new SVGRenderer(loader);\n    this._canvasRenderer = new CanvasRenderer(loader);\n  }\n\n  /**\n   * Initialize a new HybridRenderer instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {number} width - The coordinate width of the display, in pixels.\n   * @param {number} height - The coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {HybridRenderer} - This renderer instance.\n   */\n  initialize(el, width, height, origin, scaleFactor) {\n    this._root_el = domChild(el, 0, 'div');\n    const bottomEl = domChild(this._root_el, 0, 'div');\n    const topEl = domChild(this._root_el, 1, 'div');\n    this._root_el.style.position = 'relative';\n\n    // Set position absolute to overlay svg on top of canvas\n    if (!OPTS.debug) {\n      bottomEl.style.height = '100%';\n      topEl.style.position = 'absolute';\n      topEl.style.top = '0';\n      topEl.style.left = '0';\n      topEl.style.height = '100%';\n      topEl.style.width = '100%';\n    }\n    this._svgEl = OPTS.svgOnTop ? topEl : bottomEl;\n    this._canvasEl = OPTS.svgOnTop ? bottomEl : topEl;\n\n    // pointer-events to none on SVG layer so that canvas gets all events\n    this._svgEl.style.pointerEvents = 'none';\n    this._canvasRenderer.initialize(this._canvasEl, width, height, origin, scaleFactor);\n    this._svgRenderer.initialize(this._svgEl, width, height, origin, scaleFactor);\n    return super.initialize(el, width, height, origin, scaleFactor);\n  }\n\n  /**\n   * Flag a mark item as dirty.\n   * @param {Item} item - The mark item.\n   */\n  dirty(item) {\n    if (OPTS.svgMarkTypes.includes(item.mark.marktype)) {\n      this._svgRenderer.dirty(item);\n    } else {\n      this._canvasRenderer.dirty(item);\n    }\n    return this;\n  }\n\n  /**\n   * Internal rendering method.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @param {Array} markTypes - Array of the mark types to render.\n   *                            If undefined, render all mark types\n   */\n  _render(scene, markTypes) {\n    const allMarkTypes = markTypes ?? ['arc', 'area', 'image', 'line', 'path', 'rect', 'rule', 'shape', 'symbol', 'text', 'trail'];\n    const canvasMarkTypes = allMarkTypes.filter(m => !OPTS.svgMarkTypes.includes(m));\n    this._svgRenderer.render(scene, OPTS.svgMarkTypes);\n    this._canvasRenderer.render(scene, canvasMarkTypes);\n  }\n\n  /**\n   * Resize the display.\n   * @param {number} width - The new coordinate width of the display, in pixels.\n   * @param {number} height - The new coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The new origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {SVGRenderer} - This renderer instance;\n   */\n  resize(width, height, origin, scaleFactor) {\n    super.resize(width, height, origin, scaleFactor);\n    this._svgRenderer.resize(width, height, origin, scaleFactor);\n    this._canvasRenderer.resize(width, height, origin, scaleFactor);\n    return this;\n  }\n  background(bgcolor) {\n    // Propagate background color to lower canvas renderer\n    if (OPTS.svgOnTop) {\n      this._canvasRenderer.background(bgcolor);\n    } else {\n      this._svgRenderer.background(bgcolor);\n    }\n    return this;\n  }\n}\nclass HybridHandler extends CanvasHandler {\n  constructor(loader, tooltip) {\n    super(loader, tooltip);\n  }\n  initialize(el, origin, obj) {\n    const canvas = domChild(domChild(el, 0, 'div'), OPTS.svgOnTop ? 0 : 1, 'div');\n    return super.initialize(canvas, origin, obj);\n  }\n}\nconst Canvas = 'canvas';\nconst Hybrid = 'hybrid';\nconst PNG = 'png';\nconst SVG = 'svg';\nconst None = 'none';\nconst RenderType = {\n  Canvas: Canvas,\n  PNG: PNG,\n  SVG: SVG,\n  Hybrid: Hybrid,\n  None: None\n};\nconst modules = {};\nmodules[Canvas] = modules[PNG] = {\n  renderer: CanvasRenderer,\n  headless: CanvasRenderer,\n  handler: CanvasHandler\n};\nmodules[SVG] = {\n  renderer: SVGRenderer,\n  headless: SVGStringRenderer,\n  handler: SVGHandler\n};\nmodules[Hybrid] = {\n  renderer: HybridRenderer,\n  headless: HybridRenderer,\n  handler: HybridHandler\n};\nmodules[None] = {};\nfunction renderModule(name, _) {\n  name = String(name || '').toLowerCase();\n  if (arguments.length > 1) {\n    modules[name] = _;\n    return this;\n  } else {\n    return modules[name];\n  }\n}\nfunction intersect(scene, bounds, filter) {\n  const hits = [],\n    // intersection results\n    box = new Bounds().union(bounds),\n    // defensive copy\n    type = scene.marktype;\n  return type ? intersectMark(scene, box, filter, hits) : type === 'group' ? intersectGroup(scene, box, filter, hits) : error('Intersect scene must be mark node or group item.');\n}\nfunction intersectMark(mark, box, filter, hits) {\n  if (visitMark(mark, box, filter)) {\n    const items = mark.items,\n      type = mark.marktype,\n      n = items.length;\n    let i = 0;\n    if (type === 'group') {\n      for (; i < n; ++i) {\n        intersectGroup(items[i], box, filter, hits);\n      }\n    } else {\n      for (const test = Marks[type].isect; i < n; ++i) {\n        const item = items[i];\n        if (intersectItem(item, box, test)) hits.push(item);\n      }\n    }\n  }\n  return hits;\n}\nfunction visitMark(mark, box, filter) {\n  // process if bounds intersect and if\n  // (1) mark is a group mark (so we must recurse), or\n  // (2) mark is interactive and passes filter\n  return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === 'group' || mark.interactive !== false && (!filter || filter(mark)));\n}\nfunction intersectGroup(group, box, filter, hits) {\n  // test intersect against group\n  // skip groups by default unless filter says otherwise\n  if (filter && filter(group.mark) && intersectItem(group, box, Marks.group.isect)) {\n    hits.push(group);\n  }\n\n  // recursively test children marks\n  // translate box to group coordinate space\n  const marks = group.items,\n    n = marks && marks.length;\n  if (n) {\n    const x = group.x || 0,\n      y = group.y || 0;\n    box.translate(-x, -y);\n    for (let i = 0; i < n; ++i) {\n      intersectMark(marks[i], box, filter, hits);\n    }\n    box.translate(x, y);\n  }\n  return hits;\n}\nfunction intersectItem(item, box, test) {\n  // test bounds enclosure, bounds intersection, then detailed test\n  const bounds = item.bounds;\n  return box.encloses(bounds) || box.intersects(bounds) && test(item, box);\n}\nconst clipBounds = new Bounds();\nfunction boundClip(mark) {\n  const clip = mark.clip;\n  if (isFunction(clip)) {\n    clip(boundContext(clipBounds.clear()));\n  } else if (clip) {\n    clipBounds.set(0, 0, mark.group.width, mark.group.height);\n  } else return;\n  mark.bounds.intersect(clipBounds);\n}\nconst TOLERANCE = 1e-9;\nfunction sceneEqual(a, b, key) {\n  return a === b ? true : key === 'path' ? pathEqual(a, b) : a instanceof Date && b instanceof Date ? +a === +b : isNumber(a) && isNumber(b) ? Math.abs(a - b) <= TOLERANCE : !a || !b || !isObject(a) && !isObject(b) ? a == b : objectEqual(a, b);\n}\nfunction pathEqual(a, b) {\n  return sceneEqual(parse(a), parse(b));\n}\nfunction objectEqual(a, b) {\n  var ka = Object.keys(a),\n    kb = Object.keys(b),\n    key,\n    i;\n  if (ka.length !== kb.length) return false;\n  ka.sort();\n  kb.sort();\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i]) return false;\n  }\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!sceneEqual(a[key], b[key], key)) return false;\n  }\n  return typeof a === typeof b;\n}\nfunction resetSVGDefIds() {\n  resetSVGClipId();\n  resetSVGGradientId();\n}\nexport { Bounds, CanvasHandler, CanvasRenderer, Gradient, GroupItem, Handler, HybridHandler, HybridRenderer, Item, Marks, RenderType, Renderer, ResourceLoader, SVGHandler, SVGRenderer, SVGStringRenderer, Scenegraph, boundClip, boundContext, boundItem, boundMark, boundStroke, domChild, domClear, domCreate, domFind, font, fontFamily, fontSize, intersect, intersectBoxLine, intersectPath, intersectPoint, intersectRule, lineHeight, markup, multiLineOffset, curves as pathCurves, pathEqual, parse as pathParse, vg_rect as pathRectangle, pathRender, symbols as pathSymbols, vg_trail as pathTrail, point, renderModule, resetSVGClipId, resetSVGDefIds, sceneEqual, sceneFromJSON, pickVisit as scenePickVisit, sceneToJSON, visit as sceneVisit, zorder as sceneZOrder, serializeXML, setHybridRendererOptions, textMetrics };","map":{"version":3,"names":["hasOwnProperty","isFunction","inherits","truthy","lruCache","isArray","error","toSet","array","peek","extend","isNumber","isObject","curveBasis","curveBasisClosed","curveBasisOpen","curveBundle","curveCardinal","curveCardinalOpen","curveCardinalClosed","curveCatmullRom","curveCatmullRomClosed","curveCatmullRomOpen","curveLinear","curveLinearClosed","curveMonotoneY","curveMonotoneX","curveNatural","curveStep","curveStepAfter","curveStepBefore","arc","arc$2","area","area$2","line","line$2","symbol","symbol$2","path","path$3","image","image$1","canvas","loader","isDiscrete","domainCaption","gradient_id","resetSVGGradientId","patternPrefix","isGradient","value","gradient","gradientRef","g","defs","base","type","id","prefix","x1","get","y1","r1","x2","y2","r2","val","def","Gradient","p0","p1","stops","stop","offset","color","push","lookup","curve","tension","horizontal","vertical","curves","orientation","entry","paramCounts","m","l","h","v","z","c","s","q","t","a","commandPattern","numberPattern","spacePattern","flagPattern","parse","commands","matches","match","forEach","str","cmd","toLowerCase","paramCount","params","parseParams","slice","trim","count","length","Error","i","segment","index","pattern","ws","DegToRad","Math","PI","Epsilon","HalfPi","Tau","HalfSqrt3","sqrt","segmentCache","bezierCache","join","segments","x","y","rx","ry","large","sweep","rotateX","ox","oy","key","call","arguments","th","sin_th","sin","cos_th","cos","abs","px","py","pl","a00","a01","a10","a11","x0","y0","d","sfactor_sq","sfactor","xc","yc","th0","atan2","th1","th_arc","segs","ceil","result","th2","th3","bezier","cx","cy","cos_th0","sin_th0","cos_th1","sin_th1","th_half","sin_th_h2","x3","y3","temp","scale$1","current","sX","sY","n","pathRender","context","previous","controlX","controlY","tempX","tempY","tempControlX","tempControlY","anchorX","anchorY","beginPath","len","lineTo","moveTo","bezierCurveTo","quadraticCurveTo","drawArc","closePath","coords","seg","bez","Tan30","builtins","draw","size","r","w","rect","o","b","symbols","_","customSymbol","custom","parsed","C","rectangleX","rectangleY","rectangleWidth","width","rectangleHeight","height","number","clamp","min","max","vg_rect","crTL","crTR","crBL","crBR","rectangle","buffer","tl","tr","bl","br","cornerRadius","vg_trail","defined","ready","point","w2","ux","uy","ud","hypot","trail","data","defined0","value$1","item","xw","yh","sa","startAngle","ea","endAngle","pa","padAngle","ir","innerRadius","or","outerRadius","cr","cornerRadiusTopLeft","cornerRadiusTopRight","cornerRadiusBottomRight","cornerRadiusBottomLeft","sz","ts","shape","arcShape","areavShape","areahShape","lineShape","rectShape","symbolShape","trailShape","hasCornerRadius","arc$1","area$1","items","interp","interpolate","orient","line$1","shape$1","mark","symbol$1","trail$1","clip_id","resetSVGClipId","clip$1","renderer","clip","_defs","clipping","Bounds","clear","union","prototype","clone","Number","MAX_VALUE","empty","equals","set","add","expand","round","floor","scale","translate","dx","dy","rotate","angle","p","rotatedPoints","intersect","encloses","alignsWith","intersects","contains","Item","bounds","GroupItem","ResourceLoader","constructor","customLoader","_pending","_loader","pending","sanitizeURL","uri","increment","sanitize","then","opt","decrement","catch","loadImage","Image","url","href","img","cors","crossOrigin","onload","onerror","src","e","complete","Promise","accept","poll","setTimeout","boundStroke","miter","stroke","opacity","strokeOpacity","sw","strokeWidth","miterAdjustment","strokeJoin","circleThreshold","lx","ly","rot","ma","mb","mc","md","addL","addX","addY","addp","addpL","boundContext","deg","context$1","px1","py1","px2","py2","quadExtrema","px3","py3","cubicExtrema","ccw","update","cb","t0","t1","cubic","s2","t2","getContext","intersectPath","brush","isPointInPath","intersectPoint","box","intersectRect","intersectRule","intersectBoxLine","u","blend","globalCompositeOperation","dflt","addStops","addColorStop","spec","createRadialGradient","createLinearGradient","ictx","fillStyle","fillRect","createPattern","fill","fillOpacity","globalAlpha","Empty","lw","strokeStyle","lineWidth","lineCap","strokeCap","lineJoin","miterLimit","strokeMiterLimit","setLineDash","strokeDash","lineDashOffset","strokeDashOffset","compare","zindex","zorder","scene","zdirty","zitems","output","sort","visit","visitor","pickVisit","hit","drawAll","drawPath","drawOne","pick$1","test","gx","gy","pixelRatio","hitPath","filled","Array","isPointInStroke","lc","pickPath","scaleX","scaleY","translateItem","rotateItem","transformItem","markItemPath","isect","attr","emit","bound","tag","nested","pick","pickArea","Infinity","pickLine","pow","dd","pickTrail","markMultiItemPath","tip","save","clipGroup","group","offset$1","strokeOffset","attr$5","emitRectangle","off","background","foreground","strokeForeground","content","bound$5","j","noBound","rectanglePath","hitBackground","hitForeground","hitCorner","draw$4","markTypes","fore","marktype","includes","restore","dw","dh","ix","interactive","pickMark","metadata","getImage","imageWidth","aspect","imageHeight","imageXOffset","align","imageYOffset","baseline","attr$4","toDataURL","bound$4","draw$3","ar0","ar1","imageSmoothingEnabled","smooth","drawImage","xOffset","yOffset","attr$3","sx","sy","path$1","cache","pathCache","bound$3","path$2","attr$2","bound$2","draw$2","attr$1","bound$1","draw$1","hit$1","rule","widthCache","textMetrics","fontSize","measureWidth","estimateWidth","useCanvas","use","text","_estimateWidth","textValue","currentFontHeight","_measureWidth","font","currentFont","undefined","measureText","lineHeight","lineArray","textLines","lineBreak","split","multiLineOffset","limit","truncate","widthGetter","ellipsis","rtl","dir","lo","hi","mid","fontFamily","quote","String","replace","fontStyle","fontVariant","fontWeight","textAlign","tempBounds","anchorPoint","radius","theta","mode","reduce","lh","fillText","strokeText","ax","ay","intersectText","Marks","boundItem","func","DUMMY","boundMark","hasItems","keys","sceneToJSON","indent","JSON","stringify","sceneFromJSON","json","initialize","parent","Scenegraph","root","createMark","name","role","toJSON","markdef","aria","description","domCreate","doc","ns","document","createElement","createElementNS","domFind","el","nodes","childNodes","tagName","domChild","ownerDocument","insertBefore","domClear","curr","removeChild","cssClass","event","getBoundingClientRect","clientX","left","clientLeft","clientY","top","clientTop","resolveItem","origin","mdef","Handler","customTooltip","_active","_handlers","_tooltip","defaultTooltip","obj","_el","_obj","element","firstChild","_origin","_scene","on","_handlerIndex","handler","handlers","eventName","k","indexOf","handleHref","MouseEvent","setAttribute","dispatchEvent","handleTooltip","show","tooltip","getItemBoundingClientRect","right","bottom","Renderer","_bgcolor","scaleFactor","resize","bgcolor","_width","_height","_scale","dirty","render","_call","_render","renderAsync","_ready","resolve","_load","method","redraw","KeyDownEvent","KeyPressEvent","KeyUpEvent","DragEnterEvent","DragLeaveEvent","DragOverEvent","PointerDownEvent","PointerUpEvent","PointerMoveEvent","PointerOutEvent","PointerOverEvent","MouseDownEvent","MouseUpEvent","MouseMoveEvent","MouseOutEvent","MouseOverEvent","ClickEvent","DoubleClickEvent","WheelEvent","MouseWheelEvent","TouchStartEvent","TouchMoveEvent","TouchEndEvent","Events","TooltipShowEvent","TooltipHideEvent","HrefEvent","CanvasHandler","_down","_touch","_first","_events","events","pointermove","move","dragover","pointerout","inactive","dragleave","_canvas","eventListenerCheck","DOMMouseScroll","evt","fire","pointerdown","mousedown","click","touchstart","pickEvent","changedTouches","touchmove","touchend","touch","vegaType","splice","eventBundle","addEventListener","fireAll","types","moveEvents","overEvents","outEvents","exit","devicePixelRatio","window","inDOM","HTMLElement","parentNode","ratio","style","setTransform","CanvasRenderer","_options","_redraw","_dirty","_tempb","options","externalContext","appendChild","ctx","db","vb","viewBounds","clipToBounds","clearRect","SVGHandler","_hrefHandler","listener","_tooltipHandler","svg","_svg","removeEventListener","target","__data__","ARIA_HIDDEN","ARIA_LABEL","ARIA_ROLE","ARIA_ROLEDESCRIPTION","GRAPHICS_OBJECT","GRAPHICS_SYMBOL","bundle","roledesc","label","AriaIgnore","AriaGuides","desc","caption","axisCaption","legendCaption","titleCaption","AriaEncode","ariaRole","ariaRoleDescription","ariaItemAttributes","hide","prop","ariaMarkAttributes","ariaGuide","ariaMark","recurse","some","err","datum","title","extractTitle","scales","locale","dataflow","xy","props","Object","capitalize","channelCaption","map","toUpperCase","innerText","attrText","markup","buf","outer","inner","stack","open","_len","attrs","_key","close","pop","toString","serializeXML","node","_serialize","hasAttributes","attributes","hasChildNodes","children","child","nodeType","nodeValue","stylesAttr","stylesCss","rootAttributes","RootIndex","xmlns","svgns","SVGRenderer","_dirtyID","_root","_clearDefs","setAttributeNS","setAttributes","setProperty","viewBox","bg","removeAttribute","_dirtyCheck","_dirtyAll","isDirty","ownerSVGElement","dirtyParents","_update","prev","markType","isGroup","bind","sibling","process","values","__values__","extra","mark_extras","setStyle","updateGradient","updateClipping","grad","pt","preserveAspectRatio","fx","fy","fr","mask","lastChild","previousSibling","idx","cg","fg","siblingCheck","nextSibling","textContent","removeProperty","removeAttributeNS","loc","location","hash","SVGStringRenderer","_text","class","transform","attrList","_hrefs","object","prefixed","fn","styleList","display","OPTS","svgMarkTypes","svgOnTop","debug","setHybridRendererOptions","HybridRenderer","_svgRenderer","_canvasRenderer","_root_el","bottomEl","topEl","position","_svgEl","_canvasEl","pointerEvents","allMarkTypes","canvasMarkTypes","filter","HybridHandler","Canvas","Hybrid","PNG","SVG","None","RenderType","modules","headless","renderModule","hits","intersectMark","intersectGroup","visitMark","intersectItem","marks","clipBounds","boundClip","TOLERANCE","sceneEqual","pathEqual","Date","objectEqual","ka","kb","resetSVGDefIds","pathCurves","pathParse","pathRectangle","pathSymbols","pathTrail","scenePickVisit","sceneVisit","sceneZOrder"],"sources":["C:/Users/sutul/node_modules/vega-scenegraph/build/vega-scenegraph.module.js"],"sourcesContent":["import { hasOwnProperty, isFunction, inherits, truthy, lruCache, isArray, error, toSet, array, peek, extend, isNumber, isObject } from 'vega-util';\nimport { curveBasis, curveBasisClosed, curveBasisOpen, curveBundle, curveCardinal, curveCardinalOpen, curveCardinalClosed, curveCatmullRom, curveCatmullRomClosed, curveCatmullRomOpen, curveLinear, curveLinearClosed, curveMonotoneY, curveMonotoneX, curveNatural, curveStep, curveStepAfter, curveStepBefore, arc as arc$2, area as area$2, line as line$2, symbol as symbol$2 } from 'd3-shape';\nimport { path as path$3 } from 'd3-path';\nexport { path } from 'd3-path';\nimport { image as image$1, canvas } from 'vega-canvas';\nimport { loader } from 'vega-loader';\nimport { isDiscrete, domainCaption } from 'vega-scale';\n\nlet gradient_id = 0;\nfunction resetSVGGradientId() {\n  gradient_id = 0;\n}\nconst patternPrefix = 'p_';\nfunction isGradient(value) {\n  return value && value.gradient;\n}\nfunction gradientRef(g, defs, base) {\n  const type = g.gradient;\n  let id = g.id,\n    prefix = type === 'radial' ? patternPrefix : '';\n\n  // check id, assign default values as needed\n  if (!id) {\n    id = g.id = 'gradient_' + gradient_id++;\n    if (type === 'radial') {\n      g.x1 = get(g.x1, 0.5);\n      g.y1 = get(g.y1, 0.5);\n      g.r1 = get(g.r1, 0);\n      g.x2 = get(g.x2, 0.5);\n      g.y2 = get(g.y2, 0.5);\n      g.r2 = get(g.r2, 0.5);\n      prefix = patternPrefix;\n    } else {\n      g.x1 = get(g.x1, 0);\n      g.y1 = get(g.y1, 0);\n      g.x2 = get(g.x2, 1);\n      g.y2 = get(g.y2, 0);\n    }\n  }\n\n  // register definition\n  defs[id] = g;\n\n  // return url reference\n  return 'url(' + (base || '') + '#' + prefix + id + ')';\n}\nfunction get(val, def) {\n  return val != null ? val : def;\n}\nfunction Gradient (p0, p1) {\n  var stops = [],\n    gradient;\n  return gradient = {\n    gradient: 'linear',\n    x1: p0 ? p0[0] : 0,\n    y1: p0 ? p0[1] : 0,\n    x2: p1 ? p1[0] : 1,\n    y2: p1 ? p1[1] : 0,\n    stops: stops,\n    stop: function (offset, color) {\n      stops.push({\n        offset: offset,\n        color: color\n      });\n      return gradient;\n    }\n  };\n}\n\nconst lookup = {\n  'basis': {\n    curve: curveBasis\n  },\n  'basis-closed': {\n    curve: curveBasisClosed\n  },\n  'basis-open': {\n    curve: curveBasisOpen\n  },\n  'bundle': {\n    curve: curveBundle,\n    tension: 'beta',\n    value: 0.85\n  },\n  'cardinal': {\n    curve: curveCardinal,\n    tension: 'tension',\n    value: 0\n  },\n  'cardinal-open': {\n    curve: curveCardinalOpen,\n    tension: 'tension',\n    value: 0\n  },\n  'cardinal-closed': {\n    curve: curveCardinalClosed,\n    tension: 'tension',\n    value: 0\n  },\n  'catmull-rom': {\n    curve: curveCatmullRom,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'catmull-rom-closed': {\n    curve: curveCatmullRomClosed,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'catmull-rom-open': {\n    curve: curveCatmullRomOpen,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'linear': {\n    curve: curveLinear\n  },\n  'linear-closed': {\n    curve: curveLinearClosed\n  },\n  'monotone': {\n    horizontal: curveMonotoneY,\n    vertical: curveMonotoneX\n  },\n  'natural': {\n    curve: curveNatural\n  },\n  'step': {\n    curve: curveStep\n  },\n  'step-after': {\n    curve: curveStepAfter\n  },\n  'step-before': {\n    curve: curveStepBefore\n  }\n};\nfunction curves(type, orientation, tension) {\n  var entry = hasOwnProperty(lookup, type) && lookup[type],\n    curve = null;\n  if (entry) {\n    curve = entry.curve || entry[orientation || 'vertical'];\n    if (entry.tension && tension != null) {\n      curve = curve[entry.tension](tension);\n    }\n  }\n  return curve;\n}\n\nconst paramCounts = {\n  m: 2,\n  l: 2,\n  h: 1,\n  v: 1,\n  z: 0,\n  c: 6,\n  s: 4,\n  q: 4,\n  t: 2,\n  a: 7\n};\nconst commandPattern = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi;\nconst numberPattern = /^[+-]?(([0-9]*\\.[0-9]+)|([0-9]+\\.)|([0-9]+))([eE][+-]?[0-9]+)?/;\nconst spacePattern = /^((\\s+,?\\s*)|(,\\s*))/;\nconst flagPattern = /^[01]/;\nfunction parse(path) {\n  const commands = [];\n  const matches = path.match(commandPattern) || [];\n  matches.forEach(str => {\n    let cmd = str[0];\n    const type = cmd.toLowerCase();\n\n    // parse parameters\n    const paramCount = paramCounts[type];\n    const params = parseParams(type, paramCount, str.slice(1).trim());\n    const count = params.length;\n\n    // error checking based on parameter count\n    if (count < paramCount || count && count % paramCount !== 0) {\n      throw Error('Invalid SVG path, incorrect parameter count');\n    }\n\n    // register the command\n    commands.push([cmd, ...params.slice(0, paramCount)]);\n\n    // exit now if we're done, also handles zero-param 'z'\n    if (count === paramCount) {\n      return;\n    }\n\n    // handle implicit line-to\n    if (type === 'm') {\n      cmd = cmd === 'M' ? 'L' : 'l';\n    }\n\n    // repeat command when given extended param list\n    for (let i = paramCount; i < count; i += paramCount) {\n      commands.push([cmd, ...params.slice(i, i + paramCount)]);\n    }\n  });\n  return commands;\n}\nfunction parseParams(type, paramCount, segment) {\n  const params = [];\n  for (let index = 0; paramCount && index < segment.length;) {\n    for (let i = 0; i < paramCount; ++i) {\n      const pattern = type === 'a' && (i === 3 || i === 4) ? flagPattern : numberPattern;\n      const match = segment.slice(index).match(pattern);\n      if (match === null) {\n        throw Error('Invalid SVG path, incorrect parameter type');\n      }\n      index += match[0].length;\n      params.push(+match[0]);\n      const ws = segment.slice(index).match(spacePattern);\n      if (ws !== null) {\n        index += ws[0].length;\n      }\n    }\n  }\n  return params;\n}\n\nconst DegToRad = Math.PI / 180;\nconst Epsilon = 1e-14;\nconst HalfPi = Math.PI / 2;\nconst Tau = Math.PI * 2;\nconst HalfSqrt3 = Math.sqrt(3) / 2;\n\nvar segmentCache = {};\nvar bezierCache = {};\nvar join = [].join;\n\n// Copied from Inkscape svgtopdf, thanks!\nfunction segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  const key = join.call(arguments);\n  if (segmentCache[key]) {\n    return segmentCache[key];\n  }\n  const th = rotateX * DegToRad;\n  const sin_th = Math.sin(th);\n  const cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  const py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  let pl = px * px / (rx * rx) + py * py / (ry * ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n  const a00 = cos_th / rx;\n  const a01 = sin_th / rx;\n  const a10 = -sin_th / ry;\n  const a11 = cos_th / ry;\n  const x0 = a00 * ox + a01 * oy;\n  const y0 = a10 * ox + a11 * oy;\n  const x1 = a00 * x + a01 * y;\n  const y1 = a10 * x + a11 * y;\n  const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);\n  let sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  let sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);\n  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);\n  const th0 = Math.atan2(y0 - yc, x0 - xc);\n  const th1 = Math.atan2(y1 - yc, x1 - xc);\n  let th_arc = th1 - th0;\n  if (th_arc < 0 && sweep === 1) {\n    th_arc += Tau;\n  } else if (th_arc > 0 && sweep === 0) {\n    th_arc -= Tau;\n  }\n  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 0.001)));\n  const result = [];\n  for (let i = 0; i < segs; ++i) {\n    const th2 = th0 + i * th_arc / segs;\n    const th3 = th0 + (i + 1) * th_arc / segs;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n  return segmentCache[key] = result;\n}\nfunction bezier(params) {\n  const key = join.call(params);\n  if (bezierCache[key]) {\n    return bezierCache[key];\n  }\n  var cx = params[0],\n    cy = params[1],\n    th0 = params[2],\n    th1 = params[3],\n    rx = params[4],\n    ry = params[5],\n    sin_th = params[6],\n    cos_th = params[7];\n  const a00 = cos_th * rx;\n  const a01 = -sin_th * ry;\n  const a10 = sin_th * rx;\n  const a11 = cos_th * ry;\n  const cos_th0 = Math.cos(th0);\n  const sin_th0 = Math.sin(th0);\n  const cos_th1 = Math.cos(th1);\n  const sin_th1 = Math.sin(th1);\n  const th_half = 0.5 * (th1 - th0);\n  const sin_th_h2 = Math.sin(th_half * 0.5);\n  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  const x1 = cx + cos_th0 - t * sin_th0;\n  const y1 = cy + sin_th0 + t * cos_th0;\n  const x3 = cx + cos_th1;\n  const y3 = cy + sin_th1;\n  const x2 = x3 + t * sin_th1;\n  const y2 = y3 - t * cos_th1;\n  return bezierCache[key] = [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];\n}\n\nconst temp = ['l', 0, 0, 0, 0, 0, 0, 0];\nfunction scale$1(current, sX, sY) {\n  const c = temp[0] = current[0];\n  if (c === 'a' || c === 'A') {\n    temp[1] = sX * current[1];\n    temp[2] = sY * current[2];\n    temp[3] = current[3];\n    temp[4] = current[4];\n    temp[5] = current[5];\n    temp[6] = sX * current[6];\n    temp[7] = sY * current[7];\n  } else if (c === 'h' || c === 'H') {\n    temp[1] = sX * current[1];\n  } else if (c === 'v' || c === 'V') {\n    temp[1] = sY * current[1];\n  } else {\n    for (var i = 1, n = current.length; i < n; ++i) {\n      temp[i] = (i % 2 == 1 ? sX : sY) * current[i];\n    }\n  }\n  return temp;\n}\nfunction pathRender (context, path, l, t, sX, sY) {\n  var current,\n    // current instruction\n    previous = null,\n    x = 0,\n    // current x\n    y = 0,\n    // current y\n    controlX = 0,\n    // current control point x\n    controlY = 0,\n    // current control point y\n    tempX,\n    tempY,\n    tempControlX,\n    tempControlY,\n    anchorX = 0,\n    anchorY = 0;\n  if (l == null) l = 0;\n  if (t == null) t = 0;\n  if (sX == null) sX = 1;\n  if (sY == null) sY = sX;\n  if (context.beginPath) context.beginPath();\n  for (var i = 0, len = path.length; i < len; ++i) {\n    current = path[i];\n    if (sX !== 1 || sY !== 1) {\n      current = scale$1(current, sX, sY);\n    }\n    switch (current[0]) {\n      // first letter\n\n      case 'l':\n        // lineto, relative\n        x += current[1];\n        y += current[2];\n        context.lineTo(x + l, y + t);\n        break;\n      case 'L':\n        // lineto, absolute\n        x = current[1];\n        y = current[2];\n        context.lineTo(x + l, y + t);\n        break;\n      case 'h':\n        // horizontal lineto, relative\n        x += current[1];\n        context.lineTo(x + l, y + t);\n        break;\n      case 'H':\n        // horizontal lineto, absolute\n        x = current[1];\n        context.lineTo(x + l, y + t);\n        break;\n      case 'v':\n        // vertical lineto, relative\n        y += current[1];\n        context.lineTo(x + l, y + t);\n        break;\n      case 'V':\n        // verical lineto, absolute\n        y = current[1];\n        context.lineTo(x + l, y + t);\n        break;\n      case 'm':\n        // moveTo, relative\n        x += current[1];\n        y += current[2];\n        anchorX = x;\n        anchorY = y;\n        context.moveTo(x + l, y + t);\n        break;\n      case 'M':\n        // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        anchorX = x;\n        anchorY = y;\n        context.moveTo(x + l, y + t);\n        break;\n      case 'c':\n        // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        context.bezierCurveTo(x + current[1] + l,\n        // x1\n        y + current[2] + t,\n        // y1\n        controlX + l,\n        // x2\n        controlY + t,\n        // y2\n        tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n      case 'C':\n        // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        context.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);\n        break;\n      case 's':\n        // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t);\n\n        // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n        controlX = x + current[1];\n        controlY = y + current[2];\n        x = tempX;\n        y = tempY;\n        break;\n      case 'S':\n        // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n        controlX = current[1];\n        controlY = current[2];\n        break;\n      case 'q':\n        // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        controlX = x + current[1];\n        controlY = y + current[2];\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n      case 'Q':\n        // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        context.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        break;\n      case 't':\n        // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        } else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        } else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n        tempControlX = controlX;\n        tempControlY = controlY;\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        break;\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);\n        x = tempX;\n        y = tempY;\n        break;\n      case 'a':\n        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]);\n        x += current[6];\n        y += current[7];\n        break;\n      case 'A':\n        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]);\n        x = current[6];\n        y = current[7];\n        break;\n      case 'z':\n      case 'Z':\n        x = anchorX;\n        y = anchorY;\n        context.closePath();\n        break;\n    }\n    previous = current;\n  }\n}\nfunction drawArc(context, x, y, coords) {\n  const seg = segments(coords[5],\n  // end x\n  coords[6],\n  // end y\n  coords[0],\n  // radius x\n  coords[1],\n  // radius y\n  coords[3],\n  // large flag\n  coords[4],\n  // sweep flag\n  coords[2],\n  // rotation\n  x, y);\n  for (let i = 0; i < seg.length; ++i) {\n    const bez = bezier(seg[i]);\n    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);\n  }\n}\n\nconst Tan30 = 0.5773502691896257;\nconst builtins = {\n  'circle': {\n    draw: function (context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(r, 0);\n      context.arc(0, 0, r, 0, Tau);\n    }\n  },\n  'cross': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n        s = r / 2.5;\n      context.moveTo(-r, -s);\n      context.lineTo(-r, s);\n      context.lineTo(-s, s);\n      context.lineTo(-s, r);\n      context.lineTo(s, r);\n      context.lineTo(s, s);\n      context.lineTo(r, s);\n      context.lineTo(r, -s);\n      context.lineTo(s, -s);\n      context.lineTo(s, -r);\n      context.lineTo(-s, -r);\n      context.lineTo(-s, -s);\n      context.closePath();\n    }\n  },\n  'diamond': {\n    draw: function (context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(-r, 0);\n      context.lineTo(0, -r);\n      context.lineTo(r, 0);\n      context.lineTo(0, r);\n      context.closePath();\n    }\n  },\n  'square': {\n    draw: function (context, size) {\n      var w = Math.sqrt(size),\n        x = -w / 2;\n      context.rect(x, x, w, w);\n    }\n  },\n  'arrow': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n        s = r / 7,\n        t = r / 2.5,\n        v = r / 8;\n      context.moveTo(-s, r);\n      context.lineTo(s, r);\n      context.lineTo(s, -v);\n      context.lineTo(t, -v);\n      context.lineTo(0, -r);\n      context.lineTo(-t, -v);\n      context.lineTo(-s, -v);\n      context.closePath();\n    }\n  },\n  'wedge': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n        h = HalfSqrt3 * r,\n        o = h - r * Tan30,\n        b = r / 4;\n      context.moveTo(0, -h - o);\n      context.lineTo(-b, h - o);\n      context.lineTo(b, h - o);\n      context.closePath();\n    }\n  },\n  'triangle': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n        h = HalfSqrt3 * r,\n        o = h - r * Tan30;\n      context.moveTo(0, -h - o);\n      context.lineTo(-r, h - o);\n      context.lineTo(r, h - o);\n      context.closePath();\n    }\n  },\n  'triangle-up': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n        h = HalfSqrt3 * r;\n      context.moveTo(0, -h);\n      context.lineTo(-r, h);\n      context.lineTo(r, h);\n      context.closePath();\n    }\n  },\n  'triangle-down': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n        h = HalfSqrt3 * r;\n      context.moveTo(0, h);\n      context.lineTo(-r, -h);\n      context.lineTo(r, -h);\n      context.closePath();\n    }\n  },\n  'triangle-right': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n        h = HalfSqrt3 * r;\n      context.moveTo(h, 0);\n      context.lineTo(-h, -r);\n      context.lineTo(-h, r);\n      context.closePath();\n    }\n  },\n  'triangle-left': {\n    draw: function (context, size) {\n      var r = Math.sqrt(size) / 2,\n        h = HalfSqrt3 * r;\n      context.moveTo(-h, 0);\n      context.lineTo(h, -r);\n      context.lineTo(h, r);\n      context.closePath();\n    }\n  },\n  'stroke': {\n    draw: function (context, size) {\n      const r = Math.sqrt(size) / 2;\n      context.moveTo(-r, 0);\n      context.lineTo(r, 0);\n    }\n  }\n};\nfunction symbols(_) {\n  return hasOwnProperty(builtins, _) ? builtins[_] : customSymbol(_);\n}\nvar custom = {};\nfunction customSymbol(path) {\n  if (!hasOwnProperty(custom, path)) {\n    const parsed = parse(path);\n    custom[path] = {\n      draw: function (context, size) {\n        pathRender(context, parsed, 0, 0, Math.sqrt(size) / 2);\n      }\n    };\n  }\n  return custom[path];\n}\n\n// See http://spencermortensen.com/articles/bezier-circle/\nconst C = 0.448084975506; // C = 1 - c\n\nfunction rectangleX(d) {\n  return d.x;\n}\nfunction rectangleY(d) {\n  return d.y;\n}\nfunction rectangleWidth(d) {\n  return d.width;\n}\nfunction rectangleHeight(d) {\n  return d.height;\n}\nfunction number(_) {\n  return typeof _ === 'function' ? _ : () => +_;\n}\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n}\nfunction vg_rect () {\n  var x = rectangleX,\n    y = rectangleY,\n    width = rectangleWidth,\n    height = rectangleHeight,\n    crTL = number(0),\n    crTR = crTL,\n    crBL = crTL,\n    crBR = crTL,\n    context = null;\n  function rectangle(_, x0, y0) {\n    var buffer,\n      x1 = x0 != null ? x0 : +x.call(this, _),\n      y1 = y0 != null ? y0 : +y.call(this, _),\n      w = +width.call(this, _),\n      h = +height.call(this, _),\n      s = Math.min(w, h) / 2,\n      tl = clamp(+crTL.call(this, _), 0, s),\n      tr = clamp(+crTR.call(this, _), 0, s),\n      bl = clamp(+crBL.call(this, _), 0, s),\n      br = clamp(+crBR.call(this, _), 0, s);\n    if (!context) context = buffer = path$3();\n    if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {\n      context.rect(x1, y1, w, h);\n    } else {\n      var x2 = x1 + w,\n        y2 = y1 + h;\n      context.moveTo(x1 + tl, y1);\n      context.lineTo(x2 - tr, y1);\n      context.bezierCurveTo(x2 - C * tr, y1, x2, y1 + C * tr, x2, y1 + tr);\n      context.lineTo(x2, y2 - br);\n      context.bezierCurveTo(x2, y2 - C * br, x2 - C * br, y2, x2 - br, y2);\n      context.lineTo(x1 + bl, y2);\n      context.bezierCurveTo(x1 + C * bl, y2, x1, y2 - C * bl, x1, y2 - bl);\n      context.lineTo(x1, y1 + tl);\n      context.bezierCurveTo(x1, y1 + C * tl, x1 + C * tl, y1, x1 + tl, y1);\n      context.closePath();\n    }\n    if (buffer) {\n      context = null;\n      return buffer + '' || null;\n    }\n  }\n  rectangle.x = function (_) {\n    if (arguments.length) {\n      x = number(_);\n      return rectangle;\n    } else {\n      return x;\n    }\n  };\n  rectangle.y = function (_) {\n    if (arguments.length) {\n      y = number(_);\n      return rectangle;\n    } else {\n      return y;\n    }\n  };\n  rectangle.width = function (_) {\n    if (arguments.length) {\n      width = number(_);\n      return rectangle;\n    } else {\n      return width;\n    }\n  };\n  rectangle.height = function (_) {\n    if (arguments.length) {\n      height = number(_);\n      return rectangle;\n    } else {\n      return height;\n    }\n  };\n  rectangle.cornerRadius = function (tl, tr, br, bl) {\n    if (arguments.length) {\n      crTL = number(tl);\n      crTR = tr != null ? number(tr) : crTL;\n      crBR = br != null ? number(br) : crTL;\n      crBL = bl != null ? number(bl) : crTR;\n      return rectangle;\n    } else {\n      return crTL;\n    }\n  };\n  rectangle.context = function (_) {\n    if (arguments.length) {\n      context = _ == null ? null : _;\n      return rectangle;\n    } else {\n      return context;\n    }\n  };\n  return rectangle;\n}\n\nfunction vg_trail () {\n  var x,\n    y,\n    size,\n    defined,\n    context = null,\n    ready,\n    x1,\n    y1,\n    r1;\n  function point(x2, y2, w2) {\n    const r2 = w2 / 2;\n    if (ready) {\n      var ux = y1 - y2,\n        uy = x2 - x1;\n      if (ux || uy) {\n        // get normal vector\n        var ud = Math.hypot(ux, uy),\n          rx = (ux /= ud) * r1,\n          ry = (uy /= ud) * r1,\n          t = Math.atan2(uy, ux);\n\n        // draw segment\n        context.moveTo(x1 - rx, y1 - ry);\n        context.lineTo(x2 - ux * r2, y2 - uy * r2);\n        context.arc(x2, y2, r2, t - Math.PI, t);\n        context.lineTo(x1 + rx, y1 + ry);\n        context.arc(x1, y1, r1, t, t + Math.PI);\n      } else {\n        context.arc(x2, y2, r2, 0, Tau);\n      }\n      context.closePath();\n    } else {\n      ready = 1;\n    }\n    x1 = x2;\n    y1 = y2;\n    r1 = r2;\n  }\n  function trail(data) {\n    var i,\n      n = data.length,\n      d,\n      defined0 = false,\n      buffer;\n    if (context == null) context = buffer = path$3();\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) ready = 0;\n      }\n      if (defined0) point(+x(d, i, data), +y(d, i, data), +size(d, i, data));\n    }\n    if (buffer) {\n      context = null;\n      return buffer + '' || null;\n    }\n  }\n  trail.x = function (_) {\n    if (arguments.length) {\n      x = _;\n      return trail;\n    } else {\n      return x;\n    }\n  };\n  trail.y = function (_) {\n    if (arguments.length) {\n      y = _;\n      return trail;\n    } else {\n      return y;\n    }\n  };\n  trail.size = function (_) {\n    if (arguments.length) {\n      size = _;\n      return trail;\n    } else {\n      return size;\n    }\n  };\n  trail.defined = function (_) {\n    if (arguments.length) {\n      defined = _;\n      return trail;\n    } else {\n      return defined;\n    }\n  };\n  trail.context = function (_) {\n    if (arguments.length) {\n      if (_ == null) {\n        context = null;\n      } else {\n        context = _;\n      }\n      return trail;\n    } else {\n      return context;\n    }\n  };\n  return trail;\n}\n\nfunction value$1(a, b) {\n  return a != null ? a : b;\n}\nconst x = item => item.x || 0,\n  y = item => item.y || 0,\n  w = item => item.width || 0,\n  h = item => item.height || 0,\n  xw = item => (item.x || 0) + (item.width || 0),\n  yh = item => (item.y || 0) + (item.height || 0),\n  sa = item => item.startAngle || 0,\n  ea = item => item.endAngle || 0,\n  pa = item => item.padAngle || 0,\n  ir = item => item.innerRadius || 0,\n  or = item => item.outerRadius || 0,\n  cr = item => item.cornerRadius || 0,\n  tl = item => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0,\n  tr = item => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0,\n  br = item => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0,\n  bl = item => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0,\n  sz = item => value$1(item.size, 64),\n  ts = item => item.size || 1,\n  def = item => !(item.defined === false),\n  type = item => symbols(item.shape || 'circle');\nconst arcShape = arc$2().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr),\n  areavShape = area$2().x(x).y1(y).y0(yh).defined(def),\n  areahShape = area$2().y(y).x1(x).x0(xw).defined(def),\n  lineShape = line$2().x(x).y(y).defined(def),\n  rectShape = vg_rect().x(x).y(y).width(w).height(h).cornerRadius(tl, tr, br, bl),\n  symbolShape = symbol$2().type(type).size(sz),\n  trailShape = vg_trail().x(x).y(y).defined(def).size(ts);\nfunction hasCornerRadius(item) {\n  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;\n}\nfunction arc$1(context, item) {\n  return arcShape.context(context)(item);\n}\nfunction area$1(context, items) {\n  const item = items[0],\n    interp = item.interpolate || 'linear';\n  return (item.orient === 'horizontal' ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context)(items);\n}\nfunction line$1(context, items) {\n  const item = items[0],\n    interp = item.interpolate || 'linear';\n  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context)(items);\n}\nfunction rectangle(context, item, x, y) {\n  return rectShape.context(context)(item, x, y);\n}\nfunction shape$1(context, item) {\n  return (item.mark.shape || item.shape).context(context)(item);\n}\nfunction symbol$1(context, item) {\n  return symbolShape.context(context)(item);\n}\nfunction trail$1(context, items) {\n  return trailShape.context(context)(items);\n}\n\nvar clip_id = 1;\nfunction resetSVGClipId() {\n  clip_id = 1;\n}\nfunction clip$1 (renderer, item, size) {\n  var clip = item.clip,\n    defs = renderer._defs,\n    id = item.clip_id || (item.clip_id = 'clip' + clip_id++),\n    c = defs.clipping[id] || (defs.clipping[id] = {\n      id: id\n    });\n  if (isFunction(clip)) {\n    c.path = clip(null);\n  } else if (hasCornerRadius(size)) {\n    c.path = rectangle(null, size, 0, 0);\n  } else {\n    c.width = size.width || 0;\n    c.height = size.height || 0;\n  }\n  return 'url(#' + id + ')';\n}\n\nfunction Bounds(b) {\n  this.clear();\n  if (b) this.union(b);\n}\nBounds.prototype = {\n  clone() {\n    return new Bounds(this);\n  },\n  clear() {\n    this.x1 = +Number.MAX_VALUE;\n    this.y1 = +Number.MAX_VALUE;\n    this.x2 = -Number.MAX_VALUE;\n    this.y2 = -Number.MAX_VALUE;\n    return this;\n  },\n  empty() {\n    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;\n  },\n  equals(b) {\n    return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;\n  },\n  set(x1, y1, x2, y2) {\n    if (x2 < x1) {\n      this.x2 = x1;\n      this.x1 = x2;\n    } else {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n    if (y2 < y1) {\n      this.y2 = y1;\n      this.y1 = y2;\n    } else {\n      this.y1 = y1;\n      this.y2 = y2;\n    }\n    return this;\n  },\n  add(x, y) {\n    if (x < this.x1) this.x1 = x;\n    if (y < this.y1) this.y1 = y;\n    if (x > this.x2) this.x2 = x;\n    if (y > this.y2) this.y2 = y;\n    return this;\n  },\n  expand(d) {\n    this.x1 -= d;\n    this.y1 -= d;\n    this.x2 += d;\n    this.y2 += d;\n    return this;\n  },\n  round() {\n    this.x1 = Math.floor(this.x1);\n    this.y1 = Math.floor(this.y1);\n    this.x2 = Math.ceil(this.x2);\n    this.y2 = Math.ceil(this.y2);\n    return this;\n  },\n  scale(s) {\n    this.x1 *= s;\n    this.y1 *= s;\n    this.x2 *= s;\n    this.y2 *= s;\n    return this;\n  },\n  translate(dx, dy) {\n    this.x1 += dx;\n    this.x2 += dx;\n    this.y1 += dy;\n    this.y2 += dy;\n    return this;\n  },\n  rotate(angle, x, y) {\n    const p = this.rotatedPoints(angle, x, y);\n    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);\n  },\n  rotatedPoints(angle, x, y) {\n    var {\n        x1,\n        y1,\n        x2,\n        y2\n      } = this,\n      cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      cx = x - x * cos + y * sin,\n      cy = y - x * sin - y * cos;\n    return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];\n  },\n  union(b) {\n    if (b.x1 < this.x1) this.x1 = b.x1;\n    if (b.y1 < this.y1) this.y1 = b.y1;\n    if (b.x2 > this.x2) this.x2 = b.x2;\n    if (b.y2 > this.y2) this.y2 = b.y2;\n    return this;\n  },\n  intersect(b) {\n    if (b.x1 > this.x1) this.x1 = b.x1;\n    if (b.y1 > this.y1) this.y1 = b.y1;\n    if (b.x2 < this.x2) this.x2 = b.x2;\n    if (b.y2 < this.y2) this.y2 = b.y2;\n    return this;\n  },\n  encloses(b) {\n    return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;\n  },\n  alignsWith(b) {\n    return b && (this.x1 == b.x1 || this.x2 == b.x2 || this.y1 == b.y1 || this.y2 == b.y2);\n  },\n  intersects(b) {\n    return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);\n  },\n  contains(x, y) {\n    return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);\n  },\n  width() {\n    return this.x2 - this.x1;\n  },\n  height() {\n    return this.y2 - this.y1;\n  }\n};\n\nfunction Item(mark) {\n  this.mark = mark;\n  this.bounds = this.bounds || new Bounds();\n}\n\nfunction GroupItem(mark) {\n  Item.call(this, mark);\n  this.items = this.items || [];\n}\ninherits(GroupItem, Item);\n\nclass ResourceLoader {\n  constructor(customLoader) {\n    this._pending = 0;\n    this._loader = customLoader || loader();\n  }\n  pending() {\n    return this._pending;\n  }\n  sanitizeURL(uri) {\n    const loader = this;\n    increment(loader);\n    return loader._loader.sanitize(uri, {\n      context: 'href'\n    }).then(opt => {\n      decrement(loader);\n      return opt;\n    }).catch(() => {\n      decrement(loader);\n      return null;\n    });\n  }\n  loadImage(uri) {\n    const loader = this,\n      Image = image$1();\n    increment(loader);\n    return loader._loader.sanitize(uri, {\n      context: 'image'\n    }).then(opt => {\n      const url = opt.href;\n      if (!url || !Image) throw {\n        url: url\n      };\n      const img = new Image();\n\n      // set crossOrigin only if cors is defined; empty string sets anonymous mode\n      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/crossOrigin\n      const cors = hasOwnProperty(opt, 'crossOrigin') ? opt.crossOrigin : 'anonymous';\n      if (cors != null) img.crossOrigin = cors;\n\n      // attempt to load image resource\n      img.onload = () => decrement(loader);\n      img.onerror = () => decrement(loader);\n      img.src = url;\n      return img;\n    }).catch(e => {\n      decrement(loader);\n      return {\n        complete: false,\n        width: 0,\n        height: 0,\n        src: e && e.url || ''\n      };\n    });\n  }\n  ready() {\n    const loader = this;\n    return new Promise(accept => {\n      function poll(value) {\n        if (!loader.pending()) accept(value);else setTimeout(() => {\n          poll(true);\n        }, 10);\n      }\n      poll(false);\n    });\n  }\n}\nfunction increment(loader) {\n  loader._pending += 1;\n}\nfunction decrement(loader) {\n  loader._pending -= 1;\n}\n\nfunction boundStroke (bounds, item, miter) {\n  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {\n    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;\n    bounds.expand(sw + (miter ? miterAdjustment(item, sw) : 0));\n  }\n  return bounds;\n}\nfunction miterAdjustment(item, strokeWidth) {\n  // TODO: more sophisticated adjustment? Or miter support in boundContext?\n  return item.strokeJoin && item.strokeJoin !== 'miter' ? 0 : strokeWidth;\n}\n\nconst circleThreshold = Tau - 1e-8;\nlet bounds, lx, ly, rot, ma, mb, mc, md;\nconst add = (x, y) => bounds.add(x, y);\nconst addL = (x, y) => add(lx = x, ly = y);\nconst addX = x => add(x, bounds.y1);\nconst addY = y => add(bounds.x1, y);\nconst px = (x, y) => ma * x + mc * y;\nconst py = (x, y) => mb * x + md * y;\nconst addp = (x, y) => add(px(x, y), py(x, y));\nconst addpL = (x, y) => addL(px(x, y), py(x, y));\nfunction boundContext (_, deg) {\n  bounds = _;\n  if (deg) {\n    rot = deg * DegToRad;\n    ma = md = Math.cos(rot);\n    mb = Math.sin(rot);\n    mc = -mb;\n  } else {\n    ma = md = 1;\n    rot = mb = mc = 0;\n  }\n  return context$1;\n}\nconst context$1 = {\n  beginPath() {},\n  closePath() {},\n  moveTo: addpL,\n  lineTo: addpL,\n  rect(x, y, w, h) {\n    if (rot) {\n      addp(x + w, y);\n      addp(x + w, y + h);\n      addp(x, y + h);\n      addpL(x, y);\n    } else {\n      add(x + w, y + h);\n      addL(x, y);\n    }\n  },\n  quadraticCurveTo(x1, y1, x2, y2) {\n    const px1 = px(x1, y1),\n      py1 = py(x1, y1),\n      px2 = px(x2, y2),\n      py2 = py(x2, y2);\n    quadExtrema(lx, px1, px2, addX);\n    quadExtrema(ly, py1, py2, addY);\n    addL(px2, py2);\n  },\n  bezierCurveTo(x1, y1, x2, y2, x3, y3) {\n    const px1 = px(x1, y1),\n      py1 = py(x1, y1),\n      px2 = px(x2, y2),\n      py2 = py(x2, y2),\n      px3 = px(x3, y3),\n      py3 = py(x3, y3);\n    cubicExtrema(lx, px1, px2, px3, addX);\n    cubicExtrema(ly, py1, py2, py3, addY);\n    addL(px3, py3);\n  },\n  arc(cx, cy, r, sa, ea, ccw) {\n    sa += rot;\n    ea += rot;\n\n    // store last point on path\n    lx = r * Math.cos(ea) + cx;\n    ly = r * Math.sin(ea) + cy;\n    if (Math.abs(ea - sa) > circleThreshold) {\n      // treat as full circle\n      add(cx - r, cy - r);\n      add(cx + r, cy + r);\n    } else {\n      const update = a => add(r * Math.cos(a) + cx, r * Math.sin(a) + cy);\n      let s, i;\n\n      // sample end points\n      update(sa);\n      update(ea);\n\n      // sample interior points aligned with 90 degrees\n      if (ea !== sa) {\n        sa = sa % Tau;\n        if (sa < 0) sa += Tau;\n        ea = ea % Tau;\n        if (ea < 0) ea += Tau;\n        if (ea < sa) {\n          ccw = !ccw; // flip direction\n          s = sa;\n          sa = ea;\n          ea = s; // swap end-points\n        }\n        if (ccw) {\n          ea -= Tau;\n          s = sa - sa % HalfPi;\n          for (i = 0; i < 4 && s > ea; ++i, s -= HalfPi) update(s);\n        } else {\n          s = sa - sa % HalfPi + HalfPi;\n          for (i = 0; i < 4 && s < ea; ++i, s = s + HalfPi) update(s);\n        }\n      }\n    }\n  }\n};\nfunction quadExtrema(x0, x1, x2, cb) {\n  const t = (x0 - x1) / (x0 + x2 - 2 * x1);\n  if (0 < t && t < 1) cb(x0 + (x1 - x0) * t);\n}\nfunction cubicExtrema(x0, x1, x2, x3, cb) {\n  const a = x3 - x0 + 3 * x1 - 3 * x2,\n    b = x0 + x2 - 2 * x1,\n    c = x0 - x1;\n  let t0 = 0,\n    t1 = 0,\n    r;\n\n  // solve for parameter t\n  if (Math.abs(a) > Epsilon) {\n    // quadratic equation\n    r = b * b + c * a;\n    if (r >= 0) {\n      r = Math.sqrt(r);\n      t0 = (-b + r) / a;\n      t1 = (-b - r) / a;\n    }\n  } else {\n    // linear equation\n    t0 = 0.5 * c / b;\n  }\n\n  // calculate position\n  if (0 < t0 && t0 < 1) cb(cubic(t0, x0, x1, x2, x3));\n  if (0 < t1 && t1 < 1) cb(cubic(t1, x0, x1, x2, x3));\n}\nfunction cubic(t, x0, x1, x2, x3) {\n  const s = 1 - t,\n    s2 = s * s,\n    t2 = t * t;\n  return s2 * s * x0 + 3 * s2 * t * x1 + 3 * s * t2 * x2 + t2 * t * x3;\n}\n\nvar context = (context = canvas(1, 1)) ? context.getContext('2d') : null;\n\nconst b = new Bounds();\nfunction intersectPath(draw) {\n  return function (item, brush) {\n    // rely on (inaccurate) bounds intersection if no context\n    if (!context) return true;\n\n    // add path to offscreen graphics context\n    draw(context, item);\n\n    // get bounds intersection region\n    b.clear().union(item.bounds).intersect(brush).round();\n    const {\n      x1,\n      y1,\n      x2,\n      y2\n    } = b;\n\n    // iterate over intersection region\n    // perform fine grained inclusion test\n    for (let y = y1; y <= y2; ++y) {\n      for (let x = x1; x <= x2; ++x) {\n        if (context.isPointInPath(x, y)) {\n          return true;\n        }\n      }\n    }\n\n    // false if no hits in intersection region\n    return false;\n  };\n}\nfunction intersectPoint(item, box) {\n  return box.contains(item.x || 0, item.y || 0);\n}\nfunction intersectRect(item, box) {\n  const x = item.x || 0,\n    y = item.y || 0,\n    w = item.width || 0,\n    h = item.height || 0;\n  return box.intersects(b.set(x, y, x + w, y + h));\n}\nfunction intersectRule(item, box) {\n  const x = item.x || 0,\n    y = item.y || 0,\n    x2 = item.x2 != null ? item.x2 : x,\n    y2 = item.y2 != null ? item.y2 : y;\n  return intersectBoxLine(box, x, y, x2, y2);\n}\nfunction intersectBoxLine(box, x, y, u, v) {\n  const {\n      x1,\n      y1,\n      x2,\n      y2\n    } = box,\n    dx = u - x,\n    dy = v - y;\n  let t0 = 0,\n    t1 = 1,\n    p,\n    q,\n    r,\n    e;\n  for (e = 0; e < 4; ++e) {\n    if (e === 0) {\n      p = -dx;\n      q = -(x1 - x);\n    }\n    if (e === 1) {\n      p = dx;\n      q = x2 - x;\n    }\n    if (e === 2) {\n      p = -dy;\n      q = -(y1 - y);\n    }\n    if (e === 3) {\n      p = dy;\n      q = y2 - y;\n    }\n    if (Math.abs(p) < 1e-10 && q < 0) return false;\n    r = q / p;\n    if (p < 0) {\n      if (r > t1) return false;else if (r > t0) t0 = r;\n    } else if (p > 0) {\n      if (r < t0) return false;else if (r < t1) t1 = r;\n    }\n  }\n  return true;\n}\n\nfunction blend (context, item) {\n  context.globalCompositeOperation = item.blend || 'source-over';\n}\n\nfunction value (value, dflt) {\n  return value == null ? dflt : value;\n}\n\nfunction addStops(gradient, stops) {\n  const n = stops.length;\n  for (let i = 0; i < n; ++i) {\n    gradient.addColorStop(stops[i].offset, stops[i].color);\n  }\n  return gradient;\n}\nfunction gradient (context, spec, bounds) {\n  const w = bounds.width(),\n    h = bounds.height();\n  let gradient;\n  if (spec.gradient === 'radial') {\n    gradient = context.createRadialGradient(bounds.x1 + value(spec.x1, 0.5) * w, bounds.y1 + value(spec.y1, 0.5) * h, Math.max(w, h) * value(spec.r1, 0), bounds.x1 + value(spec.x2, 0.5) * w, bounds.y1 + value(spec.y2, 0.5) * h, Math.max(w, h) * value(spec.r2, 0.5));\n  } else {\n    // linear gradient\n    const x1 = value(spec.x1, 0),\n      y1 = value(spec.y1, 0),\n      x2 = value(spec.x2, 1),\n      y2 = value(spec.y2, 0);\n    if (x1 === x2 || y1 === y2 || w === h) {\n      // axis aligned: use normal gradient\n      gradient = context.createLinearGradient(bounds.x1 + x1 * w, bounds.y1 + y1 * h, bounds.x1 + x2 * w, bounds.y1 + y2 * h);\n    } else {\n      // not axis aligned: render gradient into a pattern (#2365)\n      // this allows us to use normalized bounding box coordinates\n      const image = canvas(Math.ceil(w), Math.ceil(h)),\n        ictx = image.getContext('2d');\n      ictx.scale(w, h);\n      ictx.fillStyle = addStops(ictx.createLinearGradient(x1, y1, x2, y2), spec.stops);\n      ictx.fillRect(0, 0, w, h);\n      return context.createPattern(image, 'no-repeat');\n    }\n  }\n  return addStops(gradient, spec.stops);\n}\n\nfunction color (context, item, value) {\n  return isGradient(value) ? gradient(context, value, item.bounds) : value;\n}\n\nfunction fill (context, item, opacity) {\n  opacity *= item.fillOpacity == null ? 1 : item.fillOpacity;\n  if (opacity > 0) {\n    context.globalAlpha = opacity;\n    context.fillStyle = color(context, item, item.fill);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvar Empty = [];\nfunction stroke (context, item, opacity) {\n  var lw = (lw = item.strokeWidth) != null ? lw : 1;\n  if (lw <= 0) return false;\n  opacity *= item.strokeOpacity == null ? 1 : item.strokeOpacity;\n  if (opacity > 0) {\n    context.globalAlpha = opacity;\n    context.strokeStyle = color(context, item, item.stroke);\n    context.lineWidth = lw;\n    context.lineCap = item.strokeCap || 'butt';\n    context.lineJoin = item.strokeJoin || 'miter';\n    context.miterLimit = item.strokeMiterLimit || 10;\n    if (context.setLineDash) {\n      context.setLineDash(item.strokeDash || Empty);\n      context.lineDashOffset = item.strokeDashOffset || 0;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction compare(a, b) {\n  return a.zindex - b.zindex || a.index - b.index;\n}\nfunction zorder(scene) {\n  if (!scene.zdirty) return scene.zitems;\n  var items = scene.items,\n    output = [],\n    item,\n    i,\n    n;\n  for (i = 0, n = items.length; i < n; ++i) {\n    item = items[i];\n    item.index = i;\n    if (item.zindex) output.push(item);\n  }\n  scene.zdirty = false;\n  return scene.zitems = output.sort(compare);\n}\nfunction visit(scene, visitor) {\n  var items = scene.items,\n    i,\n    n;\n  if (!items || !items.length) return;\n  const zitems = zorder(scene);\n  if (zitems && zitems.length) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      if (!items[i].zindex) visitor(items[i]);\n    }\n    items = zitems;\n  }\n  for (i = 0, n = items.length; i < n; ++i) {\n    visitor(items[i]);\n  }\n}\nfunction pickVisit(scene, visitor) {\n  var items = scene.items,\n    hit,\n    i;\n  if (!items || !items.length) return null;\n  const zitems = zorder(scene);\n  if (zitems && zitems.length) items = zitems;\n  for (i = items.length; --i >= 0;) {\n    if (hit = visitor(items[i])) return hit;\n  }\n  if (items === zitems) {\n    for (items = scene.items, i = items.length; --i >= 0;) {\n      if (!items[i].zindex) {\n        if (hit = visitor(items[i])) return hit;\n      }\n    }\n  }\n  return null;\n}\n\nfunction drawAll(path) {\n  return function (context, scene, bounds) {\n    visit(scene, item => {\n      if (!bounds || bounds.intersects(item.bounds)) {\n        drawPath(path, context, item, item);\n      }\n    });\n  };\n}\nfunction drawOne(path) {\n  return function (context, scene, bounds) {\n    if (scene.items.length && (!bounds || bounds.intersects(scene.bounds))) {\n      drawPath(path, context, scene.items[0], scene.items);\n    }\n  };\n}\nfunction drawPath(path, context, item, items) {\n  var opacity = item.opacity == null ? 1 : item.opacity;\n  if (opacity === 0) return;\n  if (path(context, items)) return;\n  blend(context, item);\n  if (item.fill && fill(context, item, opacity)) {\n    context.fill();\n  }\n  if (item.stroke && stroke(context, item, opacity)) {\n    context.stroke();\n  }\n}\n\nfunction pick$1(test) {\n  test = test || truthy;\n  return function (context, scene, x, y, gx, gy) {\n    x *= context.pixelRatio;\n    y *= context.pixelRatio;\n    return pickVisit(scene, item => {\n      const b = item.bounds;\n      // first hit test against bounding box\n      if (b && !b.contains(gx, gy) || !b) return;\n      // if in bounding box, perform more careful test\n      if (test(context, item, x, y, gx, gy)) return item;\n    });\n  };\n}\nfunction hitPath(path, filled) {\n  return function (context, o, x, y) {\n    var item = Array.isArray(o) ? o[0] : o,\n      fill = filled == null ? item.fill : filled,\n      stroke = item.stroke && context.isPointInStroke,\n      lw,\n      lc;\n    if (stroke) {\n      lw = item.strokeWidth;\n      lc = item.strokeCap;\n      context.lineWidth = lw != null ? lw : 1;\n      context.lineCap = lc != null ? lc : 'butt';\n    }\n    return path(context, o) ? false : fill && context.isPointInPath(x, y) || stroke && context.isPointInStroke(x, y);\n  };\n}\nfunction pickPath(path) {\n  return pick$1(hitPath(path));\n}\n\nfunction translate(x, y) {\n  return 'translate(' + x + ',' + y + ')';\n}\nfunction rotate(a) {\n  return 'rotate(' + a + ')';\n}\nfunction scale(scaleX, scaleY) {\n  return 'scale(' + scaleX + ',' + scaleY + ')';\n}\nfunction translateItem(item) {\n  return translate(item.x || 0, item.y || 0);\n}\nfunction rotateItem(item) {\n  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '');\n}\nfunction transformItem(item) {\n  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '') + (item.scaleX || item.scaleY ? ' ' + scale(item.scaleX || 1, item.scaleY || 1) : '');\n}\n\nfunction markItemPath (type, shape, isect) {\n  function attr(emit, item) {\n    emit('transform', rotateItem(item));\n    emit('d', shape(null, item));\n  }\n  function bound(bounds, item) {\n    shape(boundContext(bounds, item.angle), item);\n    return boundStroke(bounds, item).translate(item.x || 0, item.y || 0);\n  }\n  function draw(context, item) {\n    var x = item.x || 0,\n      y = item.y || 0,\n      a = item.angle || 0;\n    context.translate(x, y);\n    if (a) context.rotate(a *= DegToRad);\n    context.beginPath();\n    shape(context, item);\n    if (a) context.rotate(-a);\n    context.translate(-x, -y);\n  }\n  return {\n    type: type,\n    tag: 'path',\n    nested: false,\n    attr: attr,\n    bound: bound,\n    draw: drawAll(draw),\n    pick: pickPath(draw),\n    isect: isect || intersectPath(draw)\n  };\n}\n\nvar arc = markItemPath('arc', arc$1);\n\nfunction pickArea(a, p) {\n  var v = a[0].orient === 'horizontal' ? p[1] : p[0],\n    z = a[0].orient === 'horizontal' ? 'y' : 'x',\n    i = a.length,\n    min = +Infinity,\n    hit,\n    d;\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    d = Math.abs(a[i][z] - v);\n    if (d < min) {\n      min = d;\n      hit = a[i];\n    }\n  }\n  return hit;\n}\nfunction pickLine(a, p) {\n  var t = Math.pow(a[0].strokeWidth || 1, 2),\n    i = a.length,\n    dx,\n    dy,\n    dd;\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    dx = a[i].x - p[0];\n    dy = a[i].y - p[1];\n    dd = dx * dx + dy * dy;\n    if (dd < t) return a[i];\n  }\n  return null;\n}\nfunction pickTrail(a, p) {\n  var i = a.length,\n    dx,\n    dy,\n    dd;\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    dx = a[i].x - p[0];\n    dy = a[i].y - p[1];\n    dd = dx * dx + dy * dy;\n    dx = a[i].size || 1;\n    if (dd < dx * dx) return a[i];\n  }\n  return null;\n}\n\nfunction markMultiItemPath (type, shape, tip) {\n  function attr(emit, item) {\n    var items = item.mark.items;\n    if (items.length) emit('d', shape(null, items));\n  }\n  function bound(bounds, mark) {\n    var items = mark.items;\n    if (items.length === 0) {\n      return bounds;\n    } else {\n      shape(boundContext(bounds), items);\n      return boundStroke(bounds, items[0]);\n    }\n  }\n  function draw(context, items) {\n    context.beginPath();\n    shape(context, items);\n  }\n  const hit = hitPath(draw);\n  function pick(context, scene, x, y, gx, gy) {\n    var items = scene.items,\n      b = scene.bounds;\n    if (!items || !items.length || b && !b.contains(gx, gy)) {\n      return null;\n    }\n    x *= context.pixelRatio;\n    y *= context.pixelRatio;\n    return hit(context, items, x, y) ? items[0] : null;\n  }\n  return {\n    type: type,\n    tag: 'path',\n    nested: true,\n    attr: attr,\n    bound: bound,\n    draw: drawOne(draw),\n    pick: pick,\n    isect: intersectPoint,\n    tip: tip\n  };\n}\n\nvar area = markMultiItemPath('area', area$1, pickArea);\n\nfunction clip (context, scene) {\n  var clip = scene.clip;\n  context.save();\n  if (isFunction(clip)) {\n    context.beginPath();\n    clip(context);\n    context.clip();\n  } else {\n    clipGroup(context, scene.group);\n  }\n}\nfunction clipGroup(context, group) {\n  context.beginPath();\n  hasCornerRadius(group) ? rectangle(context, group, 0, 0) : context.rect(0, 0, group.width || 0, group.height || 0);\n  context.clip();\n}\n\nfunction offset$1(item) {\n  const sw = value(item.strokeWidth, 1);\n  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;\n}\nfunction attr$5(emit, item) {\n  emit('transform', translateItem(item));\n}\nfunction emitRectangle(emit, item) {\n  const off = offset$1(item);\n  emit('d', rectangle(null, item, off, off));\n}\nfunction background(emit, item) {\n  emit('class', 'background');\n  emit('aria-hidden', true);\n  emitRectangle(emit, item);\n}\nfunction foreground(emit, item) {\n  emit('class', 'foreground');\n  emit('aria-hidden', true);\n  if (item.strokeForeground) {\n    emitRectangle(emit, item);\n  } else {\n    emit('d', '');\n  }\n}\nfunction content(emit, item, renderer) {\n  const url = item.clip ? clip$1(renderer, item, item) : null;\n  emit('clip-path', url);\n}\nfunction bound$5(bounds, group) {\n  if (!group.clip && group.items) {\n    const items = group.items,\n      m = items.length;\n    for (let j = 0; j < m; ++j) {\n      bounds.union(items[j].bounds);\n    }\n  }\n  if ((group.clip || group.width || group.height) && !group.noBound) {\n    bounds.add(0, 0).add(group.width || 0, group.height || 0);\n  }\n  boundStroke(bounds, group);\n  return bounds.translate(group.x || 0, group.y || 0);\n}\nfunction rectanglePath(context, group, x, y) {\n  const off = offset$1(group);\n  context.beginPath();\n  rectangle(context, group, (x || 0) + off, (y || 0) + off);\n}\nconst hitBackground = hitPath(rectanglePath);\nconst hitForeground = hitPath(rectanglePath, false);\nconst hitCorner = hitPath(rectanglePath, true);\nfunction draw$4(context, scene, bounds, markTypes) {\n  visit(scene, group => {\n    const gx = group.x || 0,\n      gy = group.y || 0,\n      fore = group.strokeForeground,\n      opacity = group.opacity == null ? 1 : group.opacity;\n\n    // draw group background\n    if ((group.stroke || group.fill) && opacity) {\n      rectanglePath(context, group, gx, gy);\n      blend(context, group);\n      if (group.fill && fill(context, group, opacity)) {\n        context.fill();\n      }\n      if (group.stroke && !fore && stroke(context, group, opacity)) {\n        context.stroke();\n      }\n    }\n\n    // setup graphics context, set clip and bounds\n    context.save();\n    context.translate(gx, gy);\n    if (group.clip) clipGroup(context, group);\n    if (bounds) bounds.translate(-gx, -gy);\n\n    // draw group contents\n    visit(group, item => {\n      if (item.marktype === 'group' || markTypes == null || markTypes.includes(item.marktype)) {\n        this.draw(context, item, bounds, markTypes);\n      }\n    });\n\n    // restore graphics context\n    if (bounds) bounds.translate(gx, gy);\n    context.restore();\n\n    // draw group foreground\n    if (fore && group.stroke && opacity) {\n      rectanglePath(context, group, gx, gy);\n      blend(context, group);\n      if (stroke(context, group, opacity)) {\n        context.stroke();\n      }\n    }\n  });\n}\nfunction pick(context, scene, x, y, gx, gy) {\n  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {\n    return null;\n  }\n  const cx = x * context.pixelRatio,\n    cy = y * context.pixelRatio;\n  return pickVisit(scene, group => {\n    let hit, dx, dy;\n\n    // first hit test bounding box\n    const b = group.bounds;\n    if (b && !b.contains(gx, gy)) return;\n\n    // passed bounds check, test rectangular clip\n    dx = group.x || 0;\n    dy = group.y || 0;\n    const dw = dx + (group.width || 0),\n      dh = dy + (group.height || 0),\n      c = group.clip;\n    if (c && (gx < dx || gx > dw || gy < dy || gy > dh)) return;\n\n    // adjust coordinate system\n    context.save();\n    context.translate(dx, dy);\n    dx = gx - dx;\n    dy = gy - dy;\n\n    // test background for rounded corner clip\n    if (c && hasCornerRadius(group) && !hitCorner(context, group, cx, cy)) {\n      context.restore();\n      return null;\n    }\n    const fore = group.strokeForeground,\n      ix = scene.interactive !== false;\n\n    // hit test against group foreground\n    if (ix && fore && group.stroke && hitForeground(context, group, cx, cy)) {\n      context.restore();\n      return group;\n    }\n\n    // hit test against contained marks\n    hit = pickVisit(group, mark => pickMark(mark, dx, dy) ? this.pick(mark, x, y, dx, dy) : null);\n\n    // hit test against group background\n    if (!hit && ix && (group.fill || !fore && group.stroke) && hitBackground(context, group, cx, cy)) {\n      hit = group;\n    }\n\n    // restore state and return\n    context.restore();\n    return hit || null;\n  });\n}\nfunction pickMark(mark, x, y) {\n  return (mark.interactive !== false || mark.marktype === 'group') && mark.bounds && mark.bounds.contains(x, y);\n}\nvar group = {\n  type: 'group',\n  tag: 'g',\n  nested: false,\n  attr: attr$5,\n  bound: bound$5,\n  draw: draw$4,\n  pick: pick,\n  isect: intersectRect,\n  content: content,\n  background: background,\n  foreground: foreground\n};\n\nvar metadata = {\n  'xmlns': 'http://www.w3.org/2000/svg',\n  'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n  'version': '1.1'\n};\n\nfunction getImage(item, renderer) {\n  var image = item.image;\n  if (!image || item.url && item.url !== image.url) {\n    image = {\n      complete: false,\n      width: 0,\n      height: 0\n    };\n    renderer.loadImage(item.url).then(image => {\n      item.image = image;\n      item.image.url = item.url;\n    });\n  }\n  return image;\n}\nfunction imageWidth(item, image) {\n  return item.width != null ? item.width : !image || !image.width ? 0 : item.aspect !== false && item.height ? item.height * image.width / image.height : image.width;\n}\nfunction imageHeight(item, image) {\n  return item.height != null ? item.height : !image || !image.height ? 0 : item.aspect !== false && item.width ? item.width * image.height / image.width : image.height;\n}\nfunction imageXOffset(align, w) {\n  return align === 'center' ? w / 2 : align === 'right' ? w : 0;\n}\nfunction imageYOffset(baseline, h) {\n  return baseline === 'middle' ? h / 2 : baseline === 'bottom' ? h : 0;\n}\nfunction attr$4(emit, item, renderer) {\n  const img = getImage(item, renderer),\n    w = imageWidth(item, img),\n    h = imageHeight(item, img),\n    x = (item.x || 0) - imageXOffset(item.align, w),\n    y = (item.y || 0) - imageYOffset(item.baseline, h),\n    i = !img.src && img.toDataURL ? img.toDataURL() : img.src || '';\n  emit('href', i, metadata['xmlns:xlink'], 'xlink:href');\n  emit('transform', translate(x, y));\n  emit('width', w);\n  emit('height', h);\n  emit('preserveAspectRatio', item.aspect === false ? 'none' : 'xMidYMid');\n}\nfunction bound$4(bounds, item) {\n  const img = item.image,\n    w = imageWidth(item, img),\n    h = imageHeight(item, img),\n    x = (item.x || 0) - imageXOffset(item.align, w),\n    y = (item.y || 0) - imageYOffset(item.baseline, h);\n  return bounds.set(x, y, x + w, y + h);\n}\nfunction draw$3(context, scene, bounds) {\n  visit(scene, item => {\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n\n    const img = getImage(item, this);\n    let w = imageWidth(item, img);\n    let h = imageHeight(item, img);\n    if (w === 0 || h === 0) return; // early exit\n\n    let x = (item.x || 0) - imageXOffset(item.align, w),\n      y = (item.y || 0) - imageYOffset(item.baseline, h),\n      opacity,\n      ar0,\n      ar1,\n      t;\n    if (item.aspect !== false) {\n      ar0 = img.width / img.height;\n      ar1 = item.width / item.height;\n      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {\n        if (ar1 < ar0) {\n          t = w / ar0;\n          y += (h - t) / 2;\n          h = t;\n        } else {\n          t = h * ar0;\n          x += (w - t) / 2;\n          w = t;\n        }\n      }\n    }\n    if (img.complete || img.toDataURL) {\n      blend(context, item);\n      context.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;\n      context.imageSmoothingEnabled = item.smooth !== false;\n      context.drawImage(img, x, y, w, h);\n    }\n  });\n}\nvar image = {\n  type: 'image',\n  tag: 'image',\n  nested: false,\n  attr: attr$4,\n  bound: bound$4,\n  draw: draw$3,\n  pick: pick$1(),\n  isect: truthy,\n  // bounds check is sufficient\n  get: getImage,\n  xOffset: imageXOffset,\n  yOffset: imageYOffset\n};\n\nvar line = markMultiItemPath('line', line$1, pickLine);\n\nfunction attr$3(emit, item) {\n  var sx = item.scaleX || 1,\n    sy = item.scaleY || 1;\n  if (sx !== 1 || sy !== 1) {\n    emit('vector-effect', 'non-scaling-stroke');\n  }\n  emit('transform', transformItem(item));\n  emit('d', item.path);\n}\nfunction path$1(context, item) {\n  var path = item.path;\n  if (path == null) return true;\n  var x = item.x || 0,\n    y = item.y || 0,\n    sx = item.scaleX || 1,\n    sy = item.scaleY || 1,\n    a = (item.angle || 0) * DegToRad,\n    cache = item.pathCache;\n  if (!cache || cache.path !== path) {\n    (item.pathCache = cache = parse(path)).path = path;\n  }\n  if (a && context.rotate && context.translate) {\n    context.translate(x, y);\n    context.rotate(a);\n    pathRender(context, cache, 0, 0, sx, sy);\n    context.rotate(-a);\n    context.translate(-x, -y);\n  } else {\n    pathRender(context, cache, x, y, sx, sy);\n  }\n}\nfunction bound$3(bounds, item) {\n  return path$1(boundContext(bounds, item.angle), item) ? bounds.set(0, 0, 0, 0) : boundStroke(bounds, item, true);\n}\nvar path$2 = {\n  type: 'path',\n  tag: 'path',\n  nested: false,\n  attr: attr$3,\n  bound: bound$3,\n  draw: drawAll(path$1),\n  pick: pickPath(path$1),\n  isect: intersectPath(path$1)\n};\n\nfunction attr$2(emit, item) {\n  emit('d', rectangle(null, item));\n}\nfunction bound$2(bounds, item) {\n  var x, y;\n  return boundStroke(bounds.set(x = item.x || 0, y = item.y || 0, x + item.width || 0, y + item.height || 0), item);\n}\nfunction draw$2(context, item) {\n  context.beginPath();\n  rectangle(context, item);\n}\nvar rect = {\n  type: 'rect',\n  tag: 'path',\n  nested: false,\n  attr: attr$2,\n  bound: bound$2,\n  draw: drawAll(draw$2),\n  pick: pickPath(draw$2),\n  isect: intersectRect\n};\n\nfunction attr$1(emit, item) {\n  emit('transform', translateItem(item));\n  emit('x2', item.x2 != null ? item.x2 - (item.x || 0) : 0);\n  emit('y2', item.y2 != null ? item.y2 - (item.y || 0) : 0);\n}\nfunction bound$1(bounds, item) {\n  var x1, y1;\n  return boundStroke(bounds.set(x1 = item.x || 0, y1 = item.y || 0, item.x2 != null ? item.x2 : x1, item.y2 != null ? item.y2 : y1), item);\n}\nfunction path(context, item, opacity) {\n  var x1, y1, x2, y2;\n  if (item.stroke && stroke(context, item, opacity)) {\n    x1 = item.x || 0;\n    y1 = item.y || 0;\n    x2 = item.x2 != null ? item.x2 : x1;\n    y2 = item.y2 != null ? item.y2 : y1;\n    context.beginPath();\n    context.moveTo(x1, y1);\n    context.lineTo(x2, y2);\n    return true;\n  }\n  return false;\n}\nfunction draw$1(context, scene, bounds) {\n  visit(scene, item => {\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n    var opacity = item.opacity == null ? 1 : item.opacity;\n    if (opacity && path(context, item, opacity)) {\n      blend(context, item);\n      context.stroke();\n    }\n  });\n}\nfunction hit$1(context, item, x, y) {\n  if (!context.isPointInStroke) return false;\n  return path(context, item, 1) && context.isPointInStroke(x, y);\n}\nvar rule = {\n  type: 'rule',\n  tag: 'line',\n  nested: false,\n  attr: attr$1,\n  bound: bound$1,\n  draw: draw$1,\n  pick: pick$1(hit$1),\n  isect: intersectRule\n};\n\nvar shape = markItemPath('shape', shape$1);\n\nvar symbol = markItemPath('symbol', symbol$1, intersectPoint);\n\n// memoize text width measurement\nconst widthCache = lruCache();\nvar textMetrics = {\n  height: fontSize,\n  measureWidth: measureWidth,\n  estimateWidth: estimateWidth,\n  width: estimateWidth,\n  canvas: useCanvas\n};\nuseCanvas(true);\nfunction useCanvas(use) {\n  textMetrics.width = use && context ? measureWidth : estimateWidth;\n}\n\n// make simple estimate if no canvas is available\nfunction estimateWidth(item, text) {\n  return _estimateWidth(textValue(item, text), fontSize(item));\n}\nfunction _estimateWidth(text, currentFontHeight) {\n  return ~~(0.8 * text.length * currentFontHeight);\n}\n\n// measure text width if canvas is available\nfunction measureWidth(item, text) {\n  return fontSize(item) <= 0 || !(text = textValue(item, text)) ? 0 : _measureWidth(text, font(item));\n}\nfunction _measureWidth(text, currentFont) {\n  const key = `(${currentFont}) ${text}`;\n  let width = widthCache.get(key);\n  if (width === undefined) {\n    context.font = currentFont;\n    width = context.measureText(text).width;\n    widthCache.set(key, width);\n  }\n  return width;\n}\nfunction fontSize(item) {\n  return item.fontSize != null ? +item.fontSize || 0 : 11;\n}\nfunction lineHeight(item) {\n  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;\n}\nfunction lineArray(_) {\n  return isArray(_) ? _.length > 1 ? _ : _[0] : _;\n}\nfunction textLines(item) {\n  return lineArray(item.lineBreak && item.text && !isArray(item.text) ? item.text.split(item.lineBreak) : item.text);\n}\nfunction multiLineOffset(item) {\n  const tl = textLines(item);\n  return (isArray(tl) ? tl.length - 1 : 0) * lineHeight(item);\n}\nfunction textValue(item, line) {\n  const text = line == null ? '' : (line + '').trim();\n  return item.limit > 0 && text.length ? truncate(item, text) : text;\n}\nfunction widthGetter(item) {\n  if (textMetrics.width === measureWidth) {\n    // we are using canvas\n    const currentFont = font(item);\n    return text => _measureWidth(text, currentFont);\n  } else if (textMetrics.width === estimateWidth) {\n    // we are relying on estimates\n    const currentFontHeight = fontSize(item);\n    return text => _estimateWidth(text, currentFontHeight);\n  } else {\n    // User defined textMetrics.width function in use (e.g. vl-convert)\n    return text => textMetrics.width(item, text);\n  }\n}\nfunction truncate(item, text) {\n  var limit = +item.limit,\n    width = widthGetter(item);\n  if (width(text) < limit) return text;\n  var ellipsis = item.ellipsis || '\\u2026',\n    rtl = item.dir === 'rtl',\n    lo = 0,\n    hi = text.length,\n    mid;\n  limit -= width(ellipsis);\n  if (rtl) {\n    while (lo < hi) {\n      mid = lo + hi >>> 1;\n      if (width(text.slice(mid)) > limit) lo = mid + 1;else hi = mid;\n    }\n    return ellipsis + text.slice(lo);\n  } else {\n    while (lo < hi) {\n      mid = 1 + (lo + hi >>> 1);\n      if (width(text.slice(0, mid)) < limit) lo = mid;else hi = mid - 1;\n    }\n    return text.slice(0, lo) + ellipsis;\n  }\n}\nfunction fontFamily(item, quote) {\n  var font = item.font;\n  return (quote && font ? String(font).replace(/\"/g, '\\'') : font) || 'sans-serif';\n}\nfunction font(item, quote) {\n  return '' + (item.fontStyle ? item.fontStyle + ' ' : '') + (item.fontVariant ? item.fontVariant + ' ' : '') + (item.fontWeight ? item.fontWeight + ' ' : '') + fontSize(item) + 'px ' + fontFamily(item, quote);\n}\nfunction offset(item) {\n  // perform our own font baseline calculation\n  // why? not all browsers support SVG 1.1 'alignment-baseline' :(\n  // this also ensures consistent layout across renderers\n  var baseline = item.baseline,\n    h = fontSize(item);\n  return Math.round(baseline === 'top' ? 0.79 * h : baseline === 'middle' ? 0.30 * h : baseline === 'bottom' ? -0.21 * h : baseline === 'line-top' ? 0.29 * h + 0.5 * lineHeight(item) : baseline === 'line-bottom' ? 0.29 * h - 0.5 * lineHeight(item) : 0);\n}\n\nconst textAlign = {\n  'left': 'start',\n  'center': 'middle',\n  'right': 'end'\n};\nconst tempBounds = new Bounds();\nfunction anchorPoint(item) {\n  var x = item.x || 0,\n    y = item.y || 0,\n    r = item.radius || 0,\n    t;\n  if (r) {\n    t = (item.theta || 0) - HalfPi;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n  tempBounds.x1 = x;\n  tempBounds.y1 = y;\n  return tempBounds;\n}\nfunction attr(emit, item) {\n  var dx = item.dx || 0,\n    dy = (item.dy || 0) + offset(item),\n    p = anchorPoint(item),\n    x = p.x1,\n    y = p.y1,\n    a = item.angle || 0,\n    t;\n  emit('text-anchor', textAlign[item.align] || 'start');\n  if (a) {\n    t = translate(x, y) + ' ' + rotate(a);\n    if (dx || dy) t += ' ' + translate(dx, dy);\n  } else {\n    t = translate(x + dx, y + dy);\n  }\n  emit('transform', t);\n}\nfunction bound(bounds, item, mode) {\n  var h = textMetrics.height(item),\n    a = item.align,\n    p = anchorPoint(item),\n    x = p.x1,\n    y = p.y1,\n    dx = item.dx || 0,\n    dy = (item.dy || 0) + offset(item) - Math.round(0.8 * h),\n    // use 4/5 offset\n    tl = textLines(item),\n    w;\n\n  // get dimensions\n  if (isArray(tl)) {\n    // multi-line text\n    h += lineHeight(item) * (tl.length - 1);\n    w = tl.reduce((w, t) => Math.max(w, textMetrics.width(item, t)), 0);\n  } else {\n    // single-line text\n    w = textMetrics.width(item, tl);\n  }\n\n  // horizontal alignment\n  if (a === 'center') {\n    dx -= w / 2;\n  } else if (a === 'right') {\n    dx -= w;\n  } else ;\n  bounds.set(dx += x, dy += y, dx + w, dy + h);\n  if (item.angle && !mode) {\n    bounds.rotate(item.angle * DegToRad, x, y);\n  } else if (mode === 2) {\n    return bounds.rotatedPoints(item.angle * DegToRad, x, y);\n  }\n  return bounds;\n}\nfunction draw(context, scene, bounds) {\n  visit(scene, item => {\n    var opacity = item.opacity == null ? 1 : item.opacity,\n      p,\n      x,\n      y,\n      i,\n      lh,\n      tl,\n      str;\n    if (bounds && !bounds.intersects(item.bounds) ||\n    // bounds check\n    opacity === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0) return;\n    context.font = font(item);\n    context.textAlign = item.align || 'left';\n    p = anchorPoint(item);\n    x = p.x1, y = p.y1;\n    if (item.angle) {\n      context.save();\n      context.translate(x, y);\n      context.rotate(item.angle * DegToRad);\n      x = y = 0; // reset x, y\n    }\n    x += item.dx || 0;\n    y += (item.dy || 0) + offset(item);\n    tl = textLines(item);\n    blend(context, item);\n    if (isArray(tl)) {\n      lh = lineHeight(item);\n      for (i = 0; i < tl.length; ++i) {\n        str = textValue(item, tl[i]);\n        if (item.fill && fill(context, item, opacity)) {\n          context.fillText(str, x, y);\n        }\n        if (item.stroke && stroke(context, item, opacity)) {\n          context.strokeText(str, x, y);\n        }\n        y += lh;\n      }\n    } else {\n      str = textValue(item, tl);\n      if (item.fill && fill(context, item, opacity)) {\n        context.fillText(str, x, y);\n      }\n      if (item.stroke && stroke(context, item, opacity)) {\n        context.strokeText(str, x, y);\n      }\n    }\n    if (item.angle) context.restore();\n  });\n}\nfunction hit(context, item, x, y, gx, gy) {\n  if (item.fontSize <= 0) return false;\n  if (!item.angle) return true; // bounds sufficient if no rotation\n\n  // project point into space of unrotated bounds\n  var p = anchorPoint(item),\n    ax = p.x1,\n    ay = p.y1,\n    b = bound(tempBounds, item, 1),\n    a = -item.angle * DegToRad,\n    cos = Math.cos(a),\n    sin = Math.sin(a),\n    px = cos * gx - sin * gy + (ax - cos * ax + sin * ay),\n    py = sin * gx + cos * gy + (ay - sin * ax - cos * ay);\n  return b.contains(px, py);\n}\nfunction intersectText(item, box) {\n  const p = bound(tempBounds, item, 2);\n  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);\n}\nvar text = {\n  type: 'text',\n  tag: 'text',\n  nested: false,\n  attr: attr,\n  bound: bound,\n  draw: draw,\n  pick: pick$1(hit),\n  isect: intersectText\n};\n\nvar trail = markMultiItemPath('trail', trail$1, pickTrail);\n\nvar Marks = {\n  arc: arc,\n  area: area,\n  group: group,\n  image: image,\n  line: line,\n  path: path$2,\n  rect: rect,\n  rule: rule,\n  shape: shape,\n  symbol: symbol,\n  text: text,\n  trail: trail\n};\n\nfunction boundItem (item, func, opt) {\n  var type = Marks[item.mark.marktype],\n    bound = func || type.bound;\n  if (type.nested) item = item.mark;\n  return bound(item.bounds || (item.bounds = new Bounds()), item, opt);\n}\n\nvar DUMMY = {\n  mark: null\n};\nfunction boundMark (mark, bounds, opt) {\n  var type = Marks[mark.marktype],\n    bound = type.bound,\n    items = mark.items,\n    hasItems = items && items.length,\n    i,\n    n,\n    item,\n    b;\n  if (type.nested) {\n    if (hasItems) {\n      item = items[0];\n    } else {\n      // no items, fake it\n      DUMMY.mark = mark;\n      item = DUMMY;\n    }\n    b = boundItem(item, bound, opt);\n    bounds = bounds && bounds.union(b) || b;\n    return bounds;\n  }\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n  if (hasItems) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      bounds.union(boundItem(items[i], bound, opt));\n    }\n  }\n  return mark.bounds = bounds;\n}\n\nconst keys = ['marktype', 'name', 'role', 'interactive', 'clip', 'items', 'zindex', 'x', 'y', 'width', 'height', 'align', 'baseline',\n// layout\n'fill', 'fillOpacity', 'opacity', 'blend',\n// fill\n'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap',\n// stroke\n'strokeDash', 'strokeDashOffset',\n// stroke dash\n'strokeForeground', 'strokeOffset',\n// group\n'startAngle', 'endAngle', 'innerRadius', 'outerRadius',\n// arc\n'cornerRadius', 'padAngle',\n// arc, rect\n'cornerRadiusTopLeft', 'cornerRadiusTopRight',\n// rect, group\n'cornerRadiusBottomLeft', 'cornerRadiusBottomRight', 'interpolate', 'tension', 'orient', 'defined',\n// area, line\n'url', 'aspect', 'smooth',\n// image\n'path', 'scaleX', 'scaleY',\n// path\n'x2', 'y2',\n// rule\n'size', 'shape',\n// symbol\n'text', 'angle', 'theta', 'radius', 'dir', 'dx', 'dy',\n// text\n'ellipsis', 'limit', 'lineBreak', 'lineHeight', 'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant',\n// font\n'description', 'aria', 'ariaRole', 'ariaRoleDescription' // aria\n];\nfunction sceneToJSON(scene, indent) {\n  return JSON.stringify(scene, keys, indent);\n}\nfunction sceneFromJSON(json) {\n  const scene = typeof json === 'string' ? JSON.parse(json) : json;\n  return initialize(scene);\n}\nfunction initialize(scene) {\n  var type = scene.marktype,\n    items = scene.items,\n    parent,\n    i,\n    n;\n  if (items) {\n    for (i = 0, n = items.length; i < n; ++i) {\n      parent = type ? 'mark' : 'group';\n      items[i][parent] = scene;\n      if (items[i].zindex) items[i][parent].zdirty = true;\n      if ('group' === (type || parent)) initialize(items[i]);\n    }\n  }\n  if (type) boundMark(scene);\n  return scene;\n}\n\nclass Scenegraph {\n  constructor(scene) {\n    if (arguments.length) {\n      this.root = sceneFromJSON(scene);\n    } else {\n      this.root = createMark({\n        marktype: 'group',\n        name: 'root',\n        role: 'frame'\n      });\n      this.root.items = [new GroupItem(this.root)];\n    }\n  }\n  toJSON(indent) {\n    return sceneToJSON(this.root, indent || 0);\n  }\n  mark(markdef, group, index) {\n    group = group || this.root.items[0];\n    const mark = createMark(markdef, group);\n    group.items[index] = mark;\n    if (mark.zindex) mark.group.zdirty = true;\n    return mark;\n  }\n}\nfunction createMark(def, group) {\n  const mark = {\n    bounds: new Bounds(),\n    clip: !!def.clip,\n    group: group,\n    interactive: def.interactive === false ? false : true,\n    items: [],\n    marktype: def.marktype,\n    name: def.name || undefined,\n    role: def.role || undefined,\n    zindex: def.zindex || 0\n  };\n\n  // add accessibility properties if defined\n  if (def.aria != null) {\n    mark.aria = def.aria;\n  }\n  if (def.description) {\n    mark.description = def.description;\n  }\n  return mark;\n}\n\n// create a new DOM element\nfunction domCreate(doc, tag, ns) {\n  if (!doc && typeof document !== 'undefined' && document.createElement) {\n    doc = document;\n  }\n  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;\n}\n\n// find first child element with matching tag\nfunction domFind(el, tag) {\n  tag = tag.toLowerCase();\n  var nodes = el.childNodes,\n    i = 0,\n    n = nodes.length;\n  for (; i < n; ++i) if (nodes[i].tagName.toLowerCase() === tag) {\n    return nodes[i];\n  }\n}\n\n// retrieve child element at given index\n// create & insert if doesn't exist or if tags do not match\nfunction domChild(el, index, tag, ns) {\n  var a = el.childNodes[index],\n    b;\n  if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {\n    b = a || null;\n    a = domCreate(el.ownerDocument, tag, ns);\n    el.insertBefore(a, b);\n  }\n  return a;\n}\n\n// remove all child elements at or above the given index\nfunction domClear(el, index) {\n  var nodes = el.childNodes,\n    curr = nodes.length;\n  while (curr > index) el.removeChild(nodes[--curr]);\n  return el;\n}\n\n// generate css class name for mark\nfunction cssClass(mark) {\n  return 'mark-' + mark.marktype + (mark.role ? ' role-' + mark.role : '') + (mark.name ? ' ' + mark.name : '');\n}\n\nfunction point (event, el) {\n  const rect = el.getBoundingClientRect();\n  return [event.clientX - rect.left - (el.clientLeft || 0), event.clientY - rect.top - (el.clientTop || 0)];\n}\n\nfunction resolveItem (item, event, el, origin) {\n  var mark = item && item.mark,\n    mdef,\n    p;\n  if (mark && (mdef = Marks[mark.marktype]).tip) {\n    p = point(event, el);\n    p[0] -= origin[0];\n    p[1] -= origin[1];\n    while (item = item.mark.group) {\n      p[0] -= item.x || 0;\n      p[1] -= item.y || 0;\n    }\n    item = mdef.tip(mark.items, p);\n  }\n  return item;\n}\n\nclass Handler {\n  /**\n   * Create a new Handler instance.\n   * @param {object} [customLoader] - Optional loader instance for\n   *   href URL sanitization. If not specified, a standard loader\n   *   instance will be generated.\n   * @param {function} [customTooltip] - Optional tooltip handler\n   *   function for custom tooltip display.\n   * @constructor\n   */\n  constructor(customLoader, customTooltip) {\n    this._active = null;\n    this._handlers = {};\n    this._loader = customLoader || loader();\n    this._tooltip = customTooltip || defaultTooltip;\n  }\n\n  /**\n   * Initialize a new Handler instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {object} [obj] - Optional context object that should serve as\n   *   the \"this\" context for event callbacks.\n   * @return {Handler} - This handler instance.\n   */\n  initialize(el, origin, obj) {\n    this._el = el;\n    this._obj = obj || null;\n    return this.origin(origin);\n  }\n\n  /**\n   * Returns the parent container element for a visualization.\n   * @return {DOMElement} - The containing DOM element.\n   */\n  element() {\n    return this._el;\n  }\n\n  /**\n   * Returns the scene element (e.g., canvas or SVG) of the visualization\n   * Subclasses must override if the first child is not the scene element.\n   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n   */\n  canvas() {\n    return this._el && this._el.firstChild;\n  }\n\n  /**\n   * Get / set the origin coordinates of the visualization.\n   */\n  origin(origin) {\n    if (arguments.length) {\n      this._origin = origin || [0, 0];\n      return this;\n    } else {\n      return this._origin.slice();\n    }\n  }\n\n  /**\n   * Get / set the scenegraph root.\n   */\n  scene(scene) {\n    if (!arguments.length) return this._scene;\n    this._scene = scene;\n    return this;\n  }\n\n  /**\n   * Add an event handler. Subclasses should override this method.\n   */\n  on( /*type, handler*/) {}\n\n  /**\n   * Remove an event handler. Subclasses should override this method.\n   */\n  off( /*type, handler*/) {}\n\n  /**\n   * Utility method for finding the array index of an event handler.\n   * @param {Array} h - An array of registered event handlers.\n   * @param {string} type - The event type.\n   * @param {function} handler - The event handler instance to find.\n   * @return {number} - The handler's array index or -1 if not registered.\n   */\n  _handlerIndex(h, type, handler) {\n    for (let i = h ? h.length : 0; --i >= 0;) {\n      if (h[i].type === type && (!handler || h[i].handler === handler)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns an array with registered event handlers.\n   * @param {string} [type] - The event type to query. Any annotations\n   *   are ignored; for example, for the argument \"click.foo\", \".foo\" will\n   *   be ignored and the method returns all \"click\" handlers. If type is\n   *   null or unspecified, this method returns handlers for all types.\n   * @return {Array} - A new array containing all registered event handlers.\n   */\n  handlers(type) {\n    const h = this._handlers,\n      a = [];\n    if (type) {\n      a.push(...h[this.eventName(type)]);\n    } else {\n      for (const k in h) {\n        a.push(...h[k]);\n      }\n    }\n    return a;\n  }\n\n  /**\n   * Parses an event name string to return the specific event type.\n   * For example, given \"click.foo\" returns \"click\"\n   * @param {string} name - The input event type string.\n   * @return {string} - A string with the event type only.\n   */\n  eventName(name) {\n    const i = name.indexOf('.');\n    return i < 0 ? name : name.slice(0, i);\n  }\n\n  /**\n   * Handle hyperlink navigation in response to an item.href value.\n   * @param {Event} event - The event triggering hyperlink navigation.\n   * @param {Item} item - The scenegraph item.\n   * @param {string} href - The URL to navigate to.\n   */\n  handleHref(event, item, href) {\n    this._loader.sanitize(href, {\n      context: 'href'\n    }).then(opt => {\n      const e = new MouseEvent(event.type, event),\n        a = domCreate(null, 'a');\n      for (const name in opt) a.setAttribute(name, opt[name]);\n      a.dispatchEvent(e);\n    }).catch(() => {});\n  }\n\n  /**\n   * Handle tooltip display in response to an item.tooltip value.\n   * @param {Event} event - The event triggering tooltip display.\n   * @param {Item} item - The scenegraph item.\n   * @param {boolean} show - A boolean flag indicating whether\n   *   to show or hide a tooltip for the given item.\n   */\n  handleTooltip(event, item, show) {\n    if (item && item.tooltip != null) {\n      item = resolveItem(item, event, this.canvas(), this._origin);\n      const value = show && item && item.tooltip || null;\n      this._tooltip.call(this._obj, this, event, item, value);\n    }\n  }\n\n  /**\n   * Returns the size of a scenegraph item and its position relative\n   * to the viewport.\n   * @param {Item} item - The scenegraph item.\n   * @return {object} - A bounding box object (compatible with the\n   *   DOMRect type) consisting of x, y, width, heigh, top, left,\n   *   right, and bottom properties.\n   */\n  getItemBoundingClientRect(item) {\n    const el = this.canvas();\n    if (!el) return;\n    const rect = el.getBoundingClientRect(),\n      origin = this._origin,\n      bounds = item.bounds,\n      width = bounds.width(),\n      height = bounds.height();\n    let x = bounds.x1 + origin[0] + rect.left,\n      y = bounds.y1 + origin[1] + rect.top;\n\n    // translate coordinate for each parent group\n    while (item.mark && (item = item.mark.group)) {\n      x += item.x || 0;\n      y += item.y || 0;\n    }\n\n    // return DOMRect-compatible bounding box\n    return {\n      x,\n      y,\n      width,\n      height,\n      left: x,\n      top: y,\n      right: x + width,\n      bottom: y + height\n    };\n  }\n}\n\n// The default tooltip display handler.\n// Sets the HTML title attribute on the visualization container.\nfunction defaultTooltip(handler, event, item, value) {\n  handler.element().setAttribute('title', value || '');\n}\n\nclass Renderer {\n  /**\n   * Create a new Renderer instance.\n   * @param {object} [loader] - Optional loader instance for\n   *   image and href URL sanitization. If not specified, a\n   *   standard loader instance will be generated.\n   * @constructor\n   */\n  constructor(loader) {\n    this._el = null;\n    this._bgcolor = null;\n    this._loader = new ResourceLoader(loader);\n  }\n\n  /**\n   * Initialize a new Renderer instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {number} width - The coordinate width of the display, in pixels.\n   * @param {number} height - The coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {Renderer} - This renderer instance.\n   */\n  initialize(el, width, height, origin, scaleFactor) {\n    this._el = el;\n    return this.resize(width, height, origin, scaleFactor);\n  }\n\n  /**\n   * Returns the parent container element for a visualization.\n   * @return {DOMElement} - The containing DOM element.\n   */\n  element() {\n    return this._el;\n  }\n\n  /**\n   * Returns the scene element (e.g., canvas or SVG) of the visualization\n   * Subclasses must override if the first child is not the scene element.\n   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n   */\n  canvas() {\n    return this._el && this._el.firstChild;\n  }\n\n  /**\n   * Get / set the background color.\n   */\n  background(bgcolor) {\n    if (arguments.length === 0) return this._bgcolor;\n    this._bgcolor = bgcolor;\n    return this;\n  }\n\n  /**\n   * Resize the display.\n   * @param {number} width - The new coordinate width of the display, in pixels.\n   * @param {number} height - The new coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The new origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {Renderer} - This renderer instance;\n   */\n  resize(width, height, origin, scaleFactor) {\n    this._width = width;\n    this._height = height;\n    this._origin = origin || [0, 0];\n    this._scale = scaleFactor || 1;\n    return this;\n  }\n\n  /**\n   * Report a dirty item whose bounds should be redrawn.\n   * This base class method does nothing. Subclasses that perform\n   * incremental should implement this method.\n   * @param {Item} item - The dirty item whose bounds should be redrawn.\n   */\n  dirty( /*item*/) {}\n\n  /**\n   * Render an input scenegraph, potentially with a set of dirty items.\n   * This method will perform an immediate rendering with available resources.\n   * The renderer may also need to perform image loading to perform a complete\n   * render. This process can lead to asynchronous re-rendering of the scene\n   * after this method returns. To receive notification when rendering is\n   * complete, use the renderAsync method instead.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @param {Array} markTypes - Array of the mark types to render.\n   *                            If undefined, render all mark types\n   * @return {Renderer} - This renderer instance.\n   */\n  render(scene, markTypes) {\n    const r = this;\n\n    // bind arguments into a render call, and cache it\n    // this function may be subsequently called for async redraw\n    r._call = function () {\n      r._render(scene, markTypes);\n    };\n\n    // invoke the renderer\n    r._call();\n\n    // clear the cached call for garbage collection\n    // async redraws will stash their own copy\n    r._call = null;\n    return r;\n  }\n\n  /**\n   * Internal rendering method. Renderer subclasses should override this\n   * method to actually perform rendering.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @param {Array} markTypes - Array of the mark types to render.\n   *                            If undefined, render all mark types\n   */\n  _render( /*scene, markTypes*/\n  ) {\n    // subclasses to override\n  }\n\n  /**\n   * Asynchronous rendering method. Similar to render, but returns a Promise\n   * that resolves when all rendering is completed. Sometimes a renderer must\n   * perform image loading to get a complete rendering. The returned\n   * Promise will not resolve until this process completes.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @param {Array} markTypes - Array of the mark types to render.\n   *                            If undefined, render all mark types\n   * @return {Promise} - A Promise that resolves when rendering is complete.\n   */\n  renderAsync(scene, markTypes) {\n    const r = this.render(scene, markTypes);\n    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);\n  }\n\n  /**\n   * Internal method for asynchronous resource loading.\n   * Proxies method calls to the ImageLoader, and tracks loading\n   * progress to invoke a re-render once complete.\n   * @param {string} method - The method name to invoke on the ImageLoader.\n   * @param {string} uri - The URI for the requested resource.\n   * @return {Promise} - A Promise that resolves to the requested resource.\n   */\n  _load(method, uri) {\n    var r = this,\n      p = r._loader[method](uri);\n    if (!r._ready) {\n      // re-render the scene when loading completes\n      const call = r._call;\n      r._ready = r._loader.ready().then(redraw => {\n        if (redraw) call();\n        r._ready = null;\n      });\n    }\n    return p;\n  }\n\n  /**\n   * Sanitize a URL to include as a hyperlink in the rendered scene.\n   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks\n   * image loading progress and invokes a re-render once complete.\n   * @param {string} uri - The URI string to sanitize.\n   * @return {Promise} - A Promise that resolves to the sanitized URL.\n   */\n  sanitizeURL(uri) {\n    return this._load('sanitizeURL', uri);\n  }\n\n  /**\n   * Requests an image to include in the rendered scene.\n   * This method proxies a call to ImageLoader.loadImage, but also tracks\n   * image loading progress and invokes a re-render once complete.\n   * @param {string} uri - The URI string of the image.\n   * @return {Promise} - A Promise that resolves to the loaded Image.\n   */\n  loadImage(uri) {\n    return this._load('loadImage', uri);\n  }\n}\n\nconst KeyDownEvent = 'keydown';\nconst KeyPressEvent = 'keypress';\nconst KeyUpEvent = 'keyup';\nconst DragEnterEvent = 'dragenter';\nconst DragLeaveEvent = 'dragleave';\nconst DragOverEvent = 'dragover';\nconst PointerDownEvent = 'pointerdown';\nconst PointerUpEvent = 'pointerup';\nconst PointerMoveEvent = 'pointermove';\nconst PointerOutEvent = 'pointerout';\nconst PointerOverEvent = 'pointerover';\nconst MouseDownEvent = 'mousedown';\nconst MouseUpEvent = 'mouseup';\nconst MouseMoveEvent = 'mousemove';\nconst MouseOutEvent = 'mouseout';\nconst MouseOverEvent = 'mouseover';\nconst ClickEvent = 'click';\nconst DoubleClickEvent = 'dblclick';\nconst WheelEvent = 'wheel';\nconst MouseWheelEvent = 'mousewheel';\nconst TouchStartEvent = 'touchstart';\nconst TouchMoveEvent = 'touchmove';\nconst TouchEndEvent = 'touchend';\nconst Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, PointerDownEvent, PointerUpEvent, PointerMoveEvent, PointerOutEvent, PointerOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];\nconst TooltipShowEvent = PointerMoveEvent;\nconst TooltipHideEvent = MouseOutEvent;\nconst HrefEvent = ClickEvent;\n\nclass CanvasHandler extends Handler {\n  constructor(loader, tooltip) {\n    super(loader, tooltip);\n    this._down = null;\n    this._touch = null;\n    this._first = true;\n    this._events = {};\n\n    // supported events\n    this.events = Events;\n    this.pointermove = move([PointerMoveEvent, MouseMoveEvent], [PointerOverEvent, MouseOverEvent], [PointerOutEvent, MouseOutEvent]);\n    this.dragover = move([DragOverEvent], [DragEnterEvent], [DragLeaveEvent]), this.pointerout = inactive([PointerOutEvent, MouseOutEvent]);\n    this.dragleave = inactive([DragLeaveEvent]);\n  }\n  initialize(el, origin, obj) {\n    this._canvas = el && domFind(el, 'canvas');\n\n    // add minimal events required for proper state management\n    [ClickEvent, MouseDownEvent, PointerDownEvent, PointerMoveEvent, PointerOutEvent, DragLeaveEvent].forEach(type => eventListenerCheck(this, type));\n    return super.initialize(el, origin, obj);\n  }\n\n  // return the backing canvas instance\n  canvas() {\n    return this._canvas;\n  }\n\n  // retrieve the current canvas context\n  context() {\n    return this._canvas.getContext('2d');\n  }\n\n  // to keep old versions of firefox happy\n  DOMMouseScroll(evt) {\n    this.fire(MouseWheelEvent, evt);\n  }\n  pointerdown(evt) {\n    this._down = this._active;\n    this.fire(PointerDownEvent, evt);\n  }\n  mousedown(evt) {\n    this._down = this._active;\n    this.fire(MouseDownEvent, evt);\n  }\n  click(evt) {\n    if (this._down === this._active) {\n      this.fire(ClickEvent, evt);\n      this._down = null;\n    }\n  }\n  touchstart(evt) {\n    this._touch = this.pickEvent(evt.changedTouches[0]);\n    if (this._first) {\n      this._active = this._touch;\n      this._first = false;\n    }\n    this.fire(TouchStartEvent, evt, true);\n  }\n  touchmove(evt) {\n    this.fire(TouchMoveEvent, evt, true);\n  }\n  touchend(evt) {\n    this.fire(TouchEndEvent, evt, true);\n    this._touch = null;\n  }\n\n  // fire an event\n  fire(type, evt, touch) {\n    const a = touch ? this._touch : this._active,\n      h = this._handlers[type];\n\n    // set event type relative to scenegraph items\n    evt.vegaType = type;\n\n    // handle hyperlinks and tooltips first\n    if (type === HrefEvent && a && a.href) {\n      this.handleHref(evt, a, a.href);\n    } else if (type === TooltipShowEvent || type === TooltipHideEvent) {\n      this.handleTooltip(evt, a, type !== TooltipHideEvent);\n    }\n\n    // invoke all registered handlers\n    if (h) {\n      for (let i = 0, len = h.length; i < len; ++i) {\n        h[i].handler.call(this._obj, evt, a);\n      }\n    }\n  }\n\n  // add an event handler\n  on(type, handler) {\n    const name = this.eventName(type),\n      h = this._handlers,\n      i = this._handlerIndex(h[name], type, handler);\n    if (i < 0) {\n      eventListenerCheck(this, type);\n      (h[name] || (h[name] = [])).push({\n        type: type,\n        handler: handler\n      });\n    }\n    return this;\n  }\n\n  // remove an event handler\n  off(type, handler) {\n    const name = this.eventName(type),\n      h = this._handlers[name],\n      i = this._handlerIndex(h, type, handler);\n    if (i >= 0) {\n      h.splice(i, 1);\n    }\n    return this;\n  }\n  pickEvent(evt) {\n    const p = point(evt, this._canvas),\n      o = this._origin;\n    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);\n  }\n\n  // find the scenegraph item at the current pointer position\n  // x, y -- the absolute x, y pointer coordinates on the canvas element\n  // gx, gy -- the relative coordinates within the current group\n  pick(scene, x, y, gx, gy) {\n    const g = this.context(),\n      mark = Marks[scene.marktype];\n    return mark.pick.call(this, g, scene, x, y, gx, gy);\n  }\n}\nconst eventBundle = type => type === TouchStartEvent || type === TouchMoveEvent || type === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type];\n\n// lazily add listeners to the canvas as needed\nfunction eventListenerCheck(handler, type) {\n  eventBundle(type).forEach(_ => addEventListener(handler, _));\n}\nfunction addEventListener(handler, type) {\n  const canvas = handler.canvas();\n  if (canvas && !handler._events[type]) {\n    handler._events[type] = 1;\n    canvas.addEventListener(type, handler[type] ? evt => handler[type](evt) : evt => handler.fire(type, evt));\n  }\n}\nfunction fireAll(handler, types, event) {\n  types.forEach(type => handler.fire(type, event));\n}\nfunction move(moveEvents, overEvents, outEvents) {\n  return function (evt) {\n    const a = this._active,\n      p = this.pickEvent(evt);\n    if (p === a) {\n      // active item and picked item are the same\n      fireAll(this, moveEvents, evt); // fire move\n    } else {\n      // active item and picked item are different\n      if (!a || !a.exit) {\n        // fire out for prior active item\n        // suppress if active item was removed from scene\n        fireAll(this, outEvents, evt);\n      }\n      this._active = p; // set new active item\n      fireAll(this, overEvents, evt); // fire over for new active item\n      fireAll(this, moveEvents, evt); // fire move for new active item\n    }\n  };\n}\nfunction inactive(types) {\n  return function (evt) {\n    fireAll(this, types, evt);\n    this._active = null;\n  };\n}\n\nfunction devicePixelRatio() {\n  return typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1;\n}\nfunction resize (canvas, width, height, origin, scaleFactor, opt) {\n  const inDOM = typeof HTMLElement !== 'undefined' && canvas instanceof HTMLElement && canvas.parentNode != null,\n    context = canvas.getContext('2d'),\n    ratio = inDOM ? devicePixelRatio() : scaleFactor;\n  canvas.width = width * ratio;\n  canvas.height = height * ratio;\n  for (const key in opt) {\n    context[key] = opt[key];\n  }\n  if (inDOM && ratio !== 1) {\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n  }\n  context.pixelRatio = ratio;\n  context.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);\n  return canvas;\n}\n\nclass CanvasRenderer extends Renderer {\n  constructor(loader) {\n    super(loader);\n    this._options = {};\n    this._redraw = false;\n    this._dirty = new Bounds();\n    this._tempb = new Bounds();\n  }\n  initialize(el, width, height, origin, scaleFactor, options) {\n    this._options = options || {};\n    this._canvas = this._options.externalContext ? null : canvas(1, 1, this._options.type); // instantiate a small canvas\n\n    if (el && this._canvas) {\n      domClear(el, 0).appendChild(this._canvas);\n      this._canvas.setAttribute('class', 'marks');\n    }\n\n    // this method will invoke resize to size the canvas appropriately\n    return super.initialize(el, width, height, origin, scaleFactor);\n  }\n  resize(width, height, origin, scaleFactor) {\n    super.resize(width, height, origin, scaleFactor);\n    if (this._canvas) {\n      // configure canvas size and transform\n      resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);\n    } else {\n      // external context needs to be scaled and positioned to origin\n      const ctx = this._options.externalContext;\n      if (!ctx) error('CanvasRenderer is missing a valid canvas or context');\n      ctx.scale(this._scale, this._scale);\n      ctx.translate(this._origin[0], this._origin[1]);\n    }\n    this._redraw = true;\n    return this;\n  }\n  canvas() {\n    return this._canvas;\n  }\n  context() {\n    return this._options.externalContext || (this._canvas ? this._canvas.getContext('2d') : null);\n  }\n  dirty(item) {\n    const b = this._tempb.clear().union(item.bounds);\n    let g = item.mark.group;\n    while (g) {\n      b.translate(g.x || 0, g.y || 0);\n      g = g.mark.group;\n    }\n    this._dirty.union(b);\n  }\n  _render(scene, markTypes) {\n    const g = this.context(),\n      o = this._origin,\n      w = this._width,\n      h = this._height,\n      db = this._dirty,\n      vb = viewBounds(o, w, h);\n\n    // setup\n    g.save();\n    const b = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);\n    this.clear(-o[0], -o[1], w, h);\n\n    // render\n    this.draw(g, scene, b, markTypes);\n\n    // takedown\n    g.restore();\n    db.clear();\n    return this;\n  }\n  draw(ctx, scene, bounds, markTypes) {\n    if (scene.marktype !== 'group' && markTypes != null && !markTypes.includes(scene.marktype)) {\n      return;\n    }\n    const mark = Marks[scene.marktype];\n    if (scene.clip) clip(ctx, scene);\n    mark.draw.call(this, ctx, scene, bounds, markTypes);\n    if (scene.clip) ctx.restore();\n  }\n  clear(x, y, w, h) {\n    const opt = this._options,\n      g = this.context();\n    if (opt.type !== 'pdf' && !opt.externalContext) {\n      // calling clear rect voids vector output in pdf mode\n      // and could remove external context content (#2615)\n      g.clearRect(x, y, w, h);\n    }\n    if (this._bgcolor != null) {\n      g.fillStyle = this._bgcolor;\n      g.fillRect(x, y, w, h);\n    }\n  }\n}\nconst viewBounds = (origin, width, height) => new Bounds().set(0, 0, width, height).translate(-origin[0], -origin[1]);\nfunction clipToBounds(g, b, origin) {\n  // expand bounds by 1 pixel, then round to pixel boundaries\n  b.expand(1).round();\n\n  // align to base pixel grid in case of non-integer scaling (#2425)\n  if (g.pixelRatio % 1) {\n    b.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);\n  }\n\n  // to avoid artifacts translate if origin has fractional pixels\n  b.translate(-(origin[0] % 1), -(origin[1] % 1));\n\n  // set clip path\n  g.beginPath();\n  g.rect(b.x1, b.y1, b.width(), b.height());\n  g.clip();\n  return b;\n}\n\nclass SVGHandler extends Handler {\n  constructor(loader, tooltip) {\n    super(loader, tooltip);\n    const h = this;\n    h._hrefHandler = listener(h, (evt, item) => {\n      if (item && item.href) h.handleHref(evt, item, item.href);\n    });\n    h._tooltipHandler = listener(h, (evt, item) => {\n      h.handleTooltip(evt, item, evt.type !== TooltipHideEvent);\n    });\n  }\n  initialize(el, origin, obj) {\n    let svg = this._svg;\n    if (svg) {\n      svg.removeEventListener(HrefEvent, this._hrefHandler);\n      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);\n      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);\n    }\n    this._svg = svg = el && domFind(el, 'svg');\n    if (svg) {\n      svg.addEventListener(HrefEvent, this._hrefHandler);\n      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);\n      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);\n    }\n    return super.initialize(el, origin, obj);\n  }\n  canvas() {\n    return this._svg;\n  }\n\n  // add an event handler\n  on(type, handler) {\n    const name = this.eventName(type),\n      h = this._handlers,\n      i = this._handlerIndex(h[name], type, handler);\n    if (i < 0) {\n      const x = {\n        type,\n        handler,\n        listener: listener(this, handler)\n      };\n      (h[name] || (h[name] = [])).push(x);\n      if (this._svg) {\n        this._svg.addEventListener(name, x.listener);\n      }\n    }\n    return this;\n  }\n\n  // remove an event handler\n  off(type, handler) {\n    const name = this.eventName(type),\n      h = this._handlers[name],\n      i = this._handlerIndex(h, type, handler);\n    if (i >= 0) {\n      if (this._svg) {\n        this._svg.removeEventListener(name, h[i].listener);\n      }\n      h.splice(i, 1);\n    }\n    return this;\n  }\n}\n\n// wrap an event listener for the SVG DOM\nconst listener = (context, handler) => evt => {\n  let item = evt.target.__data__;\n  item = Array.isArray(item) ? item[0] : item;\n  evt.vegaType = evt.type;\n  handler.call(context._obj, evt, item);\n};\n\nconst ARIA_HIDDEN = 'aria-hidden';\nconst ARIA_LABEL = 'aria-label';\nconst ARIA_ROLE = 'role';\nconst ARIA_ROLEDESCRIPTION = 'aria-roledescription';\nconst GRAPHICS_OBJECT = 'graphics-object';\nconst GRAPHICS_SYMBOL = 'graphics-symbol';\nconst bundle = (role, roledesc, label) => ({\n  [ARIA_ROLE]: role,\n  [ARIA_ROLEDESCRIPTION]: roledesc,\n  [ARIA_LABEL]: label || undefined\n});\n\n// these roles are covered by related roles\n// we can ignore them, no need to generate attributes\nconst AriaIgnore = toSet(['axis-domain', 'axis-grid', 'axis-label', 'axis-tick', 'axis-title', 'legend-band', 'legend-entry', 'legend-gradient', 'legend-label', 'legend-title', 'legend-symbol', 'title']);\n\n// aria attribute generators for guide roles\nconst AriaGuides = {\n  'axis': {\n    desc: 'axis',\n    caption: axisCaption\n  },\n  'legend': {\n    desc: 'legend',\n    caption: legendCaption\n  },\n  'title-text': {\n    desc: 'title',\n    caption: item => `Title text '${titleCaption(item)}'`\n  },\n  'title-subtitle': {\n    desc: 'subtitle',\n    caption: item => `Subtitle text '${titleCaption(item)}'`\n  }\n};\n\n// aria properties generated for mark item encoding channels\nconst AriaEncode = {\n  ariaRole: ARIA_ROLE,\n  ariaRoleDescription: ARIA_ROLEDESCRIPTION,\n  description: ARIA_LABEL\n};\nfunction ariaItemAttributes(emit, item) {\n  const hide = item.aria === false;\n  emit(ARIA_HIDDEN, hide || undefined);\n  if (hide || item.description == null) {\n    for (const prop in AriaEncode) {\n      emit(AriaEncode[prop], undefined);\n    }\n  } else {\n    const type = item.mark.marktype;\n    emit(ARIA_LABEL, item.description);\n    emit(ARIA_ROLE, item.ariaRole || (type === 'group' ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));\n    emit(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || `${type} mark`);\n  }\n}\nfunction ariaMarkAttributes(mark) {\n  return mark.aria === false ? {\n    [ARIA_HIDDEN]: true\n  } : AriaIgnore[mark.role] ? null : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role]) : ariaMark(mark);\n}\nfunction ariaMark(mark) {\n  const type = mark.marktype;\n  const recurse = type === 'group' || type === 'text' || mark.items.some(_ => _.description != null && _.aria !== false);\n  return bundle(recurse ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, `${type} mark container`, mark.description);\n}\nfunction ariaGuide(mark, opt) {\n  try {\n    const item = mark.items[0],\n      caption = opt.caption || (() => '');\n    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));\n  } catch (err) {\n    return null;\n  }\n}\nfunction titleCaption(item) {\n  return array(item.text).join(' ');\n}\nfunction axisCaption(item) {\n  const datum = item.datum,\n    orient = item.orient,\n    title = datum.title ? extractTitle(item) : null,\n    ctx = item.context,\n    scale = ctx.scales[datum.scale].value,\n    locale = ctx.dataflow.locale(),\n    type = scale.type,\n    xy = orient === 'left' || orient === 'right' ? 'Y' : 'X';\n  return `${xy}-axis` + (title ? ` titled '${title}'` : '') + ` for a ${isDiscrete(type) ? 'discrete' : type} scale` + ` with ${domainCaption(locale, scale, item)}`;\n}\nfunction legendCaption(item) {\n  const datum = item.datum,\n    title = datum.title ? extractTitle(item) : null,\n    type = `${datum.type || ''} legend`.trim(),\n    scales = datum.scales,\n    props = Object.keys(scales),\n    ctx = item.context,\n    scale = ctx.scales[scales[props[0]]].value,\n    locale = ctx.dataflow.locale();\n  return capitalize(type) + (title ? ` titled '${title}'` : '') + ` for ${channelCaption(props)}` + ` with ${domainCaption(locale, scale, item)}`;\n}\nfunction extractTitle(item) {\n  try {\n    return array(peek(item.items).items[0].text).join(' ');\n  } catch (err) {\n    return null;\n  }\n}\nfunction channelCaption(props) {\n  props = props.map(p => p + (p === 'fill' || p === 'stroke' ? ' color' : ''));\n  return props.length < 2 ? props[0] : props.slice(0, -1).join(', ') + ' and ' + peek(props);\n}\nfunction capitalize(s) {\n  return s.length ? s[0].toUpperCase() + s.slice(1) : s;\n}\n\nconst innerText = val => (val + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\nconst attrText = val => innerText(val).replace(/\"/g, '&quot;').replace(/\\t/g, '&#x9;').replace(/\\n/g, '&#xA;').replace(/\\r/g, '&#xD;');\nfunction markup() {\n  let buf = '',\n    outer = '',\n    inner = '';\n  const stack = [],\n    clear = () => outer = inner = '',\n    push = tag => {\n      if (outer) {\n        buf += `${outer}>${inner}`;\n        clear();\n      }\n      stack.push(tag);\n    },\n    attr = (name, value) => {\n      if (value != null) outer += ` ${name}=\"${attrText(value)}\"`;\n      return m;\n    },\n    m = {\n      open(tag) {\n        push(tag);\n        outer = '<' + tag;\n        for (var _len = arguments.length, attrs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          attrs[_key - 1] = arguments[_key];\n        }\n        for (const set of attrs) {\n          for (const key in set) attr(key, set[key]);\n        }\n        return m;\n      },\n      close() {\n        const tag = stack.pop();\n        if (outer) {\n          buf += outer + (inner ? `>${inner}</${tag}>` : '/>');\n        } else {\n          buf += `</${tag}>`;\n        }\n        clear();\n        return m;\n      },\n      attr,\n      text: t => (inner += innerText(t), m),\n      toString: () => buf\n    };\n  return m;\n}\nconst serializeXML = node => _serialize(markup(), node) + '';\nfunction _serialize(m, node) {\n  m.open(node.tagName);\n  if (node.hasAttributes()) {\n    const attrs = node.attributes,\n      n = attrs.length;\n    for (let i = 0; i < n; ++i) {\n      m.attr(attrs[i].name, attrs[i].value);\n    }\n  }\n  if (node.hasChildNodes()) {\n    const children = node.childNodes;\n    for (const child of children) {\n      child.nodeType === 3 // text node\n      ? m.text(child.nodeValue) : _serialize(m, child);\n    }\n  }\n  return m.close();\n}\n\nconst stylesAttr = {\n  fill: 'fill',\n  fillOpacity: 'fill-opacity',\n  stroke: 'stroke',\n  strokeOpacity: 'stroke-opacity',\n  strokeWidth: 'stroke-width',\n  strokeCap: 'stroke-linecap',\n  strokeJoin: 'stroke-linejoin',\n  strokeDash: 'stroke-dasharray',\n  strokeDashOffset: 'stroke-dashoffset',\n  strokeMiterLimit: 'stroke-miterlimit',\n  opacity: 'opacity'\n};\nconst stylesCss = {\n  blend: 'mix-blend-mode'\n};\n\n// ensure miter limit default is consistent with canvas (#2498)\nconst rootAttributes = {\n  'fill': 'none',\n  'stroke-miterlimit': 10\n};\n\nconst RootIndex = 0,\n  xmlns = 'http://www.w3.org/2000/xmlns/',\n  svgns = metadata.xmlns;\nclass SVGRenderer extends Renderer {\n  constructor(loader) {\n    super(loader);\n    this._dirtyID = 0;\n    this._dirty = [];\n    this._svg = null;\n    this._root = null;\n    this._defs = null;\n  }\n\n  /**\n   * Initialize a new SVGRenderer instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {number} width - The coordinate width of the display, in pixels.\n   * @param {number} height - The coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {SVGRenderer} - This renderer instance.\n   */\n  initialize(el, width, height, origin, scaleFactor) {\n    // create the svg definitions cache\n    this._defs = {};\n    this._clearDefs();\n    if (el) {\n      this._svg = domChild(el, 0, 'svg', svgns);\n      this._svg.setAttributeNS(xmlns, 'xmlns', svgns);\n      this._svg.setAttributeNS(xmlns, 'xmlns:xlink', metadata['xmlns:xlink']);\n      this._svg.setAttribute('version', metadata['version']);\n      this._svg.setAttribute('class', 'marks');\n      domClear(el, 1);\n\n      // set the svg root group\n      this._root = domChild(this._svg, RootIndex, 'g', svgns);\n      setAttributes(this._root, rootAttributes);\n\n      // ensure no additional child elements\n      domClear(this._svg, RootIndex + 1);\n    }\n\n    // set background color if defined\n    this.background(this._bgcolor);\n    return super.initialize(el, width, height, origin, scaleFactor);\n  }\n\n  /**\n   * Get / set the background color.\n   */\n  background(bgcolor) {\n    if (arguments.length && this._svg) {\n      this._svg.style.setProperty('background-color', bgcolor);\n    }\n    return super.background(...arguments);\n  }\n\n  /**\n   * Resize the display.\n   * @param {number} width - The new coordinate width of the display, in pixels.\n   * @param {number} height - The new coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The new origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {SVGRenderer} - This renderer instance;\n   */\n  resize(width, height, origin, scaleFactor) {\n    super.resize(width, height, origin, scaleFactor);\n    if (this._svg) {\n      setAttributes(this._svg, {\n        width: this._width * this._scale,\n        height: this._height * this._scale,\n        viewBox: `0 0 ${this._width} ${this._height}`\n      });\n      this._root.setAttribute('transform', `translate(${this._origin})`);\n    }\n    this._dirty = [];\n    return this;\n  }\n\n  /**\n   * Returns the SVG element of the visualization.\n   * @return {DOMElement} - The SVG element.\n   */\n  canvas() {\n    return this._svg;\n  }\n\n  /**\n   * Returns an SVG text string for the rendered content,\n   * or null if this renderer is currently headless.\n   */\n  svg() {\n    const svg = this._svg,\n      bg = this._bgcolor;\n    if (!svg) return null;\n    let node;\n    if (bg) {\n      svg.removeAttribute('style');\n      node = domChild(svg, RootIndex, 'rect', svgns);\n      setAttributes(node, {\n        width: this._width,\n        height: this._height,\n        fill: bg\n      });\n    }\n    const text = serializeXML(svg);\n    if (bg) {\n      svg.removeChild(node);\n      this._svg.style.setProperty('background-color', bg);\n    }\n    return text;\n  }\n\n  /**\n   * Internal rendering method.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @param {Array} markTypes - Array of the mark types to render.\n   *                            If undefined, render all mark types\n   */\n  _render(scene, markTypes) {\n    // perform spot updates and re-render markup\n    if (this._dirtyCheck()) {\n      if (this._dirtyAll) this._clearDefs();\n      this.mark(this._root, scene, undefined, markTypes);\n      domClear(this._root, 1);\n    }\n    this.defs();\n    this._dirty = [];\n    ++this._dirtyID;\n    return this;\n  }\n\n  // -- Manage rendering of items marked as dirty --\n\n  /**\n   * Flag a mark item as dirty.\n   * @param {Item} item - The mark item.\n   */\n  dirty(item) {\n    if (item.dirty !== this._dirtyID) {\n      item.dirty = this._dirtyID;\n      this._dirty.push(item);\n    }\n  }\n\n  /**\n   * Check if a mark item is considered dirty.\n   * @param {Item} item - The mark item.\n   */\n  isDirty(item) {\n    return this._dirtyAll || !item._svg || !item._svg.ownerSVGElement || item.dirty === this._dirtyID;\n  }\n\n  /**\n   * Internal method to check dirty status and, if possible,\n   * make targetted updates without a full rendering pass.\n   */\n  _dirtyCheck() {\n    this._dirtyAll = true;\n    const items = this._dirty;\n    if (!items.length || !this._dirtyID) return true;\n    const id = ++this._dirtyID;\n    let item, mark, type, mdef, i, n, o;\n    for (i = 0, n = items.length; i < n; ++i) {\n      item = items[i];\n      mark = item.mark;\n      if (mark.marktype !== type) {\n        // memoize mark instance lookup\n        type = mark.marktype;\n        mdef = Marks[type];\n      }\n      if (mark.zdirty && mark.dirty !== id) {\n        this._dirtyAll = false;\n        dirtyParents(item, id);\n        mark.items.forEach(i => {\n          i.dirty = id;\n        });\n      }\n      if (mark.zdirty) continue; // handle in standard drawing pass\n\n      if (item.exit) {\n        // EXIT\n        if (mdef.nested && mark.items.length) {\n          // if nested mark with remaining points, update instead\n          o = mark.items[0];\n          if (o._svg) this._update(mdef, o._svg, o);\n        } else if (item._svg) {\n          // otherwise remove from DOM\n          o = item._svg.parentNode;\n          if (o) o.removeChild(item._svg);\n        }\n        item._svg = null;\n        continue;\n      }\n      item = mdef.nested ? mark.items[0] : item;\n      if (item._update === id) continue; // already visited\n\n      if (!item._svg || !item._svg.ownerSVGElement) {\n        // ENTER\n        this._dirtyAll = false;\n        dirtyParents(item, id);\n      } else {\n        // IN-PLACE UPDATE\n        this._update(mdef, item._svg, item);\n      }\n      item._update = id;\n    }\n    return !this._dirtyAll;\n  }\n\n  // -- Construct & maintain scenegraph to SVG mapping ---\n\n  /**\n   * Render a set of mark items.\n   * @param {SVGElement} el - The parent element in the SVG tree.\n   * @param {object} scene - The mark parent to render.\n   * @param {SVGElement} prev - The previous sibling in the SVG tree.\n   * @param {Array} markTypes - Array of the mark types to render.\n   *                            If undefined, render all mark types\n   */\n  mark(el, scene, prev, markTypes) {\n    if (!this.isDirty(scene)) {\n      return scene._svg;\n    }\n    const svg = this._svg,\n      markType = scene.marktype,\n      mdef = Marks[markType],\n      events = scene.interactive === false ? 'none' : null,\n      isGroup = mdef.tag === 'g';\n    const parent = bind(scene, el, prev, 'g', svg);\n    if (markType !== 'group' && markTypes != null && !markTypes.includes(markType)) {\n      domClear(parent, 0);\n      return scene._svg;\n    }\n    parent.setAttribute('class', cssClass(scene));\n\n    // apply aria attributes to parent container element\n    const aria = ariaMarkAttributes(scene);\n    for (const key in aria) setAttribute(parent, key, aria[key]);\n    if (!isGroup) {\n      setAttribute(parent, 'pointer-events', events);\n    }\n    setAttribute(parent, 'clip-path', scene.clip ? clip$1(this, scene, scene.group) : null);\n    let sibling = null,\n      i = 0;\n    const process = item => {\n      const dirty = this.isDirty(item),\n        node = bind(item, parent, sibling, mdef.tag, svg);\n      if (dirty) {\n        this._update(mdef, node, item);\n        if (isGroup) recurse(this, node, item, markTypes);\n      }\n      sibling = node;\n      ++i;\n    };\n    if (mdef.nested) {\n      if (scene.items.length) process(scene.items[0]);\n    } else {\n      visit(scene, process);\n    }\n    domClear(parent, i);\n    return parent;\n  }\n\n  /**\n   * Update the attributes of an SVG element for a mark item.\n   * @param {object} mdef - The mark definition object\n   * @param {SVGElement} el - The SVG element.\n   * @param {Item} item - The mark item.\n   */\n  _update(mdef, el, item) {\n    // set dom element and values cache\n    // provides access to emit method\n    element = el;\n    values = el.__values__;\n\n    // apply aria-specific properties\n    ariaItemAttributes(emit, item);\n\n    // apply svg attributes\n    mdef.attr(emit, item, this);\n\n    // some marks need special treatment\n    const extra = mark_extras[mdef.type];\n    if (extra) extra.call(this, mdef, el, item);\n\n    // apply svg style attributes\n    // note: element state may have been modified by 'extra' method\n    if (element) this.style(element, item);\n  }\n\n  /**\n   * Update the presentation attributes of an SVG element for a mark item.\n   * @param {SVGElement} el - The SVG element.\n   * @param {Item} item - The mark item.\n   */\n  style(el, item) {\n    if (item == null) return;\n    for (const prop in stylesAttr) {\n      let value = prop === 'font' ? fontFamily(item) : item[prop];\n      if (value === values[prop]) continue;\n      const name = stylesAttr[prop];\n      if (value == null) {\n        el.removeAttribute(name);\n      } else {\n        if (isGradient(value)) {\n          value = gradientRef(value, this._defs.gradient, href());\n        }\n        el.setAttribute(name, value + '');\n      }\n      values[prop] = value;\n    }\n    for (const prop in stylesCss) {\n      setStyle(el, stylesCss[prop], item[prop]);\n    }\n  }\n\n  /**\n   * Render SVG defs, as needed.\n   * Must be called *after* marks have been processed to ensure the\n   * collected state is current and accurate.\n   */\n  defs() {\n    const svg = this._svg,\n      defs = this._defs;\n    let el = defs.el,\n      index = 0;\n    for (const id in defs.gradient) {\n      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);\n      index = updateGradient(el, defs.gradient[id], index);\n    }\n    for (const id in defs.clipping) {\n      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);\n      index = updateClipping(el, defs.clipping[id], index);\n    }\n\n    // clean-up\n    if (el) {\n      index === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index);\n    }\n  }\n\n  /**\n   * Clear defs caches.\n   */\n  _clearDefs() {\n    const def = this._defs;\n    def.gradient = {};\n    def.clipping = {};\n  }\n}\n\n// mark ancestor chain with a dirty id\nfunction dirtyParents(item, id) {\n  for (; item && item.dirty !== id; item = item.mark.group) {\n    item.dirty = id;\n    if (item.mark && item.mark.dirty !== id) {\n      item.mark.dirty = id;\n    } else return;\n  }\n}\n\n// update gradient definitions\nfunction updateGradient(el, grad, index) {\n  let i, n, stop;\n  if (grad.gradient === 'radial') {\n    // SVG radial gradients automatically transform to normalized bbox\n    // coordinates, in a way that is cumbersome to replicate in canvas.\n    // We wrap the radial gradient in a pattern element, allowing us to\n    // maintain a circular gradient that matches what canvas provides.\n    let pt = domChild(el, index++, 'pattern', svgns);\n    setAttributes(pt, {\n      id: patternPrefix + grad.id,\n      viewBox: '0,0,1,1',\n      width: '100%',\n      height: '100%',\n      preserveAspectRatio: 'xMidYMid slice'\n    });\n    pt = domChild(pt, 0, 'rect', svgns);\n    setAttributes(pt, {\n      width: 1,\n      height: 1,\n      fill: `url(${href()}#${grad.id})`\n    });\n    el = domChild(el, index++, 'radialGradient', svgns);\n    setAttributes(el, {\n      id: grad.id,\n      fx: grad.x1,\n      fy: grad.y1,\n      fr: grad.r1,\n      cx: grad.x2,\n      cy: grad.y2,\n      r: grad.r2\n    });\n  } else {\n    el = domChild(el, index++, 'linearGradient', svgns);\n    setAttributes(el, {\n      id: grad.id,\n      x1: grad.x1,\n      x2: grad.x2,\n      y1: grad.y1,\n      y2: grad.y2\n    });\n  }\n  for (i = 0, n = grad.stops.length; i < n; ++i) {\n    stop = domChild(el, i, 'stop', svgns);\n    stop.setAttribute('offset', grad.stops[i].offset);\n    stop.setAttribute('stop-color', grad.stops[i].color);\n  }\n  domClear(el, i);\n  return index;\n}\n\n// update clipping path definitions\nfunction updateClipping(el, clip, index) {\n  let mask;\n  el = domChild(el, index, 'clipPath', svgns);\n  el.setAttribute('id', clip.id);\n  if (clip.path) {\n    mask = domChild(el, 0, 'path', svgns);\n    mask.setAttribute('d', clip.path);\n  } else {\n    mask = domChild(el, 0, 'rect', svgns);\n    setAttributes(mask, {\n      x: 0,\n      y: 0,\n      width: clip.width,\n      height: clip.height\n    });\n  }\n  domClear(el, 1);\n  return index + 1;\n}\n\n// Recursively process group contents.\nfunction recurse(renderer, el, group, markTypes) {\n  // child 'g' element is second to last among children (path, g, path)\n  // other children here are foreground and background path elements\n  el = el.lastChild.previousSibling;\n  let prev,\n    idx = 0;\n  visit(group, item => {\n    prev = renderer.mark(el, item, prev, markTypes);\n    ++idx;\n  });\n\n  // remove any extraneous DOM elements\n  domClear(el, 1 + idx);\n}\n\n// Bind a scenegraph item to an SVG DOM element.\n// Create new SVG elements as needed.\nfunction bind(item, el, sibling, tag, svg) {\n  let node = item._svg,\n    doc;\n\n  // create a new dom node if needed\n  if (!node) {\n    doc = el.ownerDocument;\n    node = domCreate(doc, tag, svgns);\n    item._svg = node;\n    if (item.mark) {\n      node.__data__ = item;\n      node.__values__ = {\n        fill: 'default'\n      };\n\n      // if group, create background, content, and foreground elements\n      if (tag === 'g') {\n        const bg = domCreate(doc, 'path', svgns);\n        node.appendChild(bg);\n        bg.__data__ = item;\n        const cg = domCreate(doc, 'g', svgns);\n        node.appendChild(cg);\n        cg.__data__ = item;\n        const fg = domCreate(doc, 'path', svgns);\n        node.appendChild(fg);\n        fg.__data__ = item;\n        fg.__values__ = {\n          fill: 'default'\n        };\n      }\n    }\n  }\n\n  // (re-)insert if (a) not contained in SVG or (b) sibling order has changed\n  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {\n    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);\n  }\n  return node;\n}\n\n// check if two nodes are ordered siblings\nfunction siblingCheck(node, sibling) {\n  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling; // treat null/undefined the same\n}\n\n// -- Set attributes & styles on SVG elements ---\n\nlet element = null,\n  // temp var for current SVG element\n  values = null; // temp var for current values hash\n\n// Extra configuration for certain mark types\nconst mark_extras = {\n  group(mdef, el, item) {\n    const fg = element = el.childNodes[2];\n    values = fg.__values__;\n    mdef.foreground(emit, item, this);\n    values = el.__values__; // use parent's values hash\n    element = el.childNodes[1];\n    mdef.content(emit, item, this);\n    const bg = element = el.childNodes[0];\n    mdef.background(emit, item, this);\n    const value = item.mark.interactive === false ? 'none' : null;\n    if (value !== values.events) {\n      setAttribute(fg, 'pointer-events', value);\n      setAttribute(bg, 'pointer-events', value);\n      values.events = value;\n    }\n    if (item.strokeForeground && item.stroke) {\n      const fill = item.fill;\n      setAttribute(fg, 'display', null);\n\n      // set style of background\n      this.style(bg, item);\n      setAttribute(bg, 'stroke', null);\n\n      // set style of foreground\n      if (fill) item.fill = null;\n      values = fg.__values__;\n      this.style(fg, item);\n      if (fill) item.fill = fill;\n\n      // leave element null to prevent downstream styling\n      element = null;\n    } else {\n      // ensure foreground is ignored\n      setAttribute(fg, 'display', 'none');\n    }\n  },\n  image(mdef, el, item) {\n    if (item.smooth === false) {\n      setStyle(el, 'image-rendering', 'optimizeSpeed');\n      setStyle(el, 'image-rendering', 'pixelated');\n    } else {\n      setStyle(el, 'image-rendering', null);\n    }\n  },\n  text(mdef, el, item) {\n    const tl = textLines(item);\n    let key, value, doc, lh;\n    if (isArray(tl)) {\n      // multi-line text\n      value = tl.map(_ => textValue(item, _));\n      key = value.join('\\n'); // content cache key\n\n      if (key !== values.text) {\n        domClear(el, 0);\n        doc = el.ownerDocument;\n        lh = lineHeight(item);\n        value.forEach((t, i) => {\n          const ts = domCreate(doc, 'tspan', svgns);\n          ts.__data__ = item; // data binding\n          ts.textContent = t;\n          if (i) {\n            ts.setAttribute('x', 0);\n            ts.setAttribute('dy', lh);\n          }\n          el.appendChild(ts);\n        });\n        values.text = key;\n      }\n    } else {\n      // single-line text\n      value = textValue(item, tl);\n      if (value !== values.text) {\n        el.textContent = value;\n        values.text = value;\n      }\n    }\n    setAttribute(el, 'font-family', fontFamily(item));\n    setAttribute(el, 'font-size', fontSize(item) + 'px');\n    setAttribute(el, 'font-style', item.fontStyle);\n    setAttribute(el, 'font-variant', item.fontVariant);\n    setAttribute(el, 'font-weight', item.fontWeight);\n  }\n};\nfunction emit(name, value, ns) {\n  // early exit if value is unchanged\n  if (value === values[name]) return;\n\n  // use appropriate method given namespace (ns)\n  if (ns) {\n    setAttributeNS(element, name, value, ns);\n  } else {\n    setAttribute(element, name, value);\n  }\n\n  // note current value for future comparison\n  values[name] = value;\n}\nfunction setStyle(el, name, value) {\n  if (value !== values[name]) {\n    if (value == null) {\n      el.style.removeProperty(name);\n    } else {\n      el.style.setProperty(name, value + '');\n    }\n    values[name] = value;\n  }\n}\nfunction setAttributes(el, attrs) {\n  for (const key in attrs) {\n    setAttribute(el, key, attrs[key]);\n  }\n}\nfunction setAttribute(el, name, value) {\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    el.setAttribute(name, value);\n  } else {\n    // else remove DOM attribute\n    el.removeAttribute(name);\n  }\n}\nfunction setAttributeNS(el, name, value, ns) {\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    el.setAttributeNS(ns, name, value);\n  } else {\n    // else remove DOM attribute\n    el.removeAttributeNS(ns, name);\n  }\n}\nfunction href() {\n  let loc;\n  return typeof window === 'undefined' ? '' : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;\n}\n\nclass SVGStringRenderer extends Renderer {\n  constructor(loader) {\n    super(loader);\n    this._text = null;\n    this._defs = {\n      gradient: {},\n      clipping: {}\n    };\n  }\n\n  /**\n   * Returns the rendered SVG text string,\n   * or null if rendering has not yet occurred.\n   */\n  svg() {\n    return this._text;\n  }\n\n  /**\n   * Internal rendering method.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   */\n  _render(scene) {\n    const m = markup();\n\n    // svg tag\n    m.open('svg', extend({}, metadata, {\n      class: 'marks',\n      width: this._width * this._scale,\n      height: this._height * this._scale,\n      viewBox: `0 0 ${this._width} ${this._height}`\n    }));\n\n    // background, if defined\n    const bg = this._bgcolor;\n    if (bg && bg !== 'transparent' && bg !== 'none') {\n      m.open('rect', {\n        width: this._width,\n        height: this._height,\n        fill: bg\n      }).close();\n    }\n\n    // root content group\n    m.open('g', rootAttributes, {\n      transform: 'translate(' + this._origin + ')'\n    });\n    this.mark(m, scene);\n    m.close(); // </g>\n\n    // defs\n    this.defs(m);\n\n    // get SVG text string\n    this._text = m.close() + '';\n    return this;\n  }\n\n  /**\n   * Render a set of mark items.\n   * @param {object} m - The markup context.\n   * @param {object} scene - The mark parent to render.\n   */\n  mark(m, scene) {\n    const mdef = Marks[scene.marktype],\n      tag = mdef.tag,\n      attrList = [ariaItemAttributes, mdef.attr];\n\n    // render opening group tag\n    m.open('g', {\n      'class': cssClass(scene),\n      'clip-path': scene.clip ? clip$1(this, scene, scene.group) : null\n    }, ariaMarkAttributes(scene), {\n      'pointer-events': tag !== 'g' && scene.interactive === false ? 'none' : null\n    });\n\n    // render contained elements\n    const process = item => {\n      const href = this.href(item);\n      if (href) m.open('a', href);\n      m.open(tag, this.attr(scene, item, attrList, tag !== 'g' ? tag : null));\n      if (tag === 'text') {\n        const tl = textLines(item);\n        if (isArray(tl)) {\n          // multi-line text\n          const attrs = {\n            x: 0,\n            dy: lineHeight(item)\n          };\n          for (let i = 0; i < tl.length; ++i) {\n            m.open('tspan', i ? attrs : null).text(textValue(item, tl[i])).close();\n          }\n        } else {\n          // single-line text\n          m.text(textValue(item, tl));\n        }\n      } else if (tag === 'g') {\n        const fore = item.strokeForeground,\n          fill = item.fill,\n          stroke = item.stroke;\n        if (fore && stroke) {\n          item.stroke = null;\n        }\n        m.open('path', this.attr(scene, item, mdef.background, 'bgrect')).close();\n\n        // recurse for group content\n        m.open('g', this.attr(scene, item, mdef.content));\n        visit(item, scene => this.mark(m, scene));\n        m.close();\n        if (fore && stroke) {\n          if (fill) item.fill = null;\n          item.stroke = stroke;\n          m.open('path', this.attr(scene, item, mdef.foreground, 'bgrect')).close();\n          if (fill) item.fill = fill;\n        } else {\n          m.open('path', this.attr(scene, item, mdef.foreground, 'bgfore')).close();\n        }\n      }\n      m.close(); // </tag>\n      if (href) m.close(); // </a>\n    };\n    if (mdef.nested) {\n      if (scene.items && scene.items.length) process(scene.items[0]);\n    } else {\n      visit(scene, process);\n    }\n\n    // render closing group tag\n    return m.close(); // </g>\n  }\n\n  /**\n   * Get href attributes for a hyperlinked mark item.\n   * @param {Item} item - The mark item.\n   */\n  href(item) {\n    const href = item.href;\n    let attr;\n    if (href) {\n      if (attr = this._hrefs && this._hrefs[href]) {\n        return attr;\n      } else {\n        this.sanitizeURL(href).then(attr => {\n          // rewrite to use xlink namespace\n          attr['xlink:href'] = attr.href;\n          attr.href = null;\n          (this._hrefs || (this._hrefs = {}))[href] = attr;\n        });\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get an object of SVG attributes for a mark item.\n   * @param {object} scene - The mark parent.\n   * @param {Item} item - The mark item.\n   * @param {array|function} attrs - One or more attribute emitters.\n   * @param {string} tag - The tag being rendered.\n   */\n  attr(scene, item, attrs, tag) {\n    const object = {},\n      emit = (name, value, ns, prefixed) => {\n        object[prefixed || name] = value;\n      };\n\n    // apply mark specific attributes\n    if (Array.isArray(attrs)) {\n      attrs.forEach(fn => fn(emit, item, this));\n    } else {\n      attrs(emit, item, this);\n    }\n\n    // apply style attributes\n    if (tag) {\n      style(object, item, scene, tag, this._defs);\n    }\n    return object;\n  }\n\n  /**\n   * Render SVG defs, as needed.\n   * Must be called *after* marks have been processed to ensure the\n   * collected state is current and accurate.\n   * @param {object} m - The markup context.\n   */\n  defs(m) {\n    const gradient = this._defs.gradient,\n      clipping = this._defs.clipping,\n      count = Object.keys(gradient).length + Object.keys(clipping).length;\n    if (count === 0) return; // nothing to do\n\n    m.open('defs');\n    for (const id in gradient) {\n      const def = gradient[id],\n        stops = def.stops;\n      if (def.gradient === 'radial') {\n        // SVG radial gradients automatically transform to normalized bbox\n        // coordinates, in a way that is cumbersome to replicate in canvas.\n        // We wrap the radial gradient in a pattern element, allowing us to\n        // maintain a circular gradient that matches what canvas provides.\n\n        m.open('pattern', {\n          id: patternPrefix + id,\n          viewBox: '0,0,1,1',\n          width: '100%',\n          height: '100%',\n          preserveAspectRatio: 'xMidYMid slice'\n        });\n        m.open('rect', {\n          width: '1',\n          height: '1',\n          fill: 'url(#' + id + ')'\n        }).close();\n        m.close(); // </pattern>\n\n        m.open('radialGradient', {\n          id: id,\n          fx: def.x1,\n          fy: def.y1,\n          fr: def.r1,\n          cx: def.x2,\n          cy: def.y2,\n          r: def.r2\n        });\n      } else {\n        m.open('linearGradient', {\n          id: id,\n          x1: def.x1,\n          x2: def.x2,\n          y1: def.y1,\n          y2: def.y2\n        });\n      }\n      for (let i = 0; i < stops.length; ++i) {\n        m.open('stop', {\n          offset: stops[i].offset,\n          'stop-color': stops[i].color\n        }).close();\n      }\n      m.close();\n    }\n    for (const id in clipping) {\n      const def = clipping[id];\n      m.open('clipPath', {\n        id: id\n      });\n      if (def.path) {\n        m.open('path', {\n          d: def.path\n        }).close();\n      } else {\n        m.open('rect', {\n          x: 0,\n          y: 0,\n          width: def.width,\n          height: def.height\n        }).close();\n      }\n      m.close();\n    }\n    m.close();\n  }\n}\n\n// Helper function for attr for style presentation attributes\nfunction style(s, item, scene, tag, defs) {\n  let styleList;\n  if (item == null) return s;\n  if (tag === 'bgrect' && scene.interactive === false) {\n    s['pointer-events'] = 'none';\n  }\n  if (tag === 'bgfore') {\n    if (scene.interactive === false) {\n      s['pointer-events'] = 'none';\n    }\n    s.display = 'none';\n    if (item.fill !== null) return s;\n  }\n  if (tag === 'image' && item.smooth === false) {\n    styleList = ['image-rendering: optimizeSpeed;', 'image-rendering: pixelated;'];\n  }\n  if (tag === 'text') {\n    s['font-family'] = fontFamily(item);\n    s['font-size'] = fontSize(item) + 'px';\n    s['font-style'] = item.fontStyle;\n    s['font-variant'] = item.fontVariant;\n    s['font-weight'] = item.fontWeight;\n  }\n  for (const prop in stylesAttr) {\n    let value = item[prop];\n    const name = stylesAttr[prop];\n    if (value === 'transparent' && (name === 'fill' || name === 'stroke')) ; else if (value != null) {\n      if (isGradient(value)) {\n        value = gradientRef(value, defs.gradient, '');\n      }\n      s[name] = value;\n    }\n  }\n  for (const prop in stylesCss) {\n    const value = item[prop];\n    if (value != null) {\n      styleList = styleList || [];\n      styleList.push(`${stylesCss[prop]}: ${value};`);\n    }\n  }\n  if (styleList) {\n    s.style = styleList.join(' ');\n  }\n  return s;\n}\n\n/**\n * @typedef {Object} HybridRendererOptions\n *\n * @property {string[]} [svgMarkTypes=['text']] - An array of SVG mark types to render\n *                                                in the SVG layer. All other mark types\n *                                                will be rendered in the Canvas layer.\n * @property {boolean} [svgOnTop=true] - Flag to determine if SVG should be rendered on top.\n * @property {boolean} [debug=false] - Flag to enable or disable debugging mode. When true,\n *                                     the top layer will be stacked below the bottom layer\n *                                     rather than overlaid on top.\n */\n\n/** @type {HybridRendererOptions} */\nconst OPTS = {\n  svgMarkTypes: ['text'],\n  svgOnTop: true,\n  debug: false\n};\n\n/**\n * Configure the HybridRenderer\n *\n * @param {HybridRendererOptions} options - HybridRenderer configuration options.\n */\nfunction setHybridRendererOptions(options) {\n  OPTS['svgMarkTypes'] = options.svgMarkTypes ?? ['text'];\n  OPTS['svgOnTop'] = options.svgOnTop ?? true;\n  OPTS['debug'] = options.debug ?? false;\n}\nclass HybridRenderer extends Renderer {\n  constructor(loader) {\n    super(loader);\n    this._svgRenderer = new SVGRenderer(loader);\n    this._canvasRenderer = new CanvasRenderer(loader);\n  }\n\n  /**\n   * Initialize a new HybridRenderer instance.\n   * @param {DOMElement} el - The containing DOM element for the display.\n   * @param {number} width - The coordinate width of the display, in pixels.\n   * @param {number} height - The coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {HybridRenderer} - This renderer instance.\n   */\n  initialize(el, width, height, origin, scaleFactor) {\n    this._root_el = domChild(el, 0, 'div');\n    const bottomEl = domChild(this._root_el, 0, 'div');\n    const topEl = domChild(this._root_el, 1, 'div');\n    this._root_el.style.position = 'relative';\n\n    // Set position absolute to overlay svg on top of canvas\n    if (!OPTS.debug) {\n      bottomEl.style.height = '100%';\n      topEl.style.position = 'absolute';\n      topEl.style.top = '0';\n      topEl.style.left = '0';\n      topEl.style.height = '100%';\n      topEl.style.width = '100%';\n    }\n    this._svgEl = OPTS.svgOnTop ? topEl : bottomEl;\n    this._canvasEl = OPTS.svgOnTop ? bottomEl : topEl;\n\n    // pointer-events to none on SVG layer so that canvas gets all events\n    this._svgEl.style.pointerEvents = 'none';\n    this._canvasRenderer.initialize(this._canvasEl, width, height, origin, scaleFactor);\n    this._svgRenderer.initialize(this._svgEl, width, height, origin, scaleFactor);\n    return super.initialize(el, width, height, origin, scaleFactor);\n  }\n\n  /**\n   * Flag a mark item as dirty.\n   * @param {Item} item - The mark item.\n   */\n  dirty(item) {\n    if (OPTS.svgMarkTypes.includes(item.mark.marktype)) {\n      this._svgRenderer.dirty(item);\n    } else {\n      this._canvasRenderer.dirty(item);\n    }\n    return this;\n  }\n\n  /**\n   * Internal rendering method.\n   * @param {object} scene - The root mark of a scenegraph to render.\n   * @param {Array} markTypes - Array of the mark types to render.\n   *                            If undefined, render all mark types\n   */\n  _render(scene, markTypes) {\n    const allMarkTypes = markTypes ?? ['arc', 'area', 'image', 'line', 'path', 'rect', 'rule', 'shape', 'symbol', 'text', 'trail'];\n    const canvasMarkTypes = allMarkTypes.filter(m => !OPTS.svgMarkTypes.includes(m));\n    this._svgRenderer.render(scene, OPTS.svgMarkTypes);\n    this._canvasRenderer.render(scene, canvasMarkTypes);\n  }\n\n  /**\n   * Resize the display.\n   * @param {number} width - The new coordinate width of the display, in pixels.\n   * @param {number} height - The new coordinate height of the display, in pixels.\n   * @param {Array<number>} origin - The new origin of the display, in pixels.\n   *   The coordinate system will be translated to this point.\n   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n   *   the width and height to determine the final pixel size.\n   * @return {SVGRenderer} - This renderer instance;\n   */\n  resize(width, height, origin, scaleFactor) {\n    super.resize(width, height, origin, scaleFactor);\n    this._svgRenderer.resize(width, height, origin, scaleFactor);\n    this._canvasRenderer.resize(width, height, origin, scaleFactor);\n    return this;\n  }\n  background(bgcolor) {\n    // Propagate background color to lower canvas renderer\n    if (OPTS.svgOnTop) {\n      this._canvasRenderer.background(bgcolor);\n    } else {\n      this._svgRenderer.background(bgcolor);\n    }\n    return this;\n  }\n}\n\nclass HybridHandler extends CanvasHandler {\n  constructor(loader, tooltip) {\n    super(loader, tooltip);\n  }\n  initialize(el, origin, obj) {\n    const canvas = domChild(domChild(el, 0, 'div'), OPTS.svgOnTop ? 0 : 1, 'div');\n    return super.initialize(canvas, origin, obj);\n  }\n}\n\nconst Canvas = 'canvas';\nconst Hybrid = 'hybrid';\nconst PNG = 'png';\nconst SVG = 'svg';\nconst None = 'none';\nconst RenderType = {\n  Canvas: Canvas,\n  PNG: PNG,\n  SVG: SVG,\n  Hybrid: Hybrid,\n  None: None\n};\nconst modules = {};\nmodules[Canvas] = modules[PNG] = {\n  renderer: CanvasRenderer,\n  headless: CanvasRenderer,\n  handler: CanvasHandler\n};\nmodules[SVG] = {\n  renderer: SVGRenderer,\n  headless: SVGStringRenderer,\n  handler: SVGHandler\n};\nmodules[Hybrid] = {\n  renderer: HybridRenderer,\n  headless: HybridRenderer,\n  handler: HybridHandler\n};\nmodules[None] = {};\nfunction renderModule(name, _) {\n  name = String(name || '').toLowerCase();\n  if (arguments.length > 1) {\n    modules[name] = _;\n    return this;\n  } else {\n    return modules[name];\n  }\n}\n\nfunction intersect(scene, bounds, filter) {\n  const hits = [],\n    // intersection results\n    box = new Bounds().union(bounds),\n    // defensive copy\n    type = scene.marktype;\n  return type ? intersectMark(scene, box, filter, hits) : type === 'group' ? intersectGroup(scene, box, filter, hits) : error('Intersect scene must be mark node or group item.');\n}\nfunction intersectMark(mark, box, filter, hits) {\n  if (visitMark(mark, box, filter)) {\n    const items = mark.items,\n      type = mark.marktype,\n      n = items.length;\n    let i = 0;\n    if (type === 'group') {\n      for (; i < n; ++i) {\n        intersectGroup(items[i], box, filter, hits);\n      }\n    } else {\n      for (const test = Marks[type].isect; i < n; ++i) {\n        const item = items[i];\n        if (intersectItem(item, box, test)) hits.push(item);\n      }\n    }\n  }\n  return hits;\n}\nfunction visitMark(mark, box, filter) {\n  // process if bounds intersect and if\n  // (1) mark is a group mark (so we must recurse), or\n  // (2) mark is interactive and passes filter\n  return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === 'group' || mark.interactive !== false && (!filter || filter(mark)));\n}\nfunction intersectGroup(group, box, filter, hits) {\n  // test intersect against group\n  // skip groups by default unless filter says otherwise\n  if (filter && filter(group.mark) && intersectItem(group, box, Marks.group.isect)) {\n    hits.push(group);\n  }\n\n  // recursively test children marks\n  // translate box to group coordinate space\n  const marks = group.items,\n    n = marks && marks.length;\n  if (n) {\n    const x = group.x || 0,\n      y = group.y || 0;\n    box.translate(-x, -y);\n    for (let i = 0; i < n; ++i) {\n      intersectMark(marks[i], box, filter, hits);\n    }\n    box.translate(x, y);\n  }\n  return hits;\n}\nfunction intersectItem(item, box, test) {\n  // test bounds enclosure, bounds intersection, then detailed test\n  const bounds = item.bounds;\n  return box.encloses(bounds) || box.intersects(bounds) && test(item, box);\n}\n\nconst clipBounds = new Bounds();\nfunction boundClip (mark) {\n  const clip = mark.clip;\n  if (isFunction(clip)) {\n    clip(boundContext(clipBounds.clear()));\n  } else if (clip) {\n    clipBounds.set(0, 0, mark.group.width, mark.group.height);\n  } else return;\n  mark.bounds.intersect(clipBounds);\n}\n\nconst TOLERANCE = 1e-9;\nfunction sceneEqual(a, b, key) {\n  return a === b ? true : key === 'path' ? pathEqual(a, b) : a instanceof Date && b instanceof Date ? +a === +b : isNumber(a) && isNumber(b) ? Math.abs(a - b) <= TOLERANCE : !a || !b || !isObject(a) && !isObject(b) ? a == b : objectEqual(a, b);\n}\nfunction pathEqual(a, b) {\n  return sceneEqual(parse(a), parse(b));\n}\nfunction objectEqual(a, b) {\n  var ka = Object.keys(a),\n    kb = Object.keys(b),\n    key,\n    i;\n  if (ka.length !== kb.length) return false;\n  ka.sort();\n  kb.sort();\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i]) return false;\n  }\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!sceneEqual(a[key], b[key], key)) return false;\n  }\n  return typeof a === typeof b;\n}\n\nfunction resetSVGDefIds() {\n  resetSVGClipId();\n  resetSVGGradientId();\n}\n\nexport { Bounds, CanvasHandler, CanvasRenderer, Gradient, GroupItem, Handler, HybridHandler, HybridRenderer, Item, Marks, RenderType, Renderer, ResourceLoader, SVGHandler, SVGRenderer, SVGStringRenderer, Scenegraph, boundClip, boundContext, boundItem, boundMark, boundStroke, domChild, domClear, domCreate, domFind, font, fontFamily, fontSize, intersect, intersectBoxLine, intersectPath, intersectPoint, intersectRule, lineHeight, markup, multiLineOffset, curves as pathCurves, pathEqual, parse as pathParse, vg_rect as pathRectangle, pathRender, symbols as pathSymbols, vg_trail as pathTrail, point, renderModule, resetSVGClipId, resetSVGDefIds, sceneEqual, sceneFromJSON, pickVisit as scenePickVisit, sceneToJSON, visit as sceneVisit, zorder as sceneZOrder, serializeXML, setHybridRendererOptions, textMetrics };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}