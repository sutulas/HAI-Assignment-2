{"ast":null,"code":"import { isAggregateOp } from '../../aggregate';\nimport { vgField } from '../../channeldef';\nimport { duplicate, hash } from '../../util';\nimport { unique } from '../../util';\nimport { DataFlowNode } from './dataflow';\n/**\n * A class for the window transform nodes\n */\nexport class WindowTransformNode extends DataFlowNode {\n  clone() {\n    return new WindowTransformNode(null, duplicate(this.transform));\n  }\n  constructor(parent, transform) {\n    super(parent);\n    this.transform = transform;\n  }\n  addDimensions(fields) {\n    this.transform.groupby = unique(this.transform.groupby.concat(fields), d => d);\n  }\n  dependentFields() {\n    const out = new Set();\n    (this.transform.groupby ?? []).forEach(out.add, out);\n    (this.transform.sort ?? []).forEach(m => out.add(m.field));\n    this.transform.window.map(w => w.field).filter(f => f !== undefined).forEach(out.add, out);\n    return out;\n  }\n  producedFields() {\n    return new Set(this.transform.window.map(this.getDefaultName));\n  }\n  getDefaultName(windowFieldDef) {\n    return windowFieldDef.as ?? vgField(windowFieldDef);\n  }\n  hash() {\n    return `WindowTransform ${hash(this.transform)}`;\n  }\n  assemble() {\n    const fields = [];\n    const ops = [];\n    const as = [];\n    const params = [];\n    for (const window of this.transform.window) {\n      ops.push(window.op);\n      as.push(this.getDefaultName(window));\n      params.push(window.param === undefined ? null : window.param);\n      fields.push(window.field === undefined ? null : window.field);\n    }\n    const frame = this.transform.frame;\n    const groupby = this.transform.groupby;\n    if (frame && frame[0] === null && frame[1] === null && ops.every(o => isAggregateOp(o))) {\n      // when the window does not rely on any particular window ops or frame, switch to a simpler and more efficient joinaggregate\n      return {\n        type: 'joinaggregate',\n        as,\n        ops: ops,\n        fields,\n        ...(groupby !== undefined ? {\n          groupby\n        } : {})\n      };\n    }\n    const sortFields = [];\n    const sortOrder = [];\n    if (this.transform.sort !== undefined) {\n      for (const sortField of this.transform.sort) {\n        sortFields.push(sortField.field);\n        sortOrder.push(sortField.order ?? 'ascending');\n      }\n    }\n    const sort = {\n      field: sortFields,\n      order: sortOrder\n    };\n    const ignorePeers = this.transform.ignorePeers;\n    return {\n      type: 'window',\n      params,\n      as,\n      ops,\n      fields,\n      sort,\n      ...(ignorePeers !== undefined ? {\n        ignorePeers\n      } : {}),\n      ...(groupby !== undefined ? {\n        groupby\n      } : {}),\n      ...(frame !== undefined ? {\n        frame\n      } : {})\n    };\n  }\n}","map":{"version":3,"names":["isAggregateOp","vgField","duplicate","hash","unique","DataFlowNode","WindowTransformNode","clone","transform","constructor","parent","addDimensions","fields","groupby","concat","d","dependentFields","out","Set","forEach","add","sort","m","field","window","map","w","filter","f","undefined","producedFields","getDefaultName","windowFieldDef","as","assemble","ops","params","push","op","param","frame","every","o","type","sortFields","sortOrder","sortField","order","ignorePeers"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\data\\window.ts"],"sourcesContent":["import {AggregateOp, WindowTransform as VgWindowTransform} from 'vega';\nimport {isAggregateOp} from '../../aggregate';\nimport {vgField} from '../../channeldef';\nimport {SortOrder} from '../../sort';\nimport {WindowFieldDef, WindowOnlyOp, WindowTransform} from '../../transform';\nimport {duplicate, hash} from '../../util';\nimport {VgComparator, VgJoinAggregateTransform} from '../../vega.schema';\nimport {unique} from '../../util';\nimport {DataFlowNode} from './dataflow';\n\n/**\n * A class for the window transform nodes\n */\nexport class WindowTransformNode extends DataFlowNode {\n  public clone() {\n    return new WindowTransformNode(null, duplicate(this.transform));\n  }\n\n  constructor(\n    parent: DataFlowNode,\n    private readonly transform: WindowTransform\n  ) {\n    super(parent);\n  }\n\n  public addDimensions(fields: string[]) {\n    this.transform.groupby = unique(this.transform.groupby.concat(fields), d => d);\n  }\n\n  public dependentFields() {\n    const out = new Set<string>();\n\n    (this.transform.groupby ?? []).forEach(out.add, out);\n    (this.transform.sort ?? []).forEach(m => out.add(m.field));\n\n    this.transform.window\n      .map(w => w.field)\n      .filter(f => f !== undefined)\n      .forEach(out.add, out);\n\n    return out;\n  }\n\n  public producedFields() {\n    return new Set(this.transform.window.map(this.getDefaultName));\n  }\n\n  private getDefaultName(windowFieldDef: WindowFieldDef): string {\n    return windowFieldDef.as ?? vgField(windowFieldDef);\n  }\n\n  public hash() {\n    return `WindowTransform ${hash(this.transform)}`;\n  }\n\n  public assemble(): VgWindowTransform | VgJoinAggregateTransform {\n    const fields: string[] = [];\n    const ops: (AggregateOp | WindowOnlyOp)[] = [];\n    const as: string[] = [];\n    const params = [];\n\n    for (const window of this.transform.window) {\n      ops.push(window.op);\n      as.push(this.getDefaultName(window));\n      params.push(window.param === undefined ? null : window.param);\n      fields.push(window.field === undefined ? null : window.field);\n    }\n\n    const frame = this.transform.frame;\n    const groupby = this.transform.groupby;\n\n    if (frame && frame[0] === null && frame[1] === null && ops.every(o => isAggregateOp(o))) {\n      // when the window does not rely on any particular window ops or frame, switch to a simpler and more efficient joinaggregate\n      return {\n        type: 'joinaggregate',\n        as,\n        ops: ops as AggregateOp[],\n        fields,\n        ...(groupby !== undefined ? {groupby} : {})\n      } as VgJoinAggregateTransform;\n    }\n\n    const sortFields: string[] = [];\n    const sortOrder: SortOrder[] = [];\n    if (this.transform.sort !== undefined) {\n      for (const sortField of this.transform.sort) {\n        sortFields.push(sortField.field);\n        sortOrder.push(sortField.order ?? 'ascending');\n      }\n    }\n    const sort: VgComparator = {\n      field: sortFields,\n      order: sortOrder\n    };\n    const ignorePeers = this.transform.ignorePeers;\n\n    return {\n      type: 'window',\n      params,\n      as,\n      ops,\n      fields,\n      sort,\n      ...(ignorePeers !== undefined ? {ignorePeers} : {}),\n      ...(groupby !== undefined ? {groupby} : {}),\n      ...(frame !== undefined ? {frame} : {})\n    } as VgWindowTransform;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}