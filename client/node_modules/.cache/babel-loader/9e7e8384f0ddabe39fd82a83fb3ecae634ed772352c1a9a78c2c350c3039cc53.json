{"ast":null,"code":"import { hasOwnProperty, isObject, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, SHARED_DOMAIN_OPS, MULTIDOMAIN_SORT_OP_INDEX as UNIONDOMAIN_SORT_OP_INDEX } from '../../aggregate';\nimport { isBinning, isBinParams, isParameterExtent } from '../../bin';\nimport { getSecondaryRangeChannel, isScaleChannel, isXorY } from '../../channel';\nimport { binRequiresRange, getBandPosition, getFieldOrDatumDef, hasBandEnd, isDatumDef, isFieldDef, valueExpr, vgField } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport * as log from '../../log';\nimport { isPathMark, isRectBasedMark } from '../../mark';\nimport { hasDiscreteDomain, isDomainUnionWith, isParameterDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortArray, isSortByEncoding, isSortField } from '../../sort';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport * as util from '../../util';\nimport { isDataRefDomain, isDataRefUnionedDomain, isFieldRefUnionDomain, isSignalRef } from '../../vega.schema';\nimport { getMarkConfig } from '../common';\nimport { getBinSignalName } from '../data/bin';\nimport { sortArrayIndexField } from '../data/calculate';\nimport { FACET_SCALE_PREFIX } from '../data/optimize';\nimport { OFFSETTED_RECT_END_SUFFIX, OFFSETTED_RECT_START_SUFFIX } from '../data/timeunit';\nimport { getScaleDataSourceForHandlingInvalidValues } from '../invalid/datasources';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit, mergeValuesWithExplicit } from '../split';\nexport function parseScaleDomain(model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleDomain(model);\n  } else {\n    parseNonUnitScaleDomain(model);\n  }\n}\nfunction parseUnitScaleDomain(model) {\n  const localScaleComponents = model.component.scales;\n  for (const channel of util.keys(localScaleComponents)) {\n    const domains = parseDomainForChannel(model, channel);\n    const localScaleCmpt = localScaleComponents[channel];\n    localScaleCmpt.setWithExplicit('domains', domains);\n    parseSelectionDomain(model, channel);\n    if (model.component.data.isFaceted) {\n      // get resolve from closest facet parent as this decides whether we need to refer to cloned subtree or not\n      let facetParent = model;\n      while (!isFacetModel(facetParent) && facetParent.parent) {\n        facetParent = facetParent.parent;\n      }\n      const resolve = facetParent.component.resolve.scale[channel];\n      if (resolve === 'shared') {\n        for (const domain of domains.value) {\n          // Replace the scale domain with data output from a cloned subtree after the facet.\n          if (isDataRefDomain(domain)) {\n            // use data from cloned subtree (which is the same as data but with a prefix added once)\n            domain.data = FACET_SCALE_PREFIX + domain.data.replace(FACET_SCALE_PREFIX, '');\n          }\n        }\n      }\n    }\n  }\n}\nfunction parseNonUnitScaleDomain(model) {\n  for (const child of model.children) {\n    parseScaleDomain(child);\n  }\n  const localScaleComponents = model.component.scales;\n  for (const channel of util.keys(localScaleComponents)) {\n    let domains;\n    let selectionExtent = null;\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        if (domains === undefined) {\n          domains = childComponent.getWithExplicit('domains');\n        } else {\n          domains = mergeValuesWithExplicit(domains, childComponent.getWithExplicit('domains'), 'domains', 'scale', domainsTieBreaker);\n        }\n        const se = childComponent.get('selectionExtent');\n        if (selectionExtent && se && selectionExtent.param !== se.param) {\n          log.warn(log.message.NEEDS_SAME_SELECTION);\n        }\n        selectionExtent = se;\n      }\n    }\n    localScaleComponents[channel].setWithExplicit('domains', domains);\n    if (selectionExtent) {\n      localScaleComponents[channel].set('selectionExtent', selectionExtent, true);\n    }\n  }\n}\n/**\n * Remove unaggregated domain if it is not applicable\n * Add unaggregated domain if domain is not specified and config.scale.useUnaggregatedDomain is true.\n */\nfunction normalizeUnaggregatedDomain(domain, fieldDef, scaleType, scaleConfig) {\n  if (domain === 'unaggregated') {\n    const {\n      valid,\n      reason\n    } = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if (!valid) {\n      log.warn(reason);\n      return undefined;\n    }\n  } else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n    // Apply config if domain is not specified.\n    const {\n      valid\n    } = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if (valid) {\n      return 'unaggregated';\n    }\n  }\n  return domain;\n}\nexport function parseDomainForChannel(model, channel) {\n  const scaleType = model.getScaleComponent(channel).get('type');\n  const {\n    encoding\n  } = model;\n  const domain = normalizeUnaggregatedDomain(model.scaleDomain(channel), model.typedFieldDef(channel), scaleType, model.config.scale);\n  if (domain !== model.scaleDomain(channel)) {\n    model.specifiedScales[channel] = {\n      ...model.specifiedScales[channel],\n      domain\n    };\n  }\n  // If channel is either X or Y then union them with X2 & Y2 if they exist\n  if (channel === 'x' && getFieldOrDatumDef(encoding.x2)) {\n    if (getFieldOrDatumDef(encoding.x)) {\n      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'x'), parseSingleChannelDomain(scaleType, domain, model, 'x2'), 'domain', 'scale', domainsTieBreaker);\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'x2');\n    }\n  } else if (channel === 'y' && getFieldOrDatumDef(encoding.y2)) {\n    if (getFieldOrDatumDef(encoding.y)) {\n      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'y'), parseSingleChannelDomain(scaleType, domain, model, 'y2'), 'domain', 'scale', domainsTieBreaker);\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'y2');\n    }\n  }\n  return parseSingleChannelDomain(scaleType, domain, model, channel);\n}\nfunction mapDomainToDataSignal(domain, type, timeUnit) {\n  return domain.map(v => {\n    const data = valueExpr(v, {\n      timeUnit,\n      type\n    });\n    return {\n      signal: `{data: ${data}}`\n    };\n  });\n}\nfunction convertDomainIfItIsDateTime(domain, type, timeUnit) {\n  // explicit value\n  const normalizedTimeUnit = normalizeTimeUnit(timeUnit)?.unit;\n  if (type === 'temporal' || normalizedTimeUnit) {\n    return mapDomainToDataSignal(domain, type, normalizedTimeUnit);\n  }\n  return [domain]; // Date time won't make sense\n}\nfunction parseSingleChannelDomain(scaleType, domain, model, channel) {\n  const {\n    encoding,\n    markDef,\n    mark,\n    config,\n    stack\n  } = model;\n  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n  const {\n    type\n  } = fieldOrDatumDef;\n  const timeUnit = fieldOrDatumDef['timeUnit'];\n  const dataSourceTypeForScaleDomain = getScaleDataSourceForHandlingInvalidValues({\n    invalid: getMarkConfig('invalid', markDef, config),\n    isPath: isPathMark(mark)\n  });\n  if (isDomainUnionWith(domain)) {\n    const defaultDomain = parseSingleChannelDomain(scaleType, undefined, model, channel);\n    const unionWith = convertDomainIfItIsDateTime(domain.unionWith, type, timeUnit);\n    return makeExplicit([...unionWith, ...defaultDomain.value]);\n  } else if (isSignalRef(domain)) {\n    return makeExplicit([domain]);\n  } else if (domain && domain !== 'unaggregated' && !isParameterDomain(domain)) {\n    return makeExplicit(convertDomainIfItIsDateTime(domain, type, timeUnit));\n  }\n  if (stack && channel === stack.fieldChannel) {\n    if (stack.offset === 'normalize') {\n      return makeImplicit([[0, 1]]);\n    }\n    const data = model.requestDataName(dataSourceTypeForScaleDomain);\n    return makeImplicit([{\n      data,\n      field: model.vgField(channel, {\n        suffix: 'start'\n      })\n    }, {\n      data,\n      field: model.vgField(channel, {\n        suffix: 'end'\n      })\n    }]);\n  }\n  const sort = isScaleChannel(channel) && isFieldDef(fieldOrDatumDef) ? domainSort(model, channel, scaleType) : undefined;\n  if (isDatumDef(fieldOrDatumDef)) {\n    const d = convertDomainIfItIsDateTime([fieldOrDatumDef.datum], type, timeUnit);\n    return makeImplicit(d);\n  }\n  const fieldDef = fieldOrDatumDef; // now we can be sure it's a fieldDef\n  if (domain === 'unaggregated') {\n    const {\n      field\n    } = fieldOrDatumDef;\n    return makeImplicit([{\n      data: model.requestDataName(dataSourceTypeForScaleDomain),\n      field: vgField({\n        field,\n        aggregate: 'min'\n      })\n    }, {\n      data: model.requestDataName(dataSourceTypeForScaleDomain),\n      field: vgField({\n        field,\n        aggregate: 'max'\n      })\n    }]);\n  } else if (isBinning(fieldDef.bin)) {\n    if (hasDiscreteDomain(scaleType)) {\n      if (scaleType === 'bin-ordinal') {\n        // we can omit the domain as it is inferred from the `bins` property\n        return makeImplicit([]);\n      }\n      // ordinal bin scale takes domain from bin_range, ordered by bin start\n      // This is useful for both axis-based scale (x/y) and legend-based scale (other channels).\n      return makeImplicit([{\n        // If sort by aggregation of a specified sort field, we need to use RAW table,\n        // so we can aggregate values for the scale independently from the main aggregation.\n        data: util.isBoolean(sort) ? model.requestDataName(dataSourceTypeForScaleDomain) : model.requestDataName(DataSourceType.Raw),\n        // Use range if we added it and the scale does not support computing a range as a signal.\n        field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? {\n          binSuffix: 'range'\n        } : {}),\n        // we have to use a sort object if sort = true to make the sort correct by bin start\n        sort: sort === true || !isObject(sort) ? {\n          field: model.vgField(channel, {}),\n          op: 'min' // min or max doesn't matter since we sort by the start of the bin range\n        } : sort\n      }]);\n    } else {\n      // continuous scales\n      const {\n        bin\n      } = fieldDef;\n      if (isBinning(bin)) {\n        const binSignal = getBinSignalName(model, fieldDef.field, bin);\n        return makeImplicit([new SignalRefWrapper(() => {\n          const signal = model.getSignalName(binSignal);\n          return `[${signal}.start, ${signal}.stop]`;\n        })]);\n      } else {\n        return makeImplicit([{\n          data: model.requestDataName(dataSourceTypeForScaleDomain),\n          field: model.vgField(channel, {})\n        }]);\n      }\n    }\n  } else if (fieldDef.timeUnit && util.contains(['time', 'utc'], scaleType)) {\n    const fieldDef2 = encoding[getSecondaryRangeChannel(channel)];\n    if (hasBandEnd(fieldDef, fieldDef2, markDef, config)) {\n      const data = model.requestDataName(dataSourceTypeForScaleDomain);\n      const bandPosition = getBandPosition({\n        fieldDef,\n        fieldDef2,\n        markDef,\n        config\n      });\n      const isRectWithOffset = isRectBasedMark(mark) && bandPosition !== 0.5 && isXorY(channel);\n      return makeImplicit([{\n        data,\n        field: model.vgField(channel, isRectWithOffset ? {\n          suffix: OFFSETTED_RECT_START_SUFFIX\n        } : {})\n      }, {\n        data,\n        field: model.vgField(channel, {\n          suffix: isRectWithOffset ? OFFSETTED_RECT_END_SUFFIX : 'end'\n        })\n      }]);\n    }\n  }\n  if (sort) {\n    return makeImplicit([{\n      // If sort by aggregation of a specified sort field, we need to use RAW table,\n      // so we can aggregate values for the scale independently from the main aggregation.\n      data: util.isBoolean(sort) ? model.requestDataName(dataSourceTypeForScaleDomain) : model.requestDataName(DataSourceType.Raw),\n      field: model.vgField(channel),\n      sort\n    }]);\n  } else {\n    return makeImplicit([{\n      data: model.requestDataName(dataSourceTypeForScaleDomain),\n      field: model.vgField(channel)\n    }]);\n  }\n}\nfunction normalizeSortField(sort, isStackedMeasure) {\n  const {\n    op,\n    field,\n    order\n  } = sort;\n  return {\n    // Apply default op\n    op: op ?? (isStackedMeasure ? 'sum' : DEFAULT_SORT_OP),\n    // flatten nested fields\n    ...(field ? {\n      field: util.replacePathInField(field)\n    } : {}),\n    ...(order ? {\n      order\n    } : {})\n  };\n}\nfunction parseSelectionDomain(model, channel) {\n  const scale = model.component.scales[channel];\n  const spec = model.specifiedScales[channel].domain;\n  const bin = model.fieldDef(channel)?.bin;\n  const domain = isParameterDomain(spec) ? spec : undefined;\n  const extent = isBinParams(bin) && isParameterExtent(bin.extent) ? bin.extent : undefined;\n  if (domain || extent) {\n    // As scale parsing occurs before selection parsing, we cannot set\n    // domainRaw directly. So instead, we store the selectionExtent on\n    // the scale component, and then add domainRaw during scale assembly.\n    scale.set('selectionExtent', domain ?? extent, true);\n  }\n}\nexport function domainSort(model, channel, scaleType) {\n  if (!hasDiscreteDomain(scaleType)) {\n    return undefined;\n  }\n  // save to cast as the only exception is the geojson type for shape, which would not generate a scale\n  const fieldDef = model.fieldDef(channel);\n  const sort = fieldDef.sort;\n  // if the sort is specified with array, use the derived sort index field\n  if (isSortArray(sort)) {\n    return {\n      op: 'min',\n      field: sortArrayIndexField(fieldDef, channel),\n      order: 'ascending'\n    };\n  }\n  const {\n    stack\n  } = model;\n  const stackDimensions = stack ? new Set([...stack.groupbyFields, ...stack.stackBy.map(s => s.fieldDef.field)]) : undefined;\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n  if (isSortField(sort)) {\n    const isStackedMeasure = stack && !stackDimensions.has(sort.field);\n    return normalizeSortField(sort, isStackedMeasure);\n  } else if (isSortByEncoding(sort)) {\n    const {\n      encoding,\n      order\n    } = sort;\n    const fieldDefToSortBy = model.fieldDef(encoding);\n    const {\n      aggregate,\n      field\n    } = fieldDefToSortBy;\n    const isStackedMeasure = stack && !stackDimensions.has(field);\n    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n      return normalizeSortField({\n        field: vgField(fieldDefToSortBy),\n        order\n      }, isStackedMeasure);\n    } else if (isAggregateOp(aggregate) || !aggregate) {\n      return normalizeSortField({\n        op: aggregate,\n        // can't be argmin/argmax since we don't support them in encoding field def\n        field,\n        order\n      }, isStackedMeasure);\n    }\n  } else if (sort === 'descending') {\n    return {\n      op: 'min',\n      field: model.vgField(channel),\n      order: 'descending'\n    };\n  } else if (util.contains(['ascending', undefined /* default =ascending*/], sort)) {\n    return true;\n  }\n  // sort == null\n  return undefined;\n}\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditions apply:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nexport function canUseUnaggregatedDomain(fieldDef, scaleType) {\n  const {\n    aggregate,\n    type\n  } = fieldDef;\n  if (!aggregate) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n    };\n  }\n  if (isString(aggregate) && !SHARED_DOMAIN_OPS.has(aggregate)) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainWithNonSharedDomainOp(aggregate)\n    };\n  }\n  if (type === 'quantitative') {\n    if (scaleType === 'log') {\n      return {\n        valid: false,\n        reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n      };\n    }\n  }\n  return {\n    valid: true\n  };\n}\n/**\n * Tie breaker for mergeValuesWithExplicit for domains. We concat the specified values.\n */\nfunction domainsTieBreaker(v1, v2, property, propertyOf) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingDomainProperty(property, propertyOf, v1.value, v2.value));\n  }\n  // If equal score, concat the domains so that we union them later.\n  return {\n    explicit: v1.explicit,\n    value: [...v1.value, ...v2.value]\n  };\n}\n/**\n * Converts an array of domains to a single Vega scale domain.\n */\nexport function mergeDomains(domains) {\n  const uniqueDomains = util.unique(domains.map(domain => {\n    // ignore sort property when computing the unique domains\n    if (isDataRefDomain(domain)) {\n      const {\n        sort: _s,\n        ...domainWithoutSort\n      } = domain;\n      return domainWithoutSort;\n    }\n    return domain;\n  }), util.hash);\n  const sorts = util.unique(domains.map(d => {\n    if (isDataRefDomain(d)) {\n      const s = d.sort;\n      if (s !== undefined && !util.isBoolean(s)) {\n        if ('op' in s && s.op === 'count') {\n          // let's make sure that if op is count, we don't use a field\n          delete s.field;\n        }\n        if (s.order === 'ascending') {\n          // drop order: ascending as it is the default\n          delete s.order;\n        }\n      }\n      return s;\n    }\n    return undefined;\n  }).filter(s => s !== undefined), util.hash);\n  if (uniqueDomains.length === 0) {\n    return undefined;\n  } else if (uniqueDomains.length === 1) {\n    const domain = domains[0];\n    if (isDataRefDomain(domain) && sorts.length > 0) {\n      let sort = sorts[0];\n      if (sorts.length > 1) {\n        log.warn(log.message.MORE_THAN_ONE_SORT);\n        // Get sorts with non-default ops\n        const filteredSorts = sorts.filter(s => isObject(s) && 'op' in s && s.op !== 'min');\n        if (sorts.every(s => isObject(s) && 'op' in s) && filteredSorts.length === 1) {\n          sort = filteredSorts[0];\n        } else {\n          sort = true;\n        }\n      } else {\n        // Simplify domain sort by removing field and op when the field is the same as the domain field.\n        if (isObject(sort) && 'field' in sort) {\n          const sortField = sort.field;\n          if (domain.field === sortField) {\n            sort = sort.order ? {\n              order: sort.order\n            } : true;\n          }\n        }\n      }\n      return {\n        ...domain,\n        sort\n      };\n    }\n    return domain;\n  }\n  // only keep sort properties that work with unioned domains\n  const unionDomainSorts = util.unique(sorts.map(s => {\n    if (util.isBoolean(s) || !('op' in s) || isString(s.op) && hasOwnProperty(UNIONDOMAIN_SORT_OP_INDEX, s.op)) {\n      return s;\n    }\n    log.warn(log.message.domainSortDropped(s));\n    return true;\n  }), util.hash);\n  let sort;\n  if (unionDomainSorts.length === 1) {\n    sort = unionDomainSorts[0];\n  } else if (unionDomainSorts.length > 1) {\n    log.warn(log.message.MORE_THAN_ONE_SORT);\n    sort = true;\n  }\n  const allData = util.unique(domains.map(d => {\n    if (isDataRefDomain(d)) {\n      return d.data;\n    }\n    return null;\n  }), x => x);\n  if (allData.length === 1 && allData[0] !== null) {\n    // create a union domain of different fields with a single data source\n    const domain = {\n      data: allData[0],\n      fields: uniqueDomains.map(d => d.field),\n      ...(sort ? {\n        sort\n      } : {})\n    };\n    return domain;\n  }\n  return {\n    fields: uniqueDomains,\n    ...(sort ? {\n      sort\n    } : {})\n  };\n}\n/**\n * Return a field if a scale uses a single field.\n * Return `undefined` otherwise.\n */\nexport function getFieldFromDomain(domain) {\n  if (isDataRefDomain(domain) && isString(domain.field)) {\n    return domain.field;\n  } else if (isDataRefUnionedDomain(domain)) {\n    let field;\n    for (const nonUnionDomain of domain.fields) {\n      if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {\n        if (!field) {\n          field = nonUnionDomain.field;\n        } else if (field !== nonUnionDomain.field) {\n          log.warn(log.message.FACETED_INDEPENDENT_DIFFERENT_SOURCES);\n          return field;\n        }\n      }\n    }\n    log.warn(log.message.FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES);\n    return field;\n  } else if (isFieldRefUnionDomain(domain)) {\n    log.warn(log.message.FACETED_INDEPENDENT_SAME_SOURCE);\n    const field = domain.fields[0];\n    return isString(field) ? field : undefined;\n  }\n  return undefined;\n}\nexport function assembleDomain(model, channel) {\n  const scaleComponent = model.component.scales[channel];\n  const domains = scaleComponent.get('domains').map(domain => {\n    // Correct references to data as the original domain's data was determined\n    // in parseScale, which happens before parseData. Thus the original data\n    // reference can be incorrect.\n    if (isDataRefDomain(domain)) {\n      domain.data = model.lookupDataSource(domain.data);\n    }\n    return domain;\n  });\n  // domains is an array that has to be merged into a single vega domain\n  return mergeDomains(domains);\n}","map":{"version":3,"names":["hasOwnProperty","isObject","isString","isAggregateOp","isArgmaxDef","isArgminDef","SHARED_DOMAIN_OPS","MULTIDOMAIN_SORT_OP_INDEX","UNIONDOMAIN_SORT_OP_INDEX","isBinning","isBinParams","isParameterExtent","getSecondaryRangeChannel","isScaleChannel","isXorY","binRequiresRange","getBandPosition","getFieldOrDatumDef","hasBandEnd","isDatumDef","isFieldDef","valueExpr","vgField","DataSourceType","log","isPathMark","isRectBasedMark","hasDiscreteDomain","isDomainUnionWith","isParameterDomain","DEFAULT_SORT_OP","isSortArray","isSortByEncoding","isSortField","normalizeTimeUnit","util","isDataRefDomain","isDataRefUnionedDomain","isFieldRefUnionDomain","isSignalRef","getMarkConfig","getBinSignalName","sortArrayIndexField","FACET_SCALE_PREFIX","OFFSETTED_RECT_END_SUFFIX","OFFSETTED_RECT_START_SUFFIX","getScaleDataSourceForHandlingInvalidValues","isFacetModel","isUnitModel","SignalRefWrapper","makeExplicit","makeImplicit","mergeValuesWithExplicit","parseScaleDomain","model","parseUnitScaleDomain","parseNonUnitScaleDomain","localScaleComponents","component","scales","channel","keys","domains","parseDomainForChannel","localScaleCmpt","setWithExplicit","parseSelectionDomain","data","isFaceted","facetParent","parent","resolve","scale","domain","value","replace","child","children","selectionExtent","childComponent","undefined","getWithExplicit","domainsTieBreaker","se","get","param","warn","message","NEEDS_SAME_SELECTION","set","normalizeUnaggregatedDomain","fieldDef","scaleType","scaleConfig","valid","reason","canUseUnaggregatedDomain","useUnaggregatedDomain","getScaleComponent","encoding","scaleDomain","typedFieldDef","config","specifiedScales","x2","x","parseSingleChannelDomain","y2","y","mapDomainToDataSignal","type","timeUnit","map","v","signal","convertDomainIfItIsDateTime","normalizedTimeUnit","unit","markDef","mark","stack","fieldOrDatumDef","dataSourceTypeForScaleDomain","invalid","isPath","defaultDomain","unionWith","fieldChannel","offset","requestDataName","field","suffix","sort","domainSort","d","datum","aggregate","bin","isBoolean","Raw","binSuffix","op","binSignal","getSignalName","contains","fieldDef2","bandPosition","isRectWithOffset","normalizeSortField","isStackedMeasure","order","replacePathInField","spec","extent","stackDimensions","Set","groupbyFields","stackBy","s","has","fieldDefToSortBy","unaggregateDomainHasNoEffectForRawField","unaggregateDomainWithNonSharedDomainOp","unaggregatedDomainWithLogScale","v1","v2","property","propertyOf","explicit","mergeConflictingDomainProperty","mergeDomains","uniqueDomains","unique","_s","domainWithoutSort","hash","sorts","filter","length","MORE_THAN_ONE_SORT","filteredSorts","every","sortField","unionDomainSorts","domainSortDropped","allData","fields","getFieldFromDomain","nonUnionDomain","FACETED_INDEPENDENT_DIFFERENT_SOURCES","FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES","FACETED_INDEPENDENT_SAME_SOURCE","assembleDomain","scaleComponent","lookupDataSource"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\scale\\domain.ts"],"sourcesContent":["import type {SignalRef} from 'vega';\nimport {hasOwnProperty, isObject, isString} from 'vega-util';\nimport {\n  Aggregate,\n  isAggregateOp,\n  isArgmaxDef,\n  isArgminDef,\n  NonArgAggregateOp,\n  SHARED_DOMAIN_OPS,\n  MULTIDOMAIN_SORT_OP_INDEX as UNIONDOMAIN_SORT_OP_INDEX\n} from '../../aggregate';\nimport {isBinning, isBinParams, isParameterExtent} from '../../bin';\nimport {getSecondaryRangeChannel, isScaleChannel, isXorY, ScaleChannel} from '../../channel';\nimport {\n  binRequiresRange,\n  getBandPosition,\n  getFieldOrDatumDef,\n  hasBandEnd,\n  isDatumDef,\n  isFieldDef,\n  ScaleDatumDef,\n  ScaleFieldDef,\n  TypedFieldDef,\n  valueExpr,\n  vgField\n} from '../../channeldef';\nimport {CompositeAggregate} from '../../compositemark';\nimport {DataSourceType} from '../../data';\nimport {DateTime} from '../../datetime';\nimport {ExprRef} from '../../expr';\nimport * as log from '../../log';\nimport {isPathMark, isRectBasedMark} from '../../mark';\nimport {Domain, hasDiscreteDomain, isDomainUnionWith, isParameterDomain, ScaleConfig, ScaleType} from '../../scale';\nimport {ParameterExtent} from '../../selection';\nimport {DEFAULT_SORT_OP, EncodingSortField, isSortArray, isSortByEncoding, isSortField} from '../../sort';\nimport {normalizeTimeUnit, TimeUnit, TimeUnitTransformParams} from '../../timeunit';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {\n  isDataRefDomain,\n  isDataRefUnionedDomain,\n  isFieldRefUnionDomain,\n  isSignalRef,\n  VgDomain,\n  VgMultiFieldsRefWithSort,\n  VgNonUnionDomain,\n  VgScaleDataRefWithSort,\n  VgSortField,\n  VgUnionSortField\n} from '../../vega.schema';\nimport {getMarkConfig} from '../common';\nimport {getBinSignalName} from '../data/bin';\nimport {sortArrayIndexField} from '../data/calculate';\nimport {FACET_SCALE_PREFIX} from '../data/optimize';\nimport {OFFSETTED_RECT_END_SUFFIX, OFFSETTED_RECT_START_SUFFIX} from '../data/timeunit';\nimport {getScaleDataSourceForHandlingInvalidValues} from '../invalid/datasources';\nimport {isFacetModel, isUnitModel, Model} from '../model';\nimport {SignalRefWrapper} from '../signal';\nimport {Explicit, makeExplicit, makeImplicit, mergeValuesWithExplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponent, ScaleComponentIndex} from './component';\n\nexport function parseScaleDomain(model: Model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleDomain(model);\n  } else {\n    parseNonUnitScaleDomain(model);\n  }\n}\n\nfunction parseUnitScaleDomain(model: UnitModel) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  for (const channel of util.keys(localScaleComponents)) {\n    const domains = parseDomainForChannel(model, channel);\n    const localScaleCmpt = localScaleComponents[channel];\n    localScaleCmpt.setWithExplicit('domains', domains);\n    parseSelectionDomain(model, channel);\n\n    if (model.component.data.isFaceted) {\n      // get resolve from closest facet parent as this decides whether we need to refer to cloned subtree or not\n      let facetParent: Model = model;\n      while (!isFacetModel(facetParent) && facetParent.parent) {\n        facetParent = facetParent.parent;\n      }\n\n      const resolve = facetParent.component.resolve.scale[channel];\n\n      if (resolve === 'shared') {\n        for (const domain of domains.value) {\n          // Replace the scale domain with data output from a cloned subtree after the facet.\n          if (isDataRefDomain(domain)) {\n            // use data from cloned subtree (which is the same as data but with a prefix added once)\n            domain.data = FACET_SCALE_PREFIX + domain.data.replace(FACET_SCALE_PREFIX, '');\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction parseNonUnitScaleDomain(model: Model) {\n  for (const child of model.children) {\n    parseScaleDomain(child);\n  }\n\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  for (const channel of util.keys(localScaleComponents)) {\n    let domains: Explicit<VgNonUnionDomain[]>;\n    let selectionExtent: ParameterExtent = null;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        if (domains === undefined) {\n          domains = childComponent.getWithExplicit('domains');\n        } else {\n          domains = mergeValuesWithExplicit(\n            domains,\n            childComponent.getWithExplicit('domains'),\n            'domains',\n            'scale',\n            domainsTieBreaker\n          );\n        }\n\n        const se = childComponent.get('selectionExtent');\n        if (selectionExtent && se && selectionExtent.param !== se.param) {\n          log.warn(log.message.NEEDS_SAME_SELECTION);\n        }\n        selectionExtent = se;\n      }\n    }\n\n    localScaleComponents[channel].setWithExplicit('domains', domains);\n\n    if (selectionExtent) {\n      localScaleComponents[channel].set('selectionExtent', selectionExtent, true);\n    }\n  }\n}\n\n/**\n * Remove unaggregated domain if it is not applicable\n * Add unaggregated domain if domain is not specified and config.scale.useUnaggregatedDomain is true.\n */\nfunction normalizeUnaggregatedDomain(\n  domain: Domain,\n  fieldDef: TypedFieldDef<string>,\n  scaleType: ScaleType,\n  scaleConfig: ScaleConfig<SignalRef>\n) {\n  if (domain === 'unaggregated') {\n    const {valid, reason} = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if (!valid) {\n      log.warn(reason);\n      return undefined;\n    }\n  } else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n    // Apply config if domain is not specified.\n    const {valid} = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if (valid) {\n      return 'unaggregated';\n    }\n  }\n\n  return domain;\n}\n\nexport function parseDomainForChannel(model: UnitModel, channel: ScaleChannel): Explicit<VgNonUnionDomain[]> {\n  const scaleType = model.getScaleComponent(channel).get('type');\n  const {encoding} = model;\n\n  const domain = normalizeUnaggregatedDomain(\n    model.scaleDomain(channel),\n    model.typedFieldDef(channel),\n    scaleType,\n    model.config.scale\n  );\n  if (domain !== model.scaleDomain(channel)) {\n    model.specifiedScales[channel] = {\n      ...model.specifiedScales[channel],\n      domain\n    };\n  }\n\n  // If channel is either X or Y then union them with X2 & Y2 if they exist\n  if (channel === 'x' && getFieldOrDatumDef(encoding.x2)) {\n    if (getFieldOrDatumDef(encoding.x)) {\n      return mergeValuesWithExplicit(\n        parseSingleChannelDomain(scaleType, domain, model, 'x'),\n        parseSingleChannelDomain(scaleType, domain, model, 'x2'),\n        'domain',\n        'scale',\n        domainsTieBreaker\n      );\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'x2');\n    }\n  } else if (channel === 'y' && getFieldOrDatumDef(encoding.y2)) {\n    if (getFieldOrDatumDef(encoding.y)) {\n      return mergeValuesWithExplicit(\n        parseSingleChannelDomain(scaleType, domain, model, 'y'),\n        parseSingleChannelDomain(scaleType, domain, model, 'y2'),\n        'domain',\n        'scale',\n        domainsTieBreaker\n      );\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'y2');\n    }\n  }\n  return parseSingleChannelDomain(scaleType, domain, model, channel);\n}\n\nfunction mapDomainToDataSignal(\n  domain: (number | string | boolean | DateTime | ExprRef | SignalRef | number[])[],\n  type: Type,\n  timeUnit: TimeUnit\n) {\n  return domain.map(v => {\n    const data = valueExpr(v, {timeUnit, type});\n    return {signal: `{data: ${data}}`};\n  });\n}\n\nfunction convertDomainIfItIsDateTime(\n  domain: (number | string | boolean | DateTime | ExprRef | SignalRef | number[])[],\n  type: Type,\n  timeUnit: TimeUnit | TimeUnitTransformParams\n): [number[]] | [string[]] | [boolean[]] | SignalRef[] {\n  // explicit value\n  const normalizedTimeUnit = normalizeTimeUnit(timeUnit)?.unit;\n  if (type === 'temporal' || normalizedTimeUnit) {\n    return mapDomainToDataSignal(domain, type, normalizedTimeUnit);\n  }\n\n  return [domain] as [number[]] | [string[]] | [boolean[]]; // Date time won't make sense\n}\n\nfunction parseSingleChannelDomain(\n  scaleType: ScaleType,\n  domain: Domain,\n  model: UnitModel,\n  channel: ScaleChannel | 'x2' | 'y2'\n): Explicit<VgNonUnionDomain[]> {\n  const {encoding, markDef, mark, config, stack} = model;\n  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) as ScaleDatumDef<string> | ScaleFieldDef<string>;\n\n  const {type} = fieldOrDatumDef;\n  const timeUnit = (fieldOrDatumDef as any)['timeUnit'];\n\n  const dataSourceTypeForScaleDomain = getScaleDataSourceForHandlingInvalidValues({\n    invalid: getMarkConfig('invalid', markDef, config),\n    isPath: isPathMark(mark)\n  });\n\n  if (isDomainUnionWith(domain)) {\n    const defaultDomain = parseSingleChannelDomain(scaleType, undefined, model, channel);\n\n    const unionWith = convertDomainIfItIsDateTime(domain.unionWith, type, timeUnit);\n\n    return makeExplicit([...unionWith, ...defaultDomain.value]);\n  } else if (isSignalRef(domain)) {\n    return makeExplicit([domain]);\n  } else if (domain && domain !== 'unaggregated' && !isParameterDomain(domain)) {\n    return makeExplicit(convertDomainIfItIsDateTime(domain, type, timeUnit));\n  }\n\n  if (stack && channel === stack.fieldChannel) {\n    if (stack.offset === 'normalize') {\n      return makeImplicit([[0, 1]]);\n    }\n\n    const data = model.requestDataName(dataSourceTypeForScaleDomain);\n    return makeImplicit([\n      {\n        data,\n        field: model.vgField(channel, {suffix: 'start'})\n      },\n      {\n        data,\n        field: model.vgField(channel, {suffix: 'end'})\n      }\n    ]);\n  }\n\n  const sort: undefined | true | VgSortField =\n    isScaleChannel(channel) && isFieldDef(fieldOrDatumDef) ? domainSort(model, channel, scaleType) : undefined;\n\n  if (isDatumDef(fieldOrDatumDef)) {\n    const d = convertDomainIfItIsDateTime([fieldOrDatumDef.datum], type, timeUnit);\n    return makeImplicit(d);\n  }\n\n  const fieldDef = fieldOrDatumDef; // now we can be sure it's a fieldDef\n  if (domain === 'unaggregated') {\n    const {field} = fieldOrDatumDef;\n    return makeImplicit([\n      {\n        data: model.requestDataName(dataSourceTypeForScaleDomain),\n        field: vgField({field, aggregate: 'min'})\n      },\n      {\n        data: model.requestDataName(dataSourceTypeForScaleDomain),\n        field: vgField({field, aggregate: 'max'})\n      }\n    ]);\n  } else if (isBinning(fieldDef.bin)) {\n    if (hasDiscreteDomain(scaleType)) {\n      if (scaleType === 'bin-ordinal') {\n        // we can omit the domain as it is inferred from the `bins` property\n        return makeImplicit([]);\n      }\n\n      // ordinal bin scale takes domain from bin_range, ordered by bin start\n      // This is useful for both axis-based scale (x/y) and legend-based scale (other channels).\n      return makeImplicit([\n        {\n          // If sort by aggregation of a specified sort field, we need to use RAW table,\n          // so we can aggregate values for the scale independently from the main aggregation.\n          data: util.isBoolean(sort)\n            ? model.requestDataName(dataSourceTypeForScaleDomain)\n            : model.requestDataName(DataSourceType.Raw),\n          // Use range if we added it and the scale does not support computing a range as a signal.\n          field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? {binSuffix: 'range'} : {}),\n          // we have to use a sort object if sort = true to make the sort correct by bin start\n          sort:\n            sort === true || !isObject(sort)\n              ? {\n                  field: model.vgField(channel, {}),\n                  op: 'min' // min or max doesn't matter since we sort by the start of the bin range\n                }\n              : sort\n        }\n      ]);\n    } else {\n      // continuous scales\n      const {bin} = fieldDef;\n      if (isBinning(bin)) {\n        const binSignal = getBinSignalName(model, fieldDef.field, bin);\n        return makeImplicit([\n          new SignalRefWrapper(() => {\n            const signal = model.getSignalName(binSignal);\n            return `[${signal}.start, ${signal}.stop]`;\n          })\n        ]);\n      } else {\n        return makeImplicit([\n          {\n            data: model.requestDataName(dataSourceTypeForScaleDomain),\n            field: model.vgField(channel, {})\n          }\n        ]);\n      }\n    }\n  } else if (fieldDef.timeUnit && util.contains(['time', 'utc'], scaleType)) {\n    const fieldDef2 = encoding[getSecondaryRangeChannel(channel)];\n\n    if (hasBandEnd(fieldDef, fieldDef2, markDef, config)) {\n      const data = model.requestDataName(dataSourceTypeForScaleDomain);\n\n      const bandPosition = getBandPosition({fieldDef, fieldDef2, markDef, config});\n      const isRectWithOffset = isRectBasedMark(mark) && bandPosition !== 0.5 && isXorY(channel);\n      return makeImplicit([\n        {\n          data,\n          field: model.vgField(channel, isRectWithOffset ? {suffix: OFFSETTED_RECT_START_SUFFIX} : {})\n        },\n        {\n          data,\n          field: model.vgField(channel, {suffix: isRectWithOffset ? OFFSETTED_RECT_END_SUFFIX : 'end'})\n        }\n      ]);\n    }\n  }\n  if (sort) {\n    return makeImplicit([\n      {\n        // If sort by aggregation of a specified sort field, we need to use RAW table,\n        // so we can aggregate values for the scale independently from the main aggregation.\n        data: util.isBoolean(sort)\n          ? model.requestDataName(dataSourceTypeForScaleDomain)\n          : model.requestDataName(DataSourceType.Raw),\n        field: model.vgField(channel),\n        sort\n      }\n    ]);\n  } else {\n    return makeImplicit([\n      {\n        data: model.requestDataName(dataSourceTypeForScaleDomain),\n        field: model.vgField(channel)\n      }\n    ]);\n  }\n}\n\nfunction normalizeSortField(sort: EncodingSortField<string>, isStackedMeasure: boolean): VgSortField {\n  const {op, field, order} = sort;\n  return {\n    // Apply default op\n    op: op ?? (isStackedMeasure ? 'sum' : DEFAULT_SORT_OP),\n    // flatten nested fields\n    ...(field ? {field: util.replacePathInField(field)} : {}),\n\n    ...(order ? {order} : {})\n  };\n}\n\nfunction parseSelectionDomain(model: UnitModel, channel: ScaleChannel) {\n  const scale = model.component.scales[channel];\n  const spec = model.specifiedScales[channel].domain;\n  const bin = model.fieldDef(channel)?.bin;\n  const domain = isParameterDomain(spec) ? spec : undefined;\n  const extent = isBinParams(bin) && isParameterExtent(bin.extent) ? bin.extent : undefined;\n\n  if (domain || extent) {\n    // As scale parsing occurs before selection parsing, we cannot set\n    // domainRaw directly. So instead, we store the selectionExtent on\n    // the scale component, and then add domainRaw during scale assembly.\n    scale.set('selectionExtent', domain ?? extent, true);\n  }\n}\n\nexport function domainSort(\n  model: UnitModel,\n  channel: ScaleChannel,\n  scaleType: ScaleType\n): undefined | true | VgSortField {\n  if (!hasDiscreteDomain(scaleType)) {\n    return undefined;\n  }\n\n  // save to cast as the only exception is the geojson type for shape, which would not generate a scale\n  const fieldDef = model.fieldDef(channel) as ScaleFieldDef<string>;\n  const sort = fieldDef.sort;\n\n  // if the sort is specified with array, use the derived sort index field\n  if (isSortArray(sort)) {\n    return {\n      op: 'min',\n      field: sortArrayIndexField(fieldDef, channel),\n      order: 'ascending'\n    };\n  }\n\n  const {stack} = model;\n  const stackDimensions = stack\n    ? new Set([...stack.groupbyFields, ...stack.stackBy.map(s => s.fieldDef.field)])\n    : undefined;\n\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n  if (isSortField(sort)) {\n    const isStackedMeasure = stack && !stackDimensions.has(sort.field);\n    return normalizeSortField(sort, isStackedMeasure);\n  } else if (isSortByEncoding(sort)) {\n    const {encoding, order} = sort;\n    const fieldDefToSortBy = model.fieldDef(encoding);\n    const {aggregate, field} = fieldDefToSortBy;\n\n    const isStackedMeasure = stack && !stackDimensions.has(field);\n\n    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n      return normalizeSortField(\n        {\n          field: vgField(fieldDefToSortBy),\n          order\n        },\n        isStackedMeasure\n      );\n    } else if (isAggregateOp(aggregate) || !aggregate) {\n      return normalizeSortField(\n        {\n          op: aggregate as NonArgAggregateOp, // can't be argmin/argmax since we don't support them in encoding field def\n          field,\n          order\n        },\n        isStackedMeasure\n      );\n    }\n  } else if (sort === 'descending') {\n    return {\n      op: 'min',\n      field: model.vgField(channel),\n      order: 'descending'\n    };\n  } else if (util.contains(['ascending', undefined /* default =ascending*/], sort)) {\n    return true;\n  }\n\n  // sort == null\n  return undefined;\n}\n\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditions apply:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nexport function canUseUnaggregatedDomain(\n  fieldDef: TypedFieldDef<string>,\n  scaleType: ScaleType\n): {valid: boolean; reason?: string} {\n  const {aggregate, type} = fieldDef;\n\n  if (!aggregate) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n    };\n  }\n\n  if (isString(aggregate) && !(SHARED_DOMAIN_OPS as Set<Aggregate | CompositeAggregate>).has(aggregate)) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainWithNonSharedDomainOp(aggregate)\n    };\n  }\n\n  if (type === 'quantitative') {\n    if (scaleType === 'log') {\n      return {\n        valid: false,\n        reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n      };\n    }\n  }\n\n  return {valid: true};\n}\n\n/**\n * Tie breaker for mergeValuesWithExplicit for domains. We concat the specified values.\n */\nfunction domainsTieBreaker(\n  v1: Explicit<VgNonUnionDomain[]>,\n  v2: Explicit<VgNonUnionDomain[]>,\n  property: 'domains',\n  propertyOf: 'scale'\n) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingDomainProperty(property, propertyOf, v1.value, v2.value));\n  }\n  // If equal score, concat the domains so that we union them later.\n  return {explicit: v1.explicit, value: [...v1.value, ...v2.value]};\n}\n\n/**\n * Converts an array of domains to a single Vega scale domain.\n */\nexport function mergeDomains(domains: VgNonUnionDomain[]): VgDomain {\n  const uniqueDomains = util.unique(\n    domains.map(domain => {\n      // ignore sort property when computing the unique domains\n      if (isDataRefDomain(domain)) {\n        const {sort: _s, ...domainWithoutSort} = domain;\n        return domainWithoutSort;\n      }\n      return domain;\n    }),\n    util.hash\n  );\n\n  const sorts: VgSortField[] = util.unique(\n    domains\n      .map(d => {\n        if (isDataRefDomain(d)) {\n          const s = d.sort;\n          if (s !== undefined && !util.isBoolean(s)) {\n            if ('op' in s && s.op === 'count') {\n              // let's make sure that if op is count, we don't use a field\n              delete s.field;\n            }\n            if (s.order === 'ascending') {\n              // drop order: ascending as it is the default\n              delete s.order;\n            }\n          }\n          return s;\n        }\n        return undefined;\n      })\n      .filter(s => s !== undefined),\n    util.hash\n  );\n\n  if (uniqueDomains.length === 0) {\n    return undefined;\n  } else if (uniqueDomains.length === 1) {\n    const domain = domains[0];\n    if (isDataRefDomain(domain) && sorts.length > 0) {\n      let sort = sorts[0];\n      if (sorts.length > 1) {\n        log.warn(log.message.MORE_THAN_ONE_SORT);\n        // Get sorts with non-default ops\n        const filteredSorts = sorts.filter(s => isObject(s) && 'op' in s && s.op !== 'min');\n        if (sorts.every(s => isObject(s) && 'op' in s) && filteredSorts.length === 1) {\n          sort = filteredSorts[0];\n        } else {\n          sort = true;\n        }\n      } else {\n        // Simplify domain sort by removing field and op when the field is the same as the domain field.\n        if (isObject(sort) && 'field' in sort) {\n          const sortField = sort.field;\n          if (domain.field === sortField) {\n            sort = sort.order ? {order: sort.order} : true;\n          }\n        }\n      }\n      return {\n        ...domain,\n        sort\n      };\n    }\n    return domain;\n  }\n\n  // only keep sort properties that work with unioned domains\n  const unionDomainSorts = util.unique<VgUnionSortField>(\n    sorts.map(s => {\n      if (util.isBoolean(s) || !('op' in s) || (isString(s.op) && hasOwnProperty(UNIONDOMAIN_SORT_OP_INDEX, s.op))) {\n        return s as VgUnionSortField;\n      }\n      log.warn(log.message.domainSortDropped(s));\n      return true;\n    }),\n    util.hash\n  ) as VgUnionSortField[];\n\n  let sort: VgUnionSortField;\n\n  if (unionDomainSorts.length === 1) {\n    sort = unionDomainSorts[0];\n  } else if (unionDomainSorts.length > 1) {\n    log.warn(log.message.MORE_THAN_ONE_SORT);\n    sort = true;\n  }\n\n  const allData = util.unique(\n    domains.map(d => {\n      if (isDataRefDomain(d)) {\n        return d.data;\n      }\n      return null;\n    }),\n    x => x\n  );\n\n  if (allData.length === 1 && allData[0] !== null) {\n    // create a union domain of different fields with a single data source\n    const domain: VgMultiFieldsRefWithSort = {\n      data: allData[0],\n      fields: uniqueDomains.map(d => (d as VgScaleDataRefWithSort).field),\n      ...(sort ? {sort} : {})\n    };\n\n    return domain;\n  }\n\n  return {fields: uniqueDomains, ...(sort ? {sort} : {})};\n}\n\n/**\n * Return a field if a scale uses a single field.\n * Return `undefined` otherwise.\n */\nexport function getFieldFromDomain(domain: VgDomain): string {\n  if (isDataRefDomain(domain) && isString(domain.field)) {\n    return domain.field;\n  } else if (isDataRefUnionedDomain(domain)) {\n    let field;\n    for (const nonUnionDomain of domain.fields) {\n      if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {\n        if (!field) {\n          field = nonUnionDomain.field;\n        } else if (field !== nonUnionDomain.field) {\n          log.warn(log.message.FACETED_INDEPENDENT_DIFFERENT_SOURCES);\n          return field;\n        }\n      }\n    }\n    log.warn(log.message.FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES);\n    return field;\n  } else if (isFieldRefUnionDomain(domain)) {\n    log.warn(log.message.FACETED_INDEPENDENT_SAME_SOURCE);\n    const field = domain.fields[0];\n    return isString(field) ? field : undefined;\n  }\n\n  return undefined;\n}\n\nexport function assembleDomain(model: Model, channel: ScaleChannel) {\n  const scaleComponent: ScaleComponent = model.component.scales[channel];\n\n  const domains = scaleComponent.get('domains').map((domain: VgNonUnionDomain) => {\n    // Correct references to data as the original domain's data was determined\n    // in parseScale, which happens before parseData. Thus the original data\n    // reference can be incorrect.\n    if (isDataRefDomain(domain)) {\n      domain.data = model.lookupDataSource(domain.data);\n    }\n\n    return domain;\n  });\n\n  // domains is an array that has to be merged into a single vega domain\n  return mergeDomains(domains);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}