{"ast":null,"code":"import { isNumber, isString } from 'vega-util';\nimport { isMinMaxOp } from '../../aggregate';\nimport { getMainRangeChannel } from '../../channel';\nimport { isFieldDef, isFieldOrDatumDefForTimeFormat, isScaleFieldDef, isTypedFieldDef } from '../../channeldef';\nimport { isGenerator } from '../../data';\nimport { isDateTime } from '../../datetime';\nimport * as log from '../../log';\nimport { forEachLeaf } from '../../logical';\nimport { isPathMark } from '../../mark';\nimport { isFieldEqualPredicate, isFieldGTEPredicate, isFieldGTPredicate, isFieldLTEPredicate, isFieldLTPredicate, isFieldOneOfPredicate, isFieldPredicate, isFieldRangePredicate } from '../../predicate';\nimport { isSortField } from '../../sort';\nimport { accessPathDepth, accessPathWithDatum, duplicate, hash, keys, removePathFromField } from '../../util';\nimport { signalRefOrValue } from '../common';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { Split } from '../split';\nimport { DataFlowNode } from './dataflow';\n/**\n * Remove quotes from a string.\n */\nfunction unquote(pattern) {\n  if (pattern.startsWith(\"'\") && pattern.endsWith(\"'\") || pattern.startsWith('\"') && pattern.endsWith('\"')) {\n    return pattern.slice(1, -1);\n  }\n  return pattern;\n}\n/**\n * @param field The field.\n * @param parse What to parse the field as.\n */\nfunction parseExpression(field, parse) {\n  const f = accessPathWithDatum(field);\n  if (parse === 'number') {\n    return `toNumber(${f})`;\n  } else if (parse === 'boolean') {\n    return `toBoolean(${f})`;\n  } else if (parse === 'string') {\n    return `toString(${f})`;\n  } else if (parse === 'date') {\n    return `toDate(${f})`;\n  } else if (parse === 'flatten') {\n    return f;\n  } else if (parse.startsWith('date:')) {\n    const specifier = unquote(parse.slice(5, parse.length));\n    return `timeParse(${f},'${specifier}')`;\n  } else if (parse.startsWith('utc:')) {\n    const specifier = unquote(parse.slice(4, parse.length));\n    return `utcParse(${f},'${specifier}')`;\n  } else {\n    log.warn(log.message.unrecognizedParse(parse));\n    return null;\n  }\n}\nexport function getImplicitFromFilterTransform(transform) {\n  const implicit = {};\n  forEachLeaf(transform.filter, filter => {\n    if (isFieldPredicate(filter)) {\n      // Automatically add a parse node for filters with filter objects\n      let val = null;\n      // For EqualFilter, just use the equal property.\n      // For RangeFilter and OneOfFilter, all array members should have\n      // the same type, so we only use the first one.\n      if (isFieldEqualPredicate(filter)) {\n        val = signalRefOrValue(filter.equal);\n      } else if (isFieldLTEPredicate(filter)) {\n        val = signalRefOrValue(filter.lte);\n      } else if (isFieldLTPredicate(filter)) {\n        val = signalRefOrValue(filter.lt);\n      } else if (isFieldGTPredicate(filter)) {\n        val = signalRefOrValue(filter.gt);\n      } else if (isFieldGTEPredicate(filter)) {\n        val = signalRefOrValue(filter.gte);\n      } else if (isFieldRangePredicate(filter)) {\n        // FIXME: remove as any\n        val = filter.range[0];\n      } else if (isFieldOneOfPredicate(filter)) {\n        val = (filter.oneOf ?? filter.in)[0];\n      } // else -- for filter expression, we can't infer anything\n      if (val) {\n        if (isDateTime(val)) {\n          implicit[filter.field] = 'date';\n        } else if (isNumber(val)) {\n          implicit[filter.field] = 'number';\n        } else if (isString(val)) {\n          implicit[filter.field] = 'string';\n        }\n      }\n      if (filter.timeUnit) {\n        implicit[filter.field] = 'date';\n      }\n    }\n  });\n  return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\nexport function getImplicitFromEncoding(model) {\n  const implicit = {};\n  function add(fieldDef) {\n    if (isFieldOrDatumDefForTimeFormat(fieldDef)) {\n      implicit[fieldDef.field] = 'date';\n    } else if (fieldDef.type === 'quantitative' && isMinMaxOp(fieldDef.aggregate) // we need to parse numbers to support correct min and max\n    ) {\n      implicit[fieldDef.field] = 'number';\n    } else if (accessPathDepth(fieldDef.field) > 1) {\n      // For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.\n      // (Parsing numbers / dates already flattens numeric and temporal fields.)\n      if (!(fieldDef.field in implicit)) {\n        implicit[fieldDef.field] = 'flatten';\n      }\n    } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {\n      // Flatten fields that we sort by but that are not otherwise flattened.\n      if (!(fieldDef.sort.field in implicit)) {\n        implicit[fieldDef.sort.field] = 'flatten';\n      }\n    }\n  }\n  if (isUnitModel(model) || isFacetModel(model)) {\n    // Parse encoded fields\n    model.forEachFieldDef((fieldDef, channel) => {\n      if (isTypedFieldDef(fieldDef)) {\n        add(fieldDef);\n      } else {\n        const mainChannel = getMainRangeChannel(channel);\n        const mainFieldDef = model.fieldDef(mainChannel);\n        add({\n          ...fieldDef,\n          type: mainFieldDef.type\n        });\n      }\n    });\n  }\n  // Parse quantitative dimension fields of path marks as numbers so that we sort them correctly.\n  if (isUnitModel(model)) {\n    const {\n      mark,\n      markDef,\n      encoding\n    } = model;\n    if (isPathMark(mark) &&\n    // No need to sort by dimension if we have a connected scatterplot (order channel is present)\n    !model.encoding.order) {\n      const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n      const dimensionChannelDef = encoding[dimensionChannel];\n      if (isFieldDef(dimensionChannelDef) && dimensionChannelDef.type === 'quantitative' && !(dimensionChannelDef.field in implicit)) {\n        implicit[dimensionChannelDef.field] = 'number';\n      }\n    }\n  }\n  return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\nexport function getImplicitFromSelection(model) {\n  const implicit = {};\n  if (isUnitModel(model) && model.component.selection) {\n    for (const name of keys(model.component.selection)) {\n      const selCmpt = model.component.selection[name];\n      for (const proj of selCmpt.project.items) {\n        if (!proj.channel && accessPathDepth(proj.field) > 1) {\n          implicit[proj.field] = 'flatten';\n        }\n      }\n    }\n  }\n  return implicit;\n}\nexport class ParseNode extends DataFlowNode {\n  clone() {\n    return new ParseNode(null, duplicate(this._parse));\n  }\n  constructor(parent, parse) {\n    super(parent);\n    this._parse = parse;\n  }\n  hash() {\n    return `Parse ${hash(this._parse)}`;\n  }\n  /**\n   * Creates a parse node from a data.format.parse and updates ancestorParse.\n   */\n  static makeExplicit(parent, model, ancestorParse) {\n    // Custom parse\n    let explicit = {};\n    const data = model.data;\n    if (!isGenerator(data) && data?.format?.parse) {\n      explicit = data.format.parse;\n    }\n    return this.makeWithAncestors(parent, explicit, {}, ancestorParse);\n  }\n  /**\n   * Creates a parse node from \"explicit\" parse and \"implicit\" parse and updates ancestorParse.\n   */\n  static makeWithAncestors(parent, explicit, implicit, ancestorParse) {\n    // We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as \"derived\"). We also don't need to flatten a field that has already been parsed.\n    for (const field of keys(implicit)) {\n      const parsedAs = ancestorParse.getWithExplicit(field);\n      if (parsedAs.value !== undefined) {\n        // We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.\n        if (parsedAs.explicit || parsedAs.value === implicit[field] || parsedAs.value === 'derived' || implicit[field] === 'flatten') {\n          delete implicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, implicit[field], parsedAs.value));\n        }\n      }\n    }\n    for (const field of keys(explicit)) {\n      const parsedAs = ancestorParse.get(field);\n      if (parsedAs !== undefined) {\n        // Don't parse a field again if it has been parsed with the same type already.\n        if (parsedAs === explicit[field]) {\n          delete explicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, explicit[field], parsedAs));\n        }\n      }\n    }\n    const parse = new Split(explicit, implicit);\n    // add the format parse from this model so that children don't parse the same field again\n    ancestorParse.copyAll(parse);\n    // copy only non-null parses\n    const p = {};\n    for (const key of keys(parse.combine())) {\n      const val = parse.get(key);\n      if (val !== null) {\n        p[key] = val;\n      }\n    }\n    if (keys(p).length === 0 || ancestorParse.parseNothing) {\n      return null;\n    }\n    return new ParseNode(parent, p);\n  }\n  get parse() {\n    return this._parse;\n  }\n  merge(other) {\n    this._parse = {\n      ...this._parse,\n      ...other.parse\n    };\n    other.remove();\n  }\n  /**\n   * Assemble an object for Vega's format.parse property.\n   */\n  assembleFormatParse() {\n    const formatParse = {};\n    for (const field of keys(this._parse)) {\n      const p = this._parse[field];\n      if (accessPathDepth(field) === 1) {\n        formatParse[field] = p;\n      }\n    }\n    return formatParse;\n  }\n  // format parse depends and produces all fields in its parse\n  producedFields() {\n    return new Set(keys(this._parse));\n  }\n  dependentFields() {\n    return new Set(keys(this._parse));\n  }\n  assembleTransforms() {\n    let onlyNested = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return keys(this._parse).filter(field => onlyNested ? accessPathDepth(field) > 1 : true).map(field => {\n      const expr = parseExpression(field, this._parse[field]);\n      if (!expr) {\n        return null;\n      }\n      const formula = {\n        type: 'formula',\n        expr,\n        as: removePathFromField(field) // Vega output is always flattened\n      };\n      return formula;\n    }).filter(t => t !== null);\n  }\n}","map":{"version":3,"names":["isNumber","isString","isMinMaxOp","getMainRangeChannel","isFieldDef","isFieldOrDatumDefForTimeFormat","isScaleFieldDef","isTypedFieldDef","isGenerator","isDateTime","log","forEachLeaf","isPathMark","isFieldEqualPredicate","isFieldGTEPredicate","isFieldGTPredicate","isFieldLTEPredicate","isFieldLTPredicate","isFieldOneOfPredicate","isFieldPredicate","isFieldRangePredicate","isSortField","accessPathDepth","accessPathWithDatum","duplicate","hash","keys","removePathFromField","signalRefOrValue","isFacetModel","isUnitModel","Split","DataFlowNode","unquote","pattern","startsWith","endsWith","slice","parseExpression","field","parse","f","specifier","length","warn","message","unrecognizedParse","getImplicitFromFilterTransform","transform","implicit","filter","val","equal","lte","lt","gt","gte","range","oneOf","in","timeUnit","getImplicitFromEncoding","model","add","fieldDef","type","aggregate","sort","forEachFieldDef","channel","mainChannel","mainFieldDef","mark","markDef","encoding","order","dimensionChannel","orient","dimensionChannelDef","getImplicitFromSelection","component","selection","name","selCmpt","proj","project","items","ParseNode","clone","_parse","constructor","parent","makeExplicit","ancestorParse","explicit","data","format","makeWithAncestors","parsedAs","getWithExplicit","value","undefined","differentParse","get","copyAll","p","key","combine","parseNothing","merge","other","remove","assembleFormatParse","formatParse","producedFields","Set","dependentFields","assembleTransforms","onlyNested","arguments","map","expr","formula","as","t"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\data\\formatparse.ts"],"sourcesContent":["import {FormulaTransform as VgFormulaTransform, SignalRef} from 'vega';\nimport {isNumber, isString} from 'vega-util';\nimport {AncestorParse} from '.';\nimport {isMinMaxOp} from '../../aggregate';\nimport {getMainRangeChannel, SingleDefChannel} from '../../channel';\nimport {\n  isFieldDef,\n  isFieldOrDatumDefForTimeFormat,\n  isScaleFieldDef,\n  isTypedFieldDef,\n  TypedFieldDef\n} from '../../channeldef';\nimport {isGenerator, Parse} from '../../data';\nimport {DateTime, isDateTime} from '../../datetime';\nimport * as log from '../../log';\nimport {forEachLeaf} from '../../logical';\nimport {isPathMark} from '../../mark';\nimport {\n  isFieldEqualPredicate,\n  isFieldGTEPredicate,\n  isFieldGTPredicate,\n  isFieldLTEPredicate,\n  isFieldLTPredicate,\n  isFieldOneOfPredicate,\n  isFieldPredicate,\n  isFieldRangePredicate\n} from '../../predicate';\nimport {isSortField} from '../../sort';\nimport {FilterTransform} from '../../transform';\nimport {accessPathDepth, accessPathWithDatum, Dict, duplicate, hash, keys, removePathFromField} from '../../util';\nimport {signalRefOrValue} from '../common';\nimport {isFacetModel, isUnitModel, Model} from '../model';\nimport {Split} from '../split';\nimport {DataFlowNode} from './dataflow';\n\n/**\n * Remove quotes from a string.\n */\nfunction unquote(pattern: string) {\n  if ((pattern.startsWith(\"'\") && pattern.endsWith(\"'\")) || (pattern.startsWith('\"') && pattern.endsWith('\"'))) {\n    return pattern.slice(1, -1);\n  }\n  return pattern;\n}\n\n/**\n * @param field The field.\n * @param parse What to parse the field as.\n */\nfunction parseExpression(field: string, parse: string): string {\n  const f = accessPathWithDatum(field);\n  if (parse === 'number') {\n    return `toNumber(${f})`;\n  } else if (parse === 'boolean') {\n    return `toBoolean(${f})`;\n  } else if (parse === 'string') {\n    return `toString(${f})`;\n  } else if (parse === 'date') {\n    return `toDate(${f})`;\n  } else if (parse === 'flatten') {\n    return f;\n  } else if (parse.startsWith('date:')) {\n    const specifier = unquote(parse.slice(5, parse.length));\n    return `timeParse(${f},'${specifier}')`;\n  } else if (parse.startsWith('utc:')) {\n    const specifier = unquote(parse.slice(4, parse.length));\n    return `utcParse(${f},'${specifier}')`;\n  } else {\n    log.warn(log.message.unrecognizedParse(parse));\n    return null;\n  }\n}\n\nexport function getImplicitFromFilterTransform(transform: FilterTransform) {\n  const implicit: Dict<string> = {};\n  forEachLeaf(transform.filter, filter => {\n    if (isFieldPredicate(filter)) {\n      // Automatically add a parse node for filters with filter objects\n      let val: string | number | boolean | DateTime | SignalRef = null;\n\n      // For EqualFilter, just use the equal property.\n      // For RangeFilter and OneOfFilter, all array members should have\n      // the same type, so we only use the first one.\n      if (isFieldEqualPredicate(filter)) {\n        val = signalRefOrValue(filter.equal);\n      } else if (isFieldLTEPredicate(filter)) {\n        val = signalRefOrValue(filter.lte);\n      } else if (isFieldLTPredicate(filter)) {\n        val = signalRefOrValue(filter.lt);\n      } else if (isFieldGTPredicate(filter)) {\n        val = signalRefOrValue(filter.gt);\n      } else if (isFieldGTEPredicate(filter)) {\n        val = signalRefOrValue(filter.gte);\n      } else if (isFieldRangePredicate(filter)) {\n        // FIXME: remove as any\n        val = (filter as any).range[0];\n      } else if (isFieldOneOfPredicate(filter)) {\n        val = (filter.oneOf ?? (filter as any).in)[0];\n      } // else -- for filter expression, we can't infer anything\n\n      if (val) {\n        if (isDateTime(val)) {\n          implicit[filter.field] = 'date';\n        } else if (isNumber(val)) {\n          implicit[filter.field] = 'number';\n        } else if (isString(val)) {\n          implicit[filter.field] = 'string';\n        }\n      }\n\n      if (filter.timeUnit) {\n        implicit[filter.field] = 'date';\n      }\n    }\n  });\n\n  return implicit;\n}\n\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\nexport function getImplicitFromEncoding(model: Model) {\n  const implicit: Dict<string> = {};\n\n  function add(fieldDef: TypedFieldDef<string>) {\n    if (isFieldOrDatumDefForTimeFormat(fieldDef)) {\n      implicit[fieldDef.field] = 'date';\n    } else if (\n      fieldDef.type === 'quantitative' &&\n      isMinMaxOp(fieldDef.aggregate) // we need to parse numbers to support correct min and max\n    ) {\n      implicit[fieldDef.field] = 'number';\n    } else if (accessPathDepth(fieldDef.field) > 1) {\n      // For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.\n      // (Parsing numbers / dates already flattens numeric and temporal fields.)\n      if (!(fieldDef.field in implicit)) {\n        implicit[fieldDef.field] = 'flatten';\n      }\n    } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {\n      // Flatten fields that we sort by but that are not otherwise flattened.\n      if (!(fieldDef.sort.field in implicit)) {\n        implicit[fieldDef.sort.field] = 'flatten';\n      }\n    }\n  }\n\n  if (isUnitModel(model) || isFacetModel(model)) {\n    // Parse encoded fields\n    model.forEachFieldDef((fieldDef, channel) => {\n      if (isTypedFieldDef(fieldDef)) {\n        add(fieldDef);\n      } else {\n        const mainChannel = getMainRangeChannel(channel);\n        const mainFieldDef = model.fieldDef(mainChannel as SingleDefChannel) as TypedFieldDef<string>;\n        add({\n          ...fieldDef,\n          type: mainFieldDef.type\n        });\n      }\n    });\n  }\n\n  // Parse quantitative dimension fields of path marks as numbers so that we sort them correctly.\n  if (isUnitModel(model)) {\n    const {mark, markDef, encoding} = model;\n    if (\n      isPathMark(mark) &&\n      // No need to sort by dimension if we have a connected scatterplot (order channel is present)\n      !model.encoding.order\n    ) {\n      const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n      const dimensionChannelDef = encoding[dimensionChannel];\n      if (\n        isFieldDef(dimensionChannelDef) &&\n        dimensionChannelDef.type === 'quantitative' &&\n        !(dimensionChannelDef.field in implicit)\n      ) {\n        implicit[dimensionChannelDef.field] = 'number';\n      }\n    }\n  }\n\n  return implicit;\n}\n\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\nexport function getImplicitFromSelection(model: Model) {\n  const implicit: Dict<string> = {};\n\n  if (isUnitModel(model) && model.component.selection) {\n    for (const name of keys(model.component.selection)) {\n      const selCmpt = model.component.selection[name];\n      for (const proj of selCmpt.project.items) {\n        if (!proj.channel && accessPathDepth(proj.field) > 1) {\n          implicit[proj.field] = 'flatten';\n        }\n      }\n    }\n  }\n\n  return implicit;\n}\n\nexport class ParseNode extends DataFlowNode {\n  private _parse: Parse;\n\n  public clone() {\n    return new ParseNode(null, duplicate(this._parse));\n  }\n\n  constructor(parent: DataFlowNode, parse: Parse) {\n    super(parent);\n\n    this._parse = parse;\n  }\n\n  public hash() {\n    return `Parse ${hash(this._parse)}`;\n  }\n\n  /**\n   * Creates a parse node from a data.format.parse and updates ancestorParse.\n   */\n  public static makeExplicit(parent: DataFlowNode, model: Model, ancestorParse: AncestorParse) {\n    // Custom parse\n    let explicit = {};\n    const data = model.data;\n    if (!isGenerator(data) && data?.format?.parse) {\n      explicit = data.format.parse;\n    }\n\n    return this.makeWithAncestors(parent, explicit, {}, ancestorParse);\n  }\n\n  /**\n   * Creates a parse node from \"explicit\" parse and \"implicit\" parse and updates ancestorParse.\n   */\n  public static makeWithAncestors(\n    parent: DataFlowNode,\n    explicit: Parse,\n    implicit: Parse,\n    ancestorParse: AncestorParse\n  ) {\n    // We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as \"derived\"). We also don't need to flatten a field that has already been parsed.\n    for (const field of keys(implicit)) {\n      const parsedAs = ancestorParse.getWithExplicit(field);\n      if (parsedAs.value !== undefined) {\n        // We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.\n        if (\n          parsedAs.explicit ||\n          parsedAs.value === implicit[field] ||\n          parsedAs.value === 'derived' ||\n          implicit[field] === 'flatten'\n        ) {\n          delete implicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, implicit[field], parsedAs.value));\n        }\n      }\n    }\n\n    for (const field of keys(explicit)) {\n      const parsedAs = ancestorParse.get(field);\n      if (parsedAs !== undefined) {\n        // Don't parse a field again if it has been parsed with the same type already.\n        if (parsedAs === explicit[field]) {\n          delete explicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, explicit[field], parsedAs));\n        }\n      }\n    }\n\n    const parse = new Split(explicit, implicit);\n\n    // add the format parse from this model so that children don't parse the same field again\n    ancestorParse.copyAll(parse);\n\n    // copy only non-null parses\n    const p: Dict<string> = {};\n    for (const key of keys(parse.combine())) {\n      const val = parse.get(key);\n      if (val !== null) {\n        p[key] = val;\n      }\n    }\n\n    if (keys(p).length === 0 || ancestorParse.parseNothing) {\n      return null;\n    }\n\n    return new ParseNode(parent, p);\n  }\n\n  public get parse() {\n    return this._parse;\n  }\n\n  public merge(other: ParseNode) {\n    this._parse = {...this._parse, ...other.parse};\n    other.remove();\n  }\n\n  /**\n   * Assemble an object for Vega's format.parse property.\n   */\n  public assembleFormatParse() {\n    const formatParse: Dict<string> = {};\n    for (const field of keys(this._parse)) {\n      const p = this._parse[field];\n      if (accessPathDepth(field) === 1) {\n        formatParse[field] = p;\n      }\n    }\n    return formatParse;\n  }\n\n  // format parse depends and produces all fields in its parse\n  public producedFields() {\n    return new Set(keys(this._parse));\n  }\n\n  public dependentFields() {\n    return new Set(keys(this._parse));\n  }\n\n  public assembleTransforms(onlyNested = false): VgFormulaTransform[] {\n    return keys(this._parse)\n      .filter(field => (onlyNested ? accessPathDepth(field) > 1 : true))\n      .map(field => {\n        const expr = parseExpression(field, this._parse[field]);\n        if (!expr) {\n          return null;\n        }\n\n        const formula: VgFormulaTransform = {\n          type: 'formula',\n          expr,\n          as: removePathFromField(field) // Vega output is always flattened\n        };\n        return formula;\n      })\n      .filter(t => t !== null);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}