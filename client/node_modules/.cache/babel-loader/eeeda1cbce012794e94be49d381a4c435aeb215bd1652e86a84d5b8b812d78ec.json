{"ast":null,"code":"import { AXIS_PARTS, isAxisProperty, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { getFirstDefined, isEmpty, keys, normalizeAngle } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeTitleComponent } from '../common';\nimport { guideEncodeEntry } from '../guide';\nimport { parseGuideResolve } from '../resolve';\nimport { defaultTieBreaker, mergeValuesWithExplicit } from '../split';\nimport { AxisComponent, AXIS_COMPONENT_PROPERTIES } from './component';\nimport { getAxisConfig, getAxisConfigs } from './config';\nimport * as encode from './encode';\nimport { axisRules, defaultOrient, getFieldDefTitle, getLabelAngle } from './properties';\nimport { guideFormat, guideFormatType } from '../format';\nexport function parseUnitAxes(model) {\n  return POSITION_SCALE_CHANNELS.reduce((axis, channel) => {\n    if (model.component.scales[channel]) {\n      axis[channel] = [parseAxis(channel, model)];\n    }\n    return axis;\n  }, {});\n}\nconst OPPOSITE_ORIENT = {\n  bottom: 'top',\n  top: 'bottom',\n  left: 'right',\n  right: 'left'\n};\nexport function parseLayerAxes(model) {\n  const {\n    axes,\n    resolve\n  } = model.component;\n  const axisCount = {\n    top: 0,\n    bottom: 0,\n    right: 0,\n    left: 0\n  };\n  for (const child of model.children) {\n    child.parseAxesAndHeaders();\n    for (const channel of keys(child.component.axes)) {\n      resolve.axis[channel] = parseGuideResolve(model.component.resolve, channel);\n      if (resolve.axis[channel] === 'shared') {\n        // If the resolve says shared (and has not been overridden)\n        // We will try to merge and see if there is a conflict\n        axes[channel] = mergeAxisComponents(axes[channel], child.component.axes[channel]);\n        if (!axes[channel]) {\n          // If merge returns nothing, there is a conflict so we cannot make the axis shared.\n          // Thus, mark axis as independent and remove the axis component.\n          resolve.axis[channel] = 'independent';\n          delete axes[channel];\n        }\n      }\n    }\n  }\n  // Move axes to layer's axis component and merge shared axes\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    for (const child of model.children) {\n      if (!child.component.axes[channel]) {\n        // skip if the child does not have a particular axis\n        continue;\n      }\n      if (resolve.axis[channel] === 'independent') {\n        // If axes are independent, concat the axisComponent array.\n        axes[channel] = (axes[channel] ?? []).concat(child.component.axes[channel]);\n        // Automatically adjust orient\n        for (const axisComponent of child.component.axes[channel]) {\n          const {\n            value: orient,\n            explicit\n          } = axisComponent.getWithExplicit('orient');\n          if (isSignalRef(orient)) {\n            continue;\n          }\n          if (axisCount[orient] > 0 && !explicit) {\n            // Change axis orient if the number do not match\n            const oppositeOrient = OPPOSITE_ORIENT[orient];\n            if (axisCount[orient] > axisCount[oppositeOrient]) {\n              axisComponent.set('orient', oppositeOrient, false);\n            }\n          }\n          axisCount[orient]++;\n          // TODO(https://github.com/vega/vega-lite/issues/2634): automatically add extra offset?\n        }\n      }\n      // After merging, make sure to remove axes from child\n      delete child.component.axes[channel];\n    }\n    // Show gridlines for first axis only for dual-axis chart\n    if (resolve.axis[channel] === 'independent' && axes[channel] && axes[channel].length > 1) {\n      for (const [index, axisCmpt] of (axes[channel] || []).entries()) {\n        if (index > 0 && !!axisCmpt.get('grid') && !axisCmpt.explicit.grid) {\n          axisCmpt.implicit.grid = false;\n        }\n      }\n    }\n  }\n}\nfunction mergeAxisComponents(mergedAxisCmpts, childAxisCmpts) {\n  if (mergedAxisCmpts) {\n    // FIXME: this is a bit wrong once we support multiple axes\n    if (mergedAxisCmpts.length !== childAxisCmpts.length) {\n      return undefined; // Cannot merge axis component with different number of axes.\n    }\n    const length = mergedAxisCmpts.length;\n    for (let i = 0; i < length; i++) {\n      const merged = mergedAxisCmpts[i];\n      const child = childAxisCmpts[i];\n      if (!!merged !== !!child) {\n        return undefined;\n      } else if (merged && child) {\n        const mergedOrient = merged.getWithExplicit('orient');\n        const childOrient = child.getWithExplicit('orient');\n        if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n          // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n          // Cannot merge due to inconsistent orient\n          return undefined;\n        } else {\n          mergedAxisCmpts[i] = mergeAxisComponent(merged, child);\n        }\n      }\n    }\n  } else {\n    // For first one, return a copy of the child\n    return childAxisCmpts.map(axisComponent => axisComponent.clone());\n  }\n  return mergedAxisCmpts;\n}\nfunction mergeAxisComponent(merged, child) {\n  for (const prop of AXIS_COMPONENT_PROPERTIES) {\n    const mergedValueWithExplicit = mergeValuesWithExplicit(merged.getWithExplicit(prop), child.getWithExplicit(prop), prop, 'axis',\n    // Tie breaker function\n    (v1, v2) => {\n      switch (prop) {\n        case 'title':\n          return mergeTitleComponent(v1, v2);\n        case 'gridScale':\n          return {\n            explicit: v1.explicit,\n            // keep the old explicit\n            value: getFirstDefined(v1.value, v2.value)\n          };\n      }\n      return defaultTieBreaker(v1, v2, prop, 'axis');\n    });\n    merged.setWithExplicit(prop, mergedValueWithExplicit);\n  }\n  return merged;\n}\nfunction isExplicit(value, property, axis, model, channel) {\n  if (property === 'disable') {\n    return axis !== undefined; // if axis is specified or null/false, then its enable/disable state is explicit\n  }\n  axis = axis || {};\n  switch (property) {\n    case 'titleAngle':\n    case 'labelAngle':\n      return value === (isSignalRef(axis.labelAngle) ? axis.labelAngle : normalizeAngle(axis.labelAngle));\n    case 'values':\n      return !!axis.values;\n    // specified axis.values is already respected, but may get transformed.\n    case 'encode':\n      // both VL axis.encoding and axis.labelAngle affect VG axis.encode\n      return !!axis.encoding || !!axis.labelAngle;\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (value === getFieldDefTitle(model, channel)) {\n        return true;\n      }\n  }\n  // Otherwise, things are explicit if the returned value matches the specified property\n  return value === axis[property];\n}\n/**\n * Properties to always include values from config\n */\nconst propsToAlwaysIncludeConfig = new Set(['grid',\n// Grid is an exception because we need to set grid = true to generate another grid axis\n'translate',\n// translate has dependent logic for bar's bin position and it's 0.5 by default in Vega. If a config overrides this value, we need to know.\n// the rest are not axis configs in Vega, but are in VL, so we need to set too.\n'format', 'formatType', 'orient', 'labelExpr', 'tickCount', 'position', 'tickMinStep']);\nfunction parseAxis(channel, model) {\n  let axis = model.axis(channel);\n  const axisComponent = new AxisComponent();\n  const fieldOrDatumDef = getFieldOrDatumDef(model.encoding[channel]);\n  const {\n    mark,\n    config\n  } = model;\n  const orient = axis?.orient || config[channel === 'x' ? 'axisX' : 'axisY']?.orient || config.axis?.orient || defaultOrient(channel);\n  const scaleType = model.getScaleComponent(channel).get('type');\n  const axisConfigs = getAxisConfigs(channel, scaleType, orient, model.config);\n  const disable = axis !== undefined ? !axis : getAxisConfig('disable', config.style, axis?.style, axisConfigs).configValue;\n  axisComponent.set('disable', disable, axis !== undefined);\n  if (disable) {\n    return axisComponent;\n  }\n  axis = axis || {};\n  const labelAngle = getLabelAngle(fieldOrDatumDef, axis, channel, config.style, axisConfigs);\n  const formatType = guideFormatType(axis.formatType, fieldOrDatumDef, scaleType);\n  const format = guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, axis.format, axis.formatType, config, true);\n  const ruleParams = {\n    fieldOrDatumDef,\n    axis,\n    channel,\n    model,\n    scaleType,\n    orient,\n    labelAngle,\n    format,\n    formatType,\n    mark,\n    config\n  };\n  // 1.2. Add properties\n  for (const property of AXIS_COMPONENT_PROPERTIES) {\n    const value = property in axisRules ? axisRules[property](ruleParams) : isAxisProperty(property) ? axis[property] : undefined;\n    const hasValue = value !== undefined;\n    const explicit = isExplicit(value, property, axis, model, channel);\n    if (hasValue && explicit) {\n      axisComponent.set(property, value, explicit);\n    } else {\n      const {\n        configValue = undefined,\n        configFrom = undefined\n      } = isAxisProperty(property) && property !== 'values' ? getAxisConfig(property, config.style, axis.style, axisConfigs) : {};\n      const hasConfigValue = configValue !== undefined;\n      if (hasValue && !hasConfigValue) {\n        // only set property if it is explicitly set or has no config value (otherwise we will accidentally override config)\n        axisComponent.set(property, value, explicit);\n      } else if (\n      // Cases need implicit values\n      // 1. Axis config that aren't available in Vega\n      !(configFrom === 'vgAxisConfig') ||\n      // 2. Certain properties are always included (see `propsToAlwaysIncludeConfig`'s declaration for more details)\n      propsToAlwaysIncludeConfig.has(property) && hasConfigValue ||\n      // 3. Conditional axis values and signals\n      isConditionalAxisValue(configValue) || isSignalRef(configValue)) {\n        // If a config is specified and is conditional, copy conditional value from axis config\n        axisComponent.set(property, configValue, false);\n      }\n    }\n  }\n  // 2) Add guide encode definition groups\n  const axisEncoding = axis.encoding ?? {};\n  const axisEncode = AXIS_PARTS.reduce((e, part) => {\n    if (!axisComponent.hasAxisPart(part)) {\n      // No need to create encode for a disabled part.\n      return e;\n    }\n    const axisEncodingPart = guideEncodeEntry(axisEncoding[part] ?? {}, model);\n    const value = part === 'labels' ? encode.labels(model, channel, axisEncodingPart) : axisEncodingPart;\n    if (value !== undefined && !isEmpty(value)) {\n      e[part] = {\n        update: value\n      };\n    }\n    return e;\n  }, {});\n  // FIXME: By having encode as one property, we won't have fine grained encode merging.\n  if (!isEmpty(axisEncode)) {\n    axisComponent.set('encode', axisEncode, !!axis.encoding || axis.labelAngle !== undefined);\n  }\n  return axisComponent;\n}","map":{"version":3,"names":["AXIS_PARTS","isAxisProperty","isConditionalAxisValue","POSITION_SCALE_CHANNELS","getFieldOrDatumDef","getFirstDefined","isEmpty","keys","normalizeAngle","isSignalRef","mergeTitleComponent","guideEncodeEntry","parseGuideResolve","defaultTieBreaker","mergeValuesWithExplicit","AxisComponent","AXIS_COMPONENT_PROPERTIES","getAxisConfig","getAxisConfigs","encode","axisRules","defaultOrient","getFieldDefTitle","getLabelAngle","guideFormat","guideFormatType","parseUnitAxes","model","reduce","axis","channel","component","scales","parseAxis","OPPOSITE_ORIENT","bottom","top","left","right","parseLayerAxes","axes","resolve","axisCount","child","children","parseAxesAndHeaders","mergeAxisComponents","concat","axisComponent","value","orient","explicit","getWithExplicit","oppositeOrient","set","length","index","axisCmpt","entries","get","grid","implicit","mergedAxisCmpts","childAxisCmpts","undefined","i","merged","mergedOrient","childOrient","mergeAxisComponent","map","clone","prop","mergedValueWithExplicit","v1","v2","setWithExplicit","isExplicit","property","labelAngle","values","encoding","propsToAlwaysIncludeConfig","Set","fieldOrDatumDef","mark","config","scaleType","getScaleComponent","axisConfigs","disable","style","configValue","formatType","format","type","ruleParams","hasValue","configFrom","hasConfigValue","has","axisEncoding","axisEncode","e","part","hasAxisPart","axisEncodingPart","labels","update"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\axis\\parse.ts"],"sourcesContent":["import type {AxisEncode as VgAxisEncode, AxisOrient, SignalRef} from 'vega';\nimport {Axis, AXIS_PARTS, isAxisProperty, isConditionalAxisValue} from '../../axis';\nimport {PositionScaleChannel, POSITION_SCALE_CHANNELS} from '../../channel';\nimport {getFieldOrDatumDef, PositionDatumDef, PositionFieldDef} from '../../channeldef';\nimport {getFirstDefined, isEmpty, keys, normalizeAngle} from '../../util';\nimport {isSignalRef} from '../../vega.schema';\nimport {mergeTitleComponent} from '../common';\nimport {guideEncodeEntry} from '../guide';\nimport {LayerModel} from '../layer';\nimport {parseGuideResolve} from '../resolve';\nimport {defaultTieBreaker, Explicit, mergeValuesWithExplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {AxisComponent, AxisComponentIndex, AxisComponentProps, AXIS_COMPONENT_PROPERTIES} from './component';\nimport {getAxisConfig, getAxisConfigs} from './config';\nimport * as encode from './encode';\nimport {AxisRuleParams, axisRules, defaultOrient, getFieldDefTitle, getLabelAngle} from './properties';\nimport {guideFormat, guideFormatType} from '../format';\n\nexport function parseUnitAxes(model: UnitModel): AxisComponentIndex {\n  return POSITION_SCALE_CHANNELS.reduce((axis, channel) => {\n    if (model.component.scales[channel]) {\n      axis[channel] = [parseAxis(channel, model)];\n    }\n    return axis;\n  }, {} as AxisComponentIndex);\n}\n\nconst OPPOSITE_ORIENT: Record<AxisOrient, AxisOrient> = {\n  bottom: 'top',\n  top: 'bottom',\n  left: 'right',\n  right: 'left'\n};\n\nexport function parseLayerAxes(model: LayerModel) {\n  const {axes, resolve} = model.component;\n  const axisCount: Record<AxisOrient, number> = {top: 0, bottom: 0, right: 0, left: 0};\n\n  for (const child of model.children) {\n    child.parseAxesAndHeaders();\n\n    for (const channel of keys(child.component.axes)) {\n      resolve.axis[channel] = parseGuideResolve(model.component.resolve, channel);\n      if (resolve.axis[channel] === 'shared') {\n        // If the resolve says shared (and has not been overridden)\n        // We will try to merge and see if there is a conflict\n\n        axes[channel] = mergeAxisComponents(axes[channel], child.component.axes[channel]);\n\n        if (!axes[channel]) {\n          // If merge returns nothing, there is a conflict so we cannot make the axis shared.\n          // Thus, mark axis as independent and remove the axis component.\n          resolve.axis[channel] = 'independent';\n          delete axes[channel];\n        }\n      }\n    }\n  }\n\n  // Move axes to layer's axis component and merge shared axes\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    for (const child of model.children) {\n      if (!child.component.axes[channel]) {\n        // skip if the child does not have a particular axis\n        continue;\n      }\n\n      if (resolve.axis[channel] === 'independent') {\n        // If axes are independent, concat the axisComponent array.\n        axes[channel] = (axes[channel] ?? []).concat(child.component.axes[channel]);\n\n        // Automatically adjust orient\n        for (const axisComponent of child.component.axes[channel]) {\n          const {value: orient, explicit} = axisComponent.getWithExplicit('orient');\n          if (isSignalRef(orient)) {\n            continue;\n          }\n\n          if (axisCount[orient] > 0 && !explicit) {\n            // Change axis orient if the number do not match\n            const oppositeOrient = OPPOSITE_ORIENT[orient];\n            if (axisCount[orient] > axisCount[oppositeOrient]) {\n              axisComponent.set('orient', oppositeOrient, false);\n            }\n          }\n          axisCount[orient]++;\n\n          // TODO(https://github.com/vega/vega-lite/issues/2634): automatically add extra offset?\n        }\n      }\n\n      // After merging, make sure to remove axes from child\n      delete child.component.axes[channel];\n    }\n\n    // Show gridlines for first axis only for dual-axis chart\n    if (resolve.axis[channel] === 'independent' && axes[channel] && axes[channel].length > 1) {\n      for (const [index, axisCmpt] of (axes[channel] || []).entries()) {\n        if (index > 0 && !!axisCmpt.get('grid') && !axisCmpt.explicit.grid) {\n          axisCmpt.implicit.grid = false;\n        }\n      }\n    }\n  }\n}\n\nfunction mergeAxisComponents(\n  mergedAxisCmpts: AxisComponent[],\n  childAxisCmpts: readonly AxisComponent[]\n): AxisComponent[] {\n  if (mergedAxisCmpts) {\n    // FIXME: this is a bit wrong once we support multiple axes\n    if (mergedAxisCmpts.length !== childAxisCmpts.length) {\n      return undefined; // Cannot merge axis component with different number of axes.\n    }\n    const length = mergedAxisCmpts.length;\n    for (let i = 0; i < length; i++) {\n      const merged = mergedAxisCmpts[i];\n      const child = childAxisCmpts[i];\n\n      if (!!merged !== !!child) {\n        return undefined;\n      } else if (merged && child) {\n        const mergedOrient = merged.getWithExplicit('orient');\n        const childOrient = child.getWithExplicit('orient');\n\n        if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n          // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n\n          // Cannot merge due to inconsistent orient\n          return undefined;\n        } else {\n          mergedAxisCmpts[i] = mergeAxisComponent(merged, child);\n        }\n      }\n    }\n  } else {\n    // For first one, return a copy of the child\n    return childAxisCmpts.map(axisComponent => axisComponent.clone());\n  }\n  return mergedAxisCmpts;\n}\n\nfunction mergeAxisComponent(merged: AxisComponent, child: AxisComponent): AxisComponent {\n  for (const prop of AXIS_COMPONENT_PROPERTIES) {\n    const mergedValueWithExplicit = mergeValuesWithExplicit<AxisComponentProps, any>(\n      merged.getWithExplicit(prop),\n      child.getWithExplicit(prop),\n      prop,\n      'axis',\n\n      // Tie breaker function\n      (v1: Explicit<any>, v2: Explicit<any>) => {\n        switch (prop) {\n          case 'title':\n            return mergeTitleComponent(v1, v2);\n          case 'gridScale':\n            return {\n              explicit: v1.explicit, // keep the old explicit\n              value: getFirstDefined(v1.value, v2.value)\n            };\n        }\n        return defaultTieBreaker<AxisComponentProps, any>(v1, v2, prop, 'axis');\n      }\n    );\n    merged.setWithExplicit(prop, mergedValueWithExplicit);\n  }\n  return merged;\n}\n\nfunction isExplicit<T extends string | number | boolean | unknown>(\n  value: T,\n  property: keyof AxisComponentProps,\n  axis: Axis<SignalRef>,\n  model: UnitModel,\n  channel: PositionScaleChannel\n) {\n  if (property === 'disable') {\n    return axis !== undefined; // if axis is specified or null/false, then its enable/disable state is explicit\n  }\n\n  axis = axis || {};\n\n  switch (property) {\n    case 'titleAngle':\n    case 'labelAngle':\n      return value === (isSignalRef(axis.labelAngle) ? axis.labelAngle : normalizeAngle(axis.labelAngle));\n    case 'values':\n      return !!axis.values;\n    // specified axis.values is already respected, but may get transformed.\n    case 'encode':\n      // both VL axis.encoding and axis.labelAngle affect VG axis.encode\n      return !!axis.encoding || !!axis.labelAngle;\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (value === getFieldDefTitle(model, channel)) {\n        return true;\n      }\n  }\n  // Otherwise, things are explicit if the returned value matches the specified property\n  return value === (axis as any)[property];\n}\n\n/**\n * Properties to always include values from config\n */\nconst propsToAlwaysIncludeConfig = new Set([\n  'grid', // Grid is an exception because we need to set grid = true to generate another grid axis\n  'translate', // translate has dependent logic for bar's bin position and it's 0.5 by default in Vega. If a config overrides this value, we need to know.\n  // the rest are not axis configs in Vega, but are in VL, so we need to set too.\n  'format',\n  'formatType',\n  'orient',\n  'labelExpr',\n  'tickCount',\n  'position',\n  'tickMinStep'\n]);\n\nfunction parseAxis(channel: PositionScaleChannel, model: UnitModel): AxisComponent {\n  let axis = model.axis(channel);\n\n  const axisComponent = new AxisComponent();\n\n  const fieldOrDatumDef = getFieldOrDatumDef(model.encoding[channel]) as\n    | PositionFieldDef<string>\n    | PositionDatumDef<string>;\n\n  const {mark, config} = model;\n\n  const orient =\n    axis?.orient ||\n    config[channel === 'x' ? 'axisX' : 'axisY']?.orient ||\n    config.axis?.orient ||\n    defaultOrient(channel);\n\n  const scaleType = model.getScaleComponent(channel).get('type');\n\n  const axisConfigs = getAxisConfigs(channel, scaleType, orient, model.config);\n\n  const disable =\n    axis !== undefined ? !axis : getAxisConfig('disable', config.style, axis?.style, axisConfigs).configValue;\n  axisComponent.set('disable', disable, axis !== undefined);\n  if (disable) {\n    return axisComponent;\n  }\n\n  axis = axis || {};\n\n  const labelAngle = getLabelAngle(fieldOrDatumDef, axis, channel, config.style, axisConfigs);\n  const formatType = guideFormatType(axis.formatType, fieldOrDatumDef, scaleType);\n  const format = guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, axis.format, axis.formatType, config, true);\n\n  const ruleParams: AxisRuleParams = {\n    fieldOrDatumDef,\n    axis,\n    channel,\n    model,\n    scaleType,\n    orient,\n    labelAngle,\n    format,\n    formatType,\n    mark,\n    config\n  };\n  // 1.2. Add properties\n  for (const property of AXIS_COMPONENT_PROPERTIES) {\n    const value =\n      property in axisRules ? axisRules[property](ruleParams) : isAxisProperty(property) ? axis[property] : undefined;\n\n    const hasValue = value !== undefined;\n\n    const explicit = isExplicit(value, property, axis, model, channel);\n\n    if (hasValue && explicit) {\n      axisComponent.set(property, value, explicit);\n    } else {\n      const {configValue = undefined, configFrom = undefined} =\n        isAxisProperty(property) && property !== 'values'\n          ? getAxisConfig(property, config.style, axis.style, axisConfigs)\n          : {};\n      const hasConfigValue = configValue !== undefined;\n\n      if (hasValue && !hasConfigValue) {\n        // only set property if it is explicitly set or has no config value (otherwise we will accidentally override config)\n        axisComponent.set(property, value, explicit);\n      } else if (\n        // Cases need implicit values\n        // 1. Axis config that aren't available in Vega\n        !(configFrom === 'vgAxisConfig') ||\n        // 2. Certain properties are always included (see `propsToAlwaysIncludeConfig`'s declaration for more details)\n        (propsToAlwaysIncludeConfig.has(property) && hasConfigValue) ||\n        // 3. Conditional axis values and signals\n        isConditionalAxisValue(configValue) ||\n        isSignalRef(configValue)\n      ) {\n        // If a config is specified and is conditional, copy conditional value from axis config\n        axisComponent.set(property, configValue, false);\n      }\n    }\n  }\n\n  // 2) Add guide encode definition groups\n  const axisEncoding = axis.encoding ?? {};\n  const axisEncode = AXIS_PARTS.reduce((e: VgAxisEncode, part) => {\n    if (!axisComponent.hasAxisPart(part)) {\n      // No need to create encode for a disabled part.\n      return e;\n    }\n\n    const axisEncodingPart = guideEncodeEntry(axisEncoding[part] ?? {}, model);\n\n    const value = part === 'labels' ? encode.labels(model, channel, axisEncodingPart) : axisEncodingPart;\n\n    if (value !== undefined && !isEmpty(value)) {\n      e[part] = {update: value};\n    }\n    return e;\n  }, {} as VgAxisEncode);\n\n  // FIXME: By having encode as one property, we won't have fine grained encode merging.\n  if (!isEmpty(axisEncode)) {\n    axisComponent.set('encode', axisEncode, !!axis.encoding || axis.labelAngle !== undefined);\n  }\n\n  return axisComponent;\n}\n"],"mappings":"AACA,SAAcA,UAAU,EAAEC,cAAc,EAAEC,sBAAsB,QAAO,YAAY;AACnF,SAA8BC,uBAAuB,QAAO,eAAe;AAC3E,SAAQC,kBAAkB,QAA2C,kBAAkB;AACvF,SAAQC,eAAe,EAAEC,OAAO,EAAEC,IAAI,EAAEC,cAAc,QAAO,YAAY;AACzE,SAAQC,WAAW,QAAO,mBAAmB;AAC7C,SAAQC,mBAAmB,QAAO,WAAW;AAC7C,SAAQC,gBAAgB,QAAO,UAAU;AAEzC,SAAQC,iBAAiB,QAAO,YAAY;AAC5C,SAAQC,iBAAiB,EAAYC,uBAAuB,QAAO,UAAU;AAE7E,SAAQC,aAAa,EAA0CC,yBAAyB,QAAO,aAAa;AAC5G,SAAQC,aAAa,EAAEC,cAAc,QAAO,UAAU;AACtD,OAAO,KAAKC,MAAM,MAAM,UAAU;AAClC,SAAwBC,SAAS,EAAEC,aAAa,EAAEC,gBAAgB,EAAEC,aAAa,QAAO,cAAc;AACtG,SAAQC,WAAW,EAAEC,eAAe,QAAO,WAAW;AAEtD,OAAM,SAAUC,aAAaA,CAACC,KAAgB;EAC5C,OAAOxB,uBAAuB,CAACyB,MAAM,CAAC,CAACC,IAAI,EAAEC,OAAO,KAAI;IACtD,IAAIH,KAAK,CAACI,SAAS,CAACC,MAAM,CAACF,OAAO,CAAC,EAAE;MACnCD,IAAI,CAACC,OAAO,CAAC,GAAG,CAACG,SAAS,CAACH,OAAO,EAAEH,KAAK,CAAC,CAAC;IAC7C;IACA,OAAOE,IAAI;EACb,CAAC,EAAE,EAAwB,CAAC;AAC9B;AAEA,MAAMK,eAAe,GAAmC;EACtDC,MAAM,EAAE,KAAK;EACbC,GAAG,EAAE,QAAQ;EACbC,IAAI,EAAE,OAAO;EACbC,KAAK,EAAE;CACR;AAED,OAAM,SAAUC,cAAcA,CAACZ,KAAiB;EAC9C,MAAM;IAACa,IAAI;IAAEC;EAAO,CAAC,GAAGd,KAAK,CAACI,SAAS;EACvC,MAAMW,SAAS,GAA+B;IAACN,GAAG,EAAE,CAAC;IAAED,MAAM,EAAE,CAAC;IAAEG,KAAK,EAAE,CAAC;IAAED,IAAI,EAAE;EAAC,CAAC;EAEpF,KAAK,MAAMM,KAAK,IAAIhB,KAAK,CAACiB,QAAQ,EAAE;IAClCD,KAAK,CAACE,mBAAmB,EAAE;IAE3B,KAAK,MAAMf,OAAO,IAAIvB,IAAI,CAACoC,KAAK,CAACZ,SAAS,CAACS,IAAI,CAAC,EAAE;MAChDC,OAAO,CAACZ,IAAI,CAACC,OAAO,CAAC,GAAGlB,iBAAiB,CAACe,KAAK,CAACI,SAAS,CAACU,OAAO,EAAEX,OAAO,CAAC;MAC3E,IAAIW,OAAO,CAACZ,IAAI,CAACC,OAAO,CAAC,KAAK,QAAQ,EAAE;QACtC;QACA;QAEAU,IAAI,CAACV,OAAO,CAAC,GAAGgB,mBAAmB,CAACN,IAAI,CAACV,OAAO,CAAC,EAAEa,KAAK,CAACZ,SAAS,CAACS,IAAI,CAACV,OAAO,CAAC,CAAC;QAEjF,IAAI,CAACU,IAAI,CAACV,OAAO,CAAC,EAAE;UAClB;UACA;UACAW,OAAO,CAACZ,IAAI,CAACC,OAAO,CAAC,GAAG,aAAa;UACrC,OAAOU,IAAI,CAACV,OAAO,CAAC;QACtB;MACF;IACF;EACF;EAEA;EACA,KAAK,MAAMA,OAAO,IAAI3B,uBAAuB,EAAE;IAC7C,KAAK,MAAMwC,KAAK,IAAIhB,KAAK,CAACiB,QAAQ,EAAE;MAClC,IAAI,CAACD,KAAK,CAACZ,SAAS,CAACS,IAAI,CAACV,OAAO,CAAC,EAAE;QAClC;QACA;MACF;MAEA,IAAIW,OAAO,CAACZ,IAAI,CAACC,OAAO,CAAC,KAAK,aAAa,EAAE;QAC3C;QACAU,IAAI,CAACV,OAAO,CAAC,GAAG,CAACU,IAAI,CAACV,OAAO,CAAC,IAAI,EAAE,EAAEiB,MAAM,CAACJ,KAAK,CAACZ,SAAS,CAACS,IAAI,CAACV,OAAO,CAAC,CAAC;QAE3E;QACA,KAAK,MAAMkB,aAAa,IAAIL,KAAK,CAACZ,SAAS,CAACS,IAAI,CAACV,OAAO,CAAC,EAAE;UACzD,MAAM;YAACmB,KAAK,EAAEC,MAAM;YAAEC;UAAQ,CAAC,GAAGH,aAAa,CAACI,eAAe,CAAC,QAAQ,CAAC;UACzE,IAAI3C,WAAW,CAACyC,MAAM,CAAC,EAAE;YACvB;UACF;UAEA,IAAIR,SAAS,CAACQ,MAAM,CAAC,GAAG,CAAC,IAAI,CAACC,QAAQ,EAAE;YACtC;YACA,MAAME,cAAc,GAAGnB,eAAe,CAACgB,MAAM,CAAC;YAC9C,IAAIR,SAAS,CAACQ,MAAM,CAAC,GAAGR,SAAS,CAACW,cAAc,CAAC,EAAE;cACjDL,aAAa,CAACM,GAAG,CAAC,QAAQ,EAAED,cAAc,EAAE,KAAK,CAAC;YACpD;UACF;UACAX,SAAS,CAACQ,MAAM,CAAC,EAAE;UAEnB;QACF;MACF;MAEA;MACA,OAAOP,KAAK,CAACZ,SAAS,CAACS,IAAI,CAACV,OAAO,CAAC;IACtC;IAEA;IACA,IAAIW,OAAO,CAACZ,IAAI,CAACC,OAAO,CAAC,KAAK,aAAa,IAAIU,IAAI,CAACV,OAAO,CAAC,IAAIU,IAAI,CAACV,OAAO,CAAC,CAACyB,MAAM,GAAG,CAAC,EAAE;MACxF,KAAK,MAAM,CAACC,KAAK,EAAEC,QAAQ,CAAC,IAAI,CAACjB,IAAI,CAACV,OAAO,CAAC,IAAI,EAAE,EAAE4B,OAAO,EAAE,EAAE;QAC/D,IAAIF,KAAK,GAAG,CAAC,IAAI,CAAC,CAACC,QAAQ,CAACE,GAAG,CAAC,MAAM,CAAC,IAAI,CAACF,QAAQ,CAACN,QAAQ,CAACS,IAAI,EAAE;UAClEH,QAAQ,CAACI,QAAQ,CAACD,IAAI,GAAG,KAAK;QAChC;MACF;IACF;EACF;AACF;AAEA,SAASd,mBAAmBA,CAC1BgB,eAAgC,EAChCC,cAAwC;EAExC,IAAID,eAAe,EAAE;IACnB;IACA,IAAIA,eAAe,CAACP,MAAM,KAAKQ,cAAc,CAACR,MAAM,EAAE;MACpD,OAAOS,SAAS,CAAC,CAAC;IACpB;IACA,MAAMT,MAAM,GAAGO,eAAe,CAACP,MAAM;IACrC,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,MAAM,EAAEU,CAAC,EAAE,EAAE;MAC/B,MAAMC,MAAM,GAAGJ,eAAe,CAACG,CAAC,CAAC;MACjC,MAAMtB,KAAK,GAAGoB,cAAc,CAACE,CAAC,CAAC;MAE/B,IAAI,CAAC,CAACC,MAAM,KAAK,CAAC,CAACvB,KAAK,EAAE;QACxB,OAAOqB,SAAS;MAClB,CAAC,MAAM,IAAIE,MAAM,IAAIvB,KAAK,EAAE;QAC1B,MAAMwB,YAAY,GAAGD,MAAM,CAACd,eAAe,CAAC,QAAQ,CAAC;QACrD,MAAMgB,WAAW,GAAGzB,KAAK,CAACS,eAAe,CAAC,QAAQ,CAAC;QAEnD,IAAIe,YAAY,CAAChB,QAAQ,IAAIiB,WAAW,CAACjB,QAAQ,IAAIgB,YAAY,CAAClB,KAAK,KAAKmB,WAAW,CAACnB,KAAK,EAAE;UAC7F;UAEA;UACA,OAAOe,SAAS;QAClB,CAAC,MAAM;UACLF,eAAe,CAACG,CAAC,CAAC,GAAGI,kBAAkB,CAACH,MAAM,EAAEvB,KAAK,CAAC;QACxD;MACF;IACF;EACF,CAAC,MAAM;IACL;IACA,OAAOoB,cAAc,CAACO,GAAG,CAACtB,aAAa,IAAIA,aAAa,CAACuB,KAAK,EAAE,CAAC;EACnE;EACA,OAAOT,eAAe;AACxB;AAEA,SAASO,kBAAkBA,CAACH,MAAqB,EAAEvB,KAAoB;EACrE,KAAK,MAAM6B,IAAI,IAAIxD,yBAAyB,EAAE;IAC5C,MAAMyD,uBAAuB,GAAG3D,uBAAuB,CACrDoD,MAAM,CAACd,eAAe,CAACoB,IAAI,CAAC,EAC5B7B,KAAK,CAACS,eAAe,CAACoB,IAAI,CAAC,EAC3BA,IAAI,EACJ,MAAM;IAEN;IACA,CAACE,EAAiB,EAAEC,EAAiB,KAAI;MACvC,QAAQH,IAAI;QACV,KAAK,OAAO;UACV,OAAO9D,mBAAmB,CAACgE,EAAE,EAAEC,EAAE,CAAC;QACpC,KAAK,WAAW;UACd,OAAO;YACLxB,QAAQ,EAAEuB,EAAE,CAACvB,QAAQ;YAAE;YACvBF,KAAK,EAAE5C,eAAe,CAACqE,EAAE,CAACzB,KAAK,EAAE0B,EAAE,CAAC1B,KAAK;WAC1C;MACL;MACA,OAAOpC,iBAAiB,CAA0B6D,EAAE,EAAEC,EAAE,EAAEH,IAAI,EAAE,MAAM,CAAC;IACzE,CAAC,CACF;IACDN,MAAM,CAACU,eAAe,CAACJ,IAAI,EAAEC,uBAAuB,CAAC;EACvD;EACA,OAAOP,MAAM;AACf;AAEA,SAASW,UAAUA,CACjB5B,KAAQ,EACR6B,QAAkC,EAClCjD,IAAqB,EACrBF,KAAgB,EAChBG,OAA6B;EAE7B,IAAIgD,QAAQ,KAAK,SAAS,EAAE;IAC1B,OAAOjD,IAAI,KAAKmC,SAAS,CAAC,CAAC;EAC7B;EAEAnC,IAAI,GAAGA,IAAI,IAAI,EAAE;EAEjB,QAAQiD,QAAQ;IACd,KAAK,YAAY;IACjB,KAAK,YAAY;MACf,OAAO7B,KAAK,MAAMxC,WAAW,CAACoB,IAAI,CAACkD,UAAU,CAAC,GAAGlD,IAAI,CAACkD,UAAU,GAAGvE,cAAc,CAACqB,IAAI,CAACkD,UAAU,CAAC,CAAC;IACrG,KAAK,QAAQ;MACX,OAAO,CAAC,CAAClD,IAAI,CAACmD,MAAM;IACtB;IACA,KAAK,QAAQ;MACX;MACA,OAAO,CAAC,CAACnD,IAAI,CAACoD,QAAQ,IAAI,CAAC,CAACpD,IAAI,CAACkD,UAAU;IAC7C,KAAK,OAAO;MACV;MACA,IAAI9B,KAAK,KAAK3B,gBAAgB,CAACK,KAAK,EAAEG,OAAO,CAAC,EAAE;QAC9C,OAAO,IAAI;MACb;EACJ;EACA;EACA,OAAOmB,KAAK,KAAMpB,IAAY,CAACiD,QAAQ,CAAC;AAC1C;AAEA;;;AAGA,MAAMI,0BAA0B,GAAG,IAAIC,GAAG,CAAC,CACzC,MAAM;AAAE;AACR,WAAW;AAAE;AACb;AACA,QAAQ,EACR,YAAY,EACZ,QAAQ,EACR,WAAW,EACX,WAAW,EACX,UAAU,EACV,aAAa,CACd,CAAC;AAEF,SAASlD,SAASA,CAACH,OAA6B,EAAEH,KAAgB;EAChE,IAAIE,IAAI,GAAGF,KAAK,CAACE,IAAI,CAACC,OAAO,CAAC;EAE9B,MAAMkB,aAAa,GAAG,IAAIjC,aAAa,EAAE;EAEzC,MAAMqE,eAAe,GAAGhF,kBAAkB,CAACuB,KAAK,CAACsD,QAAQ,CAACnD,OAAO,CAAC,CAEtC;EAE5B,MAAM;IAACuD,IAAI;IAAEC;EAAM,CAAC,GAAG3D,KAAK;EAE5B,MAAMuB,MAAM,GACVrB,IAAI,EAAEqB,MAAM,IACZoC,MAAM,CAACxD,OAAO,KAAK,GAAG,GAAG,OAAO,GAAG,OAAO,CAAC,EAAEoB,MAAM,IACnDoC,MAAM,CAACzD,IAAI,EAAEqB,MAAM,IACnB7B,aAAa,CAACS,OAAO,CAAC;EAExB,MAAMyD,SAAS,GAAG5D,KAAK,CAAC6D,iBAAiB,CAAC1D,OAAO,CAAC,CAAC6B,GAAG,CAAC,MAAM,CAAC;EAE9D,MAAM8B,WAAW,GAAGvE,cAAc,CAACY,OAAO,EAAEyD,SAAS,EAAErC,MAAM,EAAEvB,KAAK,CAAC2D,MAAM,CAAC;EAE5E,MAAMI,OAAO,GACX7D,IAAI,KAAKmC,SAAS,GAAG,CAACnC,IAAI,GAAGZ,aAAa,CAAC,SAAS,EAAEqE,MAAM,CAACK,KAAK,EAAE9D,IAAI,EAAE8D,KAAK,EAAEF,WAAW,CAAC,CAACG,WAAW;EAC3G5C,aAAa,CAACM,GAAG,CAAC,SAAS,EAAEoC,OAAO,EAAE7D,IAAI,KAAKmC,SAAS,CAAC;EACzD,IAAI0B,OAAO,EAAE;IACX,OAAO1C,aAAa;EACtB;EAEAnB,IAAI,GAAGA,IAAI,IAAI,EAAE;EAEjB,MAAMkD,UAAU,GAAGxD,aAAa,CAAC6D,eAAe,EAAEvD,IAAI,EAAEC,OAAO,EAAEwD,MAAM,CAACK,KAAK,EAAEF,WAAW,CAAC;EAC3F,MAAMI,UAAU,GAAGpE,eAAe,CAACI,IAAI,CAACgE,UAAU,EAAET,eAAe,EAAEG,SAAS,CAAC;EAC/E,MAAMO,MAAM,GAAGtE,WAAW,CAAC4D,eAAe,EAAEA,eAAe,CAACW,IAAI,EAAElE,IAAI,CAACiE,MAAM,EAAEjE,IAAI,CAACgE,UAAU,EAAEP,MAAM,EAAE,IAAI,CAAC;EAE7G,MAAMU,UAAU,GAAmB;IACjCZ,eAAe;IACfvD,IAAI;IACJC,OAAO;IACPH,KAAK;IACL4D,SAAS;IACTrC,MAAM;IACN6B,UAAU;IACVe,MAAM;IACND,UAAU;IACVR,IAAI;IACJC;GACD;EACD;EACA,KAAK,MAAMR,QAAQ,IAAI9D,yBAAyB,EAAE;IAChD,MAAMiC,KAAK,GACT6B,QAAQ,IAAI1D,SAAS,GAAGA,SAAS,CAAC0D,QAAQ,CAAC,CAACkB,UAAU,CAAC,GAAG/F,cAAc,CAAC6E,QAAQ,CAAC,GAAGjD,IAAI,CAACiD,QAAQ,CAAC,GAAGd,SAAS;IAEjH,MAAMiC,QAAQ,GAAGhD,KAAK,KAAKe,SAAS;IAEpC,MAAMb,QAAQ,GAAG0B,UAAU,CAAC5B,KAAK,EAAE6B,QAAQ,EAAEjD,IAAI,EAAEF,KAAK,EAAEG,OAAO,CAAC;IAElE,IAAImE,QAAQ,IAAI9C,QAAQ,EAAE;MACxBH,aAAa,CAACM,GAAG,CAACwB,QAAQ,EAAE7B,KAAK,EAAEE,QAAQ,CAAC;IAC9C,CAAC,MAAM;MACL,MAAM;QAACyC,WAAW,GAAG5B,SAAS;QAAEkC,UAAU,GAAGlC;MAAS,CAAC,GACrD/D,cAAc,CAAC6E,QAAQ,CAAC,IAAIA,QAAQ,KAAK,QAAQ,GAC7C7D,aAAa,CAAC6D,QAAQ,EAAEQ,MAAM,CAACK,KAAK,EAAE9D,IAAI,CAAC8D,KAAK,EAAEF,WAAW,CAAC,GAC9D,EAAE;MACR,MAAMU,cAAc,GAAGP,WAAW,KAAK5B,SAAS;MAEhD,IAAIiC,QAAQ,IAAI,CAACE,cAAc,EAAE;QAC/B;QACAnD,aAAa,CAACM,GAAG,CAACwB,QAAQ,EAAE7B,KAAK,EAAEE,QAAQ,CAAC;MAC9C,CAAC,MAAM;MACL;MACA;MACA,EAAE+C,UAAU,KAAK,cAAc,CAAC;MAChC;MACChB,0BAA0B,CAACkB,GAAG,CAACtB,QAAQ,CAAC,IAAIqB,cAAe;MAC5D;MACAjG,sBAAsB,CAAC0F,WAAW,CAAC,IACnCnF,WAAW,CAACmF,WAAW,CAAC,EACxB;QACA;QACA5C,aAAa,CAACM,GAAG,CAACwB,QAAQ,EAAEc,WAAW,EAAE,KAAK,CAAC;MACjD;IACF;EACF;EAEA;EACA,MAAMS,YAAY,GAAGxE,IAAI,CAACoD,QAAQ,IAAI,EAAE;EACxC,MAAMqB,UAAU,GAAGtG,UAAU,CAAC4B,MAAM,CAAC,CAAC2E,CAAe,EAAEC,IAAI,KAAI;IAC7D,IAAI,CAACxD,aAAa,CAACyD,WAAW,CAACD,IAAI,CAAC,EAAE;MACpC;MACA,OAAOD,CAAC;IACV;IAEA,MAAMG,gBAAgB,GAAG/F,gBAAgB,CAAC0F,YAAY,CAACG,IAAI,CAAC,IAAI,EAAE,EAAE7E,KAAK,CAAC;IAE1E,MAAMsB,KAAK,GAAGuD,IAAI,KAAK,QAAQ,GAAGrF,MAAM,CAACwF,MAAM,CAAChF,KAAK,EAAEG,OAAO,EAAE4E,gBAAgB,CAAC,GAAGA,gBAAgB;IAEpG,IAAIzD,KAAK,KAAKe,SAAS,IAAI,CAAC1D,OAAO,CAAC2C,KAAK,CAAC,EAAE;MAC1CsD,CAAC,CAACC,IAAI,CAAC,GAAG;QAACI,MAAM,EAAE3D;MAAK,CAAC;IAC3B;IACA,OAAOsD,CAAC;EACV,CAAC,EAAE,EAAkB,CAAC;EAEtB;EACA,IAAI,CAACjG,OAAO,CAACgG,UAAU,CAAC,EAAE;IACxBtD,aAAa,CAACM,GAAG,CAAC,QAAQ,EAAEgD,UAAU,EAAE,CAAC,CAACzE,IAAI,CAACoD,QAAQ,IAAIpD,IAAI,CAACkD,UAAU,KAAKf,SAAS,CAAC;EAC3F;EAEA,OAAOhB,aAAa;AACtB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}