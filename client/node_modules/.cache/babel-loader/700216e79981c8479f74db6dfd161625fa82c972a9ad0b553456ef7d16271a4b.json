{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isBinParams } from '../bin';\nimport { isConditionalDef, isFieldDef, isScaleFieldDef } from '../channeldef';\nimport { normalizeLogicalComposition } from '../logical';\nimport { SpecMapper } from '../spec/map';\nimport { isBin, isFilter, isLookup } from '../transform';\nimport { duplicate, entries, vals } from '../util';\nexport class SelectionCompatibilityNormalizer extends SpecMapper {\n  map(spec, normParams) {\n    normParams.emptySelections ?? (normParams.emptySelections = {});\n    normParams.selectionPredicates ?? (normParams.selectionPredicates = {});\n    spec = normalizeTransforms(spec, normParams);\n    return super.map(spec, normParams);\n  }\n  mapLayerOrUnit(spec, normParams) {\n    spec = normalizeTransforms(spec, normParams);\n    if (spec.encoding) {\n      const encoding = {};\n      for (const [channel, enc] of entries(spec.encoding)) {\n        encoding[channel] = normalizeChannelDef(enc, normParams);\n      }\n      spec = {\n        ...spec,\n        encoding\n      };\n    }\n    return super.mapLayerOrUnit(spec, normParams);\n  }\n  mapUnit(spec, normParams) {\n    const {\n      selection,\n      ...rest\n    } = spec;\n    if (selection) {\n      return {\n        ...rest,\n        params: entries(selection).map(_ref => {\n          let [name, selDef] = _ref;\n          const {\n            init: value,\n            bind,\n            empty,\n            ...select\n          } = selDef;\n          if (select.type === 'single') {\n            select.type = 'point';\n            select.toggle = false;\n          } else if (select.type === 'multi') {\n            select.type = 'point';\n          }\n          // Propagate emptiness forwards and backwards\n          normParams.emptySelections[name] = empty !== 'none';\n          for (const pred of vals(normParams.selectionPredicates[name] ?? {})) {\n            pred.empty = empty !== 'none';\n          }\n          return {\n            name,\n            value,\n            select,\n            bind\n          };\n        })\n      };\n    }\n    return spec;\n  }\n}\nfunction normalizeTransforms(spec, normParams) {\n  const {\n    transform: tx,\n    ...rest\n  } = spec;\n  if (tx) {\n    const transform = tx.map(t => {\n      if (isFilter(t)) {\n        return {\n          filter: normalizePredicate(t, normParams)\n        };\n      } else if (isBin(t) && isBinParams(t.bin)) {\n        return {\n          ...t,\n          bin: normalizeBinExtent(t.bin)\n        };\n      } else if (isLookup(t)) {\n        const {\n          selection: param,\n          ...from\n        } = t.from;\n        return param ? {\n          ...t,\n          from: {\n            param,\n            ...from\n          }\n        } : t;\n      }\n      return t;\n    });\n    return {\n      ...rest,\n      transform\n    };\n  }\n  return spec;\n}\nfunction normalizeChannelDef(obj, normParams) {\n  const enc = duplicate(obj);\n  if (isFieldDef(enc) && isBinParams(enc.bin)) {\n    enc.bin = normalizeBinExtent(enc.bin);\n  }\n  if (isScaleFieldDef(enc) && enc.scale?.domain?.selection) {\n    const {\n      selection: param,\n      ...domain\n    } = enc.scale.domain;\n    enc.scale.domain = {\n      ...domain,\n      ...(param ? {\n        param\n      } : {})\n    };\n  }\n  if (isConditionalDef(enc)) {\n    if (isArray(enc.condition)) {\n      enc.condition = enc.condition.map(c => {\n        const {\n          selection,\n          param,\n          test,\n          ...cond\n        } = c;\n        return param ? c : {\n          ...cond,\n          test: normalizePredicate(c, normParams)\n        };\n      });\n    } else {\n      const {\n        selection,\n        param,\n        test,\n        ...cond\n      } = normalizeChannelDef(enc.condition, normParams);\n      enc.condition = param ? enc.condition : {\n        ...cond,\n        test: normalizePredicate(enc.condition, normParams)\n      };\n    }\n  }\n  return enc;\n}\nfunction normalizeBinExtent(bin) {\n  const ext = bin.extent;\n  if (ext?.selection) {\n    const {\n      selection: param,\n      ...rest\n    } = ext;\n    return {\n      ...bin,\n      extent: {\n        ...rest,\n        param\n      }\n    };\n  }\n  return bin;\n}\nfunction normalizePredicate(op, normParams) {\n  // Normalize old compositions of selection names (e.g., selection: {and: [\"one\", \"two\"]})\n  const normalizeSelectionComposition = o => {\n    return normalizeLogicalComposition(o, param => {\n      var _a;\n      const empty = normParams.emptySelections[param] ?? true;\n      const pred = {\n        param,\n        empty\n      };\n      (_a = normParams.selectionPredicates)[param] ?? (_a[param] = []);\n      normParams.selectionPredicates[param].push(pred);\n      return pred;\n    });\n  };\n  return op.selection ? normalizeSelectionComposition(op.selection) : normalizeLogicalComposition(op.test || op.filter, o => o.selection ? normalizeSelectionComposition(o.selection) : o);\n}","map":{"version":3,"names":["isArray","isBinParams","isConditionalDef","isFieldDef","isScaleFieldDef","normalizeLogicalComposition","SpecMapper","isBin","isFilter","isLookup","duplicate","entries","vals","SelectionCompatibilityNormalizer","map","spec","normParams","emptySelections","selectionPredicates","normalizeTransforms","mapLayerOrUnit","encoding","channel","enc","normalizeChannelDef","mapUnit","selection","rest","params","_ref","name","selDef","init","value","bind","empty","select","type","toggle","pred","transform","tx","t","filter","normalizePredicate","bin","normalizeBinExtent","param","from","obj","scale","domain","condition","c","test","cond","ext","extent","op","normalizeSelectionComposition","o","_a","push"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\normalize\\selectioncompat.ts"],"sourcesContent":["import {isArray} from 'vega-util';\nimport {BinParams, isBinParams} from '../bin';\nimport {ChannelDef, Field, isConditionalDef, isFieldDef, isScaleFieldDef} from '../channeldef';\nimport {Encoding} from '../encoding';\nimport {LogicalComposition, normalizeLogicalComposition} from '../logical';\nimport {FacetedUnitSpec, GenericSpec, LayerSpec, RepeatSpec, UnitSpec} from '../spec';\nimport {SpecMapper} from '../spec/map';\nimport {isBin, isFilter, isLookup} from '../transform';\nimport {duplicate, entries, vals} from '../util';\nimport {NormalizerParams} from './base';\n\nexport class SelectionCompatibilityNormalizer extends SpecMapper<\n  NormalizerParams,\n  FacetedUnitSpec<Field>,\n  LayerSpec<Field>,\n  UnitSpec<Field>\n> {\n  public map(\n    spec: GenericSpec<FacetedUnitSpec<Field>, LayerSpec<Field>, RepeatSpec, Field>,\n    normParams: NormalizerParams\n  ) {\n    normParams.emptySelections ??= {};\n    normParams.selectionPredicates ??= {};\n    spec = normalizeTransforms(spec, normParams);\n    return super.map(spec, normParams);\n  }\n\n  public mapLayerOrUnit(spec: FacetedUnitSpec<Field> | LayerSpec<Field>, normParams: NormalizerParams) {\n    spec = normalizeTransforms(spec, normParams);\n\n    if (spec.encoding) {\n      const encoding: Encoding<any> = {};\n      for (const [channel, enc] of entries(spec.encoding)) {\n        (encoding as any)[channel] = normalizeChannelDef(enc, normParams);\n      }\n\n      spec = {...spec, encoding};\n    }\n\n    return super.mapLayerOrUnit(spec, normParams);\n  }\n\n  public mapUnit(spec: UnitSpec<Field>, normParams: NormalizerParams) {\n    const {selection, ...rest} = spec as any;\n    if (selection) {\n      return {\n        ...rest,\n        params: entries(selection).map(([name, selDef]) => {\n          const {init: value, bind, empty, ...select} = selDef as any;\n          if (select.type === 'single') {\n            select.type = 'point';\n            select.toggle = false;\n          } else if (select.type === 'multi') {\n            select.type = 'point';\n          }\n\n          // Propagate emptiness forwards and backwards\n          (normParams.emptySelections as any)[name] = empty !== 'none';\n          for (const pred of vals((normParams.selectionPredicates as any)[name] ?? {})) {\n            pred.empty = empty !== 'none';\n          }\n\n          return {name, value, select, bind};\n        })\n      };\n    }\n\n    return spec;\n  }\n}\n\nfunction normalizeTransforms(spec: any, normParams: NormalizerParams) {\n  const {transform: tx, ...rest} = spec;\n  if (tx) {\n    const transform = tx.map((t: any) => {\n      if (isFilter(t)) {\n        return {filter: normalizePredicate(t, normParams)};\n      } else if (isBin(t) && isBinParams(t.bin)) {\n        return {\n          ...t,\n          bin: normalizeBinExtent(t.bin)\n        };\n      } else if (isLookup(t)) {\n        const {selection: param, ...from} = t.from as any;\n        return param\n          ? {\n              ...t,\n              from: {param, ...from}\n            }\n          : t;\n      }\n      return t;\n    });\n\n    return {...rest, transform};\n  }\n\n  return spec;\n}\n\nfunction normalizeChannelDef(obj: any, normParams: NormalizerParams): ChannelDef {\n  const enc = duplicate(obj);\n\n  if (isFieldDef(enc) && isBinParams(enc.bin)) {\n    enc.bin = normalizeBinExtent(enc.bin);\n  }\n\n  if (isScaleFieldDef(enc) && (enc.scale?.domain as any)?.selection) {\n    const {selection: param, ...domain} = enc.scale.domain as any;\n    enc.scale.domain = {...domain, ...(param ? {param} : {})};\n  }\n\n  if (isConditionalDef(enc)) {\n    if (isArray(enc.condition)) {\n      enc.condition = enc.condition.map((c: any) => {\n        const {selection, param, test, ...cond} = c;\n        return param ? c : {...cond, test: normalizePredicate(c, normParams)};\n      });\n    } else {\n      const {selection, param, test, ...cond} = normalizeChannelDef(enc.condition, normParams) as any;\n      enc.condition = param\n        ? enc.condition\n        : {\n            ...cond,\n            test: normalizePredicate(enc.condition, normParams)\n          };\n    }\n  }\n\n  return enc;\n}\n\nfunction normalizeBinExtent(bin: BinParams): BinParams {\n  const ext = bin.extent as any;\n  if (ext?.selection) {\n    const {selection: param, ...rest} = ext;\n    return {...bin, extent: {...rest, param}};\n  }\n\n  return bin;\n}\n\nfunction normalizePredicate(op: any, normParams: NormalizerParams) {\n  // Normalize old compositions of selection names (e.g., selection: {and: [\"one\", \"two\"]})\n  const normalizeSelectionComposition = (o: LogicalComposition<string>) => {\n    return normalizeLogicalComposition(o, param => {\n      const empty = normParams.emptySelections[param] ?? true;\n      const pred = {param, empty};\n      normParams.selectionPredicates[param] ??= [];\n      normParams.selectionPredicates[param].push(pred);\n      return pred as any;\n    });\n  };\n\n  return op.selection\n    ? normalizeSelectionComposition(op.selection)\n    : normalizeLogicalComposition(op.test || op.filter, o =>\n        o.selection ? normalizeSelectionComposition(o.selection) : o\n      );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}