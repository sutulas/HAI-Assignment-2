{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { title as fieldDefTitle } from '../../channeldef';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { assembleAxis } from '../axis/assemble';\nimport { parseGuideResolve } from '../resolve';\nimport { getHeaderProperty } from './common';\nexport function getHeaderType(orient) {\n  if (orient === 'top' || orient === 'left' || isSignalRef(orient)) {\n    // we always use header for orient signal since we can't dynamically make header becomes footer\n    return 'header';\n  }\n  return 'footer';\n}\nexport function parseFacetHeaders(model) {\n  for (const channel of FACET_CHANNELS) {\n    parseFacetHeader(model, channel);\n  }\n  mergeChildAxis(model, 'x');\n  mergeChildAxis(model, 'y');\n}\nfunction parseFacetHeader(model, channel) {\n  const {\n    facet,\n    config,\n    child,\n    component\n  } = model;\n  if (model.channelHasField(channel)) {\n    const fieldDef = facet[channel];\n    const titleConfig = getHeaderProperty('title', null, config, channel);\n    let title = fieldDefTitle(fieldDef, config, {\n      allowDisabling: true,\n      includeDefault: titleConfig === undefined || !!titleConfig\n    });\n    if (child.component.layoutHeaders[channel].title) {\n      // TODO: better handle multiline titles\n      title = isArray(title) ? title.join(', ') : title;\n      // merge title with child to produce \"Title / Subtitle / Sub-subtitle\"\n      title += ` / ${child.component.layoutHeaders[channel].title}`;\n      child.component.layoutHeaders[channel].title = null;\n    }\n    const labelOrient = getHeaderProperty('labelOrient', fieldDef.header, config, channel);\n    const labels = fieldDef.header !== null ? getFirstDefined(fieldDef.header?.labels, config.header.labels, true) : false;\n    const headerType = contains(['bottom', 'right'], labelOrient) ? 'footer' : 'header';\n    component.layoutHeaders[channel] = {\n      title: fieldDef.header !== null ? title : null,\n      facetFieldDef: fieldDef,\n      [headerType]: channel === 'facet' ? [] : [makeHeaderComponent(model, channel, labels)]\n    };\n  }\n}\nfunction makeHeaderComponent(model, channel, labels) {\n  const sizeType = channel === 'row' ? 'height' : 'width';\n  return {\n    labels,\n    sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : undefined,\n    axes: []\n  };\n}\nfunction mergeChildAxis(model, channel) {\n  const {\n    child\n  } = model;\n  if (child.component.axes[channel]) {\n    const {\n      layoutHeaders,\n      resolve\n    } = model.component;\n    resolve.axis[channel] = parseGuideResolve(resolve, channel);\n    if (resolve.axis[channel] === 'shared') {\n      // For shared axis, move the axes to facet's header or footer\n      const headerChannel = channel === 'x' ? 'column' : 'row';\n      const layoutHeader = layoutHeaders[headerChannel];\n      for (const axisComponent of child.component.axes[channel]) {\n        const headerType = getHeaderType(axisComponent.get('orient'));\n        layoutHeader[headerType] ?? (layoutHeader[headerType] = [makeHeaderComponent(model, headerChannel, false)]);\n        // FIXME: assemble shouldn't be called here, but we do it this way so we only extract the main part of the axes\n        const mainAxis = assembleAxis(axisComponent, 'main', model.config, {\n          header: true\n        });\n        if (mainAxis) {\n          // LayoutHeader no longer keep track of property precedence, thus let's combine.\n          layoutHeader[headerType][0].axes.push(mainAxis);\n        }\n        axisComponent.mainExtracted = true;\n      }\n    } else {\n      // Otherwise do nothing for independent axes\n    }\n  }\n}","map":{"version":3,"names":["isArray","FACET_CHANNELS","title","fieldDefTitle","contains","getFirstDefined","isSignalRef","assembleAxis","parseGuideResolve","getHeaderProperty","getHeaderType","orient","parseFacetHeaders","model","channel","parseFacetHeader","mergeChildAxis","facet","config","child","component","channelHasField","fieldDef","titleConfig","allowDisabling","includeDefault","undefined","layoutHeaders","join","labelOrient","header","labels","headerType","facetFieldDef","makeHeaderComponent","sizeType","sizeSignal","layoutSize","get","getSizeSignalRef","axes","resolve","axis","headerChannel","layoutHeader","axisComponent","mainAxis","push","mainExtracted"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\header\\parse.ts"],"sourcesContent":["import {AxisOrient, SignalRef} from 'vega';\nimport {isArray} from 'vega-util';\nimport {FacetChannel, FACET_CHANNELS} from '../../channel';\nimport {title as fieldDefTitle} from '../../channeldef';\nimport {contains, getFirstDefined} from '../../util';\nimport {isSignalRef} from '../../vega.schema';\nimport {assembleAxis} from '../axis/assemble';\nimport {FacetModel} from '../facet';\nimport {parseGuideResolve} from '../resolve';\nimport {getHeaderProperty} from './common';\nimport {HeaderChannel, HeaderComponent} from './component';\n\nexport function getHeaderType(orient: AxisOrient | SignalRef) {\n  if (orient === 'top' || orient === 'left' || isSignalRef(orient)) {\n    // we always use header for orient signal since we can't dynamically make header becomes footer\n    return 'header';\n  }\n  return 'footer';\n}\n\nexport function parseFacetHeaders(model: FacetModel) {\n  for (const channel of FACET_CHANNELS) {\n    parseFacetHeader(model, channel);\n  }\n\n  mergeChildAxis(model, 'x');\n  mergeChildAxis(model, 'y');\n}\n\nfunction parseFacetHeader(model: FacetModel, channel: FacetChannel) {\n  const {facet, config, child, component} = model;\n  if (model.channelHasField(channel)) {\n    const fieldDef = facet[channel];\n    const titleConfig = getHeaderProperty('title', null, config, channel);\n    let title = fieldDefTitle(fieldDef, config, {\n      allowDisabling: true,\n      includeDefault: titleConfig === undefined || !!titleConfig\n    });\n\n    if (child.component.layoutHeaders[channel].title) {\n      // TODO: better handle multiline titles\n      title = isArray(title) ? title.join(', ') : title;\n\n      // merge title with child to produce \"Title / Subtitle / Sub-subtitle\"\n      title += ` / ${child.component.layoutHeaders[channel].title}`;\n      child.component.layoutHeaders[channel].title = null;\n    }\n\n    const labelOrient = getHeaderProperty('labelOrient', fieldDef.header, config, channel);\n\n    const labels =\n      fieldDef.header !== null ? getFirstDefined(fieldDef.header?.labels, config.header.labels, true) : false;\n    const headerType = contains(['bottom', 'right'], labelOrient) ? 'footer' : 'header';\n\n    component.layoutHeaders[channel] = {\n      title: fieldDef.header !== null ? title : null,\n      facetFieldDef: fieldDef,\n      [headerType]: channel === 'facet' ? [] : [makeHeaderComponent(model, channel, labels)]\n    };\n  }\n}\n\nfunction makeHeaderComponent(model: FacetModel, channel: HeaderChannel, labels: boolean): HeaderComponent {\n  const sizeType = channel === 'row' ? 'height' : 'width';\n\n  return {\n    labels,\n    sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : undefined,\n    axes: []\n  };\n}\n\nfunction mergeChildAxis(model: FacetModel, channel: 'x' | 'y') {\n  const {child} = model;\n  if (child.component.axes[channel]) {\n    const {layoutHeaders, resolve} = model.component;\n    resolve.axis[channel] = parseGuideResolve(resolve, channel);\n\n    if (resolve.axis[channel] === 'shared') {\n      // For shared axis, move the axes to facet's header or footer\n      const headerChannel = channel === 'x' ? 'column' : 'row';\n\n      const layoutHeader = layoutHeaders[headerChannel];\n      for (const axisComponent of child.component.axes[channel]) {\n        const headerType = getHeaderType(axisComponent.get('orient'));\n        layoutHeader[headerType] ??= [makeHeaderComponent(model, headerChannel, false)];\n\n        // FIXME: assemble shouldn't be called here, but we do it this way so we only extract the main part of the axes\n        const mainAxis = assembleAxis(axisComponent, 'main', model.config, {header: true});\n        if (mainAxis) {\n          // LayoutHeader no longer keep track of property precedence, thus let's combine.\n          layoutHeader[headerType][0].axes.push(mainAxis);\n        }\n        axisComponent.mainExtracted = true;\n      }\n    } else {\n      // Otherwise do nothing for independent axes\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}