{"ast":null,"code":"import { duplicate } from '../../util';\nimport { expression } from '../predicate';\nimport { DataFlowNode } from './dataflow';\nimport { getDependentFields } from './expressions';\nexport class FilterNode extends DataFlowNode {\n  clone() {\n    return new FilterNode(null, this.model, duplicate(this.filter));\n  }\n  constructor(parent, model, filter) {\n    super(parent);\n    this.model = model;\n    this.filter = filter;\n    // TODO: refactor this to not take a node and\n    // then add a static function makeFromOperand and make the constructor take only an expression\n    this.expr = expression(this.model, this.filter, this);\n    this._dependentFields = getDependentFields(this.expr);\n  }\n  dependentFields() {\n    return this._dependentFields;\n  }\n  producedFields() {\n    return new Set(); // filter does not produce any new fields\n  }\n  assemble() {\n    return {\n      type: 'filter',\n      expr: this.expr\n    };\n  }\n  hash() {\n    return `Filter ${this.expr}`;\n  }\n}","map":{"version":3,"names":["duplicate","expression","DataFlowNode","getDependentFields","FilterNode","clone","model","filter","constructor","parent","expr","_dependentFields","dependentFields","producedFields","Set","assemble","type","hash"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\data\\filter.ts"],"sourcesContent":["import type {FilterTransform as VgFilterTransform} from 'vega';\nimport {LogicalComposition} from '../../logical';\nimport {Predicate} from '../../predicate';\nimport {duplicate} from '../../util';\nimport {Model} from '../model';\nimport {expression} from '../predicate';\nimport {DataFlowNode} from './dataflow';\nimport {getDependentFields} from './expressions';\n\nexport class FilterNode extends DataFlowNode {\n  private expr: string;\n  private _dependentFields: Set<string>;\n  public clone() {\n    return new FilterNode(null, this.model, duplicate(this.filter));\n  }\n\n  constructor(\n    parent: DataFlowNode,\n    private readonly model: Model,\n    private readonly filter: LogicalComposition<Predicate>\n  ) {\n    super(parent);\n\n    // TODO: refactor this to not take a node and\n    // then add a static function makeFromOperand and make the constructor take only an expression\n    this.expr = expression(this.model, this.filter, this);\n\n    this._dependentFields = getDependentFields(this.expr);\n  }\n\n  public dependentFields() {\n    return this._dependentFields;\n  }\n\n  public producedFields() {\n    return new Set<string>(); // filter does not produce any new fields\n  }\n\n  public assemble(): VgFilterTransform {\n    return {\n      type: 'filter',\n      expr: this.expr\n    };\n  }\n\n  public hash() {\n    return `Filter ${this.expr}`;\n  }\n}\n"],"mappings":"AAGA,SAAQA,SAAS,QAAO,YAAY;AAEpC,SAAQC,UAAU,QAAO,cAAc;AACvC,SAAQC,YAAY,QAAO,YAAY;AACvC,SAAQC,kBAAkB,QAAO,eAAe;AAEhD,OAAM,MAAOC,UAAW,SAAQF,YAAY;EAGnCG,KAAKA,CAAA;IACV,OAAO,IAAID,UAAU,CAAC,IAAI,EAAE,IAAI,CAACE,KAAK,EAAEN,SAAS,CAAC,IAAI,CAACO,MAAM,CAAC,CAAC;EACjE;EAEAC,YACEC,MAAoB,EACHH,KAAY,EACZC,MAAqC;IAEtD,KAAK,CAACE,MAAM,CAAC;IAHI,KAAAH,KAAK,GAALA,KAAK;IACL,KAAAC,MAAM,GAANA,MAAM;IAIvB;IACA;IACA,IAAI,CAACG,IAAI,GAAGT,UAAU,CAAC,IAAI,CAACK,KAAK,EAAE,IAAI,CAACC,MAAM,EAAE,IAAI,CAAC;IAErD,IAAI,CAACI,gBAAgB,GAAGR,kBAAkB,CAAC,IAAI,CAACO,IAAI,CAAC;EACvD;EAEOE,eAAeA,CAAA;IACpB,OAAO,IAAI,CAACD,gBAAgB;EAC9B;EAEOE,cAAcA,CAAA;IACnB,OAAO,IAAIC,GAAG,EAAU,CAAC,CAAC;EAC5B;EAEOC,QAAQA,CAAA;IACb,OAAO;MACLC,IAAI,EAAE,QAAQ;MACdN,IAAI,EAAE,IAAI,CAACA;KACZ;EACH;EAEOO,IAAIA,CAAA;IACT,OAAO,UAAU,IAAI,CAACP,IAAI,EAAE;EAC9B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}