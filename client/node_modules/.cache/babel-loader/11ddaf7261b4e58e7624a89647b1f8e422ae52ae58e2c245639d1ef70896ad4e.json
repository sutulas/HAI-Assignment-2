{"ast":null,"code":"import { isFunction } from 'vega-util';\nimport { isBinned, isBinning } from '../../../bin';\nimport { X, X2, Y2, getMainRangeChannel } from '../../../channel';\nimport { binRequiresRange, getBandPosition, isDatumDef, isFieldDef, isFieldOrDatumDef, isTypedFieldDef, isValueDef, vgField } from '../../../channeldef';\nimport { dateTimeToExpr, isDateTime } from '../../../datetime';\nimport { isExprRef } from '../../../expr';\nimport * as log from '../../../log';\nimport { hasDiscreteDomain } from '../../../scale';\nimport { TEMPORAL } from '../../../type';\nimport { contains, stringify } from '../../../util';\nimport { isSignalRef } from '../../../vega.schema';\nimport { signalOrValueRef } from '../../common';\nimport { getConditionalValueRefForIncludingInvalidValue } from './invalid';\nexport function midPointRefWithPositionInvalidTest(params) {\n  const {\n    channel,\n    channelDef,\n    markDef,\n    scale,\n    scaleName,\n    config\n  } = params;\n  const scaleChannel = getMainRangeChannel(channel);\n  const mainRef = midPoint(params);\n  const valueRefForIncludingInvalid = getConditionalValueRefForIncludingInvalidValue({\n    scaleChannel,\n    channelDef,\n    scale,\n    scaleName,\n    markDef,\n    config\n  });\n  return valueRefForIncludingInvalid !== undefined ? [valueRefForIncludingInvalid, mainRef] : mainRef;\n}\nexport function datumDefToExpr(datumDef) {\n  const {\n    datum\n  } = datumDef;\n  if (isDateTime(datum)) {\n    return dateTimeToExpr(datum);\n  }\n  return `${stringify(datum)}`;\n}\nexport function valueRefForFieldOrDatumDef(fieldDef, scaleName, opt, encode) {\n  const ref = {};\n  if (scaleName) {\n    ref.scale = scaleName;\n  }\n  if (isDatumDef(fieldDef)) {\n    const {\n      datum\n    } = fieldDef;\n    if (isDateTime(datum)) {\n      ref.signal = dateTimeToExpr(datum);\n    } else if (isSignalRef(datum)) {\n      ref.signal = datum.signal;\n    } else if (isExprRef(datum)) {\n      ref.signal = datum.expr;\n    } else {\n      ref.value = datum;\n    }\n  } else {\n    ref.field = vgField(fieldDef, opt);\n  }\n  if (encode) {\n    const {\n      offset,\n      band\n    } = encode;\n    if (offset) {\n      ref.offset = offset;\n    }\n    if (band) {\n      ref.band = band;\n    }\n  }\n  return ref;\n}\n/**\n * Signal that returns the middle of a bin from start and end field. Should only be used with x and y.\n */\nexport function interpolatedSignalRef(_ref) {\n  let {\n    scaleName,\n    fieldOrDatumDef,\n    fieldOrDatumDef2,\n    offset,\n    startSuffix,\n    endSuffix = 'end',\n    bandPosition = 0.5\n  } = _ref;\n  const expr = !isSignalRef(bandPosition) && 0 < bandPosition && bandPosition < 1 ? 'datum' : undefined;\n  const start = vgField(fieldOrDatumDef, {\n    expr,\n    suffix: startSuffix\n  });\n  const end = fieldOrDatumDef2 !== undefined ? vgField(fieldOrDatumDef2, {\n    expr\n  }) : vgField(fieldOrDatumDef, {\n    suffix: endSuffix,\n    expr\n  });\n  const ref = {};\n  if (bandPosition === 0 || bandPosition === 1) {\n    ref.scale = scaleName;\n    const field = bandPosition === 0 ? start : end;\n    ref.field = field;\n  } else {\n    const datum = isSignalRef(bandPosition) ? `(1-${bandPosition.signal}) * ${start} + ${bandPosition.signal} * ${end}` : `${1 - bandPosition} * ${start} + ${bandPosition} * ${end}`;\n    ref.signal = `scale(\"${scaleName}\", ${datum})`;\n  }\n  if (offset) {\n    ref.offset = offset;\n  }\n  return ref;\n}\nexport function binSizeExpr(_ref2) {\n  let {\n    scaleName,\n    fieldDef\n  } = _ref2;\n  const start = vgField(fieldDef, {\n    expr: 'datum'\n  });\n  const end = vgField(fieldDef, {\n    expr: 'datum',\n    suffix: 'end'\n  });\n  return `abs(scale(\"${scaleName}\", ${end}) - scale(\"${scaleName}\", ${start}))`;\n}\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\nexport function midPoint(_ref3) {\n  let {\n    channel,\n    channelDef,\n    channel2Def,\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef,\n    bandPosition\n  } = _ref3;\n  // TODO: datum support\n  if (channelDef) {\n    /* istanbul ignore else */\n    if (isFieldOrDatumDef(channelDef)) {\n      const scaleType = scale?.get('type');\n      if (isTypedFieldDef(channelDef)) {\n        bandPosition ?? (bandPosition = getBandPosition({\n          fieldDef: channelDef,\n          fieldDef2: channel2Def,\n          markDef,\n          config\n        }));\n        const {\n          bin,\n          timeUnit,\n          type\n        } = channelDef;\n        if (isBinning(bin) || bandPosition && timeUnit && type === TEMPORAL) {\n          // Use middle only for x an y to place marks in the center between start and end of the bin range.\n          // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n          if (stack?.impute) {\n            // For stack, we computed bin_mid so we can impute.\n            return valueRefForFieldOrDatumDef(channelDef, scaleName, {\n              binSuffix: 'mid'\n            }, {\n              offset\n            });\n          }\n          if (bandPosition && !hasDiscreteDomain(scaleType)) {\n            // if band = 0, no need to call interpolation\n            // For non-stack, we can just calculate bin mid on the fly using signal.\n            return interpolatedSignalRef({\n              scaleName,\n              fieldOrDatumDef: channelDef,\n              bandPosition,\n              offset\n            });\n          }\n          return valueRefForFieldOrDatumDef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? {\n            binSuffix: 'range'\n          } : {}, {\n            offset\n          });\n        } else if (isBinned(bin)) {\n          if (isFieldDef(channel2Def)) {\n            return interpolatedSignalRef({\n              scaleName,\n              fieldOrDatumDef: channelDef,\n              fieldOrDatumDef2: channel2Def,\n              bandPosition,\n              offset\n            });\n          } else {\n            const channel2 = channel === X ? X2 : Y2;\n            log.warn(log.message.channelRequiredForBinned(channel2));\n          }\n        }\n      }\n      return valueRefForFieldOrDatumDef(channelDef, scaleName, hasDiscreteDomain(scaleType) ? {\n        binSuffix: 'range'\n      } : {},\n      // no need for bin suffix if there is no scale\n      {\n        offset,\n        // For band, to get mid point, need to offset by half of the band\n        band: scaleType === 'band' ? bandPosition ?? channelDef.bandPosition ?? 0.5 : undefined\n      });\n    } else if (isValueDef(channelDef)) {\n      const value = channelDef.value;\n      const offsetMixins = offset ? {\n        offset\n      } : {};\n      return {\n        ...widthHeightValueOrSignalRef(channel, value),\n        ...offsetMixins\n      };\n    }\n    // If channelDef is neither field def or value def, it's a condition-only def.\n    // In such case, we will use default ref.\n  }\n  if (isFunction(defaultRef)) {\n    defaultRef = defaultRef();\n  }\n  if (defaultRef) {\n    // for non-position, ref could be undefined.\n    return {\n      ...defaultRef,\n      // only include offset when it is non-zero (zero = no offset)\n      ...(offset ? {\n        offset\n      } : {})\n    };\n  }\n  return defaultRef;\n}\n/**\n * Convert special \"width\" and \"height\" values in Vega-Lite into Vega value ref.\n */\nexport function widthHeightValueOrSignalRef(channel, value) {\n  if (contains(['x', 'x2'], channel) && value === 'width') {\n    return {\n      field: {\n        group: 'width'\n      }\n    };\n  } else if (contains(['y', 'y2'], channel) && value === 'height') {\n    return {\n      field: {\n        group: 'height'\n      }\n    };\n  }\n  return signalOrValueRef(value);\n}","map":{"version":3,"names":["isFunction","isBinned","isBinning","X","X2","Y2","getMainRangeChannel","binRequiresRange","getBandPosition","isDatumDef","isFieldDef","isFieldOrDatumDef","isTypedFieldDef","isValueDef","vgField","dateTimeToExpr","isDateTime","isExprRef","log","hasDiscreteDomain","TEMPORAL","contains","stringify","isSignalRef","signalOrValueRef","getConditionalValueRefForIncludingInvalidValue","midPointRefWithPositionInvalidTest","params","channel","channelDef","markDef","scale","scaleName","config","scaleChannel","mainRef","midPoint","valueRefForIncludingInvalid","undefined","datumDefToExpr","datumDef","datum","valueRefForFieldOrDatumDef","fieldDef","opt","encode","ref","signal","expr","value","field","offset","band","interpolatedSignalRef","_ref","fieldOrDatumDef","fieldOrDatumDef2","startSuffix","endSuffix","bandPosition","start","suffix","end","binSizeExpr","_ref2","_ref3","channel2Def","stack","defaultRef","scaleType","get","fieldDef2","bin","timeUnit","type","impute","binSuffix","channel2","warn","message","channelRequiredForBinned","offsetMixins","widthHeightValueOrSignalRef","group"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\mark\\encode\\valueref.ts"],"sourcesContent":["/**\n * Utility files for producing Vega ValueRef for marks\n */\nimport type {SignalRef} from 'vega';\nimport {isFunction} from 'vega-util';\nimport {isBinned, isBinning} from '../../../bin';\nimport {Channel, PolarPositionChannel, PositionChannel, X, X2, Y2, getMainRangeChannel} from '../../../channel';\nimport {\n  ChannelDef,\n  DatumDef,\n  FieldDefBase,\n  FieldRefOption,\n  SecondaryChannelDef,\n  SecondaryFieldDef,\n  TypedFieldDef,\n  Value,\n  binRequiresRange,\n  getBandPosition,\n  isDatumDef,\n  isFieldDef,\n  isFieldOrDatumDef,\n  isTypedFieldDef,\n  isValueDef,\n  vgField\n} from '../../../channeldef';\nimport {Config} from '../../../config';\nimport {dateTimeToExpr, isDateTime} from '../../../datetime';\nimport {isExprRef} from '../../../expr';\nimport * as log from '../../../log';\nimport {Mark, MarkDef} from '../../../mark';\nimport {hasDiscreteDomain} from '../../../scale';\nimport {StackProperties} from '../../../stack';\nimport {TEMPORAL} from '../../../type';\nimport {contains, stringify} from '../../../util';\nimport {VgValueRef, isSignalRef} from '../../../vega.schema';\nimport {signalOrValueRef} from '../../common';\nimport {ScaleComponent} from '../../scale/component';\nimport {getConditionalValueRefForIncludingInvalidValue} from './invalid';\n\nexport function midPointRefWithPositionInvalidTest(\n  params: MidPointParams & {\n    channel: PositionChannel | PolarPositionChannel;\n  }\n): VgValueRef | VgValueRef[] {\n  const {channel, channelDef, markDef, scale, scaleName, config} = params;\n  const scaleChannel = getMainRangeChannel(channel);\n  const mainRef = midPoint(params);\n\n  const valueRefForIncludingInvalid = getConditionalValueRefForIncludingInvalidValue({\n    scaleChannel,\n    channelDef,\n    scale,\n    scaleName,\n    markDef,\n    config\n  });\n\n  return valueRefForIncludingInvalid !== undefined ? [valueRefForIncludingInvalid, mainRef] : mainRef;\n}\n\nexport function datumDefToExpr(datumDef: DatumDef<string>) {\n  const {datum} = datumDef;\n  if (isDateTime(datum)) {\n    return dateTimeToExpr(datum);\n  }\n  return `${stringify(datum)}`;\n}\n\nexport function valueRefForFieldOrDatumDef(\n  fieldDef: FieldDefBase<string> | DatumDef<string>,\n  scaleName: string,\n  opt: FieldRefOption,\n  encode: {offset?: number | VgValueRef; band?: number | boolean | SignalRef}\n): VgValueRef {\n  const ref: VgValueRef = {};\n\n  if (scaleName) {\n    ref.scale = scaleName;\n  }\n\n  if (isDatumDef<string>(fieldDef)) {\n    const {datum} = fieldDef;\n    if (isDateTime(datum)) {\n      ref.signal = dateTimeToExpr(datum);\n    } else if (isSignalRef(datum)) {\n      ref.signal = datum.signal;\n    } else if (isExprRef(datum)) {\n      ref.signal = datum.expr;\n    } else {\n      ref.value = datum;\n    }\n  } else {\n    ref.field = vgField(fieldDef, opt);\n  }\n\n  if (encode) {\n    const {offset, band} = encode;\n    if (offset) {\n      ref.offset = offset;\n    }\n    if (band) {\n      ref.band = band;\n    }\n  }\n  return ref;\n}\n\n/**\n * Signal that returns the middle of a bin from start and end field. Should only be used with x and y.\n */\nexport function interpolatedSignalRef({\n  scaleName,\n  fieldOrDatumDef,\n  fieldOrDatumDef2,\n  offset,\n  startSuffix,\n  endSuffix = 'end',\n  bandPosition = 0.5\n}: {\n  scaleName: string;\n  fieldOrDatumDef: TypedFieldDef<string>;\n  fieldOrDatumDef2?: SecondaryFieldDef<string>;\n  startSuffix?: string;\n  endSuffix?: string;\n  offset: number | SignalRef | VgValueRef;\n  bandPosition: number | SignalRef;\n}): VgValueRef {\n  const expr = !isSignalRef(bandPosition) && 0 < bandPosition && bandPosition < 1 ? 'datum' : undefined;\n  const start = vgField(fieldOrDatumDef, {expr, suffix: startSuffix});\n  const end =\n    fieldOrDatumDef2 !== undefined\n      ? vgField(fieldOrDatumDef2, {expr})\n      : vgField(fieldOrDatumDef, {suffix: endSuffix, expr});\n\n  const ref: VgValueRef = {};\n\n  if (bandPosition === 0 || bandPosition === 1) {\n    ref.scale = scaleName;\n    const field = bandPosition === 0 ? start : end;\n    ref.field = field;\n  } else {\n    const datum = isSignalRef(bandPosition)\n      ? `(1-${bandPosition.signal}) * ${start} + ${bandPosition.signal} * ${end}`\n      : `${1 - bandPosition} * ${start} + ${bandPosition} * ${end}`;\n    ref.signal = `scale(\"${scaleName}\", ${datum})`;\n  }\n\n  if (offset) {\n    ref.offset = offset;\n  }\n  return ref;\n}\n\nexport function binSizeExpr({scaleName, fieldDef}: {scaleName: string; fieldDef: TypedFieldDef<string>}) {\n  const start = vgField(fieldDef, {expr: 'datum'});\n  const end = vgField(fieldDef, {expr: 'datum', suffix: 'end'});\n  return `abs(scale(\"${scaleName}\", ${end}) - scale(\"${scaleName}\", ${start}))`;\n}\n\nexport interface MidPointParams {\n  channel: Channel;\n  channelDef: ChannelDef;\n  channel2Def?: SecondaryChannelDef<string>;\n\n  markDef: MarkDef<Mark, SignalRef>;\n  config: Config<SignalRef>;\n\n  scaleName: string;\n  scale: ScaleComponent;\n  stack?: StackProperties;\n  offset?: number | SignalRef | VgValueRef;\n  defaultRef: VgValueRef | (() => VgValueRef);\n\n  bandPosition?: number | SignalRef;\n}\n\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\nexport function midPoint({\n  channel,\n  channelDef,\n  channel2Def,\n  markDef,\n  config,\n  scaleName,\n  scale,\n  stack,\n  offset,\n  defaultRef,\n  bandPosition\n}: MidPointParams): VgValueRef {\n  // TODO: datum support\n  if (channelDef) {\n    /* istanbul ignore else */\n\n    if (isFieldOrDatumDef(channelDef)) {\n      const scaleType = scale?.get('type');\n      if (isTypedFieldDef(channelDef)) {\n        bandPosition ??= getBandPosition({\n          fieldDef: channelDef,\n          fieldDef2: channel2Def,\n          markDef,\n          config\n        });\n        const {bin, timeUnit, type} = channelDef;\n\n        if (isBinning(bin) || (bandPosition && timeUnit && type === TEMPORAL)) {\n          // Use middle only for x an y to place marks in the center between start and end of the bin range.\n          // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n          if (stack?.impute) {\n            // For stack, we computed bin_mid so we can impute.\n            return valueRefForFieldOrDatumDef(channelDef, scaleName, {binSuffix: 'mid'}, {offset});\n          }\n\n          if (bandPosition && !hasDiscreteDomain(scaleType)) {\n            // if band = 0, no need to call interpolation\n            // For non-stack, we can just calculate bin mid on the fly using signal.\n            return interpolatedSignalRef({scaleName, fieldOrDatumDef: channelDef, bandPosition, offset});\n          }\n          return valueRefForFieldOrDatumDef(\n            channelDef,\n            scaleName,\n            binRequiresRange(channelDef, channel) ? {binSuffix: 'range'} : {},\n            {\n              offset\n            }\n          );\n        } else if (isBinned(bin)) {\n          if (isFieldDef(channel2Def)) {\n            return interpolatedSignalRef({\n              scaleName,\n              fieldOrDatumDef: channelDef,\n              fieldOrDatumDef2: channel2Def,\n              bandPosition,\n              offset\n            });\n          } else {\n            const channel2 = channel === X ? X2 : Y2;\n            log.warn(log.message.channelRequiredForBinned(channel2));\n          }\n        }\n      }\n\n      return valueRefForFieldOrDatumDef(\n        channelDef,\n        scaleName,\n        hasDiscreteDomain(scaleType) ? {binSuffix: 'range'} : {}, // no need for bin suffix if there is no scale\n        {\n          offset,\n          // For band, to get mid point, need to offset by half of the band\n          band: scaleType === 'band' ? (bandPosition ?? channelDef.bandPosition ?? 0.5) : undefined\n        }\n      );\n    } else if (isValueDef(channelDef)) {\n      const value = channelDef.value;\n      const offsetMixins = offset ? {offset} : {};\n\n      return {...widthHeightValueOrSignalRef(channel, value), ...offsetMixins};\n    }\n\n    // If channelDef is neither field def or value def, it's a condition-only def.\n    // In such case, we will use default ref.\n  }\n\n  if (isFunction(defaultRef)) {\n    defaultRef = defaultRef();\n  }\n\n  if (defaultRef) {\n    // for non-position, ref could be undefined.\n    return {\n      ...defaultRef,\n      // only include offset when it is non-zero (zero = no offset)\n      ...(offset ? {offset} : {})\n    };\n  }\n  return defaultRef;\n}\n\n/**\n * Convert special \"width\" and \"height\" values in Vega-Lite into Vega value ref.\n */\nexport function widthHeightValueOrSignalRef(channel: Channel, value: Value | SignalRef) {\n  if (contains(['x', 'x2'], channel) && value === 'width') {\n    return {field: {group: 'width'}};\n  } else if (contains(['y', 'y2'], channel) && value === 'height') {\n    return {field: {group: 'height'}};\n  }\n  return signalOrValueRef(value);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}