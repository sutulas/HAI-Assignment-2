{"ast":null,"code":"import { isConditionalDef } from '../../../channeldef';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { wrapCondition } from './conditional';\nimport * as ref from './valueref';\nimport { getConditionalValueRefForIncludingInvalidValue } from './invalid';\n/**\n * Return encode for non-positional channels with scales. (Text doesn't have scale.)\n */\nexport function nonPosition(channel, model) {\n  let opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    markDef,\n    encoding,\n    config\n  } = model;\n  const {\n    vgChannel\n  } = opt;\n  let {\n    defaultRef,\n    defaultValue\n  } = opt;\n  const channelDef = encoding[channel];\n  if (defaultRef === undefined) {\n    // prettier-ignore\n    defaultValue ?? (defaultValue = getMarkPropOrConfig(channel, markDef, config, {\n      vgChannel,\n      // If there is no conditonal def, we ignore vgConfig so the output spec is concise.\n      // However, if there is a conditional def, we must include vgConfig so the default is respected.\n      ignoreVgConfig: !isConditionalDef(channelDef)\n    }));\n    if (defaultValue !== undefined) {\n      defaultRef = signalOrValueRef(defaultValue);\n    }\n  }\n  const commonProps = {\n    markDef,\n    config,\n    scaleName: model.scaleName(channel),\n    scale: model.getScaleComponent(channel)\n  };\n  const invalidValueRef = getConditionalValueRefForIncludingInvalidValue({\n    ...commonProps,\n    scaleChannel: channel,\n    channelDef\n  });\n  const mainRefFn = cDef => {\n    return ref.midPoint({\n      ...commonProps,\n      channel,\n      channelDef: cDef,\n      stack: null,\n      // No need to provide stack for non-position as it does not affect mid point\n      defaultRef\n    });\n  };\n  return wrapCondition({\n    model,\n    channelDef,\n    vgChannel: vgChannel ?? channel,\n    invalidValueRef,\n    mainRefFn\n  });\n}","map":{"version":3,"names":["isConditionalDef","getMarkPropOrConfig","signalOrValueRef","wrapCondition","ref","getConditionalValueRefForIncludingInvalidValue","nonPosition","channel","model","opt","arguments","length","undefined","markDef","encoding","config","vgChannel","defaultRef","defaultValue","channelDef","ignoreVgConfig","commonProps","scaleName","scale","getScaleComponent","invalidValueRef","scaleChannel","mainRefFn","cDef","midPoint","stack"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\mark\\encode\\nonposition.ts"],"sourcesContent":["import type {SignalRef} from 'vega';\nimport {NonPositionScaleChannel} from '../../../channel';\nimport {Value, isConditionalDef} from '../../../channeldef';\nimport {VgEncodeChannel, VgEncodeEntry, VgValueRef} from '../../../vega.schema';\nimport {getMarkPropOrConfig, signalOrValueRef} from '../../common';\nimport {UnitModel} from '../../unit';\nimport {wrapCondition} from './conditional';\nimport * as ref from './valueref';\nimport {getConditionalValueRefForIncludingInvalidValue} from './invalid';\n\n/**\n * Return encode for non-positional channels with scales. (Text doesn't have scale.)\n */\nexport function nonPosition(\n  channel: NonPositionScaleChannel,\n  model: UnitModel,\n  opt: {\n    defaultValue?: Value | SignalRef;\n    vgChannel?: VgEncodeChannel;\n    defaultRef?: VgValueRef;\n  } = {}\n): VgEncodeEntry {\n  const {markDef, encoding, config} = model;\n  const {vgChannel} = opt;\n  let {defaultRef, defaultValue} = opt;\n\n  const channelDef = encoding[channel];\n\n  if (defaultRef === undefined) {\n    // prettier-ignore\n    defaultValue ??= getMarkPropOrConfig(channel, markDef, config, {\n      vgChannel,\n      // If there is no conditonal def, we ignore vgConfig so the output spec is concise.\n      // However, if there is a conditional def, we must include vgConfig so the default is respected.\n      ignoreVgConfig: !isConditionalDef(channelDef)\n    });\n\n    if (defaultValue !== undefined) {\n      defaultRef = signalOrValueRef(defaultValue);\n    }\n  }\n\n  const commonProps = {\n    markDef,\n    config,\n    scaleName: model.scaleName(channel),\n    scale: model.getScaleComponent(channel)\n  };\n\n  const invalidValueRef = getConditionalValueRefForIncludingInvalidValue({\n    ...commonProps,\n    scaleChannel: channel,\n    channelDef\n  });\n\n  const mainRefFn = (cDef: typeof channelDef) => {\n    return ref.midPoint({\n      ...commonProps,\n      channel,\n      channelDef: cDef,\n      stack: null, // No need to provide stack for non-position as it does not affect mid point\n      defaultRef\n    });\n  };\n\n  return wrapCondition({\n    model,\n    channelDef,\n    vgChannel: vgChannel ?? channel,\n    invalidValueRef,\n    mainRefFn\n  });\n}\n"],"mappings":"AAEA,SAAeA,gBAAgB,QAAO,qBAAqB;AAE3D,SAAQC,mBAAmB,EAAEC,gBAAgB,QAAO,cAAc;AAElE,SAAQC,aAAa,QAAO,eAAe;AAC3C,OAAO,KAAKC,GAAG,MAAM,YAAY;AACjC,SAAQC,8CAA8C,QAAO,WAAW;AAExE;;;AAGA,OAAM,SAAUC,WAAWA,CACzBC,OAAgC,EAChCC,KAAgB,EAKV;EAAA,IAJNC,GAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAII,EAAE;EAEN,MAAM;IAACG,OAAO;IAAEC,QAAQ;IAAEC;EAAM,CAAC,GAAGP,KAAK;EACzC,MAAM;IAACQ;EAAS,CAAC,GAAGP,GAAG;EACvB,IAAI;IAACQ,UAAU;IAAEC;EAAY,CAAC,GAAGT,GAAG;EAEpC,MAAMU,UAAU,GAAGL,QAAQ,CAACP,OAAO,CAAC;EAEpC,IAAIU,UAAU,KAAKL,SAAS,EAAE;IAC5B;IACAM,YAAY,KAAZA,YAAY,GAAKjB,mBAAmB,CAACM,OAAO,EAAEM,OAAO,EAAEE,MAAM,EAAE;MAC7DC,SAAS;MACT;MACA;MACAI,cAAc,EAAE,CAACpB,gBAAgB,CAACmB,UAAU;KAC7C,CAAC;IAEF,IAAID,YAAY,KAAKN,SAAS,EAAE;MAC9BK,UAAU,GAAGf,gBAAgB,CAACgB,YAAY,CAAC;IAC7C;EACF;EAEA,MAAMG,WAAW,GAAG;IAClBR,OAAO;IACPE,MAAM;IACNO,SAAS,EAAEd,KAAK,CAACc,SAAS,CAACf,OAAO,CAAC;IACnCgB,KAAK,EAAEf,KAAK,CAACgB,iBAAiB,CAACjB,OAAO;GACvC;EAED,MAAMkB,eAAe,GAAGpB,8CAA8C,CAAC;IACrE,GAAGgB,WAAW;IACdK,YAAY,EAAEnB,OAAO;IACrBY;GACD,CAAC;EAEF,MAAMQ,SAAS,GAAIC,IAAuB,IAAI;IAC5C,OAAOxB,GAAG,CAACyB,QAAQ,CAAC;MAClB,GAAGR,WAAW;MACdd,OAAO;MACPY,UAAU,EAAES,IAAI;MAChBE,KAAK,EAAE,IAAI;MAAE;MACbb;KACD,CAAC;EACJ,CAAC;EAED,OAAOd,aAAa,CAAC;IACnBK,KAAK;IACLW,UAAU;IACVH,SAAS,EAAEA,SAAS,IAAIT,OAAO;IAC/BkB,eAAe;IACfE;GACD,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}