{"ast":null,"code":"import { contains } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { isConcatModel, isLayerModel } from '../model';\nexport function assembleProjections(model) {\n  if (isLayerModel(model) || isConcatModel(model)) {\n    return assembleProjectionsForModelAndChildren(model);\n  } else {\n    return assembleProjectionForModel(model);\n  }\n}\nexport function assembleProjectionsForModelAndChildren(model) {\n  return model.children.reduce((projections, child) => {\n    return projections.concat(child.assembleProjections());\n  }, assembleProjectionForModel(model));\n}\nexport function assembleProjectionForModel(model) {\n  const component = model.component.projection;\n  if (!component || component.merged) {\n    return [];\n  }\n  const projection = component.combine();\n  const {\n    name\n  } = projection; // we need to extract name so that it is always present in the output and pass TS type validation\n  if (!component.data) {\n    // generate custom projection, no automatic fitting\n    return [{\n      name,\n      // translate to center by default\n      translate: {\n        signal: '[width / 2, height / 2]'\n      },\n      // parameters, overwrite default translate if specified\n      ...projection\n    }];\n  } else {\n    // generate projection that uses extent fitting\n    const size = {\n      signal: `[${component.size.map(ref => ref.signal).join(', ')}]`\n    };\n    const fits = component.data.reduce((sources, data) => {\n      const source = isSignalRef(data) ? data.signal : `data('${model.lookupDataSource(data)}')`;\n      if (!contains(sources, source)) {\n        // build a unique list of sources\n        sources.push(source);\n      }\n      return sources;\n    }, []);\n    if (fits.length <= 0) {\n      throw new Error(\"Projection's fit didn't find any data sources\");\n    }\n    return [{\n      name,\n      size,\n      fit: {\n        signal: fits.length > 1 ? `[${fits.join(', ')}]` : fits[0]\n      },\n      ...projection\n    }];\n  }\n}","map":{"version":3,"names":["contains","isSignalRef","isConcatModel","isLayerModel","assembleProjections","model","assembleProjectionsForModelAndChildren","assembleProjectionForModel","children","reduce","projections","child","concat","component","projection","merged","combine","name","data","translate","signal","size","map","ref","join","fits","sources","source","lookupDataSource","push","length","Error","fit"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\projection\\assemble.ts"],"sourcesContent":["import {Projection as VgProjection, SignalRef} from 'vega';\nimport {contains} from '../../util';\nimport {isSignalRef} from '../../vega.schema';\nimport {isConcatModel, isLayerModel, Model} from '../model';\n\nexport function assembleProjections(model: Model): VgProjection[] {\n  if (isLayerModel(model) || isConcatModel(model)) {\n    return assembleProjectionsForModelAndChildren(model);\n  } else {\n    return assembleProjectionForModel(model);\n  }\n}\n\nexport function assembleProjectionsForModelAndChildren(model: Model): VgProjection[] {\n  return model.children.reduce((projections, child) => {\n    return projections.concat(child.assembleProjections());\n  }, assembleProjectionForModel(model));\n}\n\nexport function assembleProjectionForModel(model: Model): VgProjection[] {\n  const component = model.component.projection;\n  if (!component || component.merged) {\n    return [];\n  }\n\n  const projection = component.combine();\n  const {name} = projection; // we need to extract name so that it is always present in the output and pass TS type validation\n\n  if (!component.data) {\n    // generate custom projection, no automatic fitting\n    return [\n      {\n        name,\n        // translate to center by default\n        translate: {signal: '[width / 2, height / 2]'},\n        // parameters, overwrite default translate if specified\n        ...projection\n      }\n    ];\n  } else {\n    // generate projection that uses extent fitting\n    const size: SignalRef = {\n      signal: `[${component.size.map(ref => ref.signal).join(', ')}]`\n    };\n\n    const fits: string[] = component.data.reduce((sources, data) => {\n      const source: string = isSignalRef(data) ? data.signal : `data('${model.lookupDataSource(data)}')`;\n      if (!contains(sources, source)) {\n        // build a unique list of sources\n        sources.push(source);\n      }\n      return sources;\n    }, []);\n\n    if (fits.length <= 0) {\n      throw new Error(\"Projection's fit didn't find any data sources\");\n    }\n\n    return [\n      {\n        name,\n        size,\n        fit: {\n          signal: fits.length > 1 ? `[${fits.join(', ')}]` : fits[0]\n        },\n        ...projection\n      }\n    ];\n  }\n}\n"],"mappings":"AACA,SAAQA,QAAQ,QAAO,YAAY;AACnC,SAAQC,WAAW,QAAO,mBAAmB;AAC7C,SAAQC,aAAa,EAAEC,YAAY,QAAc,UAAU;AAE3D,OAAM,SAAUC,mBAAmBA,CAACC,KAAY;EAC9C,IAAIF,YAAY,CAACE,KAAK,CAAC,IAAIH,aAAa,CAACG,KAAK,CAAC,EAAE;IAC/C,OAAOC,sCAAsC,CAACD,KAAK,CAAC;EACtD,CAAC,MAAM;IACL,OAAOE,0BAA0B,CAACF,KAAK,CAAC;EAC1C;AACF;AAEA,OAAM,SAAUC,sCAAsCA,CAACD,KAAY;EACjE,OAAOA,KAAK,CAACG,QAAQ,CAACC,MAAM,CAAC,CAACC,WAAW,EAAEC,KAAK,KAAI;IAClD,OAAOD,WAAW,CAACE,MAAM,CAACD,KAAK,CAACP,mBAAmB,EAAE,CAAC;EACxD,CAAC,EAAEG,0BAA0B,CAACF,KAAK,CAAC,CAAC;AACvC;AAEA,OAAM,SAAUE,0BAA0BA,CAACF,KAAY;EACrD,MAAMQ,SAAS,GAAGR,KAAK,CAACQ,SAAS,CAACC,UAAU;EAC5C,IAAI,CAACD,SAAS,IAAIA,SAAS,CAACE,MAAM,EAAE;IAClC,OAAO,EAAE;EACX;EAEA,MAAMD,UAAU,GAAGD,SAAS,CAACG,OAAO,EAAE;EACtC,MAAM;IAACC;EAAI,CAAC,GAAGH,UAAU,CAAC,CAAC;EAE3B,IAAI,CAACD,SAAS,CAACK,IAAI,EAAE;IACnB;IACA,OAAO,CACL;MACED,IAAI;MACJ;MACAE,SAAS,EAAE;QAACC,MAAM,EAAE;MAAyB,CAAC;MAC9C;MACA,GAAGN;KACJ,CACF;EACH,CAAC,MAAM;IACL;IACA,MAAMO,IAAI,GAAc;MACtBD,MAAM,EAAE,IAAIP,SAAS,CAACQ,IAAI,CAACC,GAAG,CAACC,GAAG,IAAIA,GAAG,CAACH,MAAM,CAAC,CAACI,IAAI,CAAC,IAAI,CAAC;KAC7D;IAED,MAAMC,IAAI,GAAaZ,SAAS,CAACK,IAAI,CAACT,MAAM,CAAC,CAACiB,OAAO,EAAER,IAAI,KAAI;MAC7D,MAAMS,MAAM,GAAW1B,WAAW,CAACiB,IAAI,CAAC,GAAGA,IAAI,CAACE,MAAM,GAAG,SAASf,KAAK,CAACuB,gBAAgB,CAACV,IAAI,CAAC,IAAI;MAClG,IAAI,CAAClB,QAAQ,CAAC0B,OAAO,EAAEC,MAAM,CAAC,EAAE;QAC9B;QACAD,OAAO,CAACG,IAAI,CAACF,MAAM,CAAC;MACtB;MACA,OAAOD,OAAO;IAChB,CAAC,EAAE,EAAE,CAAC;IAEN,IAAID,IAAI,CAACK,MAAM,IAAI,CAAC,EAAE;MACpB,MAAM,IAAIC,KAAK,CAAC,+CAA+C,CAAC;IAClE;IAEA,OAAO,CACL;MACEd,IAAI;MACJI,IAAI;MACJW,GAAG,EAAE;QACHZ,MAAM,EAAEK,IAAI,CAACK,MAAM,GAAG,CAAC,GAAG,IAAIL,IAAI,CAACD,IAAI,CAAC,IAAI,CAAC,GAAG,GAAGC,IAAI,CAAC,CAAC;OAC1D;MACD,GAAGX;KACJ,CACF;EACH;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}