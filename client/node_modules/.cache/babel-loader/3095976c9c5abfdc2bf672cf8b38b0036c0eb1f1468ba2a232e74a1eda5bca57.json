{"ast":null,"code":"import { SCALE_CHANNELS, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { channelHasNestedOffsetScale } from '../../encoding';\nimport { GEOSHAPE } from '../../mark';\nimport { NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES, scaleCompatible, scaleTypePrecedence } from '../../scale';\nimport { GEOJSON } from '../../type';\nimport { keys } from '../../util';\nimport { isUnitModel } from '../model';\nimport { defaultScaleResolve } from '../resolve';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { ScaleComponent } from './component';\nimport { parseScaleDomain } from './domain';\nimport { parseScaleProperty, parseScaleRange } from './properties';\nimport { scaleType } from './type';\nexport function parseScales(model) {\n  let {\n    ignoreRange\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  parseScaleCore(model);\n  parseScaleDomain(model);\n  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {\n    parseScaleProperty(model, prop);\n  }\n  if (!ignoreRange) {\n    // range depends on zero\n    parseScaleRange(model);\n  }\n}\nexport function parseScaleCore(model) {\n  if (isUnitModel(model)) {\n    model.component.scales = parseUnitScaleCore(model);\n  } else {\n    model.component.scales = parseNonUnitScaleCore(model);\n  }\n}\n/**\n * Parse scales for all channels of a model.\n */\nfunction parseUnitScaleCore(model) {\n  const {\n    encoding,\n    mark,\n    markDef\n  } = model;\n  const scaleComponents = {};\n  for (const channel of SCALE_CHANNELS) {\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]); // must be typed def to have scale\n    // Don't generate scale for shape of geoshape\n    if (fieldOrDatumDef && mark === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {\n      continue;\n    }\n    let specifiedScale = fieldOrDatumDef && fieldOrDatumDef.scale;\n    if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {\n      specifiedScale ?? (specifiedScale = {});\n      const hasNestedOffsetScale = channelHasNestedOffsetScale(encoding, channel);\n      const sType = scaleType(specifiedScale, channel, fieldOrDatumDef, markDef, hasNestedOffsetScale);\n      scaleComponents[channel] = new ScaleComponent(model.scaleName(`${channel}`, true), {\n        value: sType,\n        explicit: specifiedScale.type === sType\n      });\n    }\n  }\n  return scaleComponents;\n}\nconst scaleTypeTieBreaker = tieBreakByComparing((st1, st2) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2));\nfunction parseNonUnitScaleCore(model) {\n  var _a;\n  const scaleComponents = model.component.scales = {};\n  const scaleTypeWithExplicitIndex = {};\n  const resolve = model.component.resolve;\n  // Parse each child scale and determine if a particular channel can be merged.\n  for (const child of model.children) {\n    parseScaleCore(child);\n    // Instead of always merging right away -- check if it is compatible to merge first!\n    for (const channel of keys(child.component.scales)) {\n      // if resolve is undefined, set default first\n      (_a = resolve.scale)[channel] ?? (_a[channel] = defaultScaleResolve(channel, model));\n      if (resolve.scale[channel] === 'shared') {\n        const explicitScaleType = scaleTypeWithExplicitIndex[channel];\n        const childScaleType = child.component.scales[channel].getWithExplicit('type');\n        if (explicitScaleType) {\n          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n            // merge scale component if type are compatible\n            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, 'type', 'scale', scaleTypeTieBreaker);\n          } else {\n            // Otherwise, update conflicting channel to be independent\n            resolve.scale[channel] = 'independent';\n            // Remove from the index so they don't get merged\n            delete scaleTypeWithExplicitIndex[channel];\n          }\n        } else {\n          scaleTypeWithExplicitIndex[channel] = childScaleType;\n        }\n      }\n    }\n  }\n  // Merge each channel listed in the index\n  for (const channel of keys(scaleTypeWithExplicitIndex)) {\n    // Create new merged scale component\n    const name = model.scaleName(channel, true);\n    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n    scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit);\n    // rename each child and mark them as merged\n    for (const child of model.children) {\n      const childScale = child.component.scales[channel];\n      if (childScale) {\n        child.renameScale(childScale.get('name'), name);\n        childScale.merged = true;\n      }\n    }\n  }\n  return scaleComponents;\n}","map":{"version":3,"names":["SCALE_CHANNELS","SHAPE","getFieldOrDatumDef","channelHasNestedOffsetScale","GEOSHAPE","NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES","scaleCompatible","scaleTypePrecedence","GEOJSON","keys","isUnitModel","defaultScaleResolve","mergeValuesWithExplicit","tieBreakByComparing","ScaleComponent","parseScaleDomain","parseScaleProperty","parseScaleRange","scaleType","parseScales","model","ignoreRange","arguments","length","undefined","parseScaleCore","prop","component","scales","parseUnitScaleCore","parseNonUnitScaleCore","encoding","mark","markDef","scaleComponents","channel","fieldOrDatumDef","type","specifiedScale","scale","hasNestedOffsetScale","sType","scaleName","value","explicit","scaleTypeTieBreaker","st1","st2","scaleTypeWithExplicitIndex","resolve","child","children","_a","explicitScaleType","childScaleType","getWithExplicit","name","typeWithExplicit","childScale","renameScale","get","merged"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\scale\\parse.ts"],"sourcesContent":["import {ScaleChannel, SCALE_CHANNELS, SHAPE} from '../../channel';\nimport {getFieldOrDatumDef, ScaleDatumDef, TypedFieldDef} from '../../channeldef';\nimport {channelHasNestedOffsetScale} from '../../encoding';\nimport {GEOSHAPE} from '../../mark';\nimport {\n  NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES,\n  scaleCompatible,\n  ScaleType,\n  scaleTypePrecedence\n} from '../../scale';\nimport {GEOJSON} from '../../type';\nimport {keys} from '../../util';\nimport {VgScale} from '../../vega.schema';\nimport {isUnitModel, Model} from '../model';\nimport {defaultScaleResolve} from '../resolve';\nimport {Explicit, mergeValuesWithExplicit, tieBreakByComparing} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponent, ScaleComponentIndex} from './component';\nimport {parseScaleDomain} from './domain';\nimport {parseScaleProperty, parseScaleRange} from './properties';\nimport {scaleType} from './type';\n\nexport function parseScales(model: Model, {ignoreRange}: {ignoreRange?: boolean} = {}) {\n  parseScaleCore(model);\n  parseScaleDomain(model);\n  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {\n    parseScaleProperty(model, prop);\n  }\n  if (!ignoreRange) {\n    // range depends on zero\n    parseScaleRange(model);\n  }\n}\n\nexport function parseScaleCore(model: Model) {\n  if (isUnitModel(model)) {\n    model.component.scales = parseUnitScaleCore(model);\n  } else {\n    model.component.scales = parseNonUnitScaleCore(model);\n  }\n}\n\n/**\n * Parse scales for all channels of a model.\n */\nfunction parseUnitScaleCore(model: UnitModel): ScaleComponentIndex {\n  const {encoding, mark, markDef} = model;\n  const scaleComponents: ScaleComponentIndex = {};\n  for (const channel of SCALE_CHANNELS) {\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) as TypedFieldDef<string> | ScaleDatumDef; // must be typed def to have scale\n\n    // Don't generate scale for shape of geoshape\n    if (fieldOrDatumDef && mark === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {\n      continue;\n    }\n\n    let specifiedScale = fieldOrDatumDef && (fieldOrDatumDef as any).scale;\n    if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {\n      specifiedScale ??= {};\n      const hasNestedOffsetScale = channelHasNestedOffsetScale(encoding, channel);\n\n      const sType = scaleType(specifiedScale, channel, fieldOrDatumDef, markDef, hasNestedOffsetScale);\n      scaleComponents[channel] = new ScaleComponent(model.scaleName(`${channel}`, true), {\n        value: sType,\n        explicit: specifiedScale.type === sType\n      });\n    }\n  }\n  return scaleComponents;\n}\n\nconst scaleTypeTieBreaker = tieBreakByComparing(\n  (st1: ScaleType, st2: ScaleType) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2)\n);\n\nfunction parseNonUnitScaleCore(model: Model) {\n  const scaleComponents: ScaleComponentIndex = (model.component.scales = {});\n\n  const scaleTypeWithExplicitIndex: Partial<Record<ScaleChannel, Explicit<ScaleType>>> = {};\n  const resolve = model.component.resolve;\n\n  // Parse each child scale and determine if a particular channel can be merged.\n  for (const child of model.children) {\n    parseScaleCore(child);\n\n    // Instead of always merging right away -- check if it is compatible to merge first!\n    for (const channel of keys(child.component.scales)) {\n      // if resolve is undefined, set default first\n      resolve.scale[channel] ??= defaultScaleResolve(channel, model);\n\n      if (resolve.scale[channel] === 'shared') {\n        const explicitScaleType = scaleTypeWithExplicitIndex[channel];\n        const childScaleType = child.component.scales[channel].getWithExplicit('type');\n\n        if (explicitScaleType) {\n          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n            // merge scale component if type are compatible\n            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit<VgScale, ScaleType>(\n              explicitScaleType,\n              childScaleType,\n              'type',\n              'scale',\n              scaleTypeTieBreaker\n            );\n          } else {\n            // Otherwise, update conflicting channel to be independent\n            resolve.scale[channel] = 'independent';\n            // Remove from the index so they don't get merged\n            delete scaleTypeWithExplicitIndex[channel];\n          }\n        } else {\n          scaleTypeWithExplicitIndex[channel] = childScaleType;\n        }\n      }\n    }\n  }\n\n  // Merge each channel listed in the index\n  for (const channel of keys(scaleTypeWithExplicitIndex)) {\n    // Create new merged scale component\n    const name = model.scaleName(channel, true);\n    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n    scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit);\n\n    // rename each child and mark them as merged\n    for (const child of model.children) {\n      const childScale = child.component.scales[channel];\n      if (childScale) {\n        child.renameScale(childScale.get('name'), name);\n        childScale.merged = true;\n      }\n    }\n  }\n\n  return scaleComponents;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}