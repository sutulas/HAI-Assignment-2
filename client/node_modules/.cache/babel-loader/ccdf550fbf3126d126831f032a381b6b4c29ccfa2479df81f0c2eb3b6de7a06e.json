{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { TUPLE, unitName } from '.';\nimport { SELECTION_ID } from '../../selection';\nimport { vals } from '../../util';\nimport { BRUSH } from './interval';\nimport { TUPLE_FIELDS } from './project';\nconst point = {\n  defined: selCmpt => selCmpt.type === 'point',\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const fieldsSg = name + TUPLE_FIELDS;\n    const project = selCmpt.project;\n    const datum = '(item().isVoronoi ? datum.datum : datum)';\n    // Only add a discrete selection to the store if a datum is present _and_\n    // the interaction isn't occurring on a group mark. This guards against\n    // polluting interactive state with invalid values in faceted displays\n    // as the group marks are also data-driven. We force the update to account\n    // for constant null states but varying toggles (e.g., shift-click in\n    // whitespace followed by a click in whitespace; the store should only\n    // be cleared on the second click).\n    const brushes = vals(model.component.selection ?? {}).reduce((acc, cmpt) => {\n      return cmpt.type === 'interval' ? acc.concat(cmpt.name + BRUSH) : acc;\n    }, []).map(b => `indexof(item().mark.name, '${b}') < 0`).join(' && ');\n    const test = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${brushes ? ` && ${brushes}` : ''}`;\n    let update = `unit: ${unitName(model)}, `;\n    if (selCmpt.project.hasSelectionId) {\n      update += `${SELECTION_ID}: ${datum}[${stringValue(SELECTION_ID)}]`;\n    } else {\n      const values = project.items.map(p => {\n        const fieldDef = model.fieldDef(p.channel);\n        // Binned fields should capture extents, for a range test against the raw field.\n        return fieldDef?.bin ? `[${datum}[${stringValue(model.vgField(p.channel, {}))}], ` + `${datum}[${stringValue(model.vgField(p.channel, {\n          binSuffix: 'end'\n        }))}]]` : `${datum}[${stringValue(p.field)}]`;\n      }).join(', ');\n      update += `fields: ${fieldsSg}, values: [${values}]`;\n    }\n    const events = selCmpt.events;\n    return signals.concat([{\n      name: name + TUPLE,\n      on: events ? [{\n        events,\n        update: `${test} ? {${update}} : null`,\n        force: true\n      }] : []\n    }]);\n  }\n};\nexport default point;","map":{"version":3,"names":["stringValue","TUPLE","unitName","SELECTION_ID","vals","BRUSH","TUPLE_FIELDS","point","defined","selCmpt","type","signals","model","name","fieldsSg","project","datum","brushes","component","selection","reduce","acc","cmpt","concat","map","b","join","test","update","hasSelectionId","values","items","p","fieldDef","channel","bin","vgField","binSuffix","field","events","on","force"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\selection\\point.ts"],"sourcesContent":["import {Stream} from 'vega';\nimport {stringValue} from 'vega-util';\nimport {SelectionCompiler, TUPLE, unitName} from '.';\nimport {SELECTION_ID} from '../../selection';\nimport {vals} from '../../util';\nimport {BRUSH} from './interval';\nimport {TUPLE_FIELDS} from './project';\n\nconst point: SelectionCompiler<'point'> = {\n  defined: selCmpt => selCmpt.type === 'point',\n\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const fieldsSg = name + TUPLE_FIELDS;\n    const project = selCmpt.project;\n    const datum = '(item().isVoronoi ? datum.datum : datum)';\n\n    // Only add a discrete selection to the store if a datum is present _and_\n    // the interaction isn't occurring on a group mark. This guards against\n    // polluting interactive state with invalid values in faceted displays\n    // as the group marks are also data-driven. We force the update to account\n    // for constant null states but varying toggles (e.g., shift-click in\n    // whitespace followed by a click in whitespace; the store should only\n    // be cleared on the second click).\n    const brushes = vals(model.component.selection ?? {})\n      .reduce((acc, cmpt) => {\n        return cmpt.type === 'interval' ? acc.concat(cmpt.name + BRUSH) : acc;\n      }, [])\n      .map(b => `indexof(item().mark.name, '${b}') < 0`)\n      .join(' && ');\n\n    const test = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${\n      brushes ? ` && ${brushes}` : ''\n    }`;\n\n    let update = `unit: ${unitName(model)}, `;\n\n    if (selCmpt.project.hasSelectionId) {\n      update += `${SELECTION_ID}: ${datum}[${stringValue(SELECTION_ID)}]`;\n    } else {\n      const values = project.items\n        .map(p => {\n          const fieldDef = model.fieldDef(p.channel);\n          // Binned fields should capture extents, for a range test against the raw field.\n          return fieldDef?.bin\n            ? `[${datum}[${stringValue(model.vgField(p.channel, {}))}], ` +\n                `${datum}[${stringValue(model.vgField(p.channel, {binSuffix: 'end'}))}]]`\n            : `${datum}[${stringValue(p.field)}]`;\n        })\n        .join(', ');\n\n      update += `fields: ${fieldsSg}, values: [${values}]`;\n    }\n\n    const events: Stream[] = selCmpt.events;\n    return signals.concat([\n      {\n        name: name + TUPLE,\n        on: events\n          ? [\n              {\n                events,\n                update: `${test} ? {${update}} : null`,\n                force: true\n              }\n            ]\n          : []\n      }\n    ]);\n  }\n};\n\nexport default point;\n"],"mappings":"AACA,SAAQA,WAAW,QAAO,WAAW;AACrC,SAA2BC,KAAK,EAAEC,QAAQ,QAAO,GAAG;AACpD,SAAQC,YAAY,QAAO,iBAAiB;AAC5C,SAAQC,IAAI,QAAO,YAAY;AAC/B,SAAQC,KAAK,QAAO,YAAY;AAChC,SAAQC,YAAY,QAAO,WAAW;AAEtC,MAAMC,KAAK,GAA+B;EACxCC,OAAO,EAAEC,OAAO,IAAIA,OAAO,CAACC,IAAI,KAAK,OAAO;EAE5CC,OAAO,EAAEA,CAACC,KAAK,EAAEH,OAAO,EAAEE,OAAO,KAAI;IACnC,MAAME,IAAI,GAAGJ,OAAO,CAACI,IAAI;IACzB,MAAMC,QAAQ,GAAGD,IAAI,GAAGP,YAAY;IACpC,MAAMS,OAAO,GAAGN,OAAO,CAACM,OAAO;IAC/B,MAAMC,KAAK,GAAG,0CAA0C;IAExD;IACA;IACA;IACA;IACA;IACA;IACA;IACA,MAAMC,OAAO,GAAGb,IAAI,CAACQ,KAAK,CAACM,SAAS,CAACC,SAAS,IAAI,EAAE,CAAC,CAClDC,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,KAAI;MACpB,OAAOA,IAAI,CAACZ,IAAI,KAAK,UAAU,GAAGW,GAAG,CAACE,MAAM,CAACD,IAAI,CAACT,IAAI,GAAGR,KAAK,CAAC,GAAGgB,GAAG;IACvE,CAAC,EAAE,EAAE,CAAC,CACLG,GAAG,CAACC,CAAC,IAAI,8BAA8BA,CAAC,QAAQ,CAAC,CACjDC,IAAI,CAAC,MAAM,CAAC;IAEf,MAAMC,IAAI,GAAG,uFACXV,OAAO,GAAG,OAAOA,OAAO,EAAE,GAAG,EAC/B,EAAE;IAEF,IAAIW,MAAM,GAAG,SAAS1B,QAAQ,CAACU,KAAK,CAAC,IAAI;IAEzC,IAAIH,OAAO,CAACM,OAAO,CAACc,cAAc,EAAE;MAClCD,MAAM,IAAI,GAAGzB,YAAY,KAAKa,KAAK,IAAIhB,WAAW,CAACG,YAAY,CAAC,GAAG;IACrE,CAAC,MAAM;MACL,MAAM2B,MAAM,GAAGf,OAAO,CAACgB,KAAK,CACzBP,GAAG,CAACQ,CAAC,IAAG;QACP,MAAMC,QAAQ,GAAGrB,KAAK,CAACqB,QAAQ,CAACD,CAAC,CAACE,OAAO,CAAC;QAC1C;QACA,OAAOD,QAAQ,EAAEE,GAAG,GAChB,IAAInB,KAAK,IAAIhB,WAAW,CAACY,KAAK,CAACwB,OAAO,CAACJ,CAAC,CAACE,OAAO,EAAE,EAAE,CAAC,CAAC,KAAK,GACzD,GAAGlB,KAAK,IAAIhB,WAAW,CAACY,KAAK,CAACwB,OAAO,CAACJ,CAAC,CAACE,OAAO,EAAE;UAACG,SAAS,EAAE;QAAK,CAAC,CAAC,CAAC,IAAI,GAC3E,GAAGrB,KAAK,IAAIhB,WAAW,CAACgC,CAAC,CAACM,KAAK,CAAC,GAAG;MACzC,CAAC,CAAC,CACDZ,IAAI,CAAC,IAAI,CAAC;MAEbE,MAAM,IAAI,WAAWd,QAAQ,cAAcgB,MAAM,GAAG;IACtD;IAEA,MAAMS,MAAM,GAAa9B,OAAO,CAAC8B,MAAM;IACvC,OAAO5B,OAAO,CAACY,MAAM,CAAC,CACpB;MACEV,IAAI,EAAEA,IAAI,GAAGZ,KAAK;MAClBuC,EAAE,EAAED,MAAM,GACN,CACE;QACEA,MAAM;QACNX,MAAM,EAAE,GAAGD,IAAI,OAAOC,MAAM,UAAU;QACtCa,KAAK,EAAE;OACR,CACF,GACD;KACL,CACF,CAAC;EACJ;CACD;AAED,eAAelC,KAAK","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}