{"ast":null,"code":"import { Transform, rederive, ingest, replace } from 'vega-dataflow';\nimport { error, extent, inherits, identity, isArray, isFunction, isNumber, array, constant, one, accessorName, accessorFields, field, extend, toSet, zero } from 'vega-util';\nimport { tickStep, range, max, sum } from 'd3-array';\nimport { bandwidthNRD } from 'vega-statistics';\nimport { getProjectionPath, projectionProperties, projection } from 'vega-projection';\nimport { geoGraticule } from 'd3-geo';\nimport { rgb } from 'd3-color';\nimport { canvas } from 'vega-canvas';\nfunction noop() {}\nconst cases = [[], [[[1.0, 1.5], [0.5, 1.0]]], [[[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [0.5, 1.0]]], [[[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 0.5], [1.0, 1.5]]], [[[1.0, 0.5], [0.5, 1.0]]], [[[0.5, 1.0], [1.0, 0.5]]], [[[1.0, 1.5], [1.0, 0.5]]], [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [1.0, 0.5]]], [[[0.5, 1.0], [1.5, 1.0]]], [[[1.0, 1.5], [1.5, 1.0]]], [[[0.5, 1.0], [1.0, 1.5]]], []];\n\n// Implementation adapted from d3/d3-contour. Thanks!\nfunction contours() {\n  var dx = 1,\n    dy = 1,\n    smooth = smoothLinear;\n  function contours(values, tz) {\n    return tz.map(value => contour(values, value));\n  }\n\n  // Accumulate, smooth contour rings, assign holes to exterior rings.\n  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js\n  function contour(values, value) {\n    var polygons = [],\n      holes = [];\n    isorings(values, value, ring => {\n      smooth(ring, values, value);\n      if (area(ring) > 0) polygons.push([ring]);else holes.push(ring);\n    });\n    holes.forEach(hole => {\n      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\n        if (contains((polygon = polygons[i])[0], hole) !== -1) {\n          polygon.push(hole);\n          return;\n        }\n      }\n    });\n    return {\n      type: 'MultiPolygon',\n      value: value,\n      coordinates: polygons\n    };\n  }\n\n  // Marching squares with isolines stitched into rings.\n  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js\n  function isorings(values, value, callback) {\n    var fragmentByStart = [],\n      fragmentByEnd = [],\n      x,\n      y,\n      t0,\n      t1,\n      t2,\n      t3;\n\n    // Special case for the first row (y = -1, t2 = t3 = 0).\n    x = y = -1;\n    t1 = values[0] >= value;\n    cases[t1 << 1].forEach(stitch);\n    while (++x < dx - 1) {\n      t0 = t1, t1 = values[x + 1] >= value;\n      cases[t0 | t1 << 1].forEach(stitch);\n    }\n    cases[t1 << 0].forEach(stitch);\n\n    // General case for the intermediate rows.\n    while (++y < dy - 1) {\n      x = -1;\n      t1 = values[y * dx + dx] >= value;\n      t2 = values[y * dx] >= value;\n      cases[t1 << 1 | t2 << 2].forEach(stitch);\n      while (++x < dx - 1) {\n        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;\n        t3 = t2, t2 = values[y * dx + x + 1] >= value;\n        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);\n      }\n      cases[t1 | t2 << 3].forEach(stitch);\n    }\n\n    // Special case for the last row (y = dy - 1, t0 = t1 = 0).\n    x = -1;\n    t2 = values[y * dx] >= value;\n    cases[t2 << 2].forEach(stitch);\n    while (++x < dx - 1) {\n      t3 = t2, t2 = values[y * dx + x + 1] >= value;\n      cases[t2 << 2 | t3 << 3].forEach(stitch);\n    }\n    cases[t2 << 3].forEach(stitch);\n    function stitch(line) {\n      var start = [line[0][0] + x, line[0][1] + y],\n        end = [line[1][0] + x, line[1][1] + y],\n        startIndex = index(start),\n        endIndex = index(end),\n        f,\n        g;\n      if (f = fragmentByEnd[startIndex]) {\n        if (g = fragmentByStart[endIndex]) {\n          delete fragmentByEnd[f.end];\n          delete fragmentByStart[g.start];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[f.start] = fragmentByEnd[g.end] = {\n              start: f.start,\n              end: g.end,\n              ring: f.ring.concat(g.ring)\n            };\n          }\n        } else {\n          delete fragmentByEnd[f.end];\n          f.ring.push(end);\n          fragmentByEnd[f.end = endIndex] = f;\n        }\n      } else if (f = fragmentByStart[endIndex]) {\n        if (g = fragmentByEnd[startIndex]) {\n          delete fragmentByStart[f.start];\n          delete fragmentByEnd[g.end];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[g.start] = fragmentByEnd[f.end] = {\n              start: g.start,\n              end: f.end,\n              ring: g.ring.concat(f.ring)\n            };\n          }\n        } else {\n          delete fragmentByStart[f.start];\n          f.ring.unshift(start);\n          fragmentByStart[f.start = startIndex] = f;\n        }\n      } else {\n        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {\n          start: startIndex,\n          end: endIndex,\n          ring: [start, end]\n        };\n      }\n    }\n  }\n  function index(point) {\n    return point[0] * 2 + point[1] * (dx + 1) * 4;\n  }\n  function smoothLinear(ring, values, value) {\n    ring.forEach(point => {\n      var x = point[0],\n        y = point[1],\n        xt = x | 0,\n        yt = y | 0,\n        v0,\n        v1 = values[yt * dx + xt];\n      if (x > 0 && x < dx && xt === x) {\n        v0 = values[yt * dx + xt - 1];\n        point[0] = x + (value - v0) / (v1 - v0) - 0.5;\n      }\n      if (y > 0 && y < dy && yt === y) {\n        v0 = values[(yt - 1) * dx + xt];\n        point[1] = y + (value - v0) / (v1 - v0) - 0.5;\n      }\n    });\n  }\n  contours.contour = contour;\n  contours.size = function (_) {\n    if (!arguments.length) return [dx, dy];\n    var _0 = Math.floor(_[0]),\n      _1 = Math.floor(_[1]);\n    if (!(_0 >= 0 && _1 >= 0)) error('invalid size');\n    return dx = _0, dy = _1, contours;\n  };\n  contours.smooth = function (_) {\n    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;\n  };\n  return contours;\n}\nfunction area(ring) {\n  var i = 0,\n    n = ring.length,\n    area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n  return area;\n}\nfunction contains(ring, hole) {\n  var i = -1,\n    n = hole.length,\n    c;\n  while (++i < n) if (c = ringContains(ring, hole[i])) return c;\n  return 0;\n}\nfunction ringContains(ring, point) {\n  var x = point[0],\n    y = point[1],\n    contains = -1;\n  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n    var pi = ring[i],\n      xi = pi[0],\n      yi = pi[1],\n      pj = ring[j],\n      xj = pj[0],\n      yj = pj[1];\n    if (segmentContains(pi, pj, point)) return 0;\n    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = -contains;\n  }\n  return contains;\n}\nfunction segmentContains(a, b, c) {\n  var i;\n  return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);\n}\nfunction collinear(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);\n}\nfunction within(p, q, r) {\n  return p <= q && q <= r || r <= q && q <= p;\n}\nfunction quantize(k, nice, zero) {\n  return function (values) {\n    var ex = extent(values),\n      start = zero ? Math.min(ex[0], 0) : ex[0],\n      stop = ex[1],\n      span = stop - start,\n      step = nice ? tickStep(start, stop, k) : span / (k + 1);\n    return range(start + step, stop, step);\n  };\n}\n\n/**\n * Generate isocontours (level sets) based on input raster grid data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} [params.field] - The field with raster grid\n *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   specified, the levels, nice, resolve, and zero parameters are ignored.\n * @param {number} [params.levels] - The desired number of contour levels.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified levels.\n * @param {string} [params.resolve] - The method for resolving thresholds\n *   across multiple input grids. If 'independent' (the default), threshold\n *   calculation will be performed separately for each grid. If 'shared', a\n *   single set of threshold values will be used for all input grids.\n * @param {boolean} [params.zero] - Boolean flag indicating if the contour\n *   threshold values should include zero.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n * @param {boolean} [params.scale] - Optional numerical value by which to\n *   scale the output isocontour coordinates. This parameter can be useful\n *   to scale the contours to match a desired output resolution.\n * @param {string} [params.as='contour'] - The output field in which to store\n *   the generated isocontour data (default 'contour').\n */\nfunction Isocontour(params) {\n  Transform.call(this, null, params);\n}\nIsocontour.Definition = {\n  'type': 'Isocontour',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'thresholds',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'levels',\n    'type': 'number'\n  }, {\n    'name': 'nice',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'resolve',\n    'type': 'enum',\n    'values': ['shared', 'independent'],\n    'default': 'independent'\n  }, {\n    'name': 'zero',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'smooth',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'scale',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'translate',\n    'type': 'number',\n    'array': true,\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'null': true,\n    'default': 'contour'\n  }]\n};\ninherits(Isocontour, Transform, {\n  transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      source = pulse.materialize(pulse.SOURCE).source,\n      field = _.field || identity,\n      contour = contours().smooth(_.smooth !== false),\n      tz = _.thresholds || levels(source, field, _),\n      as = _.as === null ? null : _.as || 'contour',\n      values = [];\n    source.forEach(t => {\n      const grid = field(t);\n\n      // generate contour paths in GeoJSON format\n      const paths = contour.size([grid.width, grid.height])(grid.values, isArray(tz) ? tz : tz(grid.values));\n\n      // adjust contour path coordinates as needed\n      transformPaths(paths, grid, t, _);\n\n      // ingest; copy source data properties to output\n      paths.forEach(p => {\n        values.push(rederive(t, ingest(as != null ? {\n          [as]: p\n        } : p)));\n      });\n    });\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = values;\n    return out;\n  }\n});\nfunction levels(values, f, _) {\n  const q = quantize(_.levels || 10, _.nice, _.zero !== false);\n  return _.resolve !== 'shared' ? q : q(values.map(t => max(f(t).values)));\n}\nfunction transformPaths(paths, grid, datum, _) {\n  let s = _.scale || grid.scale,\n    t = _.translate || grid.translate;\n  if (isFunction(s)) s = s(datum, _);\n  if (isFunction(t)) t = t(datum, _);\n  if ((s === 1 || s == null) && !t) return;\n  const sx = (isNumber(s) ? s : s[0]) || 1,\n    sy = (isNumber(s) ? s : s[1]) || 1,\n    tx = t && t[0] || 0,\n    ty = t && t[1] || 0;\n  paths.forEach(transform(grid, sx, sy, tx, ty));\n}\nfunction transform(grid, sx, sy, tx, ty) {\n  const x1 = grid.x1 || 0,\n    y1 = grid.y1 || 0,\n    flip = sx * sy < 0;\n  function transformPolygon(coordinates) {\n    coordinates.forEach(transformRing);\n  }\n  function transformRing(coordinates) {\n    if (flip) coordinates.reverse(); // maintain winding order\n    coordinates.forEach(transformPoint);\n  }\n  function transformPoint(coordinates) {\n    coordinates[0] = (coordinates[0] - x1) * sx + tx;\n    coordinates[1] = (coordinates[1] - y1) * sy + ty;\n  }\n  return function (geometry) {\n    geometry.coordinates.forEach(transformPolygon);\n    return geometry;\n  };\n}\nfunction radius(bw, data, f) {\n  const v = bw >= 0 ? bw : bandwidthNRD(data, f);\n  return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);\n}\nfunction number(_) {\n  return isFunction(_) ? _ : constant(+_);\n}\n\n// Implementation adapted from d3/d3-contour. Thanks!\nfunction density2D() {\n  var x = d => d[0],\n    y = d => d[1],\n    weight = one,\n    bandwidth = [-1, -1],\n    dx = 960,\n    dy = 500,\n    k = 2; // log2(cellSize)\n\n  function density(data, counts) {\n    const rx = radius(bandwidth[0], data, x) >> k,\n      // blur x-radius\n      ry = radius(bandwidth[1], data, y) >> k,\n      // blur y-radius\n      ox = rx ? rx + 2 : 0,\n      // x-offset padding for blur\n      oy = ry ? ry + 2 : 0,\n      // y-offset padding for blur\n      n = 2 * ox + (dx >> k),\n      // grid width\n      m = 2 * oy + (dy >> k),\n      // grid height\n      values0 = new Float32Array(n * m),\n      values1 = new Float32Array(n * m);\n    let values = values0;\n    data.forEach(d => {\n      const xi = ox + (+x(d) >> k),\n        yi = oy + (+y(d) >> k);\n      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {\n        values0[xi + yi * n] += +weight(d);\n      }\n    });\n    if (rx > 0 && ry > 0) {\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n    } else if (rx > 0) {\n      blurX(n, m, values0, values1, rx);\n      blurX(n, m, values1, values0, rx);\n      blurX(n, m, values0, values1, rx);\n      values = values1;\n    } else if (ry > 0) {\n      blurY(n, m, values0, values1, ry);\n      blurY(n, m, values1, values0, ry);\n      blurY(n, m, values0, values1, ry);\n      values = values1;\n    }\n\n    // scale density estimates\n    // density in points per square pixel or probability density\n    const s = counts ? Math.pow(2, -2 * k) : 1 / sum(values);\n    for (let i = 0, sz = n * m; i < sz; ++i) values[i] *= s;\n    return {\n      values: values,\n      scale: 1 << k,\n      width: n,\n      height: m,\n      x1: ox,\n      y1: oy,\n      x2: ox + (dx >> k),\n      y2: oy + (dy >> k)\n    };\n  }\n  density.x = function (_) {\n    return arguments.length ? (x = number(_), density) : x;\n  };\n  density.y = function (_) {\n    return arguments.length ? (y = number(_), density) : y;\n  };\n  density.weight = function (_) {\n    return arguments.length ? (weight = number(_), density) : weight;\n  };\n  density.size = function (_) {\n    if (!arguments.length) return [dx, dy];\n    var _0 = +_[0],\n      _1 = +_[1];\n    if (!(_0 >= 0 && _1 >= 0)) error('invalid size');\n    return dx = _0, dy = _1, density;\n  };\n  density.cellSize = function (_) {\n    if (!arguments.length) return 1 << k;\n    if (!((_ = +_) >= 1)) error('invalid cell size');\n    k = Math.floor(Math.log(_) / Math.LN2);\n    return density;\n  };\n  density.bandwidth = function (_) {\n    if (!arguments.length) return bandwidth;\n    _ = array(_);\n    if (_.length === 1) _ = [+_[0], +_[0]];\n    if (_.length !== 2) error('invalid bandwidth');\n    return bandwidth = _, density;\n  };\n  return density;\n}\nfunction blurX(n, m, source, target, r) {\n  const w = (r << 1) + 1;\n  for (let j = 0; j < m; ++j) {\n    for (let i = 0, sr = 0; i < n + r; ++i) {\n      if (i < n) {\n        sr += source[i + j * n];\n      }\n      if (i >= r) {\n        if (i >= w) {\n          sr -= source[i - w + j * n];\n        }\n        target[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);\n      }\n    }\n  }\n}\nfunction blurY(n, m, source, target, r) {\n  const w = (r << 1) + 1;\n  for (let i = 0; i < n; ++i) {\n    for (let j = 0, sr = 0; j < m + r; ++j) {\n      if (j < m) {\n        sr += source[i + j * n];\n      }\n      if (j >= r) {\n        if (j >= w) {\n          sr -= source[i + (j - w) * n];\n        }\n        target[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);\n      }\n    }\n  }\n}\n\n/**\n * Perform 2D kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The [width, height] extent (in\n *   units of input pixels) over which to perform density estimation.\n * @param {function(object): number} params.x - The x-coordinate accessor.\n * @param {function(object): number} params.y - The y-coordinate accessor.\n * @param {function(object): number} [params.weight] - The weight accessor.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *   to groupby.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n *   This parameter determines the level of spatial approximation. For example,\n *   the default value of 4 maps to 2x reductions in both x- and y- dimensions.\n *   A value of 1 will result in an output raster grid whose dimensions exactly\n *   matches the size parameter.\n * @param {Array<number>} [params.bandwidth] - The KDE kernel bandwidths,\n *   in pixels. The input can be a two-element array specifying separate\n *   x and y bandwidths, or a single-element array specifying both. If the\n *   bandwidth is unspecified or less than zero, the bandwidth will be\n *   automatically determined.\n * @param {boolean} [params.counts=false] - A boolean flag indicating if the\n *   output values should be probability estimates (false, default) or\n *   smoothed counts (true).\n * @param {string} [params.as='grid'] - The output field in which to store\n *   the generated raster grid (default 'grid').\n */\nfunction KDE2D(params) {\n  Transform.call(this, null, params);\n}\nKDE2D.Definition = {\n  'type': 'KDE2D',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'required': true\n  }, {\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'weight',\n    'type': 'field'\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'cellSize',\n    'type': 'number'\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'counts',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'grid'\n  }]\n};\nconst PARAMS = ['x', 'y', 'weight', 'size', 'cellSize', 'bandwidth'];\nfunction params(obj, _) {\n  PARAMS.forEach(param => _[param] != null ? obj[param](_[param]) : 0);\n  return obj;\n}\ninherits(KDE2D, Transform, {\n  transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) return pulse.StopPropagation;\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      source = pulse.materialize(pulse.SOURCE).source,\n      groups = partition(source, _.groupby),\n      names = (_.groupby || []).map(accessorName),\n      kde = params(density2D(), _),\n      as = _.as || 'grid',\n      values = [];\n    function set(t, vals) {\n      for (let i = 0; i < names.length; ++i) t[names[i]] = vals[i];\n      return t;\n    }\n\n    // generate density raster grids\n    values = groups.map(g => ingest(set({\n      [as]: kde(g, _.counts)\n    }, g.dims)));\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = values;\n    return out;\n  }\n});\nfunction partition(data, groupby) {\n  var groups = [],\n    get = f => f(t),\n    map,\n    i,\n    n,\n    t,\n    k,\n    g;\n\n  // partition data points into groups\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n      if (!g) {\n        map[k] = g = [];\n        g.dims = k;\n        groups.push(g);\n      }\n      g.push(t);\n    }\n  }\n  return groups;\n}\n\n/**\n * Generate contours based on kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The dimensions [width, height] over which to compute contours.\n *  If the values parameter is provided, this must be the dimensions of the input data.\n *  If density estimation is performed, this is the output view dimensions in pixels.\n * @param {Array<number>} [params.values] - An array of numeric values representing an\n *  width x height grid of values over which to compute contours. If unspecified, this\n *  transform will instead attempt to compute contours for the kernel density estimate\n *  using values drawn from data tuples in the input pulse.\n * @param {function(object): number} [params.x] - The pixel x-coordinate accessor for density estimation.\n * @param {function(object): number} [params.y] - The pixel y-coordinate accessor for density estimation.\n * @param {function(object): number} [params.weight] - The data point weight accessor for density estimation.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n * @param {number} [params.bandwidth] - Kernel density estimation bandwidth.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   this parameter is set, the count and nice parameters will be ignored.\n * @param {number} [params.count] - The desired number of contours.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified count.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n */\nfunction Contour(params) {\n  Transform.call(this, null, params);\n}\nContour.Definition = {\n  'type': 'Contour',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'required': true\n  }, {\n    'name': 'values',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'x',\n    'type': 'field'\n  }, {\n    'name': 'y',\n    'type': 'field'\n  }, {\n    'name': 'weight',\n    'type': 'field'\n  }, {\n    'name': 'cellSize',\n    'type': 'number'\n  }, {\n    'name': 'bandwidth',\n    'type': 'number'\n  }, {\n    'name': 'count',\n    'type': 'number'\n  }, {\n    'name': 'nice',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'thresholds',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'smooth',\n    'type': 'boolean',\n    'default': true\n  }]\n};\ninherits(Contour, Transform, {\n  transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      contour = contours().smooth(_.smooth !== false),\n      values = _.values,\n      thresh = _.thresholds || quantize(_.count || 10, _.nice, !!values),\n      size = _.size,\n      grid,\n      post;\n    if (!values) {\n      values = pulse.materialize(pulse.SOURCE).source;\n      grid = params(density2D(), _)(values, true);\n      post = transform(grid, grid.scale || 1, grid.scale || 1, 0, 0);\n      size = [grid.width, grid.height];\n      values = grid.values;\n    }\n    thresh = isArray(thresh) ? thresh : thresh(values);\n    values = contour.size(size)(values, thresh);\n    if (post) values.forEach(post);\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = (values || []).map(ingest);\n    return out;\n  }\n});\nconst Feature = 'Feature';\nconst FeatureCollection = 'FeatureCollection';\nconst MultiPoint = 'MultiPoint';\n\n/**\n * Consolidate an array of [longitude, latitude] points or GeoJSON features\n * into a combined GeoJSON object. This transform is particularly useful for\n * combining geo data for a Projection's fit argument. The resulting GeoJSON\n * data is available as this transform's value. Input pulses are unchanged.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} [params.fields] - A two-element array\n *   of field accessors for the longitude and latitude values.\n * @param {function(object): *} params.geojson - A field accessor for\n *   retrieving GeoJSON feature data.\n */\nfunction GeoJSON(params) {\n  Transform.call(this, null, params);\n}\nGeoJSON.Definition = {\n  'type': 'GeoJSON',\n  'metadata': {},\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'geojson',\n    'type': 'field'\n  }]\n};\ninherits(GeoJSON, Transform, {\n  transform(_, pulse) {\n    var features = this._features,\n      points = this._points,\n      fields = _.fields,\n      lon = fields && fields[0],\n      lat = fields && fields[1],\n      geojson = _.geojson || !fields && identity,\n      flag = pulse.ADD,\n      mod;\n    mod = _.modified() || pulse.changed(pulse.REM) || pulse.modified(accessorFields(geojson)) || lon && pulse.modified(accessorFields(lon)) || lat && pulse.modified(accessorFields(lat));\n    if (!this.value || mod) {\n      flag = pulse.SOURCE;\n      this._features = features = [];\n      this._points = points = [];\n    }\n    if (geojson) {\n      pulse.visit(flag, t => features.push(geojson(t)));\n    }\n    if (lon && lat) {\n      pulse.visit(flag, t => {\n        var x = lon(t),\n          y = lat(t);\n        if (x != null && y != null && (x = +x) === x && (y = +y) === y) {\n          points.push([x, y]);\n        }\n      });\n      features = features.concat({\n        type: Feature,\n        geometry: {\n          type: MultiPoint,\n          coordinates: points\n        }\n      });\n    }\n    this.value = {\n      type: FeatureCollection,\n      features: features\n    };\n  }\n});\n\n/**\n * Map GeoJSON data to an SVG path string.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {function(object): *} [params.field] - The field with GeoJSON data,\n *   or null if the tuple itself is a GeoJSON feature.\n * @param {string} [params.as='path'] - The output field in which to store\n *   the generated path data (default 'path').\n */\nfunction GeoPath(params) {\n  Transform.call(this, null, params);\n}\nGeoPath.Definition = {\n  'type': 'GeoPath',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection'\n  }, {\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'pointRadius',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'path'\n  }]\n};\ninherits(GeoPath, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ALL),\n      path = this.value,\n      field = _.field || identity,\n      as = _.as || 'path',\n      flag = out.SOURCE;\n    if (!path || _.modified()) {\n      // parameters updated, reset and reflow\n      this.value = path = getProjectionPath(_.projection);\n      out.materialize().reflow();\n    } else {\n      flag = field === identity || pulse.modified(field.fields) ? out.ADD_MOD : out.ADD;\n    }\n    const prev = initPath(path, _.pointRadius);\n    out.visit(flag, t => t[as] = path(field(t)));\n    path.pointRadius(prev);\n    return out.modifies(as);\n  }\n});\nfunction initPath(path, pointRadius) {\n  const prev = path.pointRadius();\n  path.context(null);\n  if (pointRadius != null) {\n    path.pointRadius(pointRadius);\n  }\n  return prev;\n}\n\n/**\n * Geo-code a longitude/latitude point to an x/y coordinate.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {Array<function(object): *>} params.fields - A two-element array of\n *   field accessors for the longitude and latitude values.\n * @param {Array<string>} [params.as] - A two-element array of field names\n *   under which to store the result. Defaults to ['x','y'].\n */\nfunction GeoPoint(params) {\n  Transform.call(this, null, params);\n}\nGeoPoint.Definition = {\n  'type': 'GeoPoint',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection',\n    'required': true\n  }, {\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['x', 'y']\n  }]\n};\ninherits(GeoPoint, Transform, {\n  transform(_, pulse) {\n    var proj = _.projection,\n      lon = _.fields[0],\n      lat = _.fields[1],\n      as = _.as || ['x', 'y'],\n      x = as[0],\n      y = as[1],\n      mod;\n    function set(t) {\n      const xy = proj([lon(t), lat(t)]);\n      if (xy) {\n        t[x] = xy[0];\n        t[y] = xy[1];\n      } else {\n        t[x] = undefined;\n        t[y] = undefined;\n      }\n    }\n    if (_.modified()) {\n      // parameters updated, reflow\n      pulse = pulse.materialize().reflow(true).visit(pulse.SOURCE, set);\n    } else {\n      mod = pulse.modified(lon.fields) || pulse.modified(lat.fields);\n      pulse.visit(mod ? pulse.ADD_MOD : pulse.ADD, set);\n    }\n    return pulse.modifies(as);\n  }\n});\n\n/**\n * Annotate items with a geopath shape generator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {function(object): *} [params.field] - The field with GeoJSON data,\n *   or null if the tuple itself is a GeoJSON feature.\n * @param {string} [params.as='shape'] - The output field in which to store\n *   the generated path data (default 'shape').\n */\nfunction GeoShape(params) {\n  Transform.call(this, null, params);\n}\nGeoShape.Definition = {\n  'type': 'GeoShape',\n  'metadata': {\n    'modifies': true,\n    'nomod': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection'\n  }, {\n    'name': 'field',\n    'type': 'field',\n    'default': 'datum'\n  }, {\n    'name': 'pointRadius',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'shape'\n  }]\n};\ninherits(GeoShape, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ALL),\n      shape = this.value,\n      as = _.as || 'shape',\n      flag = out.ADD;\n    if (!shape || _.modified()) {\n      // parameters updated, reset and reflow\n      this.value = shape = shapeGenerator(getProjectionPath(_.projection), _.field || field('datum'), _.pointRadius);\n      out.materialize().reflow();\n      flag = out.SOURCE;\n    }\n    out.visit(flag, t => t[as] = shape);\n    return out.modifies(as);\n  }\n});\nfunction shapeGenerator(path, field, pointRadius) {\n  const shape = pointRadius == null ? _ => path(field(_)) : _ => {\n    var prev = path.pointRadius(),\n      value = path.pointRadius(pointRadius)(field(_));\n    path.pointRadius(prev);\n    return value;\n  };\n  shape.context = _ => {\n    path.context(_);\n    return shape;\n  };\n  return shape;\n}\n\n/**\n * GeoJSON feature generator for creating graticules.\n * @constructor\n */\nfunction Graticule(params) {\n  Transform.call(this, [], params);\n  this.generator = geoGraticule();\n}\nGraticule.Definition = {\n  'type': 'Graticule',\n  'metadata': {\n    'changes': true,\n    'generates': true\n  },\n  'params': [{\n    'name': 'extent',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'extentMajor',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'extentMinor',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'step',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'stepMajor',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'default': [90, 360]\n  }, {\n    'name': 'stepMinor',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'default': [10, 10]\n  }, {\n    'name': 'precision',\n    'type': 'number',\n    'default': 2.5\n  }]\n};\ninherits(Graticule, Transform, {\n  transform(_, pulse) {\n    var src = this.value,\n      gen = this.generator,\n      t;\n    if (!src.length || _.modified()) {\n      for (const prop in _) {\n        if (isFunction(gen[prop])) {\n          gen[prop](_[prop]);\n        }\n      }\n    }\n    t = gen();\n    if (src.length) {\n      pulse.mod.push(replace(src[0], t));\n    } else {\n      pulse.add.push(ingest(t));\n    }\n    src[0] = t;\n    return pulse;\n  }\n});\n\n/**\n * Render a heatmap image for input raster grid data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} [params.field] - The field with raster grid\n *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n * @param {string} [params.color] - A constant color value or function for\n *   individual pixel color. If a function, it will be invoked with an input\n *   object that includes $x, $y, $value, and $max fields for the grid.\n * @param {number} [params.opacity] - A constant opacity value or function for\n *   individual pixel opacity. If a function, it will be invoked with an input\n *   object that includes $x, $y, $value, and $max fields for the grid.\n * @param {string} [params.resolve] - The method for resolving maximum values\n *   across multiple input grids. If 'independent' (the default), maximum\n *   calculation will be performed separately for each grid. If 'shared',\n *   a single global maximum will be used for all input grids.\n * @param {string} [params.as='image'] - The output field in which to store\n *   the generated bitmap canvas images (default 'image').\n */\nfunction Heatmap(params) {\n  Transform.call(this, null, params);\n}\nHeatmap.Definition = {\n  'type': 'heatmap',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'color',\n    'type': 'string',\n    'expr': true\n  }, {\n    'name': 'opacity',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'resolve',\n    'type': 'enum',\n    'values': ['shared', 'independent'],\n    'default': 'independent'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'image'\n  }]\n};\ninherits(Heatmap, Transform, {\n  transform(_, pulse) {\n    if (!pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n    var source = pulse.materialize(pulse.SOURCE).source,\n      shared = _.resolve === 'shared',\n      field = _.field || identity,\n      opacity = opacity_(_.opacity, _),\n      color = color_(_.color, _),\n      as = _.as || 'image',\n      obj = {\n        $x: 0,\n        $y: 0,\n        $value: 0,\n        $max: shared ? max(source.map(t => max(field(t).values))) : 0\n      };\n    source.forEach(t => {\n      const v = field(t);\n\n      // build proxy data object\n      const o = extend({}, t, obj);\n      // set maximum value if not globally shared\n      if (!shared) o.$max = max(v.values || []);\n\n      // generate canvas image\n      // optimize color/opacity if not pixel-dependent\n      t[as] = toCanvas(v, o, color.dep ? color : constant(color(o)), opacity.dep ? opacity : constant(opacity(o)));\n    });\n    return pulse.reflow(true).modifies(as);\n  }\n});\n\n// get image color function\nfunction color_(color, _) {\n  let f;\n  if (isFunction(color)) {\n    f = obj => rgb(color(obj, _));\n    f.dep = dependency(color);\n  } else {\n    // default to mid-grey\n    f = constant(rgb(color || '#888'));\n  }\n  return f;\n}\n\n// get image opacity function\nfunction opacity_(opacity, _) {\n  let f;\n  if (isFunction(opacity)) {\n    f = obj => opacity(obj, _);\n    f.dep = dependency(opacity);\n  } else if (opacity) {\n    f = constant(opacity);\n  } else {\n    // default to [0, max] opacity gradient\n    f = obj => obj.$value / obj.$max || 0;\n    f.dep = true;\n  }\n  return f;\n}\n\n// check if function depends on individual pixel data\nfunction dependency(f) {\n  if (!isFunction(f)) return false;\n  const set = toSet(accessorFields(f));\n  return set.$x || set.$y || set.$value || set.$max;\n}\n\n// render raster grid to canvas\nfunction toCanvas(grid, obj, color, opacity) {\n  const n = grid.width,\n    m = grid.height,\n    x1 = grid.x1 || 0,\n    y1 = grid.y1 || 0,\n    x2 = grid.x2 || n,\n    y2 = grid.y2 || m,\n    val = grid.values,\n    value = val ? i => val[i] : zero,\n    can = canvas(x2 - x1, y2 - y1),\n    ctx = can.getContext('2d'),\n    img = ctx.getImageData(0, 0, x2 - x1, y2 - y1),\n    pix = img.data;\n  for (let j = y1, k = 0; j < y2; ++j) {\n    obj.$y = j - y1;\n    for (let i = x1, r = j * n; i < x2; ++i, k += 4) {\n      obj.$x = i - x1;\n      obj.$value = value(i + r);\n      const v = color(obj);\n      pix[k + 0] = v.r;\n      pix[k + 1] = v.g;\n      pix[k + 2] = v.b;\n      pix[k + 3] = ~~(255 * opacity(obj));\n    }\n  }\n  ctx.putImageData(img, 0, 0);\n  return can;\n}\n\n/**\n * Maintains a cartographic projection.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\nfunction Projection(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\ninherits(Projection, Transform, {\n  transform(_, pulse) {\n    let proj = this.value;\n    if (!proj || _.modified('type')) {\n      this.value = proj = create(_.type);\n      projectionProperties.forEach(prop => {\n        if (_[prop] != null) set(proj, prop, _[prop]);\n      });\n    } else {\n      projectionProperties.forEach(prop => {\n        if (_.modified(prop)) set(proj, prop, _[prop]);\n      });\n    }\n    if (_.pointRadius != null) proj.path.pointRadius(_.pointRadius);\n    if (_.fit) fit(proj, _);\n    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n  }\n});\nfunction fit(proj, _) {\n  const data = collectGeoJSON(_.fit);\n  _.extent ? proj.fitExtent(_.extent, data) : _.size ? proj.fitSize(_.size, data) : 0;\n}\nfunction create(type) {\n  const constructor = projection((type || 'mercator').toLowerCase());\n  if (!constructor) error('Unrecognized projection type: ' + type);\n  return constructor();\n}\nfunction set(proj, key, value) {\n  if (isFunction(proj[key])) proj[key](value);\n}\nfunction collectGeoJSON(data) {\n  data = array(data);\n  return data.length === 1 ? data[0] : {\n    type: FeatureCollection,\n    features: data.reduce((a, f) => a.concat(featurize(f)), [])\n  };\n}\nfunction featurize(f) {\n  return f.type === FeatureCollection ? f.features : array(f).filter(d => d != null).map(d => d.type === Feature ? d : {\n    type: Feature,\n    geometry: d\n  });\n}\nexport { Contour as contour, GeoJSON as geojson, GeoPath as geopath, GeoPoint as geopoint, GeoShape as geoshape, Graticule as graticule, Heatmap as heatmap, Isocontour as isocontour, KDE2D as kde2d, Projection as projection };","map":{"version":3,"names":["Transform","rederive","ingest","replace","error","extent","inherits","identity","isArray","isFunction","isNumber","array","constant","one","accessorName","accessorFields","field","extend","toSet","zero","tickStep","range","max","sum","bandwidthNRD","getProjectionPath","projectionProperties","projection","geoGraticule","rgb","canvas","noop","cases","contours","dx","dy","smooth","smoothLinear","values","tz","map","value","contour","polygons","holes","isorings","ring","area","push","forEach","hole","i","n","length","polygon","contains","type","coordinates","callback","fragmentByStart","fragmentByEnd","x","y","t0","t1","t2","t3","stitch","line","start","end","startIndex","index","endIndex","f","g","concat","unshift","point","xt","yt","v0","v1","size","_","arguments","_0","Math","floor","_1","c","ringContains","j","pi","xi","yi","pj","xj","yj","segmentContains","a","b","collinear","within","p","q","r","quantize","k","nice","ex","min","stop","span","step","Isocontour","params","call","Definition","transform","pulse","changed","modified","StopPropagation","out","fork","NO_SOURCE","NO_FIELDS","source","materialize","SOURCE","thresholds","levels","as","t","grid","paths","width","height","transformPaths","rem","add","resolve","datum","s","scale","translate","sx","sy","tx","ty","x1","y1","flip","transformPolygon","transformRing","reverse","transformPoint","geometry","radius","bw","data","v","round","sqrt","number","density2D","d","weight","bandwidth","density","counts","rx","ry","ox","oy","m","values0","Float32Array","values1","blurX","blurY","pow","sz","x2","y2","cellSize","log","LN2","target","w","sr","KDE2D","PARAMS","obj","param","groups","partition","groupby","names","kde","set","vals","dims","get","Contour","thresh","count","post","Feature","FeatureCollection","MultiPoint","GeoJSON","features","_features","points","_points","fields","lon","lat","geojson","flag","ADD","mod","REM","visit","GeoPath","ALL","path","reflow","ADD_MOD","prev","initPath","pointRadius","modifies","context","GeoPoint","proj","xy","undefined","GeoShape","shape","shapeGenerator","Graticule","generator","src","gen","prop","Heatmap","shared","opacity","opacity_","color","color_","$x","$y","$value","$max","o","toCanvas","dep","dependency","val","can","ctx","getContext","img","getImageData","pix","putImageData","Projection","create","fit","collectGeoJSON","fitExtent","fitSize","constructor","toLowerCase","key","reduce","featurize","filter","geopath","geopoint","geoshape","graticule","heatmap","isocontour","kde2d"],"sources":["C:/Users/sutul/node_modules/vega-geo/build/vega-geo.module.js"],"sourcesContent":["import { Transform, rederive, ingest, replace } from 'vega-dataflow';\nimport { error, extent, inherits, identity, isArray, isFunction, isNumber, array, constant, one, accessorName, accessorFields, field, extend, toSet, zero } from 'vega-util';\nimport { tickStep, range, max, sum } from 'd3-array';\nimport { bandwidthNRD } from 'vega-statistics';\nimport { getProjectionPath, projectionProperties, projection } from 'vega-projection';\nimport { geoGraticule } from 'd3-geo';\nimport { rgb } from 'd3-color';\nimport { canvas } from 'vega-canvas';\n\nfunction noop() {}\nconst cases = [[], [[[1.0, 1.5], [0.5, 1.0]]], [[[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [0.5, 1.0]]], [[[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 0.5], [1.0, 1.5]]], [[[1.0, 0.5], [0.5, 1.0]]], [[[0.5, 1.0], [1.0, 0.5]]], [[[1.0, 1.5], [1.0, 0.5]]], [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [1.0, 0.5]]], [[[0.5, 1.0], [1.5, 1.0]]], [[[1.0, 1.5], [1.5, 1.0]]], [[[0.5, 1.0], [1.0, 1.5]]], []];\n\n// Implementation adapted from d3/d3-contour. Thanks!\nfunction contours () {\n  var dx = 1,\n    dy = 1,\n    smooth = smoothLinear;\n  function contours(values, tz) {\n    return tz.map(value => contour(values, value));\n  }\n\n  // Accumulate, smooth contour rings, assign holes to exterior rings.\n  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js\n  function contour(values, value) {\n    var polygons = [],\n      holes = [];\n    isorings(values, value, ring => {\n      smooth(ring, values, value);\n      if (area(ring) > 0) polygons.push([ring]);else holes.push(ring);\n    });\n    holes.forEach(hole => {\n      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\n        if (contains((polygon = polygons[i])[0], hole) !== -1) {\n          polygon.push(hole);\n          return;\n        }\n      }\n    });\n    return {\n      type: 'MultiPolygon',\n      value: value,\n      coordinates: polygons\n    };\n  }\n\n  // Marching squares with isolines stitched into rings.\n  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js\n  function isorings(values, value, callback) {\n    var fragmentByStart = [],\n      fragmentByEnd = [],\n      x,\n      y,\n      t0,\n      t1,\n      t2,\n      t3;\n\n    // Special case for the first row (y = -1, t2 = t3 = 0).\n    x = y = -1;\n    t1 = values[0] >= value;\n    cases[t1 << 1].forEach(stitch);\n    while (++x < dx - 1) {\n      t0 = t1, t1 = values[x + 1] >= value;\n      cases[t0 | t1 << 1].forEach(stitch);\n    }\n    cases[t1 << 0].forEach(stitch);\n\n    // General case for the intermediate rows.\n    while (++y < dy - 1) {\n      x = -1;\n      t1 = values[y * dx + dx] >= value;\n      t2 = values[y * dx] >= value;\n      cases[t1 << 1 | t2 << 2].forEach(stitch);\n      while (++x < dx - 1) {\n        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;\n        t3 = t2, t2 = values[y * dx + x + 1] >= value;\n        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);\n      }\n      cases[t1 | t2 << 3].forEach(stitch);\n    }\n\n    // Special case for the last row (y = dy - 1, t0 = t1 = 0).\n    x = -1;\n    t2 = values[y * dx] >= value;\n    cases[t2 << 2].forEach(stitch);\n    while (++x < dx - 1) {\n      t3 = t2, t2 = values[y * dx + x + 1] >= value;\n      cases[t2 << 2 | t3 << 3].forEach(stitch);\n    }\n    cases[t2 << 3].forEach(stitch);\n    function stitch(line) {\n      var start = [line[0][0] + x, line[0][1] + y],\n        end = [line[1][0] + x, line[1][1] + y],\n        startIndex = index(start),\n        endIndex = index(end),\n        f,\n        g;\n      if (f = fragmentByEnd[startIndex]) {\n        if (g = fragmentByStart[endIndex]) {\n          delete fragmentByEnd[f.end];\n          delete fragmentByStart[g.start];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[f.start] = fragmentByEnd[g.end] = {\n              start: f.start,\n              end: g.end,\n              ring: f.ring.concat(g.ring)\n            };\n          }\n        } else {\n          delete fragmentByEnd[f.end];\n          f.ring.push(end);\n          fragmentByEnd[f.end = endIndex] = f;\n        }\n      } else if (f = fragmentByStart[endIndex]) {\n        if (g = fragmentByEnd[startIndex]) {\n          delete fragmentByStart[f.start];\n          delete fragmentByEnd[g.end];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[g.start] = fragmentByEnd[f.end] = {\n              start: g.start,\n              end: f.end,\n              ring: g.ring.concat(f.ring)\n            };\n          }\n        } else {\n          delete fragmentByStart[f.start];\n          f.ring.unshift(start);\n          fragmentByStart[f.start = startIndex] = f;\n        }\n      } else {\n        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {\n          start: startIndex,\n          end: endIndex,\n          ring: [start, end]\n        };\n      }\n    }\n  }\n  function index(point) {\n    return point[0] * 2 + point[1] * (dx + 1) * 4;\n  }\n  function smoothLinear(ring, values, value) {\n    ring.forEach(point => {\n      var x = point[0],\n        y = point[1],\n        xt = x | 0,\n        yt = y | 0,\n        v0,\n        v1 = values[yt * dx + xt];\n      if (x > 0 && x < dx && xt === x) {\n        v0 = values[yt * dx + xt - 1];\n        point[0] = x + (value - v0) / (v1 - v0) - 0.5;\n      }\n      if (y > 0 && y < dy && yt === y) {\n        v0 = values[(yt - 1) * dx + xt];\n        point[1] = y + (value - v0) / (v1 - v0) - 0.5;\n      }\n    });\n  }\n  contours.contour = contour;\n  contours.size = function (_) {\n    if (!arguments.length) return [dx, dy];\n    var _0 = Math.floor(_[0]),\n      _1 = Math.floor(_[1]);\n    if (!(_0 >= 0 && _1 >= 0)) error('invalid size');\n    return dx = _0, dy = _1, contours;\n  };\n  contours.smooth = function (_) {\n    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;\n  };\n  return contours;\n}\nfunction area(ring) {\n  var i = 0,\n    n = ring.length,\n    area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n  return area;\n}\nfunction contains(ring, hole) {\n  var i = -1,\n    n = hole.length,\n    c;\n  while (++i < n) if (c = ringContains(ring, hole[i])) return c;\n  return 0;\n}\nfunction ringContains(ring, point) {\n  var x = point[0],\n    y = point[1],\n    contains = -1;\n  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n    var pi = ring[i],\n      xi = pi[0],\n      yi = pi[1],\n      pj = ring[j],\n      xj = pj[0],\n      yj = pj[1];\n    if (segmentContains(pi, pj, point)) return 0;\n    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = -contains;\n  }\n  return contains;\n}\nfunction segmentContains(a, b, c) {\n  var i;\n  return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);\n}\nfunction collinear(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);\n}\nfunction within(p, q, r) {\n  return p <= q && q <= r || r <= q && q <= p;\n}\n\nfunction quantize (k, nice, zero) {\n  return function (values) {\n    var ex = extent(values),\n      start = zero ? Math.min(ex[0], 0) : ex[0],\n      stop = ex[1],\n      span = stop - start,\n      step = nice ? tickStep(start, stop, k) : span / (k + 1);\n    return range(start + step, stop, step);\n  };\n}\n\n/**\n * Generate isocontours (level sets) based on input raster grid data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} [params.field] - The field with raster grid\n *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   specified, the levels, nice, resolve, and zero parameters are ignored.\n * @param {number} [params.levels] - The desired number of contour levels.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified levels.\n * @param {string} [params.resolve] - The method for resolving thresholds\n *   across multiple input grids. If 'independent' (the default), threshold\n *   calculation will be performed separately for each grid. If 'shared', a\n *   single set of threshold values will be used for all input grids.\n * @param {boolean} [params.zero] - Boolean flag indicating if the contour\n *   threshold values should include zero.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n * @param {boolean} [params.scale] - Optional numerical value by which to\n *   scale the output isocontour coordinates. This parameter can be useful\n *   to scale the contours to match a desired output resolution.\n * @param {string} [params.as='contour'] - The output field in which to store\n *   the generated isocontour data (default 'contour').\n */\nfunction Isocontour(params) {\n  Transform.call(this, null, params);\n}\nIsocontour.Definition = {\n  'type': 'Isocontour',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'thresholds',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'levels',\n    'type': 'number'\n  }, {\n    'name': 'nice',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'resolve',\n    'type': 'enum',\n    'values': ['shared', 'independent'],\n    'default': 'independent'\n  }, {\n    'name': 'zero',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'smooth',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'scale',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'translate',\n    'type': 'number',\n    'array': true,\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'null': true,\n    'default': 'contour'\n  }]\n};\ninherits(Isocontour, Transform, {\n  transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      source = pulse.materialize(pulse.SOURCE).source,\n      field = _.field || identity,\n      contour = contours().smooth(_.smooth !== false),\n      tz = _.thresholds || levels(source, field, _),\n      as = _.as === null ? null : _.as || 'contour',\n      values = [];\n    source.forEach(t => {\n      const grid = field(t);\n\n      // generate contour paths in GeoJSON format\n      const paths = contour.size([grid.width, grid.height])(grid.values, isArray(tz) ? tz : tz(grid.values));\n\n      // adjust contour path coordinates as needed\n      transformPaths(paths, grid, t, _);\n\n      // ingest; copy source data properties to output\n      paths.forEach(p => {\n        values.push(rederive(t, ingest(as != null ? {\n          [as]: p\n        } : p)));\n      });\n    });\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = values;\n    return out;\n  }\n});\nfunction levels(values, f, _) {\n  const q = quantize(_.levels || 10, _.nice, _.zero !== false);\n  return _.resolve !== 'shared' ? q : q(values.map(t => max(f(t).values)));\n}\nfunction transformPaths(paths, grid, datum, _) {\n  let s = _.scale || grid.scale,\n    t = _.translate || grid.translate;\n  if (isFunction(s)) s = s(datum, _);\n  if (isFunction(t)) t = t(datum, _);\n  if ((s === 1 || s == null) && !t) return;\n  const sx = (isNumber(s) ? s : s[0]) || 1,\n    sy = (isNumber(s) ? s : s[1]) || 1,\n    tx = t && t[0] || 0,\n    ty = t && t[1] || 0;\n  paths.forEach(transform(grid, sx, sy, tx, ty));\n}\nfunction transform(grid, sx, sy, tx, ty) {\n  const x1 = grid.x1 || 0,\n    y1 = grid.y1 || 0,\n    flip = sx * sy < 0;\n  function transformPolygon(coordinates) {\n    coordinates.forEach(transformRing);\n  }\n  function transformRing(coordinates) {\n    if (flip) coordinates.reverse(); // maintain winding order\n    coordinates.forEach(transformPoint);\n  }\n  function transformPoint(coordinates) {\n    coordinates[0] = (coordinates[0] - x1) * sx + tx;\n    coordinates[1] = (coordinates[1] - y1) * sy + ty;\n  }\n  return function (geometry) {\n    geometry.coordinates.forEach(transformPolygon);\n    return geometry;\n  };\n}\n\nfunction radius(bw, data, f) {\n  const v = bw >= 0 ? bw : bandwidthNRD(data, f);\n  return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);\n}\nfunction number(_) {\n  return isFunction(_) ? _ : constant(+_);\n}\n\n// Implementation adapted from d3/d3-contour. Thanks!\nfunction density2D () {\n  var x = d => d[0],\n    y = d => d[1],\n    weight = one,\n    bandwidth = [-1, -1],\n    dx = 960,\n    dy = 500,\n    k = 2; // log2(cellSize)\n\n  function density(data, counts) {\n    const rx = radius(bandwidth[0], data, x) >> k,\n      // blur x-radius\n      ry = radius(bandwidth[1], data, y) >> k,\n      // blur y-radius\n      ox = rx ? rx + 2 : 0,\n      // x-offset padding for blur\n      oy = ry ? ry + 2 : 0,\n      // y-offset padding for blur\n      n = 2 * ox + (dx >> k),\n      // grid width\n      m = 2 * oy + (dy >> k),\n      // grid height\n      values0 = new Float32Array(n * m),\n      values1 = new Float32Array(n * m);\n    let values = values0;\n    data.forEach(d => {\n      const xi = ox + (+x(d) >> k),\n        yi = oy + (+y(d) >> k);\n      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {\n        values0[xi + yi * n] += +weight(d);\n      }\n    });\n    if (rx > 0 && ry > 0) {\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n    } else if (rx > 0) {\n      blurX(n, m, values0, values1, rx);\n      blurX(n, m, values1, values0, rx);\n      blurX(n, m, values0, values1, rx);\n      values = values1;\n    } else if (ry > 0) {\n      blurY(n, m, values0, values1, ry);\n      blurY(n, m, values1, values0, ry);\n      blurY(n, m, values0, values1, ry);\n      values = values1;\n    }\n\n    // scale density estimates\n    // density in points per square pixel or probability density\n    const s = counts ? Math.pow(2, -2 * k) : 1 / sum(values);\n    for (let i = 0, sz = n * m; i < sz; ++i) values[i] *= s;\n    return {\n      values: values,\n      scale: 1 << k,\n      width: n,\n      height: m,\n      x1: ox,\n      y1: oy,\n      x2: ox + (dx >> k),\n      y2: oy + (dy >> k)\n    };\n  }\n  density.x = function (_) {\n    return arguments.length ? (x = number(_), density) : x;\n  };\n  density.y = function (_) {\n    return arguments.length ? (y = number(_), density) : y;\n  };\n  density.weight = function (_) {\n    return arguments.length ? (weight = number(_), density) : weight;\n  };\n  density.size = function (_) {\n    if (!arguments.length) return [dx, dy];\n    var _0 = +_[0],\n      _1 = +_[1];\n    if (!(_0 >= 0 && _1 >= 0)) error('invalid size');\n    return dx = _0, dy = _1, density;\n  };\n  density.cellSize = function (_) {\n    if (!arguments.length) return 1 << k;\n    if (!((_ = +_) >= 1)) error('invalid cell size');\n    k = Math.floor(Math.log(_) / Math.LN2);\n    return density;\n  };\n  density.bandwidth = function (_) {\n    if (!arguments.length) return bandwidth;\n    _ = array(_);\n    if (_.length === 1) _ = [+_[0], +_[0]];\n    if (_.length !== 2) error('invalid bandwidth');\n    return bandwidth = _, density;\n  };\n  return density;\n}\nfunction blurX(n, m, source, target, r) {\n  const w = (r << 1) + 1;\n  for (let j = 0; j < m; ++j) {\n    for (let i = 0, sr = 0; i < n + r; ++i) {\n      if (i < n) {\n        sr += source[i + j * n];\n      }\n      if (i >= r) {\n        if (i >= w) {\n          sr -= source[i - w + j * n];\n        }\n        target[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);\n      }\n    }\n  }\n}\nfunction blurY(n, m, source, target, r) {\n  const w = (r << 1) + 1;\n  for (let i = 0; i < n; ++i) {\n    for (let j = 0, sr = 0; j < m + r; ++j) {\n      if (j < m) {\n        sr += source[i + j * n];\n      }\n      if (j >= r) {\n        if (j >= w) {\n          sr -= source[i + (j - w) * n];\n        }\n        target[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);\n      }\n    }\n  }\n}\n\n/**\n * Perform 2D kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The [width, height] extent (in\n *   units of input pixels) over which to perform density estimation.\n * @param {function(object): number} params.x - The x-coordinate accessor.\n * @param {function(object): number} params.y - The y-coordinate accessor.\n * @param {function(object): number} [params.weight] - The weight accessor.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *   to groupby.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n *   This parameter determines the level of spatial approximation. For example,\n *   the default value of 4 maps to 2x reductions in both x- and y- dimensions.\n *   A value of 1 will result in an output raster grid whose dimensions exactly\n *   matches the size parameter.\n * @param {Array<number>} [params.bandwidth] - The KDE kernel bandwidths,\n *   in pixels. The input can be a two-element array specifying separate\n *   x and y bandwidths, or a single-element array specifying both. If the\n *   bandwidth is unspecified or less than zero, the bandwidth will be\n *   automatically determined.\n * @param {boolean} [params.counts=false] - A boolean flag indicating if the\n *   output values should be probability estimates (false, default) or\n *   smoothed counts (true).\n * @param {string} [params.as='grid'] - The output field in which to store\n *   the generated raster grid (default 'grid').\n */\nfunction KDE2D(params) {\n  Transform.call(this, null, params);\n}\nKDE2D.Definition = {\n  'type': 'KDE2D',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'required': true\n  }, {\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'weight',\n    'type': 'field'\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'cellSize',\n    'type': 'number'\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'counts',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'grid'\n  }]\n};\nconst PARAMS = ['x', 'y', 'weight', 'size', 'cellSize', 'bandwidth'];\nfunction params(obj, _) {\n  PARAMS.forEach(param => _[param] != null ? obj[param](_[param]) : 0);\n  return obj;\n}\ninherits(KDE2D, Transform, {\n  transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) return pulse.StopPropagation;\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      source = pulse.materialize(pulse.SOURCE).source,\n      groups = partition(source, _.groupby),\n      names = (_.groupby || []).map(accessorName),\n      kde = params(density2D(), _),\n      as = _.as || 'grid',\n      values = [];\n    function set(t, vals) {\n      for (let i = 0; i < names.length; ++i) t[names[i]] = vals[i];\n      return t;\n    }\n\n    // generate density raster grids\n    values = groups.map(g => ingest(set({\n      [as]: kde(g, _.counts)\n    }, g.dims)));\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = values;\n    return out;\n  }\n});\nfunction partition(data, groupby) {\n  var groups = [],\n    get = f => f(t),\n    map,\n    i,\n    n,\n    t,\n    k,\n    g;\n\n  // partition data points into groups\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n      if (!g) {\n        map[k] = g = [];\n        g.dims = k;\n        groups.push(g);\n      }\n      g.push(t);\n    }\n  }\n  return groups;\n}\n\n/**\n * Generate contours based on kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The dimensions [width, height] over which to compute contours.\n *  If the values parameter is provided, this must be the dimensions of the input data.\n *  If density estimation is performed, this is the output view dimensions in pixels.\n * @param {Array<number>} [params.values] - An array of numeric values representing an\n *  width x height grid of values over which to compute contours. If unspecified, this\n *  transform will instead attempt to compute contours for the kernel density estimate\n *  using values drawn from data tuples in the input pulse.\n * @param {function(object): number} [params.x] - The pixel x-coordinate accessor for density estimation.\n * @param {function(object): number} [params.y] - The pixel y-coordinate accessor for density estimation.\n * @param {function(object): number} [params.weight] - The data point weight accessor for density estimation.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n * @param {number} [params.bandwidth] - Kernel density estimation bandwidth.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   this parameter is set, the count and nice parameters will be ignored.\n * @param {number} [params.count] - The desired number of contours.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified count.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n */\nfunction Contour(params) {\n  Transform.call(this, null, params);\n}\nContour.Definition = {\n  'type': 'Contour',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'required': true\n  }, {\n    'name': 'values',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'x',\n    'type': 'field'\n  }, {\n    'name': 'y',\n    'type': 'field'\n  }, {\n    'name': 'weight',\n    'type': 'field'\n  }, {\n    'name': 'cellSize',\n    'type': 'number'\n  }, {\n    'name': 'bandwidth',\n    'type': 'number'\n  }, {\n    'name': 'count',\n    'type': 'number'\n  }, {\n    'name': 'nice',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'thresholds',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'smooth',\n    'type': 'boolean',\n    'default': true\n  }]\n};\ninherits(Contour, Transform, {\n  transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      contour = contours().smooth(_.smooth !== false),\n      values = _.values,\n      thresh = _.thresholds || quantize(_.count || 10, _.nice, !!values),\n      size = _.size,\n      grid,\n      post;\n    if (!values) {\n      values = pulse.materialize(pulse.SOURCE).source;\n      grid = params(density2D(), _)(values, true);\n      post = transform(grid, grid.scale || 1, grid.scale || 1, 0, 0);\n      size = [grid.width, grid.height];\n      values = grid.values;\n    }\n    thresh = isArray(thresh) ? thresh : thresh(values);\n    values = contour.size(size)(values, thresh);\n    if (post) values.forEach(post);\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = (values || []).map(ingest);\n    return out;\n  }\n});\n\nconst Feature = 'Feature';\nconst FeatureCollection = 'FeatureCollection';\nconst MultiPoint = 'MultiPoint';\n\n/**\n * Consolidate an array of [longitude, latitude] points or GeoJSON features\n * into a combined GeoJSON object. This transform is particularly useful for\n * combining geo data for a Projection's fit argument. The resulting GeoJSON\n * data is available as this transform's value. Input pulses are unchanged.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} [params.fields] - A two-element array\n *   of field accessors for the longitude and latitude values.\n * @param {function(object): *} params.geojson - A field accessor for\n *   retrieving GeoJSON feature data.\n */\nfunction GeoJSON(params) {\n  Transform.call(this, null, params);\n}\nGeoJSON.Definition = {\n  'type': 'GeoJSON',\n  'metadata': {},\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'geojson',\n    'type': 'field'\n  }]\n};\ninherits(GeoJSON, Transform, {\n  transform(_, pulse) {\n    var features = this._features,\n      points = this._points,\n      fields = _.fields,\n      lon = fields && fields[0],\n      lat = fields && fields[1],\n      geojson = _.geojson || !fields && identity,\n      flag = pulse.ADD,\n      mod;\n    mod = _.modified() || pulse.changed(pulse.REM) || pulse.modified(accessorFields(geojson)) || lon && pulse.modified(accessorFields(lon)) || lat && pulse.modified(accessorFields(lat));\n    if (!this.value || mod) {\n      flag = pulse.SOURCE;\n      this._features = features = [];\n      this._points = points = [];\n    }\n    if (geojson) {\n      pulse.visit(flag, t => features.push(geojson(t)));\n    }\n    if (lon && lat) {\n      pulse.visit(flag, t => {\n        var x = lon(t),\n          y = lat(t);\n        if (x != null && y != null && (x = +x) === x && (y = +y) === y) {\n          points.push([x, y]);\n        }\n      });\n      features = features.concat({\n        type: Feature,\n        geometry: {\n          type: MultiPoint,\n          coordinates: points\n        }\n      });\n    }\n    this.value = {\n      type: FeatureCollection,\n      features: features\n    };\n  }\n});\n\n/**\n * Map GeoJSON data to an SVG path string.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {function(object): *} [params.field] - The field with GeoJSON data,\n *   or null if the tuple itself is a GeoJSON feature.\n * @param {string} [params.as='path'] - The output field in which to store\n *   the generated path data (default 'path').\n */\nfunction GeoPath(params) {\n  Transform.call(this, null, params);\n}\nGeoPath.Definition = {\n  'type': 'GeoPath',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection'\n  }, {\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'pointRadius',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'path'\n  }]\n};\ninherits(GeoPath, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ALL),\n      path = this.value,\n      field = _.field || identity,\n      as = _.as || 'path',\n      flag = out.SOURCE;\n    if (!path || _.modified()) {\n      // parameters updated, reset and reflow\n      this.value = path = getProjectionPath(_.projection);\n      out.materialize().reflow();\n    } else {\n      flag = field === identity || pulse.modified(field.fields) ? out.ADD_MOD : out.ADD;\n    }\n    const prev = initPath(path, _.pointRadius);\n    out.visit(flag, t => t[as] = path(field(t)));\n    path.pointRadius(prev);\n    return out.modifies(as);\n  }\n});\nfunction initPath(path, pointRadius) {\n  const prev = path.pointRadius();\n  path.context(null);\n  if (pointRadius != null) {\n    path.pointRadius(pointRadius);\n  }\n  return prev;\n}\n\n/**\n * Geo-code a longitude/latitude point to an x/y coordinate.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {Array<function(object): *>} params.fields - A two-element array of\n *   field accessors for the longitude and latitude values.\n * @param {Array<string>} [params.as] - A two-element array of field names\n *   under which to store the result. Defaults to ['x','y'].\n */\nfunction GeoPoint(params) {\n  Transform.call(this, null, params);\n}\nGeoPoint.Definition = {\n  'type': 'GeoPoint',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection',\n    'required': true\n  }, {\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['x', 'y']\n  }]\n};\ninherits(GeoPoint, Transform, {\n  transform(_, pulse) {\n    var proj = _.projection,\n      lon = _.fields[0],\n      lat = _.fields[1],\n      as = _.as || ['x', 'y'],\n      x = as[0],\n      y = as[1],\n      mod;\n    function set(t) {\n      const xy = proj([lon(t), lat(t)]);\n      if (xy) {\n        t[x] = xy[0];\n        t[y] = xy[1];\n      } else {\n        t[x] = undefined;\n        t[y] = undefined;\n      }\n    }\n    if (_.modified()) {\n      // parameters updated, reflow\n      pulse = pulse.materialize().reflow(true).visit(pulse.SOURCE, set);\n    } else {\n      mod = pulse.modified(lon.fields) || pulse.modified(lat.fields);\n      pulse.visit(mod ? pulse.ADD_MOD : pulse.ADD, set);\n    }\n    return pulse.modifies(as);\n  }\n});\n\n/**\n * Annotate items with a geopath shape generator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {function(object): *} [params.field] - The field with GeoJSON data,\n *   or null if the tuple itself is a GeoJSON feature.\n * @param {string} [params.as='shape'] - The output field in which to store\n *   the generated path data (default 'shape').\n */\nfunction GeoShape(params) {\n  Transform.call(this, null, params);\n}\nGeoShape.Definition = {\n  'type': 'GeoShape',\n  'metadata': {\n    'modifies': true,\n    'nomod': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection'\n  }, {\n    'name': 'field',\n    'type': 'field',\n    'default': 'datum'\n  }, {\n    'name': 'pointRadius',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'shape'\n  }]\n};\ninherits(GeoShape, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ALL),\n      shape = this.value,\n      as = _.as || 'shape',\n      flag = out.ADD;\n    if (!shape || _.modified()) {\n      // parameters updated, reset and reflow\n      this.value = shape = shapeGenerator(getProjectionPath(_.projection), _.field || field('datum'), _.pointRadius);\n      out.materialize().reflow();\n      flag = out.SOURCE;\n    }\n    out.visit(flag, t => t[as] = shape);\n    return out.modifies(as);\n  }\n});\nfunction shapeGenerator(path, field, pointRadius) {\n  const shape = pointRadius == null ? _ => path(field(_)) : _ => {\n    var prev = path.pointRadius(),\n      value = path.pointRadius(pointRadius)(field(_));\n    path.pointRadius(prev);\n    return value;\n  };\n  shape.context = _ => {\n    path.context(_);\n    return shape;\n  };\n  return shape;\n}\n\n/**\n * GeoJSON feature generator for creating graticules.\n * @constructor\n */\nfunction Graticule(params) {\n  Transform.call(this, [], params);\n  this.generator = geoGraticule();\n}\nGraticule.Definition = {\n  'type': 'Graticule',\n  'metadata': {\n    'changes': true,\n    'generates': true\n  },\n  'params': [{\n    'name': 'extent',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'extentMajor',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'extentMinor',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'step',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'stepMajor',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'default': [90, 360]\n  }, {\n    'name': 'stepMinor',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'default': [10, 10]\n  }, {\n    'name': 'precision',\n    'type': 'number',\n    'default': 2.5\n  }]\n};\ninherits(Graticule, Transform, {\n  transform(_, pulse) {\n    var src = this.value,\n      gen = this.generator,\n      t;\n    if (!src.length || _.modified()) {\n      for (const prop in _) {\n        if (isFunction(gen[prop])) {\n          gen[prop](_[prop]);\n        }\n      }\n    }\n    t = gen();\n    if (src.length) {\n      pulse.mod.push(replace(src[0], t));\n    } else {\n      pulse.add.push(ingest(t));\n    }\n    src[0] = t;\n    return pulse;\n  }\n});\n\n/**\n * Render a heatmap image for input raster grid data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} [params.field] - The field with raster grid\n *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n * @param {string} [params.color] - A constant color value or function for\n *   individual pixel color. If a function, it will be invoked with an input\n *   object that includes $x, $y, $value, and $max fields for the grid.\n * @param {number} [params.opacity] - A constant opacity value or function for\n *   individual pixel opacity. If a function, it will be invoked with an input\n *   object that includes $x, $y, $value, and $max fields for the grid.\n * @param {string} [params.resolve] - The method for resolving maximum values\n *   across multiple input grids. If 'independent' (the default), maximum\n *   calculation will be performed separately for each grid. If 'shared',\n *   a single global maximum will be used for all input grids.\n * @param {string} [params.as='image'] - The output field in which to store\n *   the generated bitmap canvas images (default 'image').\n */\nfunction Heatmap(params) {\n  Transform.call(this, null, params);\n}\nHeatmap.Definition = {\n  'type': 'heatmap',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'color',\n    'type': 'string',\n    'expr': true\n  }, {\n    'name': 'opacity',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'resolve',\n    'type': 'enum',\n    'values': ['shared', 'independent'],\n    'default': 'independent'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'image'\n  }]\n};\ninherits(Heatmap, Transform, {\n  transform(_, pulse) {\n    if (!pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n    var source = pulse.materialize(pulse.SOURCE).source,\n      shared = _.resolve === 'shared',\n      field = _.field || identity,\n      opacity = opacity_(_.opacity, _),\n      color = color_(_.color, _),\n      as = _.as || 'image',\n      obj = {\n        $x: 0,\n        $y: 0,\n        $value: 0,\n        $max: shared ? max(source.map(t => max(field(t).values))) : 0\n      };\n    source.forEach(t => {\n      const v = field(t);\n\n      // build proxy data object\n      const o = extend({}, t, obj);\n      // set maximum value if not globally shared\n      if (!shared) o.$max = max(v.values || []);\n\n      // generate canvas image\n      // optimize color/opacity if not pixel-dependent\n      t[as] = toCanvas(v, o, color.dep ? color : constant(color(o)), opacity.dep ? opacity : constant(opacity(o)));\n    });\n    return pulse.reflow(true).modifies(as);\n  }\n});\n\n// get image color function\nfunction color_(color, _) {\n  let f;\n  if (isFunction(color)) {\n    f = obj => rgb(color(obj, _));\n    f.dep = dependency(color);\n  } else {\n    // default to mid-grey\n    f = constant(rgb(color || '#888'));\n  }\n  return f;\n}\n\n// get image opacity function\nfunction opacity_(opacity, _) {\n  let f;\n  if (isFunction(opacity)) {\n    f = obj => opacity(obj, _);\n    f.dep = dependency(opacity);\n  } else if (opacity) {\n    f = constant(opacity);\n  } else {\n    // default to [0, max] opacity gradient\n    f = obj => obj.$value / obj.$max || 0;\n    f.dep = true;\n  }\n  return f;\n}\n\n// check if function depends on individual pixel data\nfunction dependency(f) {\n  if (!isFunction(f)) return false;\n  const set = toSet(accessorFields(f));\n  return set.$x || set.$y || set.$value || set.$max;\n}\n\n// render raster grid to canvas\nfunction toCanvas(grid, obj, color, opacity) {\n  const n = grid.width,\n    m = grid.height,\n    x1 = grid.x1 || 0,\n    y1 = grid.y1 || 0,\n    x2 = grid.x2 || n,\n    y2 = grid.y2 || m,\n    val = grid.values,\n    value = val ? i => val[i] : zero,\n    can = canvas(x2 - x1, y2 - y1),\n    ctx = can.getContext('2d'),\n    img = ctx.getImageData(0, 0, x2 - x1, y2 - y1),\n    pix = img.data;\n  for (let j = y1, k = 0; j < y2; ++j) {\n    obj.$y = j - y1;\n    for (let i = x1, r = j * n; i < x2; ++i, k += 4) {\n      obj.$x = i - x1;\n      obj.$value = value(i + r);\n      const v = color(obj);\n      pix[k + 0] = v.r;\n      pix[k + 1] = v.g;\n      pix[k + 2] = v.b;\n      pix[k + 3] = ~~(255 * opacity(obj));\n    }\n  }\n  ctx.putImageData(img, 0, 0);\n  return can;\n}\n\n/**\n * Maintains a cartographic projection.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\nfunction Projection(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\ninherits(Projection, Transform, {\n  transform(_, pulse) {\n    let proj = this.value;\n    if (!proj || _.modified('type')) {\n      this.value = proj = create(_.type);\n      projectionProperties.forEach(prop => {\n        if (_[prop] != null) set(proj, prop, _[prop]);\n      });\n    } else {\n      projectionProperties.forEach(prop => {\n        if (_.modified(prop)) set(proj, prop, _[prop]);\n      });\n    }\n    if (_.pointRadius != null) proj.path.pointRadius(_.pointRadius);\n    if (_.fit) fit(proj, _);\n    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n  }\n});\nfunction fit(proj, _) {\n  const data = collectGeoJSON(_.fit);\n  _.extent ? proj.fitExtent(_.extent, data) : _.size ? proj.fitSize(_.size, data) : 0;\n}\nfunction create(type) {\n  const constructor = projection((type || 'mercator').toLowerCase());\n  if (!constructor) error('Unrecognized projection type: ' + type);\n  return constructor();\n}\nfunction set(proj, key, value) {\n  if (isFunction(proj[key])) proj[key](value);\n}\nfunction collectGeoJSON(data) {\n  data = array(data);\n  return data.length === 1 ? data[0] : {\n    type: FeatureCollection,\n    features: data.reduce((a, f) => a.concat(featurize(f)), [])\n  };\n}\nfunction featurize(f) {\n  return f.type === FeatureCollection ? f.features : array(f).filter(d => d != null).map(d => d.type === Feature ? d : {\n    type: Feature,\n    geometry: d\n  });\n}\n\nexport { Contour as contour, GeoJSON as geojson, GeoPath as geopath, GeoPoint as geopoint, GeoShape as geoshape, Graticule as graticule, Heatmap as heatmap, Isocontour as isocontour, KDE2D as kde2d, Projection as projection };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}