{"ast":null,"code":"/**\n * Utility for generating row / column headers\n */\nimport { isArray } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { vgField } from '../../channeldef';\nimport { HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP } from '../../header';\nimport { isSortField } from '../../sort';\nimport { isFacetMapping } from '../../spec/facet';\nimport { contains, isEmpty, normalizeAngle, replaceAll } from '../../util';\nimport { defaultLabelAlign, defaultLabelBaseline } from '../axis/properties';\nimport { sortArrayIndexField } from '../data/calculate';\nimport { formatSignalRef } from '../format';\nimport { isFacetModel } from '../model';\nimport { getHeaderChannel, getHeaderProperties, getHeaderProperty } from './common';\nimport { HEADER_TYPES } from './component';\n// TODO: rename to assembleHeaderTitleGroup\nexport function assembleTitleGroup(model, channel) {\n  const title = model.component.layoutHeaders[channel].title;\n  const config = model.config ? model.config : undefined;\n  const facetFieldDef = model.component.layoutHeaders[channel].facetFieldDef ? model.component.layoutHeaders[channel].facetFieldDef : undefined;\n  const {\n    titleAnchor,\n    titleAngle: ta,\n    titleOrient\n  } = getHeaderProperties(['titleAnchor', 'titleAngle', 'titleOrient'], facetFieldDef.header, config, channel);\n  const headerChannel = getHeaderChannel(channel, titleOrient);\n  const titleAngle = normalizeAngle(ta);\n  return {\n    name: `${channel}-title`,\n    type: 'group',\n    role: `${headerChannel}-title`,\n    title: {\n      text: title,\n      ...(channel === 'row' ? {\n        orient: 'left'\n      } : {}),\n      style: 'guide-title',\n      ...defaultHeaderGuideBaseline(titleAngle, headerChannel),\n      ...defaultHeaderGuideAlign(headerChannel, titleAngle, titleAnchor),\n      ...assembleHeaderProperties(config, facetFieldDef, channel, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP)\n    }\n  };\n}\nexport function defaultHeaderGuideAlign(headerChannel, angle) {\n  let anchor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'middle';\n  switch (anchor) {\n    case 'start':\n      return {\n        align: 'left'\n      };\n    case 'end':\n      return {\n        align: 'right'\n      };\n  }\n  const align = defaultLabelAlign(angle, headerChannel === 'row' ? 'left' : 'top', headerChannel === 'row' ? 'y' : 'x');\n  return align ? {\n    align\n  } : {};\n}\nexport function defaultHeaderGuideBaseline(angle, channel) {\n  const baseline = defaultLabelBaseline(angle, channel === 'row' ? 'left' : 'top', channel === 'row' ? 'y' : 'x', true);\n  return baseline ? {\n    baseline\n  } : {};\n}\nexport function assembleHeaderGroups(model, channel) {\n  const layoutHeader = model.component.layoutHeaders[channel];\n  const groups = [];\n  for (const headerType of HEADER_TYPES) {\n    if (layoutHeader[headerType]) {\n      for (const headerComponent of layoutHeader[headerType]) {\n        const group = assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent);\n        if (group != null) {\n          groups.push(group);\n        }\n      }\n    }\n  }\n  return groups;\n}\nfunction getSort(facetFieldDef, channel) {\n  const {\n    sort\n  } = facetFieldDef;\n  if (isSortField(sort)) {\n    return {\n      field: vgField(sort, {\n        expr: 'datum'\n      }),\n      order: sort.order ?? 'ascending'\n    };\n  } else if (isArray(sort)) {\n    return {\n      field: sortArrayIndexField(facetFieldDef, channel, {\n        expr: 'datum'\n      }),\n      order: 'ascending'\n    };\n  } else {\n    return {\n      field: vgField(facetFieldDef, {\n        expr: 'datum'\n      }),\n      order: sort ?? 'ascending'\n    };\n  }\n}\nexport function assembleLabelTitle(facetFieldDef, channel, config) {\n  const {\n    format,\n    formatType,\n    labelAngle,\n    labelAnchor,\n    labelOrient,\n    labelExpr\n  } = getHeaderProperties(['format', 'formatType', 'labelAngle', 'labelAnchor', 'labelOrient', 'labelExpr'], facetFieldDef.header, config, channel);\n  const titleTextExpr = formatSignalRef({\n    fieldOrDatumDef: facetFieldDef,\n    format,\n    formatType,\n    expr: 'parent',\n    config\n  }).signal;\n  const headerChannel = getHeaderChannel(channel, labelOrient);\n  return {\n    text: {\n      signal: labelExpr ? replaceAll(replaceAll(labelExpr, 'datum.label', titleTextExpr), 'datum.value', vgField(facetFieldDef, {\n        expr: 'parent'\n      })) : titleTextExpr\n    },\n    ...(channel === 'row' ? {\n      orient: 'left'\n    } : {}),\n    style: 'guide-label',\n    frame: 'group',\n    ...defaultHeaderGuideBaseline(labelAngle, headerChannel),\n    ...defaultHeaderGuideAlign(headerChannel, labelAngle, labelAnchor),\n    ...assembleHeaderProperties(config, facetFieldDef, channel, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP)\n  };\n}\nexport function assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent) {\n  if (headerComponent) {\n    let title = null;\n    const {\n      facetFieldDef\n    } = layoutHeader;\n    const config = model.config ? model.config : undefined;\n    if (facetFieldDef && headerComponent.labels) {\n      const {\n        labelOrient\n      } = getHeaderProperties(['labelOrient'], facetFieldDef.header, config, channel);\n      // Include label title in the header if orient aligns with the channel\n      if (channel === 'row' && !contains(['top', 'bottom'], labelOrient) || channel === 'column' && !contains(['left', 'right'], labelOrient)) {\n        title = assembleLabelTitle(facetFieldDef, channel, config);\n      }\n    }\n    const isFacetWithoutRowCol = isFacetModel(model) && !isFacetMapping(model.facet);\n    const axes = headerComponent.axes;\n    const hasAxes = axes?.length > 0;\n    if (title || hasAxes) {\n      const sizeChannel = channel === 'row' ? 'height' : 'width';\n      return {\n        name: model.getName(`${channel}_${headerType}`),\n        type: 'group',\n        role: `${channel}-${headerType}`,\n        ...(layoutHeader.facetFieldDef ? {\n          from: {\n            data: model.getName(`${channel}_domain`)\n          },\n          sort: getSort(facetFieldDef, channel)\n        } : {}),\n        ...(hasAxes && isFacetWithoutRowCol ? {\n          from: {\n            data: model.getName(`facet_domain_${channel}`)\n          }\n        } : {}),\n        ...(title ? {\n          title\n        } : {}),\n        ...(headerComponent.sizeSignal ? {\n          encode: {\n            update: {\n              [sizeChannel]: headerComponent.sizeSignal\n            }\n          }\n        } : {}),\n        ...(hasAxes ? {\n          axes\n        } : {})\n      };\n    }\n  }\n  return null;\n}\nconst LAYOUT_TITLE_BAND = {\n  column: {\n    start: 0,\n    end: 1\n  },\n  row: {\n    start: 1,\n    end: 0\n  }\n};\nexport function getLayoutTitleBand(titleAnchor, headerChannel) {\n  return LAYOUT_TITLE_BAND[headerChannel][titleAnchor];\n}\nexport function assembleLayoutTitleBand(headerComponentIndex, config) {\n  const titleBand = {};\n  for (const channel of FACET_CHANNELS) {\n    const headerComponent = headerComponentIndex[channel];\n    if (headerComponent?.facetFieldDef) {\n      const {\n        titleAnchor,\n        titleOrient\n      } = getHeaderProperties(['titleAnchor', 'titleOrient'], headerComponent.facetFieldDef.header, config, channel);\n      const headerChannel = getHeaderChannel(channel, titleOrient);\n      const band = getLayoutTitleBand(titleAnchor, headerChannel);\n      if (band !== undefined) {\n        titleBand[headerChannel] = band;\n      }\n    }\n  }\n  return isEmpty(titleBand) ? undefined : titleBand;\n}\nexport function assembleHeaderProperties(config, facetFieldDef, channel, properties, propertiesMap) {\n  const props = {};\n  for (const prop of properties) {\n    if (!propertiesMap[prop]) {\n      continue;\n    }\n    const value = getHeaderProperty(prop, facetFieldDef?.header, config, channel);\n    if (value !== undefined) {\n      props[propertiesMap[prop]] = value;\n    }\n  }\n  return props;\n}","map":{"version":3,"names":["isArray","FACET_CHANNELS","vgField","HEADER_LABEL_PROPERTIES","HEADER_LABEL_PROPERTIES_MAP","HEADER_TITLE_PROPERTIES","HEADER_TITLE_PROPERTIES_MAP","isSortField","isFacetMapping","contains","isEmpty","normalizeAngle","replaceAll","defaultLabelAlign","defaultLabelBaseline","sortArrayIndexField","formatSignalRef","isFacetModel","getHeaderChannel","getHeaderProperties","getHeaderProperty","HEADER_TYPES","assembleTitleGroup","model","channel","title","component","layoutHeaders","config","undefined","facetFieldDef","titleAnchor","titleAngle","ta","titleOrient","header","headerChannel","name","type","role","text","orient","style","defaultHeaderGuideBaseline","defaultHeaderGuideAlign","assembleHeaderProperties","angle","anchor","arguments","length","align","baseline","assembleHeaderGroups","layoutHeader","groups","headerType","headerComponent","group","assembleHeaderGroup","push","getSort","sort","field","expr","order","assembleLabelTitle","format","formatType","labelAngle","labelAnchor","labelOrient","labelExpr","titleTextExpr","fieldOrDatumDef","signal","frame","labels","isFacetWithoutRowCol","facet","axes","hasAxes","sizeChannel","getName","from","data","sizeSignal","encode","update","LAYOUT_TITLE_BAND","column","start","end","row","getLayoutTitleBand","assembleLayoutTitleBand","headerComponentIndex","titleBand","band","properties","propertiesMap","props","prop","value"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\compile\\header\\assemble.ts"],"sourcesContent":["/**\n * Utility for generating row / column headers\n */\n\nimport {SignalRef, TitleAnchor, TitleConfig} from 'vega';\nimport {isArray} from 'vega-util';\nimport {FacetChannel, FACET_CHANNELS} from '../../channel';\nimport {vgField} from '../../channeldef';\nimport {Config} from '../../config';\nimport {\n  CoreHeader,\n  HEADER_LABEL_PROPERTIES,\n  HEADER_LABEL_PROPERTIES_MAP,\n  HEADER_TITLE_PROPERTIES,\n  HEADER_TITLE_PROPERTIES_MAP\n} from '../../header';\nimport {isSortField} from '../../sort';\nimport {FacetFieldDef, isFacetMapping} from '../../spec/facet';\nimport {contains, isEmpty, normalizeAngle, replaceAll} from '../../util';\nimport {RowCol, VgComparator, VgMarkGroup, VgTitle} from '../../vega.schema';\nimport {defaultLabelAlign, defaultLabelBaseline} from '../axis/properties';\nimport {sortArrayIndexField} from '../data/calculate';\nimport {formatSignalRef} from '../format';\nimport {isFacetModel, Model} from '../model';\nimport {getHeaderChannel, getHeaderProperties, getHeaderProperty} from './common';\nimport {\n  HeaderChannel,\n  HeaderComponent,\n  HeaderType,\n  HEADER_TYPES,\n  LayoutHeaderComponent,\n  LayoutHeaderComponentIndex\n} from './component';\n\n// TODO: rename to assembleHeaderTitleGroup\nexport function assembleTitleGroup(model: Model, channel: FacetChannel) {\n  const title = model.component.layoutHeaders[channel].title;\n  const config = model.config ? model.config : undefined;\n  const facetFieldDef = model.component.layoutHeaders[channel].facetFieldDef\n    ? model.component.layoutHeaders[channel].facetFieldDef\n    : undefined;\n\n  const {\n    titleAnchor,\n    titleAngle: ta,\n    titleOrient\n  } = getHeaderProperties(['titleAnchor', 'titleAngle', 'titleOrient'], facetFieldDef.header, config, channel);\n  const headerChannel = getHeaderChannel(channel, titleOrient);\n\n  const titleAngle = normalizeAngle(ta);\n\n  return {\n    name: `${channel}-title`,\n    type: 'group',\n    role: `${headerChannel}-title`,\n    title: {\n      text: title,\n      ...(channel === 'row' ? {orient: 'left'} : {}),\n      style: 'guide-title',\n      ...defaultHeaderGuideBaseline(titleAngle, headerChannel),\n      ...defaultHeaderGuideAlign(headerChannel, titleAngle, titleAnchor),\n      ...assembleHeaderProperties(config, facetFieldDef, channel, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP)\n    }\n  };\n}\n\nexport function defaultHeaderGuideAlign(headerChannel: HeaderChannel, angle: number, anchor: TitleAnchor = 'middle') {\n  switch (anchor) {\n    case 'start':\n      return {align: 'left'};\n    case 'end':\n      return {align: 'right'};\n  }\n\n  const align = defaultLabelAlign(angle, headerChannel === 'row' ? 'left' : 'top', headerChannel === 'row' ? 'y' : 'x');\n  return align ? {align} : {};\n}\n\nexport function defaultHeaderGuideBaseline(angle: number, channel: FacetChannel) {\n  const baseline = defaultLabelBaseline(angle, channel === 'row' ? 'left' : 'top', channel === 'row' ? 'y' : 'x', true);\n  return baseline ? {baseline} : {};\n}\n\nexport function assembleHeaderGroups(model: Model, channel: HeaderChannel): VgMarkGroup[] {\n  const layoutHeader = model.component.layoutHeaders[channel];\n  const groups = [];\n  for (const headerType of HEADER_TYPES) {\n    if (layoutHeader[headerType]) {\n      for (const headerComponent of layoutHeader[headerType]) {\n        const group = assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent);\n        if (group != null) {\n          groups.push(group);\n        }\n      }\n    }\n  }\n  return groups;\n}\n\nfunction getSort(facetFieldDef: FacetFieldDef<string>, channel: HeaderChannel): VgComparator {\n  const {sort} = facetFieldDef;\n  if (isSortField(sort)) {\n    return {\n      field: vgField(sort, {expr: 'datum'}),\n      order: sort.order ?? 'ascending'\n    };\n  } else if (isArray(sort)) {\n    return {\n      field: sortArrayIndexField(facetFieldDef, channel, {expr: 'datum'}),\n      order: 'ascending'\n    };\n  } else {\n    return {\n      field: vgField(facetFieldDef, {expr: 'datum'}),\n      order: sort ?? 'ascending'\n    };\n  }\n}\n\nexport function assembleLabelTitle(\n  facetFieldDef: FacetFieldDef<string, SignalRef>,\n  channel: FacetChannel,\n  config: Config<SignalRef>\n) {\n  const {format, formatType, labelAngle, labelAnchor, labelOrient, labelExpr} = getHeaderProperties(\n    ['format', 'formatType', 'labelAngle', 'labelAnchor', 'labelOrient', 'labelExpr'],\n    facetFieldDef.header,\n    config,\n    channel\n  );\n\n  const titleTextExpr = formatSignalRef({\n    fieldOrDatumDef: facetFieldDef,\n    format,\n    formatType,\n    expr: 'parent',\n    config\n  }).signal;\n  const headerChannel = getHeaderChannel(channel, labelOrient);\n\n  return {\n    text: {\n      signal: labelExpr\n        ? replaceAll(\n            replaceAll(labelExpr, 'datum.label', titleTextExpr),\n            'datum.value',\n            vgField(facetFieldDef, {expr: 'parent'})\n          )\n        : titleTextExpr\n    },\n    ...(channel === 'row' ? {orient: 'left'} : {}),\n    style: 'guide-label',\n    frame: 'group',\n    ...defaultHeaderGuideBaseline(labelAngle, headerChannel),\n    ...defaultHeaderGuideAlign(headerChannel, labelAngle, labelAnchor),\n    ...assembleHeaderProperties(config, facetFieldDef, channel, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP)\n  };\n}\n\nexport function assembleHeaderGroup(\n  model: Model,\n  channel: HeaderChannel,\n  headerType: HeaderType,\n  layoutHeader: LayoutHeaderComponent,\n  headerComponent: HeaderComponent\n) {\n  if (headerComponent) {\n    let title = null;\n    const {facetFieldDef} = layoutHeader;\n    const config = model.config ? model.config : undefined;\n    if (facetFieldDef && headerComponent.labels) {\n      const {labelOrient} = getHeaderProperties(['labelOrient'], facetFieldDef.header, config, channel);\n\n      // Include label title in the header if orient aligns with the channel\n      if (\n        (channel === 'row' && !contains(['top', 'bottom'], labelOrient)) ||\n        (channel === 'column' && !contains(['left', 'right'], labelOrient))\n      ) {\n        title = assembleLabelTitle(facetFieldDef, channel, config);\n      }\n    }\n\n    const isFacetWithoutRowCol = isFacetModel(model) && !isFacetMapping(model.facet);\n\n    const axes = headerComponent.axes;\n\n    const hasAxes = axes?.length > 0;\n    if (title || hasAxes) {\n      const sizeChannel = channel === 'row' ? 'height' : 'width';\n\n      return {\n        name: model.getName(`${channel}_${headerType}`),\n        type: 'group',\n        role: `${channel}-${headerType}`,\n\n        ...(layoutHeader.facetFieldDef\n          ? {\n              from: {data: model.getName(`${channel}_domain`)},\n              sort: getSort(facetFieldDef, channel)\n            }\n          : {}),\n        ...(hasAxes && isFacetWithoutRowCol\n          ? {\n              from: {data: model.getName(`facet_domain_${channel}`)}\n            }\n          : {}),\n\n        ...(title ? {title} : {}),\n        ...(headerComponent.sizeSignal\n          ? {\n              encode: {\n                update: {\n                  [sizeChannel]: headerComponent.sizeSignal\n                }\n              }\n            }\n          : {}),\n        ...(hasAxes ? {axes} : {})\n      };\n    }\n  }\n  return null;\n}\n\nconst LAYOUT_TITLE_BAND = {\n  column: {\n    start: 0,\n    end: 1\n  },\n  row: {\n    start: 1,\n    end: 0\n  }\n};\n\nexport function getLayoutTitleBand(titleAnchor: TitleAnchor, headerChannel: HeaderChannel): 0 | 1 {\n  return (LAYOUT_TITLE_BAND[headerChannel] as any)[titleAnchor];\n}\n\nexport function assembleLayoutTitleBand(\n  headerComponentIndex: LayoutHeaderComponentIndex,\n  config: Config<SignalRef>\n): RowCol<number> {\n  const titleBand = {};\n\n  for (const channel of FACET_CHANNELS) {\n    const headerComponent = headerComponentIndex[channel];\n    if (headerComponent?.facetFieldDef) {\n      const {titleAnchor, titleOrient} = getHeaderProperties(\n        ['titleAnchor', 'titleOrient'],\n        headerComponent.facetFieldDef.header,\n        config,\n        channel\n      );\n\n      const headerChannel = getHeaderChannel(channel, titleOrient);\n      const band = getLayoutTitleBand(titleAnchor, headerChannel);\n      if (band !== undefined) {\n        (titleBand as any)[headerChannel] = band;\n      }\n    }\n  }\n\n  return isEmpty(titleBand) ? undefined : titleBand;\n}\n\nexport function assembleHeaderProperties(\n  config: Config<SignalRef>,\n  facetFieldDef: FacetFieldDef<string, SignalRef>,\n  channel: FacetChannel,\n  properties: (keyof CoreHeader<SignalRef>)[],\n  propertiesMap: Partial<Record<keyof CoreHeader<SignalRef>, keyof TitleConfig>>\n): Partial<VgTitle> {\n  const props = {};\n  for (const prop of properties) {\n    if (!propertiesMap[prop]) {\n      continue;\n    }\n\n    const value = getHeaderProperty(prop, facetFieldDef?.header, config, channel);\n    if (value !== undefined) {\n      (props as any)[propertiesMap[prop]] = value;\n    }\n  }\n  return props;\n}\n"],"mappings":"AAAA;;;AAKA,SAAQA,OAAO,QAAO,WAAW;AACjC,SAAsBC,cAAc,QAAO,eAAe;AAC1D,SAAQC,OAAO,QAAO,kBAAkB;AAExC,SAEEC,uBAAuB,EACvBC,2BAA2B,EAC3BC,uBAAuB,EACvBC,2BAA2B,QACtB,cAAc;AACrB,SAAQC,WAAW,QAAO,YAAY;AACtC,SAAuBC,cAAc,QAAO,kBAAkB;AAC9D,SAAQC,QAAQ,EAAEC,OAAO,EAAEC,cAAc,EAAEC,UAAU,QAAO,YAAY;AAExE,SAAQC,iBAAiB,EAAEC,oBAAoB,QAAO,oBAAoB;AAC1E,SAAQC,mBAAmB,QAAO,mBAAmB;AACrD,SAAQC,eAAe,QAAO,WAAW;AACzC,SAAQC,YAAY,QAAc,UAAU;AAC5C,SAAQC,gBAAgB,EAAEC,mBAAmB,EAAEC,iBAAiB,QAAO,UAAU;AACjF,SAIEC,YAAY,QAGP,aAAa;AAEpB;AACA,OAAM,SAAUC,kBAAkBA,CAACC,KAAY,EAAEC,OAAqB;EACpE,MAAMC,KAAK,GAAGF,KAAK,CAACG,SAAS,CAACC,aAAa,CAACH,OAAO,CAAC,CAACC,KAAK;EAC1D,MAAMG,MAAM,GAAGL,KAAK,CAACK,MAAM,GAAGL,KAAK,CAACK,MAAM,GAAGC,SAAS;EACtD,MAAMC,aAAa,GAAGP,KAAK,CAACG,SAAS,CAACC,aAAa,CAACH,OAAO,CAAC,CAACM,aAAa,GACtEP,KAAK,CAACG,SAAS,CAACC,aAAa,CAACH,OAAO,CAAC,CAACM,aAAa,GACpDD,SAAS;EAEb,MAAM;IACJE,WAAW;IACXC,UAAU,EAAEC,EAAE;IACdC;EAAW,CACZ,GAAGf,mBAAmB,CAAC,CAAC,aAAa,EAAE,YAAY,EAAE,aAAa,CAAC,EAAEW,aAAa,CAACK,MAAM,EAAEP,MAAM,EAAEJ,OAAO,CAAC;EAC5G,MAAMY,aAAa,GAAGlB,gBAAgB,CAACM,OAAO,EAAEU,WAAW,CAAC;EAE5D,MAAMF,UAAU,GAAGrB,cAAc,CAACsB,EAAE,CAAC;EAErC,OAAO;IACLI,IAAI,EAAE,GAAGb,OAAO,QAAQ;IACxBc,IAAI,EAAE,OAAO;IACbC,IAAI,EAAE,GAAGH,aAAa,QAAQ;IAC9BX,KAAK,EAAE;MACLe,IAAI,EAAEf,KAAK;MACX,IAAID,OAAO,KAAK,KAAK,GAAG;QAACiB,MAAM,EAAE;MAAM,CAAC,GAAG,EAAE,CAAC;MAC9CC,KAAK,EAAE,aAAa;MACpB,GAAGC,0BAA0B,CAACX,UAAU,EAAEI,aAAa,CAAC;MACxD,GAAGQ,uBAAuB,CAACR,aAAa,EAAEJ,UAAU,EAAED,WAAW,CAAC;MAClE,GAAGc,wBAAwB,CAACjB,MAAM,EAAEE,aAAa,EAAEN,OAAO,EAAEnB,uBAAuB,EAAEC,2BAA2B;;GAEnH;AACH;AAEA,OAAM,SAAUsC,uBAAuBA,CAACR,aAA4B,EAAEU,KAAa,EAAgC;EAAA,IAA9BC,MAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAnB,SAAA,GAAAmB,SAAA,MAAsB,QAAQ;EACjH,QAAQD,MAAM;IACZ,KAAK,OAAO;MACV,OAAO;QAACG,KAAK,EAAE;MAAM,CAAC;IACxB,KAAK,KAAK;MACR,OAAO;QAACA,KAAK,EAAE;MAAO,CAAC;EAC3B;EAEA,MAAMA,KAAK,GAAGrC,iBAAiB,CAACiC,KAAK,EAAEV,aAAa,KAAK,KAAK,GAAG,MAAM,GAAG,KAAK,EAAEA,aAAa,KAAK,KAAK,GAAG,GAAG,GAAG,GAAG,CAAC;EACrH,OAAOc,KAAK,GAAG;IAACA;EAAK,CAAC,GAAG,EAAE;AAC7B;AAEA,OAAM,SAAUP,0BAA0BA,CAACG,KAAa,EAAEtB,OAAqB;EAC7E,MAAM2B,QAAQ,GAAGrC,oBAAoB,CAACgC,KAAK,EAAEtB,OAAO,KAAK,KAAK,GAAG,MAAM,GAAG,KAAK,EAAEA,OAAO,KAAK,KAAK,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC;EACrH,OAAO2B,QAAQ,GAAG;IAACA;EAAQ,CAAC,GAAG,EAAE;AACnC;AAEA,OAAM,SAAUC,oBAAoBA,CAAC7B,KAAY,EAAEC,OAAsB;EACvE,MAAM6B,YAAY,GAAG9B,KAAK,CAACG,SAAS,CAACC,aAAa,CAACH,OAAO,CAAC;EAC3D,MAAM8B,MAAM,GAAG,EAAE;EACjB,KAAK,MAAMC,UAAU,IAAIlC,YAAY,EAAE;IACrC,IAAIgC,YAAY,CAACE,UAAU,CAAC,EAAE;MAC5B,KAAK,MAAMC,eAAe,IAAIH,YAAY,CAACE,UAAU,CAAC,EAAE;QACtD,MAAME,KAAK,GAAGC,mBAAmB,CAACnC,KAAK,EAAEC,OAAO,EAAE+B,UAAU,EAAEF,YAAY,EAAEG,eAAe,CAAC;QAC5F,IAAIC,KAAK,IAAI,IAAI,EAAE;UACjBH,MAAM,CAACK,IAAI,CAACF,KAAK,CAAC;QACpB;MACF;IACF;EACF;EACA,OAAOH,MAAM;AACf;AAEA,SAASM,OAAOA,CAAC9B,aAAoC,EAAEN,OAAsB;EAC3E,MAAM;IAACqC;EAAI,CAAC,GAAG/B,aAAa;EAC5B,IAAIvB,WAAW,CAACsD,IAAI,CAAC,EAAE;IACrB,OAAO;MACLC,KAAK,EAAE5D,OAAO,CAAC2D,IAAI,EAAE;QAACE,IAAI,EAAE;MAAO,CAAC,CAAC;MACrCC,KAAK,EAAEH,IAAI,CAACG,KAAK,IAAI;KACtB;EACH,CAAC,MAAM,IAAIhE,OAAO,CAAC6D,IAAI,CAAC,EAAE;IACxB,OAAO;MACLC,KAAK,EAAE/C,mBAAmB,CAACe,aAAa,EAAEN,OAAO,EAAE;QAACuC,IAAI,EAAE;MAAO,CAAC,CAAC;MACnEC,KAAK,EAAE;KACR;EACH,CAAC,MAAM;IACL,OAAO;MACLF,KAAK,EAAE5D,OAAO,CAAC4B,aAAa,EAAE;QAACiC,IAAI,EAAE;MAAO,CAAC,CAAC;MAC9CC,KAAK,EAAEH,IAAI,IAAI;KAChB;EACH;AACF;AAEA,OAAM,SAAUI,kBAAkBA,CAChCnC,aAA+C,EAC/CN,OAAqB,EACrBI,MAAyB;EAEzB,MAAM;IAACsC,MAAM;IAAEC,UAAU;IAAEC,UAAU;IAAEC,WAAW;IAAEC,WAAW;IAAEC;EAAS,CAAC,GAAGpD,mBAAmB,CAC/F,CAAC,QAAQ,EAAE,YAAY,EAAE,YAAY,EAAE,aAAa,EAAE,aAAa,EAAE,WAAW,CAAC,EACjFW,aAAa,CAACK,MAAM,EACpBP,MAAM,EACNJ,OAAO,CACR;EAED,MAAMgD,aAAa,GAAGxD,eAAe,CAAC;IACpCyD,eAAe,EAAE3C,aAAa;IAC9BoC,MAAM;IACNC,UAAU;IACVJ,IAAI,EAAE,QAAQ;IACdnC;GACD,CAAC,CAAC8C,MAAM;EACT,MAAMtC,aAAa,GAAGlB,gBAAgB,CAACM,OAAO,EAAE8C,WAAW,CAAC;EAE5D,OAAO;IACL9B,IAAI,EAAE;MACJkC,MAAM,EAAEH,SAAS,GACb3D,UAAU,CACRA,UAAU,CAAC2D,SAAS,EAAE,aAAa,EAAEC,aAAa,CAAC,EACnD,aAAa,EACbtE,OAAO,CAAC4B,aAAa,EAAE;QAACiC,IAAI,EAAE;MAAQ,CAAC,CAAC,CACzC,GACDS;KACL;IACD,IAAIhD,OAAO,KAAK,KAAK,GAAG;MAACiB,MAAM,EAAE;IAAM,CAAC,GAAG,EAAE,CAAC;IAC9CC,KAAK,EAAE,aAAa;IACpBiC,KAAK,EAAE,OAAO;IACd,GAAGhC,0BAA0B,CAACyB,UAAU,EAAEhC,aAAa,CAAC;IACxD,GAAGQ,uBAAuB,CAACR,aAAa,EAAEgC,UAAU,EAAEC,WAAW,CAAC;IAClE,GAAGxB,wBAAwB,CAACjB,MAAM,EAAEE,aAAa,EAAEN,OAAO,EAAErB,uBAAuB,EAAEC,2BAA2B;GACjH;AACH;AAEA,OAAM,SAAUsD,mBAAmBA,CACjCnC,KAAY,EACZC,OAAsB,EACtB+B,UAAsB,EACtBF,YAAmC,EACnCG,eAAgC;EAEhC,IAAIA,eAAe,EAAE;IACnB,IAAI/B,KAAK,GAAG,IAAI;IAChB,MAAM;MAACK;IAAa,CAAC,GAAGuB,YAAY;IACpC,MAAMzB,MAAM,GAAGL,KAAK,CAACK,MAAM,GAAGL,KAAK,CAACK,MAAM,GAAGC,SAAS;IACtD,IAAIC,aAAa,IAAI0B,eAAe,CAACoB,MAAM,EAAE;MAC3C,MAAM;QAACN;MAAW,CAAC,GAAGnD,mBAAmB,CAAC,CAAC,aAAa,CAAC,EAAEW,aAAa,CAACK,MAAM,EAAEP,MAAM,EAAEJ,OAAO,CAAC;MAEjG;MACA,IACGA,OAAO,KAAK,KAAK,IAAI,CAACf,QAAQ,CAAC,CAAC,KAAK,EAAE,QAAQ,CAAC,EAAE6D,WAAW,CAAC,IAC9D9C,OAAO,KAAK,QAAQ,IAAI,CAACf,QAAQ,CAAC,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE6D,WAAW,CAAE,EACnE;QACA7C,KAAK,GAAGwC,kBAAkB,CAACnC,aAAa,EAAEN,OAAO,EAAEI,MAAM,CAAC;MAC5D;IACF;IAEA,MAAMiD,oBAAoB,GAAG5D,YAAY,CAACM,KAAK,CAAC,IAAI,CAACf,cAAc,CAACe,KAAK,CAACuD,KAAK,CAAC;IAEhF,MAAMC,IAAI,GAAGvB,eAAe,CAACuB,IAAI;IAEjC,MAAMC,OAAO,GAAGD,IAAI,EAAE9B,MAAM,GAAG,CAAC;IAChC,IAAIxB,KAAK,IAAIuD,OAAO,EAAE;MACpB,MAAMC,WAAW,GAAGzD,OAAO,KAAK,KAAK,GAAG,QAAQ,GAAG,OAAO;MAE1D,OAAO;QACLa,IAAI,EAAEd,KAAK,CAAC2D,OAAO,CAAC,GAAG1D,OAAO,IAAI+B,UAAU,EAAE,CAAC;QAC/CjB,IAAI,EAAE,OAAO;QACbC,IAAI,EAAE,GAAGf,OAAO,IAAI+B,UAAU,EAAE;QAEhC,IAAIF,YAAY,CAACvB,aAAa,GAC1B;UACEqD,IAAI,EAAE;YAACC,IAAI,EAAE7D,KAAK,CAAC2D,OAAO,CAAC,GAAG1D,OAAO,SAAS;UAAC,CAAC;UAChDqC,IAAI,EAAED,OAAO,CAAC9B,aAAa,EAAEN,OAAO;SACrC,GACD,EAAE,CAAC;QACP,IAAIwD,OAAO,IAAIH,oBAAoB,GAC/B;UACEM,IAAI,EAAE;YAACC,IAAI,EAAE7D,KAAK,CAAC2D,OAAO,CAAC,gBAAgB1D,OAAO,EAAE;UAAC;SACtD,GACD,EAAE,CAAC;QAEP,IAAIC,KAAK,GAAG;UAACA;QAAK,CAAC,GAAG,EAAE,CAAC;QACzB,IAAI+B,eAAe,CAAC6B,UAAU,GAC1B;UACEC,MAAM,EAAE;YACNC,MAAM,EAAE;cACN,CAACN,WAAW,GAAGzB,eAAe,CAAC6B;;;SAGpC,GACD,EAAE,CAAC;QACP,IAAIL,OAAO,GAAG;UAACD;QAAI,CAAC,GAAG,EAAE;OAC1B;IACH;EACF;EACA,OAAO,IAAI;AACb;AAEA,MAAMS,iBAAiB,GAAG;EACxBC,MAAM,EAAE;IACNC,KAAK,EAAE,CAAC;IACRC,GAAG,EAAE;GACN;EACDC,GAAG,EAAE;IACHF,KAAK,EAAE,CAAC;IACRC,GAAG,EAAE;;CAER;AAED,OAAM,SAAUE,kBAAkBA,CAAC9D,WAAwB,EAAEK,aAA4B;EACvF,OAAQoD,iBAAiB,CAACpD,aAAa,CAAS,CAACL,WAAW,CAAC;AAC/D;AAEA,OAAM,SAAU+D,uBAAuBA,CACrCC,oBAAgD,EAChDnE,MAAyB;EAEzB,MAAMoE,SAAS,GAAG,EAAE;EAEpB,KAAK,MAAMxE,OAAO,IAAIvB,cAAc,EAAE;IACpC,MAAMuD,eAAe,GAAGuC,oBAAoB,CAACvE,OAAO,CAAC;IACrD,IAAIgC,eAAe,EAAE1B,aAAa,EAAE;MAClC,MAAM;QAACC,WAAW;QAAEG;MAAW,CAAC,GAAGf,mBAAmB,CACpD,CAAC,aAAa,EAAE,aAAa,CAAC,EAC9BqC,eAAe,CAAC1B,aAAa,CAACK,MAAM,EACpCP,MAAM,EACNJ,OAAO,CACR;MAED,MAAMY,aAAa,GAAGlB,gBAAgB,CAACM,OAAO,EAAEU,WAAW,CAAC;MAC5D,MAAM+D,IAAI,GAAGJ,kBAAkB,CAAC9D,WAAW,EAAEK,aAAa,CAAC;MAC3D,IAAI6D,IAAI,KAAKpE,SAAS,EAAE;QACrBmE,SAAiB,CAAC5D,aAAa,CAAC,GAAG6D,IAAI;MAC1C;IACF;EACF;EAEA,OAAOvF,OAAO,CAACsF,SAAS,CAAC,GAAGnE,SAAS,GAAGmE,SAAS;AACnD;AAEA,OAAM,SAAUnD,wBAAwBA,CACtCjB,MAAyB,EACzBE,aAA+C,EAC/CN,OAAqB,EACrB0E,UAA2C,EAC3CC,aAA8E;EAE9E,MAAMC,KAAK,GAAG,EAAE;EAChB,KAAK,MAAMC,IAAI,IAAIH,UAAU,EAAE;IAC7B,IAAI,CAACC,aAAa,CAACE,IAAI,CAAC,EAAE;MACxB;IACF;IAEA,MAAMC,KAAK,GAAGlF,iBAAiB,CAACiF,IAAI,EAAEvE,aAAa,EAAEK,MAAM,EAAEP,MAAM,EAAEJ,OAAO,CAAC;IAC7E,IAAI8E,KAAK,KAAKzE,SAAS,EAAE;MACtBuE,KAAa,CAACD,aAAa,CAACE,IAAI,CAAC,CAAC,GAAGC,KAAK;IAC7C;EACF;EACA,OAAOF,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}