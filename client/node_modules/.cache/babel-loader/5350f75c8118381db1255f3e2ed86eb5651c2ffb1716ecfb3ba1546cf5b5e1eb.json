{"ast":null,"code":"import { Transform, ingest, tupleid, stableCompare } from 'vega-dataflow';\nimport { tickCount, tickFormat, validTicks, tickValues, SymbolLegend, labelFormat, labelValues, GradientLegend, scaleFraction, labelFraction, scale, Sequential, Linear, isContinuous, Time, UTC, Ordinal, scaleImplicit, Log, Sqrt, Pow, Symlog, isLogarithmic, BinOrdinal, isInterpolating, interpolateColors, interpolate, Band, Point, bandSpace, scheme, Threshold, Quantile, Quantize, quantizeInterpolator, interpolateRange, Diverging } from 'vega-scale';\nimport { inherits, isArray, error, fastmap, falsy, isFunction, constant, peek, one, toSet, isString, zoomLog, zoomPow, zoomSymlog, zoomLinear, stringValue } from 'vega-util';\nimport { sum, range } from 'd3-array';\nimport { interpolateRound, interpolate as interpolate$1 } from 'd3-interpolate';\n\n/**\n * Generates axis ticks for visualizing a spatial scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate ticks for.\n * @param {*} [params.count=10] - The approximate number of ticks, or\n *   desired tick interval, to use.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {function(*):string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid d3 4.0 format specifier.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\nfunction AxisTicks(params) {\n  Transform.call(this, null, params);\n}\ninherits(AxisTicks, Transform, {\n  transform(_, pulse) {\n    if (this.value && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n    var locale = pulse.dataflow.locale(),\n      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      ticks = this.value,\n      scale = _.scale,\n      tally = _.count == null ? _.values ? _.values.length : 10 : _.count,\n      count = tickCount(scale, tally, _.minstep),\n      format = _.format || tickFormat(locale, scale, count, _.formatSpecifier, _.formatType, !!_.values),\n      values = _.values ? validTicks(scale, _.values, count) : tickValues(scale, count);\n    if (ticks) out.rem = ticks;\n    ticks = values.map((value, i) => ingest({\n      index: i / (values.length - 1 || 1),\n      value: value,\n      label: format(value)\n    }));\n    if (_.extra && ticks.length) {\n      // add an extra tick pegged to the initial domain value\n      // this is used to generate axes with 'binned' domains\n      ticks.push(ingest({\n        index: -1,\n        extra: {\n          value: ticks[0].value\n        },\n        label: ''\n      }));\n    }\n    out.source = ticks;\n    out.add = ticks;\n    this.value = ticks;\n    return out;\n  }\n});\n\n/**\n * Joins a set of data elements against a set of visual items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): object} [params.item] - An item generator function.\n * @param {function(object): *} [params.key] - The key field associating data and visual items.\n */\nfunction DataJoin(params) {\n  Transform.call(this, null, params);\n}\nfunction defaultItemCreate() {\n  return ingest({});\n}\nfunction newMap(key) {\n  const map = fastmap().test(t => t.exit);\n  map.lookup = t => map.get(key(t));\n  return map;\n}\ninherits(DataJoin, Transform, {\n  transform(_, pulse) {\n    var df = pulse.dataflow,\n      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      item = _.item || defaultItemCreate,\n      key = _.key || tupleid,\n      map = this.value;\n\n    // prevent transient (e.g., hover) requests from\n    // cascading across marks derived from marks\n    if (isArray(out.encode)) {\n      out.encode = null;\n    }\n    if (map && (_.modified('key') || pulse.modified(key))) {\n      error('DataJoin does not support modified key function or fields.');\n    }\n    if (!map) {\n      pulse = pulse.addAll();\n      this.value = map = newMap(key);\n    }\n    pulse.visit(pulse.ADD, t => {\n      const k = key(t);\n      let x = map.get(k);\n      if (x) {\n        if (x.exit) {\n          map.empty--;\n          out.add.push(x);\n        } else {\n          out.mod.push(x);\n        }\n      } else {\n        x = item(t);\n        map.set(k, x);\n        out.add.push(x);\n      }\n      x.datum = t;\n      x.exit = false;\n    });\n    pulse.visit(pulse.MOD, t => {\n      const k = key(t),\n        x = map.get(k);\n      if (x) {\n        x.datum = t;\n        out.mod.push(x);\n      }\n    });\n    pulse.visit(pulse.REM, t => {\n      const k = key(t),\n        x = map.get(k);\n      if (t === x.datum && !x.exit) {\n        out.rem.push(x);\n        x.exit = true;\n        ++map.empty;\n      }\n    });\n    if (pulse.changed(pulse.ADD_MOD)) out.modifies('datum');\n    if (pulse.clean() || _.clean && map.empty > df.cleanThreshold) {\n      df.runAfter(map.clean);\n    }\n    return out;\n  }\n});\n\n/**\n * Invokes encoding functions for visual items.\n * @constructor\n * @param {object} params - The parameters to the encoding functions. This\n *   parameter object will be passed through to all invoked encoding functions.\n * @param {object} [params.mod=false] - Flag indicating if tuples in the input\n *   mod set that are unmodified by encoders should be included in the output.\n * @param {object} param.encoders - The encoding functions\n * @param {function(object, object): boolean} [param.encoders.update] - Update encoding set\n * @param {function(object, object): boolean} [param.encoders.enter] - Enter encoding set\n * @param {function(object, object): boolean} [param.encoders.exit] - Exit encoding set\n */\nfunction Encode(params) {\n  Transform.call(this, null, params);\n}\ninherits(Encode, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ADD_REM),\n      fmod = _.mod || false,\n      encoders = _.encoders,\n      encode = pulse.encode;\n\n    // if an array, the encode directive includes additional sets\n    // that must be defined in order for the primary set to be invoked\n    // e.g., only run the update set if the hover set is defined\n    if (isArray(encode)) {\n      if (out.changed() || encode.every(e => encoders[e])) {\n        encode = encode[0];\n        out.encode = null; // consume targeted encode directive\n      } else {\n        return pulse.StopPropagation;\n      }\n    }\n\n    // marshall encoder functions\n    var reenter = encode === 'enter',\n      update = encoders.update || falsy,\n      enter = encoders.enter || falsy,\n      exit = encoders.exit || falsy,\n      set = (encode && !reenter ? encoders[encode] : update) || falsy;\n    if (pulse.changed(pulse.ADD)) {\n      pulse.visit(pulse.ADD, t => {\n        enter(t, _);\n        update(t, _);\n      });\n      out.modifies(enter.output);\n      out.modifies(update.output);\n      if (set !== falsy && set !== update) {\n        pulse.visit(pulse.ADD, t => {\n          set(t, _);\n        });\n        out.modifies(set.output);\n      }\n    }\n    if (pulse.changed(pulse.REM) && exit !== falsy) {\n      pulse.visit(pulse.REM, t => {\n        exit(t, _);\n      });\n      out.modifies(exit.output);\n    }\n    if (reenter || set !== falsy) {\n      const flag = pulse.MOD | (_.modified() ? pulse.REFLOW : 0);\n      if (reenter) {\n        pulse.visit(flag, t => {\n          const mod = enter(t, _) || fmod;\n          if (set(t, _) || mod) out.mod.push(t);\n        });\n        if (out.mod.length) out.modifies(enter.output);\n      } else {\n        pulse.visit(flag, t => {\n          if (set(t, _) || fmod) out.mod.push(t);\n        });\n      }\n      if (out.mod.length) out.modifies(set.output);\n    }\n    return out.changed() ? out : pulse.StopPropagation;\n  }\n});\n\n/**\n * Generates legend entries for visualizing a scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate items for.\n * @param {*} [params.count=5] - The approximate number of items, or\n *   desired tick interval, to use.\n * @param {*} [params.limit] - The maximum number of entries to\n *   include in a symbol legend.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid D3 format specifier string.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\nfunction LegendEntries(params) {\n  Transform.call(this, [], params);\n}\ninherits(LegendEntries, Transform, {\n  transform(_, pulse) {\n    if (this.value != null && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n    var locale = pulse.dataflow.locale(),\n      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      items = this.value,\n      type = _.type || SymbolLegend,\n      scale = _.scale,\n      limit = +_.limit,\n      count = tickCount(scale, _.count == null ? 5 : _.count, _.minstep),\n      lskip = !!_.values || type === SymbolLegend,\n      format = _.format || labelFormat(locale, scale, count, type, _.formatSpecifier, _.formatType, lskip),\n      values = _.values || labelValues(scale, count),\n      domain,\n      fraction,\n      size,\n      offset,\n      ellipsis;\n    if (items) out.rem = items;\n    if (type === SymbolLegend) {\n      if (limit && values.length > limit) {\n        pulse.dataflow.warn('Symbol legend count exceeds limit, filtering items.');\n        items = values.slice(0, limit - 1);\n        ellipsis = true;\n      } else {\n        items = values;\n      }\n      if (isFunction(size = _.size)) {\n        // if first value maps to size zero, remove from list (vega#717)\n        if (!_.values && scale(items[0]) === 0) {\n          items = items.slice(1);\n        }\n        // compute size offset for legend entries\n        offset = items.reduce((max, value) => Math.max(max, size(value, _)), 0);\n      } else {\n        size = constant(offset = size || 8);\n      }\n      items = items.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, items),\n        value: value,\n        offset: offset,\n        size: size(value, _)\n      }));\n      if (ellipsis) {\n        ellipsis = values[items.length];\n        items.push(ingest({\n          index: items.length,\n          label: `\\u2026${values.length - items.length} entries`,\n          value: ellipsis,\n          offset: offset,\n          size: size(ellipsis, _)\n        }));\n      }\n    } else if (type === GradientLegend) {\n      domain = scale.domain(), fraction = scaleFraction(scale, domain[0], peek(domain));\n\n      // if automatic label generation produces 2 or fewer values,\n      // use the domain end points instead (fixes vega/vega#1364)\n      if (values.length < 3 && !_.values && domain[0] !== peek(domain)) {\n        values = [domain[0], peek(domain)];\n      }\n      items = values.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc: fraction(value)\n      }));\n    } else {\n      size = values.length - 1;\n      fraction = labelFraction(scale);\n      items = values.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc: index ? fraction(value) : 0,\n        perc2: index === size ? 1 : fraction(values[index + 1])\n      }));\n    }\n    out.source = items;\n    out.add = items;\n    this.value = items;\n    return out;\n  }\n});\nconst sourceX = t => t.source.x;\nconst sourceY = t => t.source.y;\nconst targetX = t => t.target.x;\nconst targetY = t => t.target.y;\n\n/**\n * Layout paths linking source and target elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\nfunction LinkPath(params) {\n  Transform.call(this, {}, params);\n}\nLinkPath.Definition = {\n  'type': 'LinkPath',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'sourceX',\n    'type': 'field',\n    'default': 'source.x'\n  }, {\n    'name': 'sourceY',\n    'type': 'field',\n    'default': 'source.y'\n  }, {\n    'name': 'targetX',\n    'type': 'field',\n    'default': 'target.x'\n  }, {\n    'name': 'targetY',\n    'type': 'field',\n    'default': 'target.y'\n  }, {\n    'name': 'orient',\n    'type': 'enum',\n    'default': 'vertical',\n    'values': ['horizontal', 'vertical', 'radial']\n  }, {\n    'name': 'shape',\n    'type': 'enum',\n    'default': 'line',\n    'values': ['line', 'arc', 'curve', 'diagonal', 'orthogonal']\n  }, {\n    'name': 'require',\n    'type': 'signal'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'path'\n  }]\n};\ninherits(LinkPath, Transform, {\n  transform(_, pulse) {\n    var sx = _.sourceX || sourceX,\n      sy = _.sourceY || sourceY,\n      tx = _.targetX || targetX,\n      ty = _.targetY || targetY,\n      as = _.as || 'path',\n      orient = _.orient || 'vertical',\n      shape = _.shape || 'line',\n      path = Paths.get(shape + '-' + orient) || Paths.get(shape);\n    if (!path) {\n      error('LinkPath unsupported type: ' + _.shape + (_.orient ? '-' + _.orient : ''));\n    }\n    pulse.visit(pulse.SOURCE, t => {\n      t[as] = path(sx(t), sy(t), tx(t), ty(t));\n    });\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n});\nconst line = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'L' + tx + ',' + ty;\nconst lineR = (sa, sr, ta, tr) => line(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\nconst arc = (sx, sy, tx, ty) => {\n  var dx = tx - sx,\n    dy = ty - sy,\n    rr = Math.hypot(dx, dy) / 2,\n    ra = 180 * Math.atan2(dy, dx) / Math.PI;\n  return 'M' + sx + ',' + sy + 'A' + rr + ',' + rr + ' ' + ra + ' 0 1' + ' ' + tx + ',' + ty;\n};\nconst arcR = (sa, sr, ta, tr) => arc(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\nconst curve = (sx, sy, tx, ty) => {\n  const dx = tx - sx,\n    dy = ty - sy,\n    ix = 0.2 * (dx + dy),\n    iy = 0.2 * (dy - dx);\n  return 'M' + sx + ',' + sy + 'C' + (sx + ix) + ',' + (sy + iy) + ' ' + (tx + iy) + ',' + (ty - ix) + ' ' + tx + ',' + ty;\n};\nconst curveR = (sa, sr, ta, tr) => curve(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\nconst orthoX = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'V' + ty + 'H' + tx;\nconst orthoY = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'H' + tx + 'V' + ty;\nconst orthoR = (sa, sr, ta, tr) => {\n  const sc = Math.cos(sa),\n    ss = Math.sin(sa),\n    tc = Math.cos(ta),\n    ts = Math.sin(ta),\n    sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n  return 'M' + sr * sc + ',' + sr * ss + 'A' + sr + ',' + sr + ' 0 0,' + (sf ? 1 : 0) + ' ' + sr * tc + ',' + sr * ts + 'L' + tr * tc + ',' + tr * ts;\n};\nconst diagonalX = (sx, sy, tx, ty) => {\n  const m = (sx + tx) / 2;\n  return 'M' + sx + ',' + sy + 'C' + m + ',' + sy + ' ' + m + ',' + ty + ' ' + tx + ',' + ty;\n};\nconst diagonalY = (sx, sy, tx, ty) => {\n  const m = (sy + ty) / 2;\n  return 'M' + sx + ',' + sy + 'C' + sx + ',' + m + ' ' + tx + ',' + m + ' ' + tx + ',' + ty;\n};\nconst diagonalR = (sa, sr, ta, tr) => {\n  const sc = Math.cos(sa),\n    ss = Math.sin(sa),\n    tc = Math.cos(ta),\n    ts = Math.sin(ta),\n    mr = (sr + tr) / 2;\n  return 'M' + sr * sc + ',' + sr * ss + 'C' + mr * sc + ',' + mr * ss + ' ' + mr * tc + ',' + mr * ts + ' ' + tr * tc + ',' + tr * ts;\n};\nconst Paths = fastmap({\n  'line': line,\n  'line-radial': lineR,\n  'arc': arc,\n  'arc-radial': arcR,\n  'curve': curve,\n  'curve-radial': curveR,\n  'orthogonal-horizontal': orthoX,\n  'orthogonal-vertical': orthoY,\n  'orthogonal-radial': orthoR,\n  'diagonal-horizontal': diagonalX,\n  'diagonal-vertical': diagonalY,\n  'diagonal-radial': diagonalR\n});\n\n/**\n * Pie and donut chart layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size pie segments.\n * @param {number} [params.startAngle=0] - The start angle (in radians) of the layout.\n * @param {number} [params.endAngle=2Ï€] - The end angle (in radians) of the layout.\n * @param {boolean} [params.sort] - Boolean flag for sorting sectors by value.\n */\nfunction Pie(params) {\n  Transform.call(this, null, params);\n}\nPie.Definition = {\n  'type': 'Pie',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'startAngle',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'endAngle',\n    'type': 'number',\n    'default': 6.283185307179586\n  }, {\n    'name': 'sort',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['startAngle', 'endAngle']\n  }]\n};\ninherits(Pie, Transform, {\n  transform(_, pulse) {\n    var as = _.as || ['startAngle', 'endAngle'],\n      startAngle = as[0],\n      endAngle = as[1],\n      field = _.field || one,\n      start = _.startAngle || 0,\n      stop = _.endAngle != null ? _.endAngle : 2 * Math.PI,\n      data = pulse.source,\n      values = data.map(field),\n      n = values.length,\n      a = start,\n      k = (stop - start) / sum(values),\n      index = range(n),\n      i,\n      t,\n      v;\n    if (_.sort) {\n      index.sort((a, b) => values[a] - values[b]);\n    }\n    for (i = 0; i < n; ++i) {\n      v = values[index[i]];\n      t = data[index[i]];\n      t[startAngle] = a;\n      t[endAngle] = a += v * k;\n    }\n    this.value = values;\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n});\nconst DEFAULT_COUNT = 5;\nfunction includeZero(scale) {\n  const type = scale.type;\n  return !scale.bins && (type === Linear || type === Pow || type === Sqrt);\n}\nfunction includePad(type) {\n  return isContinuous(type) && type !== Sequential;\n}\nconst SKIP = toSet(['set', 'modified', 'clear', 'type', 'scheme', 'schemeExtent', 'schemeCount', 'domain', 'domainMin', 'domainMid', 'domainMax', 'domainRaw', 'domainImplicit', 'nice', 'zero', 'bins', 'range', 'rangeStep', 'round', 'reverse', 'interpolate', 'interpolateGamma']);\n\n/**\n * Maintains a scale function mapping data values to visual channels.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\nfunction Scale(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\ninherits(Scale, Transform, {\n  transform(_, pulse) {\n    var df = pulse.dataflow,\n      scale$1 = this.value,\n      key = scaleKey(_);\n    if (!scale$1 || key !== scale$1.type) {\n      this.value = scale$1 = scale(key)();\n    }\n    for (key in _) if (!SKIP[key]) {\n      // padding is a scale property for band/point but not others\n      if (key === 'padding' && includePad(scale$1.type)) continue;\n      // invoke scale property setter, raise warning if not found\n      isFunction(scale$1[key]) ? scale$1[key](_[key]) : df.warn('Unsupported scale property: ' + key);\n    }\n    configureRange(scale$1, _, configureBins(scale$1, _, configureDomain(scale$1, _, df)));\n    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n  }\n});\nfunction scaleKey(_) {\n  var t = _.type,\n    d = '',\n    n;\n\n  // backwards compatibility pre Vega 5.\n  if (t === Sequential) return Sequential + '-' + Linear;\n  if (isContinuousColor(_)) {\n    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;\n    d = n === 2 ? Sequential + '-' : n === 3 ? Diverging + '-' : '';\n  }\n  return (d + t || Linear).toLowerCase();\n}\nfunction isContinuousColor(_) {\n  const t = _.type;\n  return isContinuous(t) && t !== Time && t !== UTC && (_.scheme || _.range && _.range.length && _.range.every(isString));\n}\nfunction configureDomain(scale, _, df) {\n  // check raw domain, if provided use that and exit early\n  const raw = rawDomain(scale, _.domainRaw, df);\n  if (raw > -1) return raw;\n  var domain = _.domain,\n    type = scale.type,\n    zero = _.zero || _.zero === undefined && includeZero(scale),\n    n,\n    mid;\n  if (!domain) return 0;\n\n  // adjust domain based on zero, min, max settings\n  if (zero || _.domainMin != null || _.domainMax != null || _.domainMid != null) {\n    n = (domain = domain.slice()).length - 1 || 1;\n    if (zero) {\n      if (domain[0] > 0) domain[0] = 0;\n      if (domain[n] < 0) domain[n] = 0;\n    }\n    if (_.domainMin != null) domain[0] = _.domainMin;\n    if (_.domainMax != null) domain[n] = _.domainMax;\n    if (_.domainMid != null) {\n      mid = _.domainMid;\n      const i = mid > domain[n] ? n + 1 : mid < domain[0] ? 0 : n;\n      if (i !== n) df.warn('Scale domainMid exceeds domain min or max.', mid);\n      domain.splice(i, 0, mid);\n    }\n  }\n\n  // adjust continuous domain for minimum pixel padding\n  if (includePad(type) && _.padding && domain[0] !== peek(domain)) {\n    domain = padDomain(type, domain, _.range, _.padding, _.exponent, _.constant);\n  }\n\n  // set the scale domain\n  scale.domain(domainCheck(type, domain, df));\n\n  // if ordinal scale domain is defined, prevent implicit\n  // domain construction as side-effect of scale lookup\n  if (type === Ordinal) {\n    scale.unknown(_.domainImplicit ? scaleImplicit : undefined);\n  }\n\n  // perform 'nice' adjustment as requested\n  if (_.nice && scale.nice) {\n    scale.nice(_.nice !== true && tickCount(scale, _.nice) || null);\n  }\n\n  // return the cardinality of the domain\n  return domain.length;\n}\nfunction rawDomain(scale, raw, df) {\n  if (raw) {\n    scale.domain(domainCheck(scale.type, raw, df));\n    return raw.length;\n  } else {\n    return -1;\n  }\n}\nfunction padDomain(type, domain, range, pad, exponent, constant) {\n  var span = Math.abs(peek(range) - range[0]),\n    frac = span / (span - 2 * pad),\n    d = type === Log ? zoomLog(domain, null, frac) : type === Sqrt ? zoomPow(domain, null, frac, 0.5) : type === Pow ? zoomPow(domain, null, frac, exponent || 1) : type === Symlog ? zoomSymlog(domain, null, frac, constant || 1) : zoomLinear(domain, null, frac);\n  domain = domain.slice();\n  domain[0] = d[0];\n  domain[domain.length - 1] = d[1];\n  return domain;\n}\nfunction domainCheck(type, domain, df) {\n  if (isLogarithmic(type)) {\n    // sum signs of domain values\n    // if all pos or all neg, abs(sum) === domain.length\n    var s = Math.abs(domain.reduce((s, v) => s + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));\n    if (s !== domain.length) {\n      df.warn('Log scale domain includes zero: ' + stringValue(domain));\n    }\n  }\n  return domain;\n}\nfunction configureBins(scale, _, count) {\n  let bins = _.bins;\n  if (bins && !isArray(bins)) {\n    // generate bin boundary array\n    const domain = scale.domain(),\n      lo = domain[0],\n      hi = peek(domain),\n      step = bins.step;\n    let start = bins.start == null ? lo : bins.start,\n      stop = bins.stop == null ? hi : bins.stop;\n    if (!step) error('Scale bins parameter missing step property.');\n    if (start < lo) start = step * Math.ceil(lo / step);\n    if (stop > hi) stop = step * Math.floor(hi / step);\n    bins = range(start, stop + step / 2, step);\n  }\n  if (bins) {\n    // assign bin boundaries to scale instance\n    scale.bins = bins;\n  } else if (scale.bins) {\n    // no current bins, remove bins if previously set\n    delete scale.bins;\n  }\n\n  // special handling for bin-ordinal scales\n  if (scale.type === BinOrdinal) {\n    if (!bins) {\n      // the domain specifies the bins\n      scale.bins = scale.domain();\n    } else if (!_.domain && !_.domainRaw) {\n      // the bins specify the domain\n      scale.domain(bins);\n      count = bins.length;\n    }\n  }\n\n  // return domain cardinality\n  return count;\n}\nfunction configureRange(scale, _, count) {\n  var type = scale.type,\n    round = _.round || false,\n    range = _.range;\n\n  // if range step specified, calculate full range extent\n  if (_.rangeStep != null) {\n    range = configureRangeStep(type, _, count);\n  }\n\n  // else if a range scheme is defined, use that\n  else if (_.scheme) {\n    range = configureScheme(type, _, count);\n    if (isFunction(range)) {\n      if (scale.interpolator) {\n        return scale.interpolator(range);\n      } else {\n        error(`Scale type ${type} does not support interpolating color schemes.`);\n      }\n    }\n  }\n\n  // given a range array for an interpolating scale, convert to interpolator\n  if (range && isInterpolating(type)) {\n    return scale.interpolator(interpolateColors(flip(range, _.reverse), _.interpolate, _.interpolateGamma));\n  }\n\n  // configure rounding / interpolation\n  if (range && _.interpolate && scale.interpolate) {\n    scale.interpolate(interpolate(_.interpolate, _.interpolateGamma));\n  } else if (isFunction(scale.round)) {\n    scale.round(round);\n  } else if (isFunction(scale.rangeRound)) {\n    scale.interpolate(round ? interpolateRound : interpolate$1);\n  }\n  if (range) scale.range(flip(range, _.reverse));\n}\nfunction configureRangeStep(type, _, count) {\n  if (type !== Band && type !== Point) {\n    error('Only band and point scales support rangeStep.');\n  }\n\n  // calculate full range based on requested step size and padding\n  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0,\n    inner = type === Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;\n  return [0, _.rangeStep * bandSpace(count, inner, outer)];\n}\nfunction configureScheme(type, _, count) {\n  var extent = _.schemeExtent,\n    name,\n    scheme$1;\n  if (isArray(_.scheme)) {\n    scheme$1 = interpolateColors(_.scheme, _.interpolate, _.interpolateGamma);\n  } else {\n    name = _.scheme.toLowerCase();\n    scheme$1 = scheme(name);\n    if (!scheme$1) error(`Unrecognized scheme name: ${_.scheme}`);\n  }\n\n  // determine size for potential discrete range\n  count = type === Threshold ? count + 1 : type === BinOrdinal ? count - 1 : type === Quantile || type === Quantize ? +_.schemeCount || DEFAULT_COUNT : count;\n\n  // adjust and/or quantize scheme as appropriate\n  return isInterpolating(type) ? adjustScheme(scheme$1, extent, _.reverse) : isFunction(scheme$1) ? quantizeInterpolator(adjustScheme(scheme$1, extent), count) : type === Ordinal ? scheme$1 : scheme$1.slice(0, count);\n}\nfunction adjustScheme(scheme, extent, reverse) {\n  return isFunction(scheme) && (extent || reverse) ? interpolateRange(scheme, flip(extent || [0, 1], reverse)) : scheme;\n}\nfunction flip(array, reverse) {\n  return reverse ? array.slice().reverse() : array;\n}\n\n/**\n * Sorts scenegraph items in the pulse source array.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting tuples.\n */\nfunction SortItems(params) {\n  Transform.call(this, null, params);\n}\ninherits(SortItems, Transform, {\n  transform(_, pulse) {\n    const mod = _.modified('sort') || pulse.changed(pulse.ADD) || pulse.modified(_.sort.fields) || pulse.modified('datum');\n    if (mod) pulse.source.sort(stableCompare(_.sort));\n    this.modified(mod);\n    return pulse;\n  }\n});\nconst Zero = 'zero',\n  Center = 'center',\n  Normalize = 'normalize',\n  DefOutput = ['y0', 'y1'];\n\n/**\n * Stack layout for visualization elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to stack.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {function(object,object): number} [params.sort] - A comparator for stack sorting.\n * @param {string} [offset='zero'] - Stack baseline offset. One of 'zero', 'center', 'normalize'.\n */\nfunction Stack(params) {\n  Transform.call(this, null, params);\n}\nStack.Definition = {\n  'type': 'Stack',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'offset',\n    'type': 'enum',\n    'default': Zero,\n    'values': [Zero, Center, Normalize]\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': DefOutput\n  }]\n};\ninherits(Stack, Transform, {\n  transform(_, pulse) {\n    var as = _.as || DefOutput,\n      y0 = as[0],\n      y1 = as[1],\n      sort = stableCompare(_.sort),\n      field = _.field || one,\n      stack = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero,\n      groups,\n      i,\n      n,\n      max;\n\n    // partition, sum, and sort the stack groups\n    groups = partition(pulse.source, _.groupby, sort, field);\n\n    // compute stack layouts per group\n    for (i = 0, n = groups.length, max = groups.max; i < n; ++i) {\n      stack(groups[i], max, field, y0, y1);\n    }\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n});\nfunction stackCenter(group, max, field, y0, y1) {\n  var last = (max - group.sum) / 2,\n    m = group.length,\n    j = 0,\n    t;\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last += Math.abs(field(t));\n  }\n}\nfunction stackNormalize(group, max, field, y0, y1) {\n  var scale = 1 / group.sum,\n    last = 0,\n    m = group.length,\n    j = 0,\n    v = 0,\n    t;\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last = scale * (v += Math.abs(field(t)));\n  }\n}\nfunction stackZero(group, max, field, y0, y1) {\n  var lastPos = 0,\n    lastNeg = 0,\n    m = group.length,\n    j = 0,\n    v,\n    t;\n  for (; j < m; ++j) {\n    t = group[j];\n    v = +field(t);\n    if (v < 0) {\n      t[y0] = lastNeg;\n      t[y1] = lastNeg += v;\n    } else {\n      t[y0] = lastPos;\n      t[y1] = lastPos += v;\n    }\n  }\n}\nfunction partition(data, groupby, sort, field) {\n  var groups = [],\n    get = f => f(t),\n    map,\n    i,\n    n,\n    m,\n    t,\n    k,\n    g,\n    s,\n    max;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n      if (!g) {\n        map[k] = g = [];\n        groups.push(g);\n      }\n      g.push(t);\n    }\n  }\n\n  // compute sums of groups, sort groups as needed\n  for (k = 0, max = 0, m = groups.length; k < m; ++k) {\n    g = groups[k];\n    for (i = 0, s = 0, n = g.length; i < n; ++i) {\n      s += Math.abs(field(g[i]));\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sort) g.sort(sort);\n  }\n  groups.max = max;\n  return groups;\n}\nexport { AxisTicks as axisticks, DataJoin as datajoin, Encode as encode, LegendEntries as legendentries, LinkPath as linkpath, Pie as pie, Scale as scale, SortItems as sortitems, Stack as stack };","map":{"version":3,"names":["Transform","ingest","tupleid","stableCompare","tickCount","tickFormat","validTicks","tickValues","SymbolLegend","labelFormat","labelValues","GradientLegend","scaleFraction","labelFraction","scale","Sequential","Linear","isContinuous","Time","UTC","Ordinal","scaleImplicit","Log","Sqrt","Pow","Symlog","isLogarithmic","BinOrdinal","isInterpolating","interpolateColors","interpolate","Band","Point","bandSpace","scheme","Threshold","Quantile","Quantize","quantizeInterpolator","interpolateRange","Diverging","inherits","isArray","error","fastmap","falsy","isFunction","constant","peek","one","toSet","isString","zoomLog","zoomPow","zoomSymlog","zoomLinear","stringValue","sum","range","interpolateRound","interpolate$1","AxisTicks","params","call","transform","_","pulse","value","modified","StopPropagation","locale","dataflow","out","fork","NO_SOURCE","NO_FIELDS","ticks","tally","count","values","length","minstep","format","formatSpecifier","formatType","rem","map","i","index","label","extra","push","source","add","DataJoin","defaultItemCreate","newMap","key","test","t","exit","lookup","get","df","item","encode","addAll","visit","ADD","k","x","empty","mod","set","datum","MOD","REM","changed","ADD_MOD","modifies","clean","cleanThreshold","runAfter","Encode","ADD_REM","fmod","encoders","every","e","reenter","update","enter","output","flag","REFLOW","LegendEntries","items","type","limit","lskip","domain","fraction","size","offset","ellipsis","warn","slice","reduce","max","Math","perc","perc2","sourceX","sourceY","y","targetX","target","targetY","LinkPath","Definition","sx","sy","tx","ty","as","orient","shape","path","Paths","SOURCE","reflow","line","lineR","sa","sr","ta","tr","cos","sin","arc","dx","dy","rr","hypot","ra","atan2","PI","arcR","curve","ix","iy","curveR","orthoX","orthoY","orthoR","sc","ss","tc","ts","sf","abs","diagonalX","m","diagonalY","diagonalR","mr","Pie","startAngle","endAngle","field","start","stop","data","n","a","v","sort","b","DEFAULT_COUNT","includeZero","bins","includePad","SKIP","Scale","scale$1","scaleKey","configureRange","configureBins","configureDomain","d","isContinuousColor","rawDomain","domainMid","toLowerCase","raw","domainRaw","zero","undefined","mid","domainMin","domainMax","splice","padding","padDomain","exponent","domainCheck","unknown","domainImplicit","nice","pad","span","frac","s","lo","hi","step","ceil","floor","round","rangeStep","configureRangeStep","configureScheme","interpolator","flip","reverse","interpolateGamma","rangeRound","outer","paddingOuter","inner","paddingInner","extent","schemeExtent","name","scheme$1","schemeCount","adjustScheme","array","SortItems","fields","Zero","Center","Normalize","DefOutput","Stack","y0","y1","stack","stackCenter","stackNormalize","stackZero","groups","partition","groupby","group","last","j","lastPos","lastNeg","f","g","axisticks","datajoin","legendentries","linkpath","pie","sortitems"],"sources":["C:/Users/sutul/node_modules/vega-encode/build/vega-encode.module.js"],"sourcesContent":["import { Transform, ingest, tupleid, stableCompare } from 'vega-dataflow';\nimport { tickCount, tickFormat, validTicks, tickValues, SymbolLegend, labelFormat, labelValues, GradientLegend, scaleFraction, labelFraction, scale, Sequential, Linear, isContinuous, Time, UTC, Ordinal, scaleImplicit, Log, Sqrt, Pow, Symlog, isLogarithmic, BinOrdinal, isInterpolating, interpolateColors, interpolate, Band, Point, bandSpace, scheme, Threshold, Quantile, Quantize, quantizeInterpolator, interpolateRange, Diverging } from 'vega-scale';\nimport { inherits, isArray, error, fastmap, falsy, isFunction, constant, peek, one, toSet, isString, zoomLog, zoomPow, zoomSymlog, zoomLinear, stringValue } from 'vega-util';\nimport { sum, range } from 'd3-array';\nimport { interpolateRound, interpolate as interpolate$1 } from 'd3-interpolate';\n\n/**\n * Generates axis ticks for visualizing a spatial scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate ticks for.\n * @param {*} [params.count=10] - The approximate number of ticks, or\n *   desired tick interval, to use.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {function(*):string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid d3 4.0 format specifier.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\nfunction AxisTicks(params) {\n  Transform.call(this, null, params);\n}\ninherits(AxisTicks, Transform, {\n  transform(_, pulse) {\n    if (this.value && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n    var locale = pulse.dataflow.locale(),\n      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      ticks = this.value,\n      scale = _.scale,\n      tally = _.count == null ? _.values ? _.values.length : 10 : _.count,\n      count = tickCount(scale, tally, _.minstep),\n      format = _.format || tickFormat(locale, scale, count, _.formatSpecifier, _.formatType, !!_.values),\n      values = _.values ? validTicks(scale, _.values, count) : tickValues(scale, count);\n    if (ticks) out.rem = ticks;\n    ticks = values.map((value, i) => ingest({\n      index: i / (values.length - 1 || 1),\n      value: value,\n      label: format(value)\n    }));\n    if (_.extra && ticks.length) {\n      // add an extra tick pegged to the initial domain value\n      // this is used to generate axes with 'binned' domains\n      ticks.push(ingest({\n        index: -1,\n        extra: {\n          value: ticks[0].value\n        },\n        label: ''\n      }));\n    }\n    out.source = ticks;\n    out.add = ticks;\n    this.value = ticks;\n    return out;\n  }\n});\n\n/**\n * Joins a set of data elements against a set of visual items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): object} [params.item] - An item generator function.\n * @param {function(object): *} [params.key] - The key field associating data and visual items.\n */\nfunction DataJoin(params) {\n  Transform.call(this, null, params);\n}\nfunction defaultItemCreate() {\n  return ingest({});\n}\nfunction newMap(key) {\n  const map = fastmap().test(t => t.exit);\n  map.lookup = t => map.get(key(t));\n  return map;\n}\ninherits(DataJoin, Transform, {\n  transform(_, pulse) {\n    var df = pulse.dataflow,\n      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      item = _.item || defaultItemCreate,\n      key = _.key || tupleid,\n      map = this.value;\n\n    // prevent transient (e.g., hover) requests from\n    // cascading across marks derived from marks\n    if (isArray(out.encode)) {\n      out.encode = null;\n    }\n    if (map && (_.modified('key') || pulse.modified(key))) {\n      error('DataJoin does not support modified key function or fields.');\n    }\n    if (!map) {\n      pulse = pulse.addAll();\n      this.value = map = newMap(key);\n    }\n    pulse.visit(pulse.ADD, t => {\n      const k = key(t);\n      let x = map.get(k);\n      if (x) {\n        if (x.exit) {\n          map.empty--;\n          out.add.push(x);\n        } else {\n          out.mod.push(x);\n        }\n      } else {\n        x = item(t);\n        map.set(k, x);\n        out.add.push(x);\n      }\n      x.datum = t;\n      x.exit = false;\n    });\n    pulse.visit(pulse.MOD, t => {\n      const k = key(t),\n        x = map.get(k);\n      if (x) {\n        x.datum = t;\n        out.mod.push(x);\n      }\n    });\n    pulse.visit(pulse.REM, t => {\n      const k = key(t),\n        x = map.get(k);\n      if (t === x.datum && !x.exit) {\n        out.rem.push(x);\n        x.exit = true;\n        ++map.empty;\n      }\n    });\n    if (pulse.changed(pulse.ADD_MOD)) out.modifies('datum');\n    if (pulse.clean() || _.clean && map.empty > df.cleanThreshold) {\n      df.runAfter(map.clean);\n    }\n    return out;\n  }\n});\n\n/**\n * Invokes encoding functions for visual items.\n * @constructor\n * @param {object} params - The parameters to the encoding functions. This\n *   parameter object will be passed through to all invoked encoding functions.\n * @param {object} [params.mod=false] - Flag indicating if tuples in the input\n *   mod set that are unmodified by encoders should be included in the output.\n * @param {object} param.encoders - The encoding functions\n * @param {function(object, object): boolean} [param.encoders.update] - Update encoding set\n * @param {function(object, object): boolean} [param.encoders.enter] - Enter encoding set\n * @param {function(object, object): boolean} [param.encoders.exit] - Exit encoding set\n */\nfunction Encode(params) {\n  Transform.call(this, null, params);\n}\ninherits(Encode, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ADD_REM),\n      fmod = _.mod || false,\n      encoders = _.encoders,\n      encode = pulse.encode;\n\n    // if an array, the encode directive includes additional sets\n    // that must be defined in order for the primary set to be invoked\n    // e.g., only run the update set if the hover set is defined\n    if (isArray(encode)) {\n      if (out.changed() || encode.every(e => encoders[e])) {\n        encode = encode[0];\n        out.encode = null; // consume targeted encode directive\n      } else {\n        return pulse.StopPropagation;\n      }\n    }\n\n    // marshall encoder functions\n    var reenter = encode === 'enter',\n      update = encoders.update || falsy,\n      enter = encoders.enter || falsy,\n      exit = encoders.exit || falsy,\n      set = (encode && !reenter ? encoders[encode] : update) || falsy;\n    if (pulse.changed(pulse.ADD)) {\n      pulse.visit(pulse.ADD, t => {\n        enter(t, _);\n        update(t, _);\n      });\n      out.modifies(enter.output);\n      out.modifies(update.output);\n      if (set !== falsy && set !== update) {\n        pulse.visit(pulse.ADD, t => {\n          set(t, _);\n        });\n        out.modifies(set.output);\n      }\n    }\n    if (pulse.changed(pulse.REM) && exit !== falsy) {\n      pulse.visit(pulse.REM, t => {\n        exit(t, _);\n      });\n      out.modifies(exit.output);\n    }\n    if (reenter || set !== falsy) {\n      const flag = pulse.MOD | (_.modified() ? pulse.REFLOW : 0);\n      if (reenter) {\n        pulse.visit(flag, t => {\n          const mod = enter(t, _) || fmod;\n          if (set(t, _) || mod) out.mod.push(t);\n        });\n        if (out.mod.length) out.modifies(enter.output);\n      } else {\n        pulse.visit(flag, t => {\n          if (set(t, _) || fmod) out.mod.push(t);\n        });\n      }\n      if (out.mod.length) out.modifies(set.output);\n    }\n    return out.changed() ? out : pulse.StopPropagation;\n  }\n});\n\n/**\n * Generates legend entries for visualizing a scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate items for.\n * @param {*} [params.count=5] - The approximate number of items, or\n *   desired tick interval, to use.\n * @param {*} [params.limit] - The maximum number of entries to\n *   include in a symbol legend.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid D3 format specifier string.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\nfunction LegendEntries(params) {\n  Transform.call(this, [], params);\n}\ninherits(LegendEntries, Transform, {\n  transform(_, pulse) {\n    if (this.value != null && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n    var locale = pulse.dataflow.locale(),\n      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      items = this.value,\n      type = _.type || SymbolLegend,\n      scale = _.scale,\n      limit = +_.limit,\n      count = tickCount(scale, _.count == null ? 5 : _.count, _.minstep),\n      lskip = !!_.values || type === SymbolLegend,\n      format = _.format || labelFormat(locale, scale, count, type, _.formatSpecifier, _.formatType, lskip),\n      values = _.values || labelValues(scale, count),\n      domain,\n      fraction,\n      size,\n      offset,\n      ellipsis;\n    if (items) out.rem = items;\n    if (type === SymbolLegend) {\n      if (limit && values.length > limit) {\n        pulse.dataflow.warn('Symbol legend count exceeds limit, filtering items.');\n        items = values.slice(0, limit - 1);\n        ellipsis = true;\n      } else {\n        items = values;\n      }\n      if (isFunction(size = _.size)) {\n        // if first value maps to size zero, remove from list (vega#717)\n        if (!_.values && scale(items[0]) === 0) {\n          items = items.slice(1);\n        }\n        // compute size offset for legend entries\n        offset = items.reduce((max, value) => Math.max(max, size(value, _)), 0);\n      } else {\n        size = constant(offset = size || 8);\n      }\n      items = items.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, items),\n        value: value,\n        offset: offset,\n        size: size(value, _)\n      }));\n      if (ellipsis) {\n        ellipsis = values[items.length];\n        items.push(ingest({\n          index: items.length,\n          label: `\\u2026${values.length - items.length} entries`,\n          value: ellipsis,\n          offset: offset,\n          size: size(ellipsis, _)\n        }));\n      }\n    } else if (type === GradientLegend) {\n      domain = scale.domain(), fraction = scaleFraction(scale, domain[0], peek(domain));\n\n      // if automatic label generation produces 2 or fewer values,\n      // use the domain end points instead (fixes vega/vega#1364)\n      if (values.length < 3 && !_.values && domain[0] !== peek(domain)) {\n        values = [domain[0], peek(domain)];\n      }\n      items = values.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc: fraction(value)\n      }));\n    } else {\n      size = values.length - 1;\n      fraction = labelFraction(scale);\n      items = values.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc: index ? fraction(value) : 0,\n        perc2: index === size ? 1 : fraction(values[index + 1])\n      }));\n    }\n    out.source = items;\n    out.add = items;\n    this.value = items;\n    return out;\n  }\n});\n\nconst sourceX = t => t.source.x;\nconst sourceY = t => t.source.y;\nconst targetX = t => t.target.x;\nconst targetY = t => t.target.y;\n\n/**\n * Layout paths linking source and target elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\nfunction LinkPath(params) {\n  Transform.call(this, {}, params);\n}\nLinkPath.Definition = {\n  'type': 'LinkPath',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'sourceX',\n    'type': 'field',\n    'default': 'source.x'\n  }, {\n    'name': 'sourceY',\n    'type': 'field',\n    'default': 'source.y'\n  }, {\n    'name': 'targetX',\n    'type': 'field',\n    'default': 'target.x'\n  }, {\n    'name': 'targetY',\n    'type': 'field',\n    'default': 'target.y'\n  }, {\n    'name': 'orient',\n    'type': 'enum',\n    'default': 'vertical',\n    'values': ['horizontal', 'vertical', 'radial']\n  }, {\n    'name': 'shape',\n    'type': 'enum',\n    'default': 'line',\n    'values': ['line', 'arc', 'curve', 'diagonal', 'orthogonal']\n  }, {\n    'name': 'require',\n    'type': 'signal'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'path'\n  }]\n};\ninherits(LinkPath, Transform, {\n  transform(_, pulse) {\n    var sx = _.sourceX || sourceX,\n      sy = _.sourceY || sourceY,\n      tx = _.targetX || targetX,\n      ty = _.targetY || targetY,\n      as = _.as || 'path',\n      orient = _.orient || 'vertical',\n      shape = _.shape || 'line',\n      path = Paths.get(shape + '-' + orient) || Paths.get(shape);\n    if (!path) {\n      error('LinkPath unsupported type: ' + _.shape + (_.orient ? '-' + _.orient : ''));\n    }\n    pulse.visit(pulse.SOURCE, t => {\n      t[as] = path(sx(t), sy(t), tx(t), ty(t));\n    });\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n});\nconst line = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'L' + tx + ',' + ty;\nconst lineR = (sa, sr, ta, tr) => line(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\nconst arc = (sx, sy, tx, ty) => {\n  var dx = tx - sx,\n    dy = ty - sy,\n    rr = Math.hypot(dx, dy) / 2,\n    ra = 180 * Math.atan2(dy, dx) / Math.PI;\n  return 'M' + sx + ',' + sy + 'A' + rr + ',' + rr + ' ' + ra + ' 0 1' + ' ' + tx + ',' + ty;\n};\nconst arcR = (sa, sr, ta, tr) => arc(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\nconst curve = (sx, sy, tx, ty) => {\n  const dx = tx - sx,\n    dy = ty - sy,\n    ix = 0.2 * (dx + dy),\n    iy = 0.2 * (dy - dx);\n  return 'M' + sx + ',' + sy + 'C' + (sx + ix) + ',' + (sy + iy) + ' ' + (tx + iy) + ',' + (ty - ix) + ' ' + tx + ',' + ty;\n};\nconst curveR = (sa, sr, ta, tr) => curve(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\nconst orthoX = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'V' + ty + 'H' + tx;\nconst orthoY = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'H' + tx + 'V' + ty;\nconst orthoR = (sa, sr, ta, tr) => {\n  const sc = Math.cos(sa),\n    ss = Math.sin(sa),\n    tc = Math.cos(ta),\n    ts = Math.sin(ta),\n    sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n  return 'M' + sr * sc + ',' + sr * ss + 'A' + sr + ',' + sr + ' 0 0,' + (sf ? 1 : 0) + ' ' + sr * tc + ',' + sr * ts + 'L' + tr * tc + ',' + tr * ts;\n};\nconst diagonalX = (sx, sy, tx, ty) => {\n  const m = (sx + tx) / 2;\n  return 'M' + sx + ',' + sy + 'C' + m + ',' + sy + ' ' + m + ',' + ty + ' ' + tx + ',' + ty;\n};\nconst diagonalY = (sx, sy, tx, ty) => {\n  const m = (sy + ty) / 2;\n  return 'M' + sx + ',' + sy + 'C' + sx + ',' + m + ' ' + tx + ',' + m + ' ' + tx + ',' + ty;\n};\nconst diagonalR = (sa, sr, ta, tr) => {\n  const sc = Math.cos(sa),\n    ss = Math.sin(sa),\n    tc = Math.cos(ta),\n    ts = Math.sin(ta),\n    mr = (sr + tr) / 2;\n  return 'M' + sr * sc + ',' + sr * ss + 'C' + mr * sc + ',' + mr * ss + ' ' + mr * tc + ',' + mr * ts + ' ' + tr * tc + ',' + tr * ts;\n};\nconst Paths = fastmap({\n  'line': line,\n  'line-radial': lineR,\n  'arc': arc,\n  'arc-radial': arcR,\n  'curve': curve,\n  'curve-radial': curveR,\n  'orthogonal-horizontal': orthoX,\n  'orthogonal-vertical': orthoY,\n  'orthogonal-radial': orthoR,\n  'diagonal-horizontal': diagonalX,\n  'diagonal-vertical': diagonalY,\n  'diagonal-radial': diagonalR\n});\n\n/**\n * Pie and donut chart layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size pie segments.\n * @param {number} [params.startAngle=0] - The start angle (in radians) of the layout.\n * @param {number} [params.endAngle=2Ï€] - The end angle (in radians) of the layout.\n * @param {boolean} [params.sort] - Boolean flag for sorting sectors by value.\n */\nfunction Pie(params) {\n  Transform.call(this, null, params);\n}\nPie.Definition = {\n  'type': 'Pie',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'startAngle',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'endAngle',\n    'type': 'number',\n    'default': 6.283185307179586\n  }, {\n    'name': 'sort',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['startAngle', 'endAngle']\n  }]\n};\ninherits(Pie, Transform, {\n  transform(_, pulse) {\n    var as = _.as || ['startAngle', 'endAngle'],\n      startAngle = as[0],\n      endAngle = as[1],\n      field = _.field || one,\n      start = _.startAngle || 0,\n      stop = _.endAngle != null ? _.endAngle : 2 * Math.PI,\n      data = pulse.source,\n      values = data.map(field),\n      n = values.length,\n      a = start,\n      k = (stop - start) / sum(values),\n      index = range(n),\n      i,\n      t,\n      v;\n    if (_.sort) {\n      index.sort((a, b) => values[a] - values[b]);\n    }\n    for (i = 0; i < n; ++i) {\n      v = values[index[i]];\n      t = data[index[i]];\n      t[startAngle] = a;\n      t[endAngle] = a += v * k;\n    }\n    this.value = values;\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n});\n\nconst DEFAULT_COUNT = 5;\nfunction includeZero(scale) {\n  const type = scale.type;\n  return !scale.bins && (type === Linear || type === Pow || type === Sqrt);\n}\nfunction includePad(type) {\n  return isContinuous(type) && type !== Sequential;\n}\nconst SKIP = toSet(['set', 'modified', 'clear', 'type', 'scheme', 'schemeExtent', 'schemeCount', 'domain', 'domainMin', 'domainMid', 'domainMax', 'domainRaw', 'domainImplicit', 'nice', 'zero', 'bins', 'range', 'rangeStep', 'round', 'reverse', 'interpolate', 'interpolateGamma']);\n\n/**\n * Maintains a scale function mapping data values to visual channels.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\nfunction Scale(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\ninherits(Scale, Transform, {\n  transform(_, pulse) {\n    var df = pulse.dataflow,\n      scale$1 = this.value,\n      key = scaleKey(_);\n    if (!scale$1 || key !== scale$1.type) {\n      this.value = scale$1 = scale(key)();\n    }\n    for (key in _) if (!SKIP[key]) {\n      // padding is a scale property for band/point but not others\n      if (key === 'padding' && includePad(scale$1.type)) continue;\n      // invoke scale property setter, raise warning if not found\n      isFunction(scale$1[key]) ? scale$1[key](_[key]) : df.warn('Unsupported scale property: ' + key);\n    }\n    configureRange(scale$1, _, configureBins(scale$1, _, configureDomain(scale$1, _, df)));\n    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n  }\n});\nfunction scaleKey(_) {\n  var t = _.type,\n    d = '',\n    n;\n\n  // backwards compatibility pre Vega 5.\n  if (t === Sequential) return Sequential + '-' + Linear;\n  if (isContinuousColor(_)) {\n    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;\n    d = n === 2 ? Sequential + '-' : n === 3 ? Diverging + '-' : '';\n  }\n  return (d + t || Linear).toLowerCase();\n}\nfunction isContinuousColor(_) {\n  const t = _.type;\n  return isContinuous(t) && t !== Time && t !== UTC && (_.scheme || _.range && _.range.length && _.range.every(isString));\n}\nfunction configureDomain(scale, _, df) {\n  // check raw domain, if provided use that and exit early\n  const raw = rawDomain(scale, _.domainRaw, df);\n  if (raw > -1) return raw;\n  var domain = _.domain,\n    type = scale.type,\n    zero = _.zero || _.zero === undefined && includeZero(scale),\n    n,\n    mid;\n  if (!domain) return 0;\n\n  // adjust domain based on zero, min, max settings\n  if (zero || _.domainMin != null || _.domainMax != null || _.domainMid != null) {\n    n = (domain = domain.slice()).length - 1 || 1;\n    if (zero) {\n      if (domain[0] > 0) domain[0] = 0;\n      if (domain[n] < 0) domain[n] = 0;\n    }\n    if (_.domainMin != null) domain[0] = _.domainMin;\n    if (_.domainMax != null) domain[n] = _.domainMax;\n    if (_.domainMid != null) {\n      mid = _.domainMid;\n      const i = mid > domain[n] ? n + 1 : mid < domain[0] ? 0 : n;\n      if (i !== n) df.warn('Scale domainMid exceeds domain min or max.', mid);\n      domain.splice(i, 0, mid);\n    }\n  }\n\n  // adjust continuous domain for minimum pixel padding\n  if (includePad(type) && _.padding && domain[0] !== peek(domain)) {\n    domain = padDomain(type, domain, _.range, _.padding, _.exponent, _.constant);\n  }\n\n  // set the scale domain\n  scale.domain(domainCheck(type, domain, df));\n\n  // if ordinal scale domain is defined, prevent implicit\n  // domain construction as side-effect of scale lookup\n  if (type === Ordinal) {\n    scale.unknown(_.domainImplicit ? scaleImplicit : undefined);\n  }\n\n  // perform 'nice' adjustment as requested\n  if (_.nice && scale.nice) {\n    scale.nice(_.nice !== true && tickCount(scale, _.nice) || null);\n  }\n\n  // return the cardinality of the domain\n  return domain.length;\n}\nfunction rawDomain(scale, raw, df) {\n  if (raw) {\n    scale.domain(domainCheck(scale.type, raw, df));\n    return raw.length;\n  } else {\n    return -1;\n  }\n}\nfunction padDomain(type, domain, range, pad, exponent, constant) {\n  var span = Math.abs(peek(range) - range[0]),\n    frac = span / (span - 2 * pad),\n    d = type === Log ? zoomLog(domain, null, frac) : type === Sqrt ? zoomPow(domain, null, frac, 0.5) : type === Pow ? zoomPow(domain, null, frac, exponent || 1) : type === Symlog ? zoomSymlog(domain, null, frac, constant || 1) : zoomLinear(domain, null, frac);\n  domain = domain.slice();\n  domain[0] = d[0];\n  domain[domain.length - 1] = d[1];\n  return domain;\n}\nfunction domainCheck(type, domain, df) {\n  if (isLogarithmic(type)) {\n    // sum signs of domain values\n    // if all pos or all neg, abs(sum) === domain.length\n    var s = Math.abs(domain.reduce((s, v) => s + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));\n    if (s !== domain.length) {\n      df.warn('Log scale domain includes zero: ' + stringValue(domain));\n    }\n  }\n  return domain;\n}\nfunction configureBins(scale, _, count) {\n  let bins = _.bins;\n  if (bins && !isArray(bins)) {\n    // generate bin boundary array\n    const domain = scale.domain(),\n      lo = domain[0],\n      hi = peek(domain),\n      step = bins.step;\n    let start = bins.start == null ? lo : bins.start,\n      stop = bins.stop == null ? hi : bins.stop;\n    if (!step) error('Scale bins parameter missing step property.');\n    if (start < lo) start = step * Math.ceil(lo / step);\n    if (stop > hi) stop = step * Math.floor(hi / step);\n    bins = range(start, stop + step / 2, step);\n  }\n  if (bins) {\n    // assign bin boundaries to scale instance\n    scale.bins = bins;\n  } else if (scale.bins) {\n    // no current bins, remove bins if previously set\n    delete scale.bins;\n  }\n\n  // special handling for bin-ordinal scales\n  if (scale.type === BinOrdinal) {\n    if (!bins) {\n      // the domain specifies the bins\n      scale.bins = scale.domain();\n    } else if (!_.domain && !_.domainRaw) {\n      // the bins specify the domain\n      scale.domain(bins);\n      count = bins.length;\n    }\n  }\n\n  // return domain cardinality\n  return count;\n}\nfunction configureRange(scale, _, count) {\n  var type = scale.type,\n    round = _.round || false,\n    range = _.range;\n\n  // if range step specified, calculate full range extent\n  if (_.rangeStep != null) {\n    range = configureRangeStep(type, _, count);\n  }\n\n  // else if a range scheme is defined, use that\n  else if (_.scheme) {\n    range = configureScheme(type, _, count);\n    if (isFunction(range)) {\n      if (scale.interpolator) {\n        return scale.interpolator(range);\n      } else {\n        error(`Scale type ${type} does not support interpolating color schemes.`);\n      }\n    }\n  }\n\n  // given a range array for an interpolating scale, convert to interpolator\n  if (range && isInterpolating(type)) {\n    return scale.interpolator(interpolateColors(flip(range, _.reverse), _.interpolate, _.interpolateGamma));\n  }\n\n  // configure rounding / interpolation\n  if (range && _.interpolate && scale.interpolate) {\n    scale.interpolate(interpolate(_.interpolate, _.interpolateGamma));\n  } else if (isFunction(scale.round)) {\n    scale.round(round);\n  } else if (isFunction(scale.rangeRound)) {\n    scale.interpolate(round ? interpolateRound : interpolate$1);\n  }\n  if (range) scale.range(flip(range, _.reverse));\n}\nfunction configureRangeStep(type, _, count) {\n  if (type !== Band && type !== Point) {\n    error('Only band and point scales support rangeStep.');\n  }\n\n  // calculate full range based on requested step size and padding\n  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0,\n    inner = type === Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;\n  return [0, _.rangeStep * bandSpace(count, inner, outer)];\n}\nfunction configureScheme(type, _, count) {\n  var extent = _.schemeExtent,\n    name,\n    scheme$1;\n  if (isArray(_.scheme)) {\n    scheme$1 = interpolateColors(_.scheme, _.interpolate, _.interpolateGamma);\n  } else {\n    name = _.scheme.toLowerCase();\n    scheme$1 = scheme(name);\n    if (!scheme$1) error(`Unrecognized scheme name: ${_.scheme}`);\n  }\n\n  // determine size for potential discrete range\n  count = type === Threshold ? count + 1 : type === BinOrdinal ? count - 1 : type === Quantile || type === Quantize ? +_.schemeCount || DEFAULT_COUNT : count;\n\n  // adjust and/or quantize scheme as appropriate\n  return isInterpolating(type) ? adjustScheme(scheme$1, extent, _.reverse) : isFunction(scheme$1) ? quantizeInterpolator(adjustScheme(scheme$1, extent), count) : type === Ordinal ? scheme$1 : scheme$1.slice(0, count);\n}\nfunction adjustScheme(scheme, extent, reverse) {\n  return isFunction(scheme) && (extent || reverse) ? interpolateRange(scheme, flip(extent || [0, 1], reverse)) : scheme;\n}\nfunction flip(array, reverse) {\n  return reverse ? array.slice().reverse() : array;\n}\n\n/**\n * Sorts scenegraph items in the pulse source array.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting tuples.\n */\nfunction SortItems(params) {\n  Transform.call(this, null, params);\n}\ninherits(SortItems, Transform, {\n  transform(_, pulse) {\n    const mod = _.modified('sort') || pulse.changed(pulse.ADD) || pulse.modified(_.sort.fields) || pulse.modified('datum');\n    if (mod) pulse.source.sort(stableCompare(_.sort));\n    this.modified(mod);\n    return pulse;\n  }\n});\n\nconst Zero = 'zero',\n  Center = 'center',\n  Normalize = 'normalize',\n  DefOutput = ['y0', 'y1'];\n\n/**\n * Stack layout for visualization elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to stack.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {function(object,object): number} [params.sort] - A comparator for stack sorting.\n * @param {string} [offset='zero'] - Stack baseline offset. One of 'zero', 'center', 'normalize'.\n */\nfunction Stack(params) {\n  Transform.call(this, null, params);\n}\nStack.Definition = {\n  'type': 'Stack',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'offset',\n    'type': 'enum',\n    'default': Zero,\n    'values': [Zero, Center, Normalize]\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': DefOutput\n  }]\n};\ninherits(Stack, Transform, {\n  transform(_, pulse) {\n    var as = _.as || DefOutput,\n      y0 = as[0],\n      y1 = as[1],\n      sort = stableCompare(_.sort),\n      field = _.field || one,\n      stack = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero,\n      groups,\n      i,\n      n,\n      max;\n\n    // partition, sum, and sort the stack groups\n    groups = partition(pulse.source, _.groupby, sort, field);\n\n    // compute stack layouts per group\n    for (i = 0, n = groups.length, max = groups.max; i < n; ++i) {\n      stack(groups[i], max, field, y0, y1);\n    }\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n});\nfunction stackCenter(group, max, field, y0, y1) {\n  var last = (max - group.sum) / 2,\n    m = group.length,\n    j = 0,\n    t;\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last += Math.abs(field(t));\n  }\n}\nfunction stackNormalize(group, max, field, y0, y1) {\n  var scale = 1 / group.sum,\n    last = 0,\n    m = group.length,\n    j = 0,\n    v = 0,\n    t;\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last = scale * (v += Math.abs(field(t)));\n  }\n}\nfunction stackZero(group, max, field, y0, y1) {\n  var lastPos = 0,\n    lastNeg = 0,\n    m = group.length,\n    j = 0,\n    v,\n    t;\n  for (; j < m; ++j) {\n    t = group[j];\n    v = +field(t);\n    if (v < 0) {\n      t[y0] = lastNeg;\n      t[y1] = lastNeg += v;\n    } else {\n      t[y0] = lastPos;\n      t[y1] = lastPos += v;\n    }\n  }\n}\nfunction partition(data, groupby, sort, field) {\n  var groups = [],\n    get = f => f(t),\n    map,\n    i,\n    n,\n    m,\n    t,\n    k,\n    g,\n    s,\n    max;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n      if (!g) {\n        map[k] = g = [];\n        groups.push(g);\n      }\n      g.push(t);\n    }\n  }\n\n  // compute sums of groups, sort groups as needed\n  for (k = 0, max = 0, m = groups.length; k < m; ++k) {\n    g = groups[k];\n    for (i = 0, s = 0, n = g.length; i < n; ++i) {\n      s += Math.abs(field(g[i]));\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sort) g.sort(sort);\n  }\n  groups.max = max;\n  return groups;\n}\n\nexport { AxisTicks as axisticks, DataJoin as datajoin, Encode as encode, LegendEntries as legendentries, LinkPath as linkpath, Pie as pie, Scale as scale, SortItems as sortitems, Stack as stack };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}