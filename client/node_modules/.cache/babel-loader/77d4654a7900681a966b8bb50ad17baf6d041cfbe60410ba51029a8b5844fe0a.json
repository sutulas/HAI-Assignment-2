{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { COLUMN, FACET, ROW } from '../channel';\nimport { hasConditionalFieldOrDatumDef, isFieldOrDatumDef, isValueDef } from '../channeldef';\nimport { boxPlotNormalizer } from '../compositemark/boxplot';\nimport { errorBandNormalizer } from '../compositemark/errorband';\nimport { errorBarNormalizer } from '../compositemark/errorbar';\nimport { channelHasField } from '../encoding';\nimport * as log from '../log';\nimport { isFacetMapping } from '../spec/facet';\nimport { SpecMapper } from '../spec/map';\nimport { isLayerRepeatSpec } from '../spec/repeat';\nimport { isUnitSpec } from '../spec/unit';\nimport { isEmpty, keys, omit, varName } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { PathOverlayNormalizer } from './pathoverlay';\nimport { replaceRepeaterInEncoding, replaceRepeaterInFacet } from './repeater';\nimport { RuleForRangedLineNormalizer } from './ruleforrangedline';\nexport class CoreNormalizer extends SpecMapper {\n  constructor() {\n    super(...arguments);\n    this.nonFacetUnitNormalizers = [boxPlotNormalizer, errorBarNormalizer, errorBandNormalizer, new PathOverlayNormalizer(), new RuleForRangedLineNormalizer()];\n  }\n  map(spec, params) {\n    // Special handling for a faceted unit spec as it can return a facet spec, not just a layer or unit spec like a normal unit spec.\n    if (isUnitSpec(spec)) {\n      const hasRow = channelHasField(spec.encoding, ROW);\n      const hasColumn = channelHasField(spec.encoding, COLUMN);\n      const hasFacet = channelHasField(spec.encoding, FACET);\n      if (hasRow || hasColumn || hasFacet) {\n        return this.mapFacetedUnit(spec, params);\n      }\n    }\n    return super.map(spec, params);\n  }\n  // This is for normalizing non-facet unit\n  mapUnit(spec, params) {\n    const {\n      parentEncoding,\n      parentProjection\n    } = params;\n    const encoding = replaceRepeaterInEncoding(spec.encoding, params.repeater);\n    const specWithReplacedEncoding = {\n      ...spec,\n      ...(spec.name ? {\n        name: [params.repeaterPrefix, spec.name].filter(n => n).join('_')\n      } : {}),\n      ...(encoding ? {\n        encoding\n      } : {})\n    };\n    if (parentEncoding || parentProjection) {\n      return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding, params);\n    }\n    const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);\n    for (const unitNormalizer of this.nonFacetUnitNormalizers) {\n      if (unitNormalizer.hasMatchingType(specWithReplacedEncoding, params.config)) {\n        return unitNormalizer.run(specWithReplacedEncoding, params, normalizeLayerOrUnit);\n      }\n    }\n    return specWithReplacedEncoding;\n  }\n  mapRepeat(spec, params) {\n    if (isLayerRepeatSpec(spec)) {\n      return this.mapLayerRepeat(spec, params);\n    } else {\n      return this.mapNonLayerRepeat(spec, params);\n    }\n  }\n  mapLayerRepeat(spec, params) {\n    const {\n      repeat,\n      spec: childSpec,\n      ...rest\n    } = spec;\n    const {\n      row,\n      column,\n      layer\n    } = repeat;\n    const {\n      repeater = {},\n      repeaterPrefix = ''\n    } = params;\n    if (row || column) {\n      return this.mapRepeat({\n        ...spec,\n        repeat: {\n          ...(row ? {\n            row\n          } : {}),\n          ...(column ? {\n            column\n          } : {})\n        },\n        spec: {\n          repeat: {\n            layer\n          },\n          spec: childSpec\n        }\n      }, params);\n    } else {\n      return {\n        ...rest,\n        layer: layer.map(layerValue => {\n          const childRepeater = {\n            ...repeater,\n            layer: layerValue\n          };\n          const childName = `${(childSpec.name ? `${childSpec.name}_` : '') + repeaterPrefix}child__layer_${varName(layerValue)}`;\n          const child = this.mapLayerOrUnit(childSpec, {\n            ...params,\n            repeater: childRepeater,\n            repeaterPrefix: childName\n          });\n          child.name = childName;\n          return child;\n        })\n      };\n    }\n  }\n  mapNonLayerRepeat(spec, params) {\n    const {\n      repeat,\n      spec: childSpec,\n      data,\n      ...remainingProperties\n    } = spec;\n    if (!isArray(repeat) && spec.columns) {\n      // is repeat with row/column\n      spec = omit(spec, ['columns']);\n      log.warn(log.message.columnsNotSupportByRowCol('repeat'));\n    }\n    const concat = [];\n    const {\n      repeater = {},\n      repeaterPrefix = ''\n    } = params;\n    const row = !isArray(repeat) && repeat.row || [repeater ? repeater.row : null];\n    const column = !isArray(repeat) && repeat.column || [repeater ? repeater.column : null];\n    const repeatValues = isArray(repeat) && repeat || [repeater ? repeater.repeat : null];\n    // cross product\n    for (const repeatValue of repeatValues) {\n      for (const rowValue of row) {\n        for (const columnValue of column) {\n          const childRepeater = {\n            repeat: repeatValue,\n            row: rowValue,\n            column: columnValue,\n            layer: repeater.layer\n          };\n          const childName = (childSpec.name ? `${childSpec.name}_` : '') + repeaterPrefix + 'child__' + (isArray(repeat) ? `${varName(repeatValue)}` : (repeat.row ? `row_${varName(rowValue)}` : '') + (repeat.column ? `column_${varName(columnValue)}` : ''));\n          const child = this.map(childSpec, {\n            ...params,\n            repeater: childRepeater,\n            repeaterPrefix: childName\n          });\n          child.name = childName;\n          // we move data up\n          concat.push(omit(child, ['data']));\n        }\n      }\n    }\n    const columns = isArray(repeat) ? spec.columns : repeat.column ? repeat.column.length : 1;\n    return {\n      data: childSpec.data ?? data,\n      // data from child spec should have precedence\n      align: 'all',\n      ...remainingProperties,\n      columns,\n      concat\n    };\n  }\n  mapFacet(spec, params) {\n    const {\n      facet\n    } = spec;\n    if (isFacetMapping(facet) && spec.columns) {\n      // is facet with row/column\n      spec = omit(spec, ['columns']);\n      log.warn(log.message.columnsNotSupportByRowCol('facet'));\n    }\n    return super.mapFacet(spec, params);\n  }\n  mapUnitWithParentEncodingOrProjection(spec, params) {\n    const {\n      encoding,\n      projection\n    } = spec;\n    const {\n      parentEncoding,\n      parentProjection,\n      config\n    } = params;\n    const mergedProjection = mergeProjection({\n      parentProjection,\n      projection\n    });\n    const mergedEncoding = mergeEncoding({\n      parentEncoding,\n      encoding: replaceRepeaterInEncoding(encoding, params.repeater)\n    });\n    return this.mapUnit({\n      ...spec,\n      ...(mergedProjection ? {\n        projection: mergedProjection\n      } : {}),\n      ...(mergedEncoding ? {\n        encoding: mergedEncoding\n      } : {})\n    }, {\n      config\n    });\n  }\n  mapFacetedUnit(spec, normParams) {\n    // New encoding in the inside spec should not contain row / column\n    // as row/column should be moved to facet\n    const {\n      row,\n      column,\n      facet,\n      ...encoding\n    } = spec.encoding;\n    // Mark and encoding should be moved into the inner spec\n    const {\n      mark,\n      width,\n      projection,\n      height,\n      view,\n      params,\n      encoding: _,\n      ...outerSpec\n    } = spec;\n    const {\n      facetMapping,\n      layout\n    } = this.getFacetMappingAndLayout({\n      row,\n      column,\n      facet\n    }, normParams);\n    const newEncoding = replaceRepeaterInEncoding(encoding, normParams.repeater);\n    return this.mapFacet({\n      ...outerSpec,\n      ...layout,\n      // row / column has higher precedence than facet\n      facet: facetMapping,\n      spec: {\n        ...(width ? {\n          width\n        } : {}),\n        ...(height ? {\n          height\n        } : {}),\n        ...(view ? {\n          view\n        } : {}),\n        ...(projection ? {\n          projection\n        } : {}),\n        mark,\n        encoding: newEncoding,\n        ...(params ? {\n          params\n        } : {})\n      }\n    }, normParams);\n  }\n  getFacetMappingAndLayout(facets, params) {\n    const {\n      row,\n      column,\n      facet\n    } = facets;\n    if (row || column) {\n      if (facet) {\n        log.warn(log.message.facetChannelDropped([...(row ? [ROW] : []), ...(column ? [COLUMN] : [])]));\n      }\n      const facetMapping = {};\n      const layout = {};\n      for (const channel of [ROW, COLUMN]) {\n        const def = facets[channel];\n        if (def) {\n          const {\n            align,\n            center,\n            spacing,\n            columns,\n            ...defWithoutLayout\n          } = def;\n          facetMapping[channel] = defWithoutLayout;\n          for (const prop of ['align', 'center', 'spacing']) {\n            if (def[prop] !== undefined) {\n              layout[prop] ?? (layout[prop] = {});\n              layout[prop][channel] = def[prop];\n            }\n          }\n        }\n      }\n      return {\n        facetMapping,\n        layout\n      };\n    } else {\n      const {\n        align,\n        center,\n        spacing,\n        columns,\n        ...facetMapping\n      } = facet;\n      return {\n        facetMapping: replaceRepeaterInFacet(facetMapping, params.repeater),\n        layout: {\n          ...(align ? {\n            align\n          } : {}),\n          ...(center ? {\n            center\n          } : {}),\n          ...(spacing ? {\n            spacing\n          } : {}),\n          ...(columns ? {\n            columns\n          } : {})\n        }\n      };\n    }\n  }\n  mapLayer(spec, _ref) {\n    let {\n      parentEncoding,\n      parentProjection,\n      ...otherParams\n    } = _ref;\n    // Special handling for extended layer spec\n    const {\n      encoding,\n      projection,\n      ...rest\n    } = spec;\n    const params = {\n      ...otherParams,\n      parentEncoding: mergeEncoding({\n        parentEncoding,\n        encoding,\n        layer: true\n      }),\n      parentProjection: mergeProjection({\n        parentProjection,\n        projection\n      })\n    };\n    return super.mapLayer({\n      ...rest,\n      ...(spec.name ? {\n        name: [params.repeaterPrefix, spec.name].filter(n => n).join('_')\n      } : {})\n    }, params);\n  }\n}\nfunction mergeEncoding(_ref2) {\n  let {\n    parentEncoding,\n    encoding = {},\n    layer\n  } = _ref2;\n  let merged = {};\n  if (parentEncoding) {\n    const channels = new Set([...keys(parentEncoding), ...keys(encoding)]);\n    for (const channel of channels) {\n      const channelDef = encoding[channel];\n      const parentChannelDef = parentEncoding[channel];\n      if (isFieldOrDatumDef(channelDef)) {\n        // Field/Datum Def can inherit properties from its parent\n        // Note that parentChannelDef doesn't have to be a field/datum def if the channelDef is already one.\n        const mergedChannelDef = {\n          ...parentChannelDef,\n          ...channelDef\n        };\n        merged[channel] = mergedChannelDef;\n      } else if (hasConditionalFieldOrDatumDef(channelDef)) {\n        merged[channel] = {\n          ...channelDef,\n          condition: {\n            ...parentChannelDef,\n            ...channelDef.condition\n          }\n        };\n      } else if (channelDef || channelDef === null) {\n        merged[channel] = channelDef;\n      } else if (layer || isValueDef(parentChannelDef) || isSignalRef(parentChannelDef) || isFieldOrDatumDef(parentChannelDef) || isArray(parentChannelDef)) {\n        merged[channel] = parentChannelDef;\n      }\n    }\n  } else {\n    merged = encoding;\n  }\n  return !merged || isEmpty(merged) ? undefined : merged;\n}\nfunction mergeProjection(opt) {\n  const {\n    parentProjection,\n    projection\n  } = opt;\n  if (parentProjection && projection) {\n    log.warn(log.message.projectionOverridden({\n      parentProjection,\n      projection\n    }));\n  }\n  return projection ?? parentProjection;\n}","map":{"version":3,"names":["isArray","COLUMN","FACET","ROW","hasConditionalFieldOrDatumDef","isFieldOrDatumDef","isValueDef","boxPlotNormalizer","errorBandNormalizer","errorBarNormalizer","channelHasField","log","isFacetMapping","SpecMapper","isLayerRepeatSpec","isUnitSpec","isEmpty","keys","omit","varName","isSignalRef","PathOverlayNormalizer","replaceRepeaterInEncoding","replaceRepeaterInFacet","RuleForRangedLineNormalizer","CoreNormalizer","constructor","nonFacetUnitNormalizers","map","spec","params","hasRow","encoding","hasColumn","hasFacet","mapFacetedUnit","mapUnit","parentEncoding","parentProjection","repeater","specWithReplacedEncoding","name","repeaterPrefix","filter","n","join","mapUnitWithParentEncodingOrProjection","normalizeLayerOrUnit","mapLayerOrUnit","bind","unitNormalizer","hasMatchingType","config","run","mapRepeat","mapLayerRepeat","mapNonLayerRepeat","repeat","childSpec","rest","row","column","layer","layerValue","childRepeater","childName","child","data","remainingProperties","columns","warn","message","columnsNotSupportByRowCol","concat","repeatValues","repeatValue","rowValue","columnValue","push","length","align","mapFacet","facet","projection","mergedProjection","mergeProjection","mergedEncoding","mergeEncoding","normParams","mark","width","height","view","_","outerSpec","facetMapping","layout","getFacetMappingAndLayout","newEncoding","facets","facetChannelDropped","channel","def","center","spacing","defWithoutLayout","prop","undefined","mapLayer","_ref","otherParams","_ref2","merged","channels","Set","channelDef","parentChannelDef","mergedChannelDef","condition","opt","projectionOverridden"],"sources":["C:\\Users\\sutul\\node_modules\\vega-lite\\src\\normalize\\core.ts"],"sourcesContent":["import type {SignalRef} from 'vega';\nimport {isArray} from 'vega-util';\nimport {COLUMN, FACET, ROW} from '../channel';\nimport {Field, FieldName, hasConditionalFieldOrDatumDef, isFieldOrDatumDef, isValueDef} from '../channeldef';\nimport {SharedCompositeEncoding} from '../compositemark';\nimport {boxPlotNormalizer} from '../compositemark/boxplot';\nimport {errorBandNormalizer} from '../compositemark/errorband';\nimport {errorBarNormalizer} from '../compositemark/errorbar';\nimport {channelHasField, Encoding} from '../encoding';\nimport {ExprRef} from '../expr';\nimport * as log from '../log';\nimport {Projection} from '../projection';\nimport {FacetedUnitSpec, GenericSpec, LayerSpec, UnitSpec} from '../spec';\nimport {GenericCompositionLayoutWithColumns} from '../spec/base';\nimport {GenericConcatSpec} from '../spec/concat';\nimport {\n  FacetEncodingFieldDef,\n  FacetFieldDef,\n  FacetMapping,\n  GenericFacetSpec,\n  isFacetMapping,\n  NormalizedFacetSpec\n} from '../spec/facet';\nimport {NormalizedSpec} from '../spec/index';\nimport {NormalizedLayerSpec} from '../spec/layer';\nimport {SpecMapper} from '../spec/map';\nimport {isLayerRepeatSpec, LayerRepeatSpec, NonLayerRepeatSpec, RepeatSpec} from '../spec/repeat';\nimport {isUnitSpec, NormalizedUnitSpec} from '../spec/unit';\nimport {isEmpty, keys, omit, varName} from '../util';\nimport {isSignalRef} from '../vega.schema';\nimport {NonFacetUnitNormalizer, NormalizerParams} from './base';\nimport {PathOverlayNormalizer} from './pathoverlay';\nimport {replaceRepeaterInEncoding, replaceRepeaterInFacet} from './repeater';\nimport {RuleForRangedLineNormalizer} from './ruleforrangedline';\n\nexport class CoreNormalizer extends SpecMapper<NormalizerParams, FacetedUnitSpec<Field>, LayerSpec<Field>> {\n  private nonFacetUnitNormalizers: NonFacetUnitNormalizer<any>[] = [\n    boxPlotNormalizer,\n    errorBarNormalizer,\n    errorBandNormalizer,\n    new PathOverlayNormalizer(),\n    new RuleForRangedLineNormalizer()\n  ];\n\n  public map(spec: GenericSpec<FacetedUnitSpec<Field>, LayerSpec<Field>, RepeatSpec, Field>, params: NormalizerParams) {\n    // Special handling for a faceted unit spec as it can return a facet spec, not just a layer or unit spec like a normal unit spec.\n    if (isUnitSpec(spec)) {\n      const hasRow = channelHasField(spec.encoding, ROW);\n      const hasColumn = channelHasField(spec.encoding, COLUMN);\n      const hasFacet = channelHasField(spec.encoding, FACET);\n\n      if (hasRow || hasColumn || hasFacet) {\n        return this.mapFacetedUnit(spec, params);\n      }\n    }\n\n    return super.map(spec, params);\n  }\n\n  // This is for normalizing non-facet unit\n  public mapUnit(spec: UnitSpec<Field>, params: NormalizerParams): NormalizedUnitSpec | NormalizedLayerSpec {\n    const {parentEncoding, parentProjection} = params;\n\n    const encoding = replaceRepeaterInEncoding(spec.encoding, params.repeater);\n\n    const specWithReplacedEncoding = {\n      ...spec,\n      ...(spec.name ? {name: [params.repeaterPrefix, spec.name].filter(n => n).join('_')} : {}),\n      ...(encoding ? {encoding} : {})\n    };\n\n    if (parentEncoding || parentProjection) {\n      return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding, params);\n    }\n\n    const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);\n\n    for (const unitNormalizer of this.nonFacetUnitNormalizers) {\n      if (unitNormalizer.hasMatchingType(specWithReplacedEncoding, params.config)) {\n        return unitNormalizer.run(specWithReplacedEncoding, params, normalizeLayerOrUnit);\n      }\n    }\n\n    return specWithReplacedEncoding as NormalizedUnitSpec;\n  }\n\n  protected mapRepeat(\n    spec: RepeatSpec,\n    params: NormalizerParams\n  ): GenericConcatSpec<NormalizedSpec> | NormalizedLayerSpec {\n    if (isLayerRepeatSpec(spec)) {\n      return this.mapLayerRepeat(spec, params);\n    } else {\n      return this.mapNonLayerRepeat(spec, params);\n    }\n  }\n\n  private mapLayerRepeat(\n    spec: LayerRepeatSpec,\n    params: NormalizerParams\n  ): GenericConcatSpec<NormalizedSpec> | NormalizedLayerSpec {\n    const {repeat, spec: childSpec, ...rest} = spec;\n    const {row, column, layer} = repeat;\n\n    const {repeater = {}, repeaterPrefix = ''} = params;\n\n    if (row || column) {\n      return this.mapRepeat(\n        {\n          ...spec,\n          repeat: {\n            ...(row ? {row} : {}),\n            ...(column ? {column} : {})\n          },\n          spec: {\n            repeat: {layer},\n            spec: childSpec\n          }\n        },\n        params\n      );\n    } else {\n      return {\n        ...rest,\n        layer: layer.map(layerValue => {\n          const childRepeater = {\n            ...repeater,\n            layer: layerValue\n          };\n\n          const childName = `${(childSpec.name ? `${childSpec.name}_` : '') + repeaterPrefix}child__layer_${varName(\n            layerValue\n          )}`;\n\n          const child = this.mapLayerOrUnit(childSpec, {...params, repeater: childRepeater, repeaterPrefix: childName});\n          child.name = childName;\n\n          return child;\n        })\n      };\n    }\n  }\n\n  private mapNonLayerRepeat(spec: NonLayerRepeatSpec, params: NormalizerParams): GenericConcatSpec<NormalizedSpec> {\n    const {repeat, spec: childSpec, data, ...remainingProperties} = spec;\n\n    if (!isArray(repeat) && spec.columns) {\n      // is repeat with row/column\n      spec = omit(spec, ['columns']);\n      log.warn(log.message.columnsNotSupportByRowCol('repeat'));\n    }\n\n    const concat: NormalizedSpec[] = [];\n\n    const {repeater = {}, repeaterPrefix = ''} = params;\n\n    const row = (!isArray(repeat) && repeat.row) || [repeater ? repeater.row : null];\n    const column = (!isArray(repeat) && repeat.column) || [repeater ? repeater.column : null];\n\n    const repeatValues = (isArray(repeat) && repeat) || [repeater ? repeater.repeat : null];\n\n    // cross product\n    for (const repeatValue of repeatValues) {\n      for (const rowValue of row) {\n        for (const columnValue of column) {\n          const childRepeater = {\n            repeat: repeatValue,\n            row: rowValue,\n            column: columnValue,\n            layer: repeater.layer\n          };\n\n          const childName =\n            (childSpec.name ? `${childSpec.name}_` : '') +\n            repeaterPrefix +\n            'child__' +\n            (isArray(repeat)\n              ? `${varName(repeatValue)}`\n              : (repeat.row ? `row_${varName(rowValue)}` : '') +\n                (repeat.column ? `column_${varName(columnValue)}` : ''));\n\n          const child = this.map(childSpec, {...params, repeater: childRepeater, repeaterPrefix: childName});\n          child.name = childName;\n\n          // we move data up\n          concat.push(omit(child, ['data']) as NormalizedSpec);\n        }\n      }\n    }\n\n    const columns = isArray(repeat) ? spec.columns : repeat.column ? repeat.column.length : 1;\n    return {\n      data: childSpec.data ?? data, // data from child spec should have precedence\n      align: 'all',\n      ...remainingProperties,\n      columns,\n      concat\n    };\n  }\n\n  protected mapFacet(\n    spec: GenericFacetSpec<UnitSpec<Field>, LayerSpec<Field>, Field>,\n    params: NormalizerParams\n  ): GenericFacetSpec<NormalizedUnitSpec, NormalizedLayerSpec, FieldName> {\n    const {facet} = spec;\n\n    if (isFacetMapping(facet) && spec.columns) {\n      // is facet with row/column\n      spec = omit(spec, ['columns']);\n      log.warn(log.message.columnsNotSupportByRowCol('facet'));\n    }\n\n    return super.mapFacet(spec, params);\n  }\n\n  private mapUnitWithParentEncodingOrProjection(\n    spec: FacetedUnitSpec<Field>,\n    params: NormalizerParams\n  ): NormalizedUnitSpec | NormalizedLayerSpec {\n    const {encoding, projection} = spec;\n    const {parentEncoding, parentProjection, config} = params;\n    const mergedProjection = mergeProjection({parentProjection, projection});\n    const mergedEncoding = mergeEncoding({\n      parentEncoding,\n      encoding: replaceRepeaterInEncoding(encoding, params.repeater)\n    });\n\n    return this.mapUnit(\n      {\n        ...spec,\n        ...(mergedProjection ? {projection: mergedProjection} : {}),\n        ...(mergedEncoding ? {encoding: mergedEncoding} : {})\n      },\n      {config}\n    );\n  }\n\n  private mapFacetedUnit(spec: FacetedUnitSpec<Field>, normParams: NormalizerParams): NormalizedFacetSpec {\n    // New encoding in the inside spec should not contain row / column\n    // as row/column should be moved to facet\n    const {row, column, facet, ...encoding} = spec.encoding;\n\n    // Mark and encoding should be moved into the inner spec\n    const {mark, width, projection, height, view, params, encoding: _, ...outerSpec} = spec;\n\n    const {facetMapping, layout} = this.getFacetMappingAndLayout({row, column, facet}, normParams);\n\n    const newEncoding = replaceRepeaterInEncoding(encoding, normParams.repeater);\n\n    return this.mapFacet(\n      {\n        ...outerSpec,\n        ...layout,\n\n        // row / column has higher precedence than facet\n        facet: facetMapping,\n        spec: {\n          ...(width ? {width} : {}),\n          ...(height ? {height} : {}),\n          ...(view ? {view} : {}),\n          ...(projection ? {projection} : {}),\n          mark,\n          encoding: newEncoding,\n          ...(params ? {params} : {})\n        }\n      },\n      normParams\n    );\n  }\n\n  private getFacetMappingAndLayout(\n    facets: {\n      row: FacetEncodingFieldDef<Field>;\n      column: FacetEncodingFieldDef<Field>;\n      facet: FacetEncodingFieldDef<Field>;\n    },\n    params: NormalizerParams\n  ): {facetMapping: FacetMapping<FieldName> | FacetFieldDef<FieldName>; layout: GenericCompositionLayoutWithColumns} {\n    const {row, column, facet} = facets;\n\n    if (row || column) {\n      if (facet) {\n        log.warn(log.message.facetChannelDropped([...(row ? [ROW] : []), ...(column ? [COLUMN] : [])]));\n      }\n\n      const facetMapping: any = {};\n      const layout: any = {};\n\n      for (const channel of [ROW, COLUMN]) {\n        const def = facets[channel];\n        if (def) {\n          const {align, center, spacing, columns, ...defWithoutLayout} = def;\n          facetMapping[channel] = defWithoutLayout;\n\n          for (const prop of ['align', 'center', 'spacing'] as const) {\n            if (def[prop] !== undefined) {\n              layout[prop] ??= {};\n              layout[prop][channel] = def[prop];\n            }\n          }\n        }\n      }\n\n      return {facetMapping, layout};\n    } else {\n      const {align, center, spacing, columns, ...facetMapping} = facet;\n      return {\n        facetMapping: replaceRepeaterInFacet(facetMapping, params.repeater),\n        layout: {\n          ...(align ? {align} : {}),\n          ...(center ? {center} : {}),\n          ...(spacing ? {spacing} : {}),\n          ...(columns ? {columns} : {})\n        }\n      };\n    }\n  }\n\n  public mapLayer(\n    spec: LayerSpec<Field>,\n    {parentEncoding, parentProjection, ...otherParams}: NormalizerParams\n  ): NormalizedLayerSpec {\n    // Special handling for extended layer spec\n\n    const {encoding, projection, ...rest} = spec;\n    const params: NormalizerParams = {\n      ...otherParams,\n      parentEncoding: mergeEncoding({parentEncoding, encoding, layer: true}),\n      parentProjection: mergeProjection({parentProjection, projection})\n    };\n    return super.mapLayer(\n      {\n        ...rest,\n        ...(spec.name ? {name: [params.repeaterPrefix, spec.name].filter(n => n).join('_')} : {})\n      },\n      params\n    );\n  }\n}\n\nfunction mergeEncoding({\n  parentEncoding,\n  encoding = {},\n  layer\n}: {\n  parentEncoding: SharedCompositeEncoding<any>;\n  encoding: SharedCompositeEncoding<any> | Encoding<any>;\n  layer?: boolean;\n}): Encoding<any> {\n  let merged: any = {};\n  if (parentEncoding) {\n    const channels = new Set([...keys(parentEncoding), ...keys(encoding)]);\n    for (const channel of channels) {\n      const channelDef = (encoding as any)[channel];\n      const parentChannelDef = parentEncoding[channel];\n\n      if (isFieldOrDatumDef(channelDef)) {\n        // Field/Datum Def can inherit properties from its parent\n        // Note that parentChannelDef doesn't have to be a field/datum def if the channelDef is already one.\n        const mergedChannelDef = {\n          ...parentChannelDef,\n          ...channelDef\n        };\n        merged[channel] = mergedChannelDef;\n      } else if (hasConditionalFieldOrDatumDef(channelDef)) {\n        merged[channel] = {\n          ...channelDef,\n          condition: {\n            ...parentChannelDef,\n            ...channelDef.condition\n          }\n        };\n      } else if (channelDef || channelDef === null) {\n        merged[channel] = channelDef;\n      } else if (\n        layer ||\n        isValueDef(parentChannelDef) ||\n        isSignalRef(parentChannelDef) ||\n        isFieldOrDatumDef(parentChannelDef) ||\n        isArray(parentChannelDef)\n      ) {\n        merged[channel] = parentChannelDef;\n      }\n    }\n  } else {\n    merged = encoding;\n  }\n  return !merged || isEmpty(merged) ? undefined : merged;\n}\n\nfunction mergeProjection<ES extends ExprRef | SignalRef>(opt: {\n  parentProjection: Projection<ES>;\n  projection: Projection<ES>;\n}) {\n  const {parentProjection, projection} = opt;\n  if (parentProjection && projection) {\n    log.warn(log.message.projectionOverridden({parentProjection, projection}));\n  }\n  return projection ?? parentProjection;\n}\n"],"mappings":"AACA,SAAQA,OAAO,QAAO,WAAW;AACjC,SAAQC,MAAM,EAAEC,KAAK,EAAEC,GAAG,QAAO,YAAY;AAC7C,SAA0BC,6BAA6B,EAAEC,iBAAiB,EAAEC,UAAU,QAAO,eAAe;AAE5G,SAAQC,iBAAiB,QAAO,0BAA0B;AAC1D,SAAQC,mBAAmB,QAAO,4BAA4B;AAC9D,SAAQC,kBAAkB,QAAO,2BAA2B;AAC5D,SAAQC,eAAe,QAAiB,aAAa;AAErD,OAAO,KAAKC,GAAG,MAAM,QAAQ;AAK7B,SAKEC,cAAc,QAET,eAAe;AAGtB,SAAQC,UAAU,QAAO,aAAa;AACtC,SAAQC,iBAAiB,QAAwD,gBAAgB;AACjG,SAAQC,UAAU,QAA2B,cAAc;AAC3D,SAAQC,OAAO,EAAEC,IAAI,EAAEC,IAAI,EAAEC,OAAO,QAAO,SAAS;AACpD,SAAQC,WAAW,QAAO,gBAAgB;AAE1C,SAAQC,qBAAqB,QAAO,eAAe;AACnD,SAAQC,yBAAyB,EAAEC,sBAAsB,QAAO,YAAY;AAC5E,SAAQC,2BAA2B,QAAO,qBAAqB;AAE/D,OAAM,MAAOC,cAAe,SAAQZ,UAAsE;EAA1Ga,YAAA;;IACU,KAAAC,uBAAuB,GAAkC,CAC/DpB,iBAAiB,EACjBE,kBAAkB,EAClBD,mBAAmB,EACnB,IAAIa,qBAAqB,EAAE,EAC3B,IAAIG,2BAA2B,EAAE,CAClC;EAwSH;EAtSSI,GAAGA,CAACC,IAA8E,EAAEC,MAAwB;IACjH;IACA,IAAIf,UAAU,CAACc,IAAI,CAAC,EAAE;MACpB,MAAME,MAAM,GAAGrB,eAAe,CAACmB,IAAI,CAACG,QAAQ,EAAE7B,GAAG,CAAC;MAClD,MAAM8B,SAAS,GAAGvB,eAAe,CAACmB,IAAI,CAACG,QAAQ,EAAE/B,MAAM,CAAC;MACxD,MAAMiC,QAAQ,GAAGxB,eAAe,CAACmB,IAAI,CAACG,QAAQ,EAAE9B,KAAK,CAAC;MAEtD,IAAI6B,MAAM,IAAIE,SAAS,IAAIC,QAAQ,EAAE;QACnC,OAAO,IAAI,CAACC,cAAc,CAACN,IAAI,EAAEC,MAAM,CAAC;MAC1C;IACF;IAEA,OAAO,KAAK,CAACF,GAAG,CAACC,IAAI,EAAEC,MAAM,CAAC;EAChC;EAEA;EACOM,OAAOA,CAACP,IAAqB,EAAEC,MAAwB;IAC5D,MAAM;MAACO,cAAc;MAAEC;IAAgB,CAAC,GAAGR,MAAM;IAEjD,MAAME,QAAQ,GAAGV,yBAAyB,CAACO,IAAI,CAACG,QAAQ,EAAEF,MAAM,CAACS,QAAQ,CAAC;IAE1E,MAAMC,wBAAwB,GAAG;MAC/B,GAAGX,IAAI;MACP,IAAIA,IAAI,CAACY,IAAI,GAAG;QAACA,IAAI,EAAE,CAACX,MAAM,CAACY,cAAc,EAAEb,IAAI,CAACY,IAAI,CAAC,CAACE,MAAM,CAACC,CAAC,IAAIA,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG;MAAC,CAAC,GAAG,EAAE,CAAC;MACzF,IAAIb,QAAQ,GAAG;QAACA;MAAQ,CAAC,GAAG,EAAE;KAC/B;IAED,IAAIK,cAAc,IAAIC,gBAAgB,EAAE;MACtC,OAAO,IAAI,CAACQ,qCAAqC,CAACN,wBAAwB,EAAEV,MAAM,CAAC;IACrF;IAEA,MAAMiB,oBAAoB,GAAG,IAAI,CAACC,cAAc,CAACC,IAAI,CAAC,IAAI,CAAC;IAE3D,KAAK,MAAMC,cAAc,IAAI,IAAI,CAACvB,uBAAuB,EAAE;MACzD,IAAIuB,cAAc,CAACC,eAAe,CAACX,wBAAwB,EAAEV,MAAM,CAACsB,MAAM,CAAC,EAAE;QAC3E,OAAOF,cAAc,CAACG,GAAG,CAACb,wBAAwB,EAAEV,MAAM,EAAEiB,oBAAoB,CAAC;MACnF;IACF;IAEA,OAAOP,wBAA8C;EACvD;EAEUc,SAASA,CACjBzB,IAAgB,EAChBC,MAAwB;IAExB,IAAIhB,iBAAiB,CAACe,IAAI,CAAC,EAAE;MAC3B,OAAO,IAAI,CAAC0B,cAAc,CAAC1B,IAAI,EAAEC,MAAM,CAAC;IAC1C,CAAC,MAAM;MACL,OAAO,IAAI,CAAC0B,iBAAiB,CAAC3B,IAAI,EAAEC,MAAM,CAAC;IAC7C;EACF;EAEQyB,cAAcA,CACpB1B,IAAqB,EACrBC,MAAwB;IAExB,MAAM;MAAC2B,MAAM;MAAE5B,IAAI,EAAE6B,SAAS;MAAE,GAAGC;IAAI,CAAC,GAAG9B,IAAI;IAC/C,MAAM;MAAC+B,GAAG;MAAEC,MAAM;MAAEC;IAAK,CAAC,GAAGL,MAAM;IAEnC,MAAM;MAAClB,QAAQ,GAAG,EAAE;MAAEG,cAAc,GAAG;IAAE,CAAC,GAAGZ,MAAM;IAEnD,IAAI8B,GAAG,IAAIC,MAAM,EAAE;MACjB,OAAO,IAAI,CAACP,SAAS,CACnB;QACE,GAAGzB,IAAI;QACP4B,MAAM,EAAE;UACN,IAAIG,GAAG,GAAG;YAACA;UAAG,CAAC,GAAG,EAAE,CAAC;UACrB,IAAIC,MAAM,GAAG;YAACA;UAAM,CAAC,GAAG,EAAE;SAC3B;QACDhC,IAAI,EAAE;UACJ4B,MAAM,EAAE;YAACK;UAAK,CAAC;UACfjC,IAAI,EAAE6B;;OAET,EACD5B,MAAM,CACP;IACH,CAAC,MAAM;MACL,OAAO;QACL,GAAG6B,IAAI;QACPG,KAAK,EAAEA,KAAK,CAAClC,GAAG,CAACmC,UAAU,IAAG;UAC5B,MAAMC,aAAa,GAAG;YACpB,GAAGzB,QAAQ;YACXuB,KAAK,EAAEC;WACR;UAED,MAAME,SAAS,GAAG,GAAG,CAACP,SAAS,CAACjB,IAAI,GAAG,GAAGiB,SAAS,CAACjB,IAAI,GAAG,GAAG,EAAE,IAAIC,cAAc,gBAAgBvB,OAAO,CACvG4C,UAAU,CACX,EAAE;UAEH,MAAMG,KAAK,GAAG,IAAI,CAAClB,cAAc,CAACU,SAAS,EAAE;YAAC,GAAG5B,MAAM;YAAES,QAAQ,EAAEyB,aAAa;YAAEtB,cAAc,EAAEuB;UAAS,CAAC,CAAC;UAC7GC,KAAK,CAACzB,IAAI,GAAGwB,SAAS;UAEtB,OAAOC,KAAK;QACd,CAAC;OACF;IACH;EACF;EAEQV,iBAAiBA,CAAC3B,IAAwB,EAAEC,MAAwB;IAC1E,MAAM;MAAC2B,MAAM;MAAE5B,IAAI,EAAE6B,SAAS;MAAES,IAAI;MAAE,GAAGC;IAAmB,CAAC,GAAGvC,IAAI;IAEpE,IAAI,CAAC7B,OAAO,CAACyD,MAAM,CAAC,IAAI5B,IAAI,CAACwC,OAAO,EAAE;MACpC;MACAxC,IAAI,GAAGX,IAAI,CAACW,IAAI,EAAE,CAAC,SAAS,CAAC,CAAC;MAC9BlB,GAAG,CAAC2D,IAAI,CAAC3D,GAAG,CAAC4D,OAAO,CAACC,yBAAyB,CAAC,QAAQ,CAAC,CAAC;IAC3D;IAEA,MAAMC,MAAM,GAAqB,EAAE;IAEnC,MAAM;MAAClC,QAAQ,GAAG,EAAE;MAAEG,cAAc,GAAG;IAAE,CAAC,GAAGZ,MAAM;IAEnD,MAAM8B,GAAG,GAAI,CAAC5D,OAAO,CAACyD,MAAM,CAAC,IAAIA,MAAM,CAACG,GAAG,IAAK,CAACrB,QAAQ,GAAGA,QAAQ,CAACqB,GAAG,GAAG,IAAI,CAAC;IAChF,MAAMC,MAAM,GAAI,CAAC7D,OAAO,CAACyD,MAAM,CAAC,IAAIA,MAAM,CAACI,MAAM,IAAK,CAACtB,QAAQ,GAAGA,QAAQ,CAACsB,MAAM,GAAG,IAAI,CAAC;IAEzF,MAAMa,YAAY,GAAI1E,OAAO,CAACyD,MAAM,CAAC,IAAIA,MAAM,IAAK,CAAClB,QAAQ,GAAGA,QAAQ,CAACkB,MAAM,GAAG,IAAI,CAAC;IAEvF;IACA,KAAK,MAAMkB,WAAW,IAAID,YAAY,EAAE;MACtC,KAAK,MAAME,QAAQ,IAAIhB,GAAG,EAAE;QAC1B,KAAK,MAAMiB,WAAW,IAAIhB,MAAM,EAAE;UAChC,MAAMG,aAAa,GAAG;YACpBP,MAAM,EAAEkB,WAAW;YACnBf,GAAG,EAAEgB,QAAQ;YACbf,MAAM,EAAEgB,WAAW;YACnBf,KAAK,EAAEvB,QAAQ,CAACuB;WACjB;UAED,MAAMG,SAAS,GACb,CAACP,SAAS,CAACjB,IAAI,GAAG,GAAGiB,SAAS,CAACjB,IAAI,GAAG,GAAG,EAAE,IAC3CC,cAAc,GACd,SAAS,IACR1C,OAAO,CAACyD,MAAM,CAAC,GACZ,GAAGtC,OAAO,CAACwD,WAAW,CAAC,EAAE,GACzB,CAAClB,MAAM,CAACG,GAAG,GAAG,OAAOzC,OAAO,CAACyD,QAAQ,CAAC,EAAE,GAAG,EAAE,KAC5CnB,MAAM,CAACI,MAAM,GAAG,UAAU1C,OAAO,CAAC0D,WAAW,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC;UAE9D,MAAMX,KAAK,GAAG,IAAI,CAACtC,GAAG,CAAC8B,SAAS,EAAE;YAAC,GAAG5B,MAAM;YAAES,QAAQ,EAAEyB,aAAa;YAAEtB,cAAc,EAAEuB;UAAS,CAAC,CAAC;UAClGC,KAAK,CAACzB,IAAI,GAAGwB,SAAS;UAEtB;UACAQ,MAAM,CAACK,IAAI,CAAC5D,IAAI,CAACgD,KAAK,EAAE,CAAC,MAAM,CAAC,CAAmB,CAAC;QACtD;MACF;IACF;IAEA,MAAMG,OAAO,GAAGrE,OAAO,CAACyD,MAAM,CAAC,GAAG5B,IAAI,CAACwC,OAAO,GAAGZ,MAAM,CAACI,MAAM,GAAGJ,MAAM,CAACI,MAAM,CAACkB,MAAM,GAAG,CAAC;IACzF,OAAO;MACLZ,IAAI,EAAET,SAAS,CAACS,IAAI,IAAIA,IAAI;MAAE;MAC9Ba,KAAK,EAAE,KAAK;MACZ,GAAGZ,mBAAmB;MACtBC,OAAO;MACPI;KACD;EACH;EAEUQ,QAAQA,CAChBpD,IAAgE,EAChEC,MAAwB;IAExB,MAAM;MAACoD;IAAK,CAAC,GAAGrD,IAAI;IAEpB,IAAIjB,cAAc,CAACsE,KAAK,CAAC,IAAIrD,IAAI,CAACwC,OAAO,EAAE;MACzC;MACAxC,IAAI,GAAGX,IAAI,CAACW,IAAI,EAAE,CAAC,SAAS,CAAC,CAAC;MAC9BlB,GAAG,CAAC2D,IAAI,CAAC3D,GAAG,CAAC4D,OAAO,CAACC,yBAAyB,CAAC,OAAO,CAAC,CAAC;IAC1D;IAEA,OAAO,KAAK,CAACS,QAAQ,CAACpD,IAAI,EAAEC,MAAM,CAAC;EACrC;EAEQgB,qCAAqCA,CAC3CjB,IAA4B,EAC5BC,MAAwB;IAExB,MAAM;MAACE,QAAQ;MAAEmD;IAAU,CAAC,GAAGtD,IAAI;IACnC,MAAM;MAACQ,cAAc;MAAEC,gBAAgB;MAAEc;IAAM,CAAC,GAAGtB,MAAM;IACzD,MAAMsD,gBAAgB,GAAGC,eAAe,CAAC;MAAC/C,gBAAgB;MAAE6C;IAAU,CAAC,CAAC;IACxE,MAAMG,cAAc,GAAGC,aAAa,CAAC;MACnClD,cAAc;MACdL,QAAQ,EAAEV,yBAAyB,CAACU,QAAQ,EAAEF,MAAM,CAACS,QAAQ;KAC9D,CAAC;IAEF,OAAO,IAAI,CAACH,OAAO,CACjB;MACE,GAAGP,IAAI;MACP,IAAIuD,gBAAgB,GAAG;QAACD,UAAU,EAAEC;MAAgB,CAAC,GAAG,EAAE,CAAC;MAC3D,IAAIE,cAAc,GAAG;QAACtD,QAAQ,EAAEsD;MAAc,CAAC,GAAG,EAAE;KACrD,EACD;MAAClC;IAAM,CAAC,CACT;EACH;EAEQjB,cAAcA,CAACN,IAA4B,EAAE2D,UAA4B;IAC/E;IACA;IACA,MAAM;MAAC5B,GAAG;MAAEC,MAAM;MAAEqB,KAAK;MAAE,GAAGlD;IAAQ,CAAC,GAAGH,IAAI,CAACG,QAAQ;IAEvD;IACA,MAAM;MAACyD,IAAI;MAAEC,KAAK;MAAEP,UAAU;MAAEQ,MAAM;MAAEC,IAAI;MAAE9D,MAAM;MAAEE,QAAQ,EAAE6D,CAAC;MAAE,GAAGC;IAAS,CAAC,GAAGjE,IAAI;IAEvF,MAAM;MAACkE,YAAY;MAAEC;IAAM,CAAC,GAAG,IAAI,CAACC,wBAAwB,CAAC;MAACrC,GAAG;MAAEC,MAAM;MAAEqB;IAAK,CAAC,EAAEM,UAAU,CAAC;IAE9F,MAAMU,WAAW,GAAG5E,yBAAyB,CAACU,QAAQ,EAAEwD,UAAU,CAACjD,QAAQ,CAAC;IAE5E,OAAO,IAAI,CAAC0C,QAAQ,CAClB;MACE,GAAGa,SAAS;MACZ,GAAGE,MAAM;MAET;MACAd,KAAK,EAAEa,YAAY;MACnBlE,IAAI,EAAE;QACJ,IAAI6D,KAAK,GAAG;UAACA;QAAK,CAAC,GAAG,EAAE,CAAC;QACzB,IAAIC,MAAM,GAAG;UAACA;QAAM,CAAC,GAAG,EAAE,CAAC;QAC3B,IAAIC,IAAI,GAAG;UAACA;QAAI,CAAC,GAAG,EAAE,CAAC;QACvB,IAAIT,UAAU,GAAG;UAACA;QAAU,CAAC,GAAG,EAAE,CAAC;QACnCM,IAAI;QACJzD,QAAQ,EAAEkE,WAAW;QACrB,IAAIpE,MAAM,GAAG;UAACA;QAAM,CAAC,GAAG,EAAE;;KAE7B,EACD0D,UAAU,CACX;EACH;EAEQS,wBAAwBA,CAC9BE,MAIC,EACDrE,MAAwB;IAExB,MAAM;MAAC8B,GAAG;MAAEC,MAAM;MAAEqB;IAAK,CAAC,GAAGiB,MAAM;IAEnC,IAAIvC,GAAG,IAAIC,MAAM,EAAE;MACjB,IAAIqB,KAAK,EAAE;QACTvE,GAAG,CAAC2D,IAAI,CAAC3D,GAAG,CAAC4D,OAAO,CAAC6B,mBAAmB,CAAC,CAAC,IAAIxC,GAAG,GAAG,CAACzD,GAAG,CAAC,GAAG,EAAE,CAAC,EAAE,IAAI0D,MAAM,GAAG,CAAC5D,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;MACjG;MAEA,MAAM8F,YAAY,GAAQ,EAAE;MAC5B,MAAMC,MAAM,GAAQ,EAAE;MAEtB,KAAK,MAAMK,OAAO,IAAI,CAAClG,GAAG,EAAEF,MAAM,CAAC,EAAE;QACnC,MAAMqG,GAAG,GAAGH,MAAM,CAACE,OAAO,CAAC;QAC3B,IAAIC,GAAG,EAAE;UACP,MAAM;YAACtB,KAAK;YAAEuB,MAAM;YAAEC,OAAO;YAAEnC,OAAO;YAAE,GAAGoC;UAAgB,CAAC,GAAGH,GAAG;UAClEP,YAAY,CAACM,OAAO,CAAC,GAAGI,gBAAgB;UAExC,KAAK,MAAMC,IAAI,IAAI,CAAC,OAAO,EAAE,QAAQ,EAAE,SAAS,CAAU,EAAE;YAC1D,IAAIJ,GAAG,CAACI,IAAI,CAAC,KAAKC,SAAS,EAAE;cAC3BX,MAAM,CAACU,IAAI,MAAXV,MAAM,CAACU,IAAI,IAAM,EAAE;cACnBV,MAAM,CAACU,IAAI,CAAC,CAACL,OAAO,CAAC,GAAGC,GAAG,CAACI,IAAI,CAAC;YACnC;UACF;QACF;MACF;MAEA,OAAO;QAACX,YAAY;QAAEC;MAAM,CAAC;IAC/B,CAAC,MAAM;MACL,MAAM;QAAChB,KAAK;QAAEuB,MAAM;QAAEC,OAAO;QAAEnC,OAAO;QAAE,GAAG0B;MAAY,CAAC,GAAGb,KAAK;MAChE,OAAO;QACLa,YAAY,EAAExE,sBAAsB,CAACwE,YAAY,EAAEjE,MAAM,CAACS,QAAQ,CAAC;QACnEyD,MAAM,EAAE;UACN,IAAIhB,KAAK,GAAG;YAACA;UAAK,CAAC,GAAG,EAAE,CAAC;UACzB,IAAIuB,MAAM,GAAG;YAACA;UAAM,CAAC,GAAG,EAAE,CAAC;UAC3B,IAAIC,OAAO,GAAG;YAACA;UAAO,CAAC,GAAG,EAAE,CAAC;UAC7B,IAAInC,OAAO,GAAG;YAACA;UAAO,CAAC,GAAG,EAAE;;OAE/B;IACH;EACF;EAEOuC,QAAQA,CACb/E,IAAsB,EAAAgF,IAAA,EAC8C;IAAA,IAApE;MAACxE,cAAc;MAAEC,gBAAgB;MAAE,GAAGwE;IAAW,CAAmB,GAAAD,IAAA;IAEpE;IAEA,MAAM;MAAC7E,QAAQ;MAAEmD,UAAU;MAAE,GAAGxB;IAAI,CAAC,GAAG9B,IAAI;IAC5C,MAAMC,MAAM,GAAqB;MAC/B,GAAGgF,WAAW;MACdzE,cAAc,EAAEkD,aAAa,CAAC;QAAClD,cAAc;QAAEL,QAAQ;QAAE8B,KAAK,EAAE;MAAI,CAAC,CAAC;MACtExB,gBAAgB,EAAE+C,eAAe,CAAC;QAAC/C,gBAAgB;QAAE6C;MAAU,CAAC;KACjE;IACD,OAAO,KAAK,CAACyB,QAAQ,CACnB;MACE,GAAGjD,IAAI;MACP,IAAI9B,IAAI,CAACY,IAAI,GAAG;QAACA,IAAI,EAAE,CAACX,MAAM,CAACY,cAAc,EAAEb,IAAI,CAACY,IAAI,CAAC,CAACE,MAAM,CAACC,CAAC,IAAIA,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG;MAAC,CAAC,GAAG,EAAE;KACzF,EACDf,MAAM,CACP;EACH;;AAGF,SAASyD,aAAaA,CAAAwB,KAAA,EAQrB;EAAA,IARsB;IACrB1E,cAAc;IACdL,QAAQ,GAAG,EAAE;IACb8B;EAAK,CAKN,GAAAiD,KAAA;EACC,IAAIC,MAAM,GAAQ,EAAE;EACpB,IAAI3E,cAAc,EAAE;IAClB,MAAM4E,QAAQ,GAAG,IAAIC,GAAG,CAAC,CAAC,GAAGjG,IAAI,CAACoB,cAAc,CAAC,EAAE,GAAGpB,IAAI,CAACe,QAAQ,CAAC,CAAC,CAAC;IACtE,KAAK,MAAMqE,OAAO,IAAIY,QAAQ,EAAE;MAC9B,MAAME,UAAU,GAAInF,QAAgB,CAACqE,OAAO,CAAC;MAC7C,MAAMe,gBAAgB,GAAG/E,cAAc,CAACgE,OAAO,CAAC;MAEhD,IAAIhG,iBAAiB,CAAC8G,UAAU,CAAC,EAAE;QACjC;QACA;QACA,MAAME,gBAAgB,GAAG;UACvB,GAAGD,gBAAgB;UACnB,GAAGD;SACJ;QACDH,MAAM,CAACX,OAAO,CAAC,GAAGgB,gBAAgB;MACpC,CAAC,MAAM,IAAIjH,6BAA6B,CAAC+G,UAAU,CAAC,EAAE;QACpDH,MAAM,CAACX,OAAO,CAAC,GAAG;UAChB,GAAGc,UAAU;UACbG,SAAS,EAAE;YACT,GAAGF,gBAAgB;YACnB,GAAGD,UAAU,CAACG;;SAEjB;MACH,CAAC,MAAM,IAAIH,UAAU,IAAIA,UAAU,KAAK,IAAI,EAAE;QAC5CH,MAAM,CAACX,OAAO,CAAC,GAAGc,UAAU;MAC9B,CAAC,MAAM,IACLrD,KAAK,IACLxD,UAAU,CAAC8G,gBAAgB,CAAC,IAC5BhG,WAAW,CAACgG,gBAAgB,CAAC,IAC7B/G,iBAAiB,CAAC+G,gBAAgB,CAAC,IACnCpH,OAAO,CAACoH,gBAAgB,CAAC,EACzB;QACAJ,MAAM,CAACX,OAAO,CAAC,GAAGe,gBAAgB;MACpC;IACF;EACF,CAAC,MAAM;IACLJ,MAAM,GAAGhF,QAAQ;EACnB;EACA,OAAO,CAACgF,MAAM,IAAIhG,OAAO,CAACgG,MAAM,CAAC,GAAGL,SAAS,GAAGK,MAAM;AACxD;AAEA,SAAS3B,eAAeA,CAAiCkC,GAGxD;EACC,MAAM;IAACjF,gBAAgB;IAAE6C;EAAU,CAAC,GAAGoC,GAAG;EAC1C,IAAIjF,gBAAgB,IAAI6C,UAAU,EAAE;IAClCxE,GAAG,CAAC2D,IAAI,CAAC3D,GAAG,CAAC4D,OAAO,CAACiD,oBAAoB,CAAC;MAAClF,gBAAgB;MAAE6C;IAAU,CAAC,CAAC,CAAC;EAC5E;EACA,OAAOA,UAAU,IAAI7C,gBAAgB;AACvC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}